{"meta":{"title":"苇名一心的博客","subtitle":null,"description":"经验分享和技术交流。","author":"苇名一心","url":"https://666wxy666.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-04-01T09:45:17.617Z","updated":"2020-03-25T08:57:28.904Z","comments":true,"path":"404.html","permalink":"https://666wxy666.github.io/404.html","excerpt":"","text":"404很抱歉，您访问的页面不存在可能是输入地址有误或该地址已被删除，您可以留言告诉我您要访问哪个页面找不到了，谢谢。"},{"title":"关于","date":"2020-04-27T12:38:07.457Z","updated":"2020-04-27T12:38:07.457Z","comments":true,"path":"about/index.html","permalink":"https://666wxy666.github.io/about/index.html","excerpt":"","text":"这里是我的基本信息：我的博客（Github）：苇名一心我的博客（Gitee）：苇名一心我的Github主页：666WXY666我的Gitee主页：wxy_666我的B站：在下-苇名一心我的知乎：苇名一心我的网易云：在下-苇名一心我的微博：在下-苇名一心欢迎关注我，与我联系。"},{"title":"所有分类","date":"2020-04-01T09:45:17.618Z","updated":"2020-03-22T10:40:41.483Z","comments":true,"path":"categories/index.html","permalink":"https://666wxy666.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-04-01T09:45:17.618Z","updated":"2020-03-25T07:29:48.422Z","comments":true,"path":"faqs/index.html","permalink":"https://666wxy666.github.io/faqs/index.html","excerpt":"","text":"README"},{"title":"我的朋友们","date":"2020-04-07T12:01:17.904Z","updated":"2020-04-07T12:01:17.904Z","comments":true,"path":"friends/index.html","permalink":"https://666wxy666.github.io/friends/index.html","excerpt":"这里是我的朋友和一些大佬，感兴趣的就点进去看看吧！","text":"这里是我的朋友和一些大佬，感兴趣的就点进去看看吧！想在这里展示或者有什么问题欢迎给我留言。"},{"title":"","date":"2020-04-01T09:45:17.618Z","updated":"2020-03-22T01:11:48.329Z","comments":true,"path":"mylist/index.html","permalink":"https://666wxy666.github.io/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-04-01T09:45:17.619Z","updated":"2020-03-25T07:51:09.297Z","comments":true,"path":"tags/index.html","permalink":"https://666wxy666.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"现代交换原理 MOOC习题 5~章","slug":"现代交换原理-MOOC习题-5~章","date":"2020-05-18T01:45:04.913Z","updated":"2020-05-18T13:36:08.566Z","comments":true,"path":"2020/05/18/现代交换原理-MOOC习题-5~章/","link":"","permalink":"https://666wxy666.github.io/2020/05/18/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86-MOOC%E4%B9%A0%E9%A2%98-5~%E7%AB%A0/","excerpt":"自己随便整理了一下在学习“现代交换原理”网课时遇到的一些习题，易错点之类的。接上文现代交换原理 MOOC习题 1~4章。","text":"自己随便整理了一下在学习“现代交换原理”网课时遇到的一些习题，易错点之类的。接上文现代交换原理 MOOC习题 1~4章。第五章 信令与协议通话所需的媒体资源可以理解为控制呼叫的接续和拆线和通信网管理和维护的信息资源。通信网中为用户建立连接和拆除连接，需要网中各个相关设备协调工作，为此在各个设备间传输的控制信号和规约称为信令。路由标记供MTP3级进行消息寻址和路由，而MTP3的路由标记是由信令点编码实现的。电信网（现代通信网）的三大支撑网络：同步网，管理网，信令网。SIP与普通电话用户进行通话时要进行协议转换，SIP-&gt;七号信令。SIP协议中SDP的媒体端口号由网关（中继网关）保存。中继网关是分组网和电路网边界设备，实现不同媒体协议的转换。注意中继网关（Trunk Gateway）跟代理服务器（Proxy Server）不是一个东西。中继网关也叫落地设备，简称TG。用于VOIP网络电话系统或呼叫中心、软交换等，将模拟信号与数字信号相互转换。是voip解决方案的重要组成部分，它位于NGN网络的边缘接入层，连接PSTN和voip网络，实现IP包转TDM的功能。 承载着IP域与电路域的语音汇接任务。常识问题。显然错误，MTP1的通路也要经过TST交换网络。错误，不多解释。模拟用户信令：主要包括用户向交换机发送的监视信令和选择信令，交换机向用户发送的铃流和忙音等音信号。用于PSTN。状态信令：用户线的忙闲状态，如主、被叫的摘、挂机状态；地址信令：主叫所拨的被叫号码，直流脉冲或双音频；铃流和信号音：交换机向用户发送的信号。振铃信号、信号音、来电显示的FSK信号；数字用户信令：通过消息的形式传送以上信息，用于ISDN用户。例如：DSS1 30B+D在用户线上传输的信令叫用户线信令，No.7信令是专为电话局之间交互控制信息而设计的，所以是局间信令，也就是在中继线上交互的信令，以数字信号方式传送。它跟能否携带电话号码没关系。未完待续……所有的习题：现代交换原理 MOOC习题 1~4章现代交换原理 MOOC习题 5~章","categories":[{"name":"现代交换原理","slug":"现代交换原理","permalink":"https://666wxy666.github.io/categories/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"},{"name":"习题","slug":"现代交换原理/习题","permalink":"https://666wxy666.github.io/categories/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"习题","slug":"习题","permalink":"https://666wxy666.github.io/tags/%E4%B9%A0%E9%A2%98/"},{"name":"易错点","slug":"易错点","permalink":"https://666wxy666.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"网课","slug":"网课","permalink":"https://666wxy666.github.io/tags/%E7%BD%91%E8%AF%BE/"},{"name":"MOOC","slug":"MOOC","permalink":"https://666wxy666.github.io/tags/MOOC/"},{"name":"现代交换原理","slug":"现代交换原理","permalink":"https://666wxy666.github.io/tags/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"}]},{"title":"大数据 习题","slug":"大数据-习题","date":"2020-05-07T13:47:17.443Z","updated":"2020-05-08T14:23:24.105Z","comments":true,"path":"2020/05/07/大数据-习题/","link":"","permalink":"https://666wxy666.github.io/2020/05/07/%E5%A4%A7%E6%95%B0%E6%8D%AE-%E4%B9%A0%E9%A2%98/","excerpt":"自己随便整理了一下在学习“大数据”时遇到的一些习题，易错点之类的。","text":"自己随便整理了一下在学习“大数据”时遇到的一些习题，易错点之类的。1、关于Spark中task，block，partition，split，core的关系每一个过程的任务数，对应一个inputSplit, Partition输入可能以多个文件的形式存储在HDFS上，每个File都包含了很多块，称为Block。当Spark读取这些文件作为输入时，会根据具体数据格式对应的InputFormat进行解析，一般是将若干个Block合并成一个输入分片，称为InputSplit，注意InputSplit不能跨越文件。随后将为这些输入分片生成具体的Task。InputSplit与Task是一一对应的关系。随后这些具体的Task每个都会被分配到集群上的某个节点的某个Executor去执行。每个节点可以起一个或多个Executor。每个Executor由若干core组成，每个Executor的每个core一次只能执行一个Task。注意： 这里的core是虚拟的core而不是机器的物理CPU核，可以理解为就是Executor的一个工作线程。每个Task执行的结果就是生成了目标RDD的一个partiton。Task被执行的并发度 = Executor数目$\\times$每个Executor核数（=core总个数）至于partition的数目：对于数据读入阶段，例如sc.textFile，输入文件被划分为多少InputSplit就会需要多少初始Task。在Map阶段partition数目保持不变。在Reduce阶段，RDD的聚合会触发shuffle操作，聚合后的RDD的partition数目跟具体操作有关，例如repartition操作会聚合成指定分区数，还有一些算子是可配置的。RDD在计算的时候，每个分区都会起一个task，所以rdd的分区数目决定了总的task数目。申请的计算节点（Executor）数目和每个计算节点核数，决定了你同一时刻可以并行执行的task。比如：RDD有100个分区，那么计算的时候就会生成100个task，你的资源配置为10个计算节点，每个2个核，同一时刻可以并行的task数目为20，计算这个RDD就需要5个轮次。如果计算资源不变，你有101个task的话，就需要6个轮次，在最后一轮中，只有一个task在执行，其余核都在空转。如果资源不变，你的RDD只有2个分区，那么同一时刻只有2个task运行，其余18个核空转，造成资源浪费。这就是在spark调优中，增大RDD分区数目，增大任务并行度的原因。2、HDFS体系架构HDFS采用了主从（Master/Slave）结构 模型，一个HDFS集群是由一个 NameNode和若干个 DataNode 组成的。其中 NameNode 作为主服务器，管理文件系统的命名空间和客户端对文件的 访问操作；集群中的 DataNode 管理存储的数据。HDFS 允许用户以文件的形 式存储数据。从内部来看，文件被分成 若干个数据块，而且这若干个数据块存 放在一组 DataNode 上。NameNode 执行文件系统的命名空间操作，比如打开、关闭、重命名文件或目录等，它也负责数据块到具体 DataNode 的映射。 DataNode 负责处理文件系统客户端的文件读写请求，并在 NameNode 的统 一调度下进行数据块的创建、删除和复制工作。3、HDFS的读操作流程初始化FileSystem，然后客户端用函数 open()打开文件。FileSystem调用元数据节点，得到数据 块信息，并对每一个数据块、元数据节点返回，保存数据块的数据节点地址。客户端调用Stream的read()函数开始读 取数据。FSDataInputStream连接保存此文件第 一个数据块的最近的数据节点Datanode， data从数据节点读到客户端。当第一个数据块读取完毕时， FSDataInputStream关闭和此数据节点的 连接，然后连接此文件下一个数据块的 最近的数据节点。当客户端读取完毕数据的时候，调用 FSDataInputStream的close()函数，关闭连接。4、HDFS的写操作流程5、习题 未完待续……敬请期待……","categories":[{"name":"大数据","slug":"大数据","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"习题","slug":"大数据/习题","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"习题","slug":"习题","permalink":"https://666wxy666.github.io/tags/%E4%B9%A0%E9%A2%98/"},{"name":"易错点","slug":"易错点","permalink":"https://666wxy666.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"大数据","slug":"大数据","permalink":"https://666wxy666.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Spark","slug":"Spark","permalink":"https://666wxy666.github.io/tags/Spark/"},{"name":"HDFS","slug":"HDFS","permalink":"https://666wxy666.github.io/tags/HDFS/"},{"name":"MapReduce","slug":"MapReduce","permalink":"https://666wxy666.github.io/tags/MapReduce/"}]},{"title":"现代交换原理 MOOC习题 1~4章","slug":"现代交换原理-MOOC习题-1~4章","date":"2020-05-07T02:37:07.224Z","updated":"2020-05-18T08:20:06.855Z","comments":true,"path":"2020/05/07/现代交换原理-MOOC习题-1~4章/","link":"","permalink":"https://666wxy666.github.io/2020/05/07/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86-MOOC%E4%B9%A0%E9%A2%98-1~4%E7%AB%A0/","excerpt":"自己随便整理了一下在学习“现代交换原理”网课时遇到的一些习题，易错点之类的。","text":"自己随便整理了一下在学习“现代交换原理”网课时遇到的一些习题，易错点之类的。第一章 交换概论 都是类似的道理，话音业务需要实时、高可靠、恒定速率，因此电路交换适合，异步显然不适合于话音业务。电路交换是先建立好链路，在进行的交换。路由选择是先进行的，信息转发在建立好的链路上进行。分组交换是上面描述的特点。通信网三要素是：交换设备、传输设备、终端设备。交换网络的三要素是：交换单元、不同交换单元间的拓扑连接、控制方式。第二章 交换网络交换单元的端口类型有两种：控制端口和状态端口。T接线器：话音存储器（SM）：固定每个存储单元8bit存话音，存储单元的数量m就是时隙数m。控制存储器（CM）：存储单元大小为$\\log_2{m}$，所以时隙数一般都是2的幂次，存储单元的数量m也是时隙数m。S接线器没有话音存储器，控制存储器（CM），可以把S接线器的所有的控制存储器看成$m\\times{n}$个方格，m为时隙数，n为入（出）线数：S接线器所含CM的数量就是入（出）线数n，也就是一列为一个CM，共有n列。每个CM所含的存储单元的数量为入（出）线的时隙数m，也就是每个格代表一个存储单元，每个CM有m个存储单元，m行。每个存储单元的大小为$\\log_2{m}$bit。$N\\times{N}$的Banyan网络需要$k=\\log_2{N}$级，如果要使用$2\\times{2}$的交换单元构建，那么每层就需要$\\frac{N}{2}$个交换单元，k层共需要$k\\times{\\frac{N}{2}}=\\frac{N}{2}\\times{\\log_2{N}}$，如果是M层的话，则需要$m\\times{\\frac{N}{2}\\times{\\log_2{N}}}$个$2\\times{2}$的交换单元。因此这个题需要$3\\times{\\frac{8}{2}\\times{\\log_2{8}}}=36$个$2\\times{2}$的交换单元。第三章 电路交换常识知识。示意图：B+C-&gt;A： 这三个题都是基础知识。直连？应该是可以实现不经过交换设备的语音通信。用户模块的处理机与区域处理机相连，区域处理机又与其他区域处理机和中央处理机相连。周期级程序是按一定周期进行的各种扫描和驱动，例如200ms摘挂机扫描。开通业务应该是基本级程序负责。第四章 分组交换TCP连接的建立不是路由器基本功能。ISDN全称是综合业务数字网，不需要支持模拟业务。ATM 适配层（AAL）主要负责百 ATM 层与高层之间的信元转发过程。从上层收到信息后，AAL 将数据分割成 ATM 信元；从 ATM 层收到信息后，AAL 必须重度新组合数据形成一专个上层能够辨识的格式。上述操作称之为分段与重组（SAR），它是 AAL 的主要任务。此外不同的 AAL 支持属不同的流量或服务类型。MPLS标记可以任意级，标记栈实现多级标记，Label可以有多个。A、MPLS和ATM和帧中继都是路由选择和数据转发分开进行，都是面向连接的，但是不需要为每一次通信业务都建立新的连接；而传统IP网是无连接的，路由选择和数据转发同时进行。B、MPLS和ATM都是虚连接，使用时连接，不需要时可以拆除连接，不是永久连接。C、MPLS使用的是Label标记方式的逻辑连接，ATM是VPI/VCI方式的逻辑连接，都是逻辑虚连接。D、MPLS通过LDP等协议，在LSR和LER、LSR和LSR之间完成标记信息的分发，形成与FEC对应的LSP路径。同上一个题的D选项。入口LER接收分组，完成第三层功能，判定分组所属的FEC，并给分组加上标记形成MPLS标记分组。LSR依据分组上的标记以及标记转发表通过交换单元对其进行转发，不再进行任何第三层处理，也就是只处理标记部分，不处理IP分组头。出口 LER 将分组中的标记去掉后转发至目的地。MPLS与ATM/FR类似，标记都是本地（逐段）有效的，需要路由器进行标记转换。未完待续……所有的习题：现代交换原理 MOOC习题 1~4章现代交换原理 MOOC习题 5~章","categories":[{"name":"现代交换原理","slug":"现代交换原理","permalink":"https://666wxy666.github.io/categories/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"},{"name":"习题","slug":"现代交换原理/习题","permalink":"https://666wxy666.github.io/categories/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"习题","slug":"习题","permalink":"https://666wxy666.github.io/tags/%E4%B9%A0%E9%A2%98/"},{"name":"易错点","slug":"易错点","permalink":"https://666wxy666.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"网课","slug":"网课","permalink":"https://666wxy666.github.io/tags/%E7%BD%91%E8%AF%BE/"},{"name":"MOOC","slug":"MOOC","permalink":"https://666wxy666.github.io/tags/MOOC/"},{"name":"现代交换原理","slug":"现代交换原理","permalink":"https://666wxy666.github.io/tags/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"}]},{"title":"Linux MOOC习题 10~章","slug":"Linux-MOOC习题-10~章","date":"2020-05-07T01:46:38.801Z","updated":"2020-05-14T03:24:12.810Z","comments":true,"path":"2020/05/07/Linux-MOOC习题-10~章/","link":"","permalink":"https://666wxy666.github.io/2020/05/07/Linux-MOOC%E4%B9%A0%E9%A2%98-10~%E7%AB%A0/","excerpt":"自己随便整理了一下在学习Linux网课时遇到的一些习题，易错点之类的，接上文Linux MOOC习题 5~9章。","text":"自己随便整理了一下在学习Linux网课时遇到的一些习题，易错点之类的，接上文Linux MOOC习题 5~9章。十、shell流程控制：条件、循环与函数B选项：明显的错误，then要么另起一行，要么前面加;。C选项和D选项：都是没加fi，C选项还有其他的错误，这明显是和C语言之类的给混了。 十一、进程的基本概念 int a[N] = { 2 };的意思是把a[N]第一个元素赋值为2，其他的赋值为0，也就是说，所有的元素都被赋值了，因此占空间很大。int a[N];的a[N]没有赋初值，只需记录a的长度即可，占用空间很小。从图中（test是第一种赋值的，test2是第二种不赋值的）也可以看出，差别巨大：忙等待主要是占用CPU，和内存没啥关系。十二、进程的创建和重定向 注意，这个程序是持续不间断运行的，也就是说，不能停止后再重启，但是重定向是只能在程序运行的时候进行的操作，程序一旦开始运行就没办法重定向了，因此不能实现。但是如果foo可以终止后重启，确实可以用shell脚本等程序实现上述功能。修改foo程序也可以实现上述功能。执行的大致流程，只是各进程执行情况，并不代表真实执行顺序：父进程（0）：输出：i=0父进程0产生第一个子进程0-10-1：到下一轮for循环，i=1输出：i=1子进程0-1产生第一个子进程0-1-10-1-1：到下一轮for循环，i=2输出：i=2进程0-1-1产生第一个子进程0-1-1-10-1-1-1：到下一轮for循环，i=3输出：i=3进程0-1-1-1产生第一个子进程0-1-1-1-10-1-1-1-1：到下一轮for循环，i=40-1-1-1-1结束到下一轮for循环，i=40-1-1-1结束到下一轮for循环，i=3输出：i=3进程0-1-1产生第二个子进程0-1-1-20-1-1-2：到下一轮for循环，i=40-1-1-2结束到下一轮for循环，i=40-1-1结束到下一轮for循环，i=2输出：i=2子进程0-1产生第二个子进程0-1-20-1-2：到下一轮for循环，i=3输出：i=3进程0-1-2产生第一个子进程0-1-2-10-1-2-1：到下一轮for循环，i=40-1-2-1结束到下一轮for循环，i=40-1-2结束到下一轮for循环，i=3输出：i=3子进程0-1产生第三个子进程0-1-30-1-3：到下一轮for循环，i=40-1-3结束到下一轮for循环，i=40-1结束到下一轮for循环，i=1输出：i=1父进程0产生第二个子进程0-20-2：到下一轮for循环，i=2输出：i=2进程0-2产生第一个子进程0-2-10-2-1：到下一轮for循环，i=3输出：i=3进程0-2-1产生第一个子进程0-2-1-10-2-1-1：到下一轮for循环，i=40-2-1-1结束到下一轮for循环，i=40-2-1结束到下一轮for循环，i=3输出：i=3进程0-2产生第二个子进程0-2-20-2-2：到下一轮for循环，i=40-2-2结束到下一轮for循环，i=40-2结束到下一轮for循环，i=2输出：i=2父进程0产生第三个子进程0-30-3：到下一轮for循环，i=3输出：i=3进程0-3产生第一个子进程0-3-10-3-1：到下一轮for循环，i=40-3-1结束到下一轮for循环，i=40-3结束到下一轮for循环，i=3输出：i=3父进程0产生第四个子进程0-40-4：到下一轮for循环，i=40-4结束到下一轮for循环，i=4父进程0结束共15行输出，分别为：输出次数i=0$2^0=1$i=1$2^1=2$i=2$2^2=4$i=3$2^3=8$在linux下的实际执行情况：可以发现确实是15行，但是却有两个问题：为什么最后产生了一个空行，在等待用户输入？shell提示符其实是主进程死了以后，shell给出来的。因为实际运行结果是子进程死得晚，父进程死的早。其实，你不按回车，大家也都运行结束了，只是shell提示符出现得比某个子进程早。你看起来这个效果，其实这个提示符已经在上面显示了，那个时候主进程结束，shell给出了提示符，但此时子进程还没有结束，因此会继续输出，但这个时候shell已经进入了等待下一个命令的状态了，就像这样：​ 可以发现，echo命令已经可以被shell接受了。程序为什么分两部分输出了？这是因为后面的子进程因为他的父进程先死掉了，变成了孤儿进程，打印出他们的父进程pid，发现是1，也证明了这一点：因此我们可以对程序进行如下修改：1234567891011121314151617181920212223242526/* * @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. * @Description: * @Version: * @Author: 苇名一心 * @Date: 2020-05-11 20:02:00 * @LastEditors: 苇名一心 * @LastEditTime: 2020-05-14 11:18:43 */#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;unistd.h&gt;int main(int argc, char const *argv[])&#123; int i,status,wait_pid; for (i = 0; i &lt; 4; i++) &#123; printf(\"i=%d,pid=%d,ppid=%d\\n\", i,getpid(),getppid()); if(fork()&gt;0) &#123; wait_pid = wait(&amp;status); &#125; &#125; return 0;&#125;对每个fork加上wait语句，就可以完全按照上面的进程树执行顺序执行，且不会有任何问题了。PS：对于wait，如果其所有子进程都还在运行，则阻塞；如果是一部分子进程终止，而另一部分还在运行，那么父进程还会阻塞吗？答案是不会，只要有一个进程终止，wait就会返回。也就是说只要wait接收到一个SIGCHLD信号，wait()就会返回。对于两个或多个子进程的情况，需要调用wait两次或多次。说白了在每一个fork后面的父进程分支中都要有一个wait与之对应。与wait相关的详细知识请参照这位兄弟的博客：wait()函数的详细分析。未完待续……所有的习题：Linux MOOC习题 1~4章Linux MOOC习题 5~9章Linux MOOC习题 10~章","categories":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/categories/Linux/"},{"name":"习题","slug":"Linux/习题","permalink":"https://666wxy666.github.io/categories/Linux/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/tags/Linux/"},{"name":"习题","slug":"习题","permalink":"https://666wxy666.github.io/tags/%E4%B9%A0%E9%A2%98/"},{"name":"易错点","slug":"易错点","permalink":"https://666wxy666.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"网课","slug":"网课","permalink":"https://666wxy666.github.io/tags/%E7%BD%91%E8%AF%BE/"},{"name":"MOOC","slug":"MOOC","permalink":"https://666wxy666.github.io/tags/MOOC/"}]},{"title":"Linux 拓展学习","slug":"Linux-拓展学习","date":"2020-04-29T12:40:47.779Z","updated":"2020-05-08T14:23:11.008Z","comments":true,"path":"2020/04/29/Linux-拓展学习/","link":"","permalink":"https://666wxy666.github.io/2020/04/29/Linux-%E6%8B%93%E5%B1%95%E5%AD%A6%E4%B9%A0/","excerpt":"简单的写了一些Linux的课外拓展学习的相关知识和问题。","text":"简单的写了一些Linux的课外拓展学习的相关知识和问题。一、命令的参数编写一个小程序，可以显示命令的选项和参数1234567891011#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int i; for (i = 0; i &lt; argc; i++) &#123; printf(\"%d:%p [%s]\\n\", i, argv[i], argv[i]); &#125; return 0;&#125;效果：二、关于控制printf输出的颜色编写程序hello.c，编译和运行程序，得到类似以下结果：可以通过1\\033[来控制printf输出的颜色，格式为：1printf(\"\\033[字背景颜色;字体颜色m 字符串 \\033[0m\" );注意，一定要在printf最后使用1\\033[0m来消除前面的作用，否则前面的设置对后面的printf都有效果。ANSI控制码效果\\033[0m关闭所有属性\\033[1m设置高亮度\\033[4m下划线\\033[5m闪烁\\033[7m反显\\033[8m消隐\\033[30m —\\033[37m设置前景色\\033[40m—\\033[47m设置背景色\\033[nA光标上移n行\\03[nB光标下移n行\\033[nC光标右移n行\\033[nD光标左移n行字背景颜色范围: 40–49字颜色范围: 30—39字背景颜色代号字背景颜色字颜色代号字颜色40黑30黑41红31红42绿32绿43黄33黄44蓝34蓝45紫35紫46青36青47白37白小程序具体代码：12345678910#define NONE \"\\e[0m\"#define RED \"\\e[0;31m\"#define CYAN \"\\e[0;36m\"#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; printf(RED \"Hello \" CYAN \"World!\\n\" NONE); printf(\"\\e[0;31mHello \\e[0;36mWorld!\\n\\e[0m\"); return 0;&#125;在这里\\e和\\033是一个意思，e的八进制代码就是033，这两个print其实效果是一样的，前面那个printf中多个连续的“xxx”字符串会被自动整合为一个字符串，其实最终执行的就是第二个printf。效果：三、关于Linux中bash的变量、替换和元字符要求只列出所有bash进程的状态，使用命令1ps -ef | grep bash但grep进程自身也被输出了：使用以下的命令：12345ps -ef | grep [b]ashps -ef | grep \\\\bashps -ef | grep b\\\\ashps -ef | grep b\\ashps -ef | grep ba\\\\sh可以上面这5个命令的核心目的其实是改变grep在1ps -ef命令中的显示形式，例如这一个，我们使用三通（tee）命令将在grep命令过滤之前的输出定向到一个文件中。先将原命令试一下：12ps -ef | tee 1.txt | grep bashcat 1.txt与1这个命令进行一下对比：12ps -ef | tee 1.txt | grep [b]ashcat 1.txt我们可以很明显的看到，grep命令确实改变了，因为正则表达式1[b]ash是可以匹配bash的，但是却不能匹配[b]ash，因此第一行的-bash这一行被取了出来，而最后grep这一行，由于不匹配[b]ash，就取不出来了，刚好实现了我们只列出所有bash进程的状态的目的，下面的几个命令大同小异。不可以12ps -ef | tee 1.txt | grep \\\\bashcat 1.txt首先，\\是Shell的元字符，先被\\转义为真正的单个字符\\，因此传给grep的正则表达式其实是\\bash，而在正则表达式中，\\b有特殊含义，是单词边界，因此就连bash和\\bash全部都没有匹配到。可以12ps -ef | tee 1.txt | grep b\\\\ashcat 1.txt和2一样，传给grep的正则表达式为b\\ash，在正则表达式中\\a是没有意义的，因此\\被丢弃，正则表达式其实就是bash，所以第一行的-bash这一行被取了出来，而最后grep这一行，由于不匹配b\\ash，就取不出来了。不可以12ps -ef | tee 1.txt | grep b\\ashcat 1.txt首先，\\a先经过Shell的替换，因\\a是没有特殊含义的，因此\\被直接丢掉，传给grep的正则表达式为bash，这就和使用这个命令是一样的：1ps -ef | grep bash显然是不能实现目的。不可以12ps -ef | tee 1.txt | grep ba\\\\shcat 1.txt这个和2基本是一样的，和3唯一的区别就是，第3个中\\a对正则表达式而言是没有特殊含义的，但是\\s对正则表达式而言是有特殊含义的，\\s代表空白字符（可能是空格、制表符、其他空白），也就是说，grep匹配到的应该是类似于：1ba h这种的字符串，显然-bash和ba\\sh都不符合，因此就什么都没取到。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/categories/Linux/"},{"name":"拓展学习","slug":"Linux/拓展学习","permalink":"https://666wxy666.github.io/categories/Linux/%E6%8B%93%E5%B1%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/tags/Linux/"},{"name":"拓展","slug":"拓展","permalink":"https://666wxy666.github.io/tags/%E6%8B%93%E5%B1%95/"},{"name":"难点","slug":"难点","permalink":"https://666wxy666.github.io/tags/%E9%9A%BE%E7%82%B9/"}]},{"title":"Linux MOOC习题 5~9章","slug":"Linux-MOOC习题-5~9章","date":"2020-04-29T01:54:47.814Z","updated":"2020-05-09T13:34:56.962Z","comments":true,"path":"2020/04/29/Linux-MOOC习题-5~9章/","link":"","permalink":"https://666wxy666.github.io/2020/04/29/Linux-MOOC%E4%B9%A0%E9%A2%98-5~9%E7%AB%A0/","excerpt":"自己随便整理了一下在学习Linux网课时遇到的一些习题，易错点之类的，接上文Linux MOOC习题 1~4章。","text":"自己随便整理了一下在学习Linux网课时遇到的一些习题，易错点之类的，接上文Linux MOOC习题 1~4章。PS：第七章是上机实验，第一次上机实验和第二次的实验因为是提交阶段暂不公开，后面可能会发。五、文件管理和目录管理 在Linux中，Shell会自动帮你进项一些替换，实际运行的命令其实是：1cp src/x.c src/xx.c src/xxx.c src/x.h src/xx.h src/xxx.h……如果有好多.c和.h文件（超过两个），cp就会报错：cp: target xxx is not a directory但是如果只有两个.c或.h文件，那么就会产生非常严重的后果，实际运行了下面的命令：1cp src/x.c src/y.c这是非常危险的，这样y.c的内容会被x.c覆盖，这是我们不愿意看到的。那么应该用什么命令来实现题目的要求呢？1cp src/*.[ch] .我们显示地指定复制到.（当前目录），就不会出现问题了。这也是在Linux中很怪的地方，明明你不能写这个文件，但是你却可以删除，如果不加-f，删除只读文件时会有提示，但是加了-f就没有任何提示了。还有一点需要注意的是，如第6题所说，加了-f也不能删除无权限删除的文件。 关于第10题，不像Windows，在Linux中这些后缀都是约定俗成的，只是为了做标记用，好区分而已，没有实际意义。六、Linux命令风格和文件系统这两个题都忽略了“符号链接”的作用。 这俩没啥好说的。在Linux中，一般是-1代表失败，&gt;=0的值代表成功。八、文件和目录的权限、Shell目录有执行权限（即x权限）意味着分析路径名过程中可检索该目录。九、替换、元字符和转义如果你是执行这个命令的操作员，估计你马上就心情不好了。由于拼错了单词，把DATABASE不小心写成了DATEBASE，灾难来了。未命名的变量被bash替换为空字符串，实际上你以root身份执行了最邪恶的一条命令：1rm -rf /*永远不要盲目自信，谁也保证不了自己不会犯错误，怎么才能避免这样的悲剧发生？尽量不要以root身份登录。bash有选项，引用未定义的变量会出错而不是替换为空字符串，可以打开这个选项。早期的编程语言把引用的未定义过的变量自动加上定义，这种做法实际上太糟糕，最早的FORTRAN语言就这种做法，据说曾因此导致一次太空任务失败。在设计你自己的系统时，建库命令能够从目录名开始建库，就是说要求建库之前/opt/data下不需要存在目录puma，而不是要求建库之前/opt/data有个空目录puma，这样的话，即使你的命令变成了1rm -rf $DATEBASE因为你的失误，会导致rm命令抱怨缺少参数而什么都不做，这个结果是可以接受的。在Linux中，目前我已知的Shell的元字符有：1空格 制表符 回车 &gt; &lt; | ; &amp; $ * [ ] ? \\ ( ) '' \" \" 反撇号`第11题中，这三个命令都可以取消文件通配符*的特殊作用，让echo直接打印字符*，并且这个替换是Shell进行的，也就是说，echo拿到的命令都是一样的，他是分不清操作员输入的是哪个命令，这三个命令的参数：而对于不转义的命令的参数：1echo *因此结果就很明显了：未完待续……所有的习题：Linux MOOC习题 1~4章Linux MOOC习题 5~9章Linux MOOC习题 10~章","categories":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/categories/Linux/"},{"name":"习题","slug":"Linux/习题","permalink":"https://666wxy666.github.io/categories/Linux/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/tags/Linux/"},{"name":"习题","slug":"习题","permalink":"https://666wxy666.github.io/tags/%E4%B9%A0%E9%A2%98/"},{"name":"易错点","slug":"易错点","permalink":"https://666wxy666.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"网课","slug":"网课","permalink":"https://666wxy666.github.io/tags/%E7%BD%91%E8%AF%BE/"},{"name":"MOOC","slug":"MOOC","permalink":"https://666wxy666.github.io/tags/MOOC/"}]},{"title":"Linux MOOC习题 1~4章","slug":"Linux-MOOC习题-1~4章","date":"2020-04-28T13:08:08.946Z","updated":"2020-05-09T13:29:46.904Z","comments":true,"path":"2020/04/28/Linux-MOOC习题-1~4章/","link":"","permalink":"https://666wxy666.github.io/2020/04/28/Linux-MOOC%E4%B9%A0%E9%A2%98-1~4%E7%AB%A0/","excerpt":"自己随便整理了一下在学习Linux网课时遇到的一些习题，易错点之类的。","text":"自己随便整理了一下在学习Linux网课时遇到的一些习题，易错点之类的。废话不多说，直接开始：PS：第一章是课程介绍。二、开始使用Linux和文本文件的处理第1题其实是很基础的问题，早期的终端一般由键盘、显示器和RS232串行通信接口构成，没有磁盘存储器，其实可以想象成和打字机差不多的东西，他就是直接在显示器上显示了，不需要磁盘存储器。第2题也比较基础：行律的作用是：一行内字符的缓冲、回显和编辑，直到按下回车键；数据的加工，类似第二题中的将“\\n”替换为“\\r\\n”；将CTRL-C字符转换为终止进程的信号；驱动程序其实是串口与行律的接口，负责上行和下行字符流。这俩题没啥好说的，基础知识。并不是这样的，CTRL-C确实传送了字符（Ctrl+字母组合键可以产生ASCII码为1-26的控制字符，字母序号是几，ASCII码就是几，Ctrl+C的ASCII码应为3），其实还是行律的作用，他将CTRL-C字符转换为终止进程的信号，从而通知Linux主机，进程终止。 这俩题都是关于uniq命令的。123uniq -uuniq -duniq第一个命令，-u代表unique，只打印没有重复的行；第二个命令，-d代表duplicated，只打印重复的行，注意重复的行只打印一次；第三个命令，啥也不加就是都打印，但是也是复的行只打印一次；还有就是关于重复的行，意思其实是连续的紧邻的两行内容相同才被叫做重复的行，因此第10题是错的。这个题不难，写出来的目的是只要记得Less is more就很好想了，less是more的升级版。 这俩题也不多解释了，od不可打印字符也可以显示，tr是用于翻译，把string1出现的字符替换为string2中对应的字符，ASCII字符0也可以翻译。1tr string1 string2三、正则表达式先说一下正则表达式的元字符，有6个，分别是：1. * [ \\ ^ $关于他们各自的含义不多说，自行百度，一定要注意的是]不是元字符，很容易搞错。而关于单字符正则表达式，显而易见，就是匹配一个字符呗，不过有特殊的:\\加一个字符构成的转义字符，看做单字符正则表达式；1\\. \\* \\[ \\\\ \\^ \\$[]定义的集合也被看做单字符正则表达式;因为.本来的含义是匹配任意字符，转义后就是单字符.，因此都是单字符正则表达式，而$在尾部时和^在首部时有特殊含义，因此转义之前不是，转义后就是单字符​了。这个题就比较有意思了，先看一下sed命令的基本用法：1sed 's/正则表达式/字符串/g' 文件名列表s选项的意思是替换，将文件中匹配第一个//中的正则表达式的内容替换为第二个//中的字符串。然后我们在看上题‘’中的正则表达式（也就是第一个//中的内容）1\\[[^][]*]可以分为三部分：因为[是元字符，加\\转义后就变成了真正的[。1\\[中间这一部分是一个集合[]，重复一次或多次[]*，集合里面的^代表排除，排除了]和[，意思就是说除]和[外的字符重复一次或多次。那么这就有一个问题，第一个[为什么不与第一个]匹配，反而去和最后一个]匹配呢？个人觉得，因为如果与第一个]匹配，就有了[^]，这显然是错误的正则表达式，那么就继续向后匹配，因此就匹配到了最后面的]。1[^][]*因为]不是元字符，也没有[与它匹配，它就是单纯的一个字符]。1]综上所述，这个正则表达式可以匹配“[非]和[的字符任意多个]”，类似[参考文献23]这样的，但是如果[]里面还有]和[，就匹配不到了。再看上面的题，第二个//里面是空的，那么就是把匹配到的内容删除，很好理解。四、文件比较，文件通配符vi的基本用法，在命令状态12345678:q 退出（:quit的缩写）:q! 退出且不保存（:quit!的缩写）:wq 保存并退出:wq! 保存并退出即使文件没有写入权限（强制保存退出）:x 保存并退出（类似:wq，但是只有在有更改的情况下才保存）:exit 保存并退出（和:x相同）:qa 退出所有(:quitall的缩写):cq 退出且不保存（即便有错误）另外在“正常模式”下输入“ZZ”来保存并退出Vim（和:x相同），或者“ZQ”不保存并退出（和:q!相同）注意此处ZZ大写和小写是完全不同的。diff一般用于比较文本文件。未完待续……所有的习题：Linux MOOC习题 1~4章Linux MOOC习题 5~9章Linux MOOC习题 10~章","categories":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/categories/Linux/"},{"name":"习题","slug":"Linux/习题","permalink":"https://666wxy666.github.io/categories/Linux/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/tags/Linux/"},{"name":"习题","slug":"习题","permalink":"https://666wxy666.github.io/tags/%E4%B9%A0%E9%A2%98/"},{"name":"易错点","slug":"易错点","permalink":"https://666wxy666.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"网课","slug":"网课","permalink":"https://666wxy666.github.io/tags/%E7%BD%91%E8%AF%BE/"},{"name":"MOOC","slug":"MOOC","permalink":"https://666wxy666.github.io/tags/MOOC/"}]},{"title":"Python 爬虫小Demo 学堂在线课程","slug":"Python-爬虫小Demo-学堂在线课程","date":"2020-04-07T11:43:33.300Z","updated":"2020-05-18T12:22:07.776Z","comments":true,"path":"2020/04/07/Python-爬虫小Demo-学堂在线课程/","link":"","permalink":"https://666wxy666.github.io/2020/04/07/Python-%E7%88%AC%E8%99%AB%E5%B0%8FDemo-%E5%AD%A6%E5%A0%82%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/","excerpt":"本文是关于Python中的Spider的小Demo，通过Python的scrapy爬取京学堂在线课程的相关数据。","text":"本文是关于Python中的Spider的小Demo，通过Python的scrapy爬取京学堂在线课程的相关数据。一、编译环境：PyCharm 2019.3.4 (Professional Edition)Build #PY-193.6911.25, built on March 18, 2020Runtime version: 11.0.6+8-b520.43 amd64VM: OpenJDK 64-Bit Server VM by JetBrains s.r.oWindows 10 10.0GC: ParNew, ConcurrentMarkSweepMemory: 725MCores: 8Registry: ide.balloon.shadow.size=0Non-Bundled Plugins:GrepConsole,Statistic,cn.yiiguxing.plugin.translate,com.chrisrm.idea.MaterialThemeUI,com.notime.intellijPlugin.backgroundImagePlus,com.wakatime.intellij.plugin,izhangzhihao.rainbow.brackets,mobi.hsz.idea.gitignore, net.vektah.codeglance, org.intellij.giteePython Version：3.7（Anaconda3）Package：scrapy==2.0.1二、详细步骤①准备工作在Pycharm中新建一个Pure Python项目（记得要按照一中的要求配好Python环境）。打开Pycharm的下方的终端（Terminal），当然这些也可以在系统终端里操作，不过可能需要的步骤多一些，还是直接在Pycharm里方便一些。在终端里输入1scrapy startproject myScrapy本来是可以在我们刚刚创建的项目里新建一个名为“myScrapy”的scrapy项目的，但是不知道为什么竟然报错了：这是什么奇奇怪怪的错误，我都没有“d:\\bld\\scrapy_1584555997548_h_env\\python.exe”这个目录，经过查找相关问题的资料，问题可能是出在Python环境上，因为我上一次新建项目时并没有报错，这一次我直接用的上一个项目的环境，网上还有一种说法是Scrapy的bug，详见Fatal error launching scrapy&gt;1.6.0 from Anaconda PromptIssue with conda-forge scrapy&gt;1.6.0 on Windows目前找到了两种解决方案：把python环境复制到报错的那个目录（d:\\bld\\scrapy_1584555997548_h_env\\python.exe），然后在创建scrapy项目，但这个解决方法有点愚蠢，就没有采用。在scrapy命令前面添加“python -m”选项：1python -m scrapy startproject myScrapy就可以正常创建了。关于Python的-m选项，官方给出的解释是“run library module as a script”，简单来说就是将库中的Python模块当作脚本去运行。特别感谢简书的大佬ccw1078提供的解释，很清晰明了，有兴趣的可以去瞅一下，因为和本文的主题爬虫没啥关系，在这里就不赘述了。出现这些提示就代表创建成功了。然后在spiders文件里新建一个spider.py文件，用于写爬虫。我们来看一下目前scrapy项目的目录结构。__init__.py：pycharm生成的文件，简化导入语句用的，可以忽略，没啥用，建议删了，留着可能会出问题。spiders：存放你Spider爬虫源文件​ spider.py：代码主要在这里写。items.py：数据容器。middlewares.py：Downloader Middlewares(下载器中间件)和Spider Middlewares(蜘蛛中间件)实现的地方。pipelines.py：项目管道文件，相当于数据中转站。实现数据的清洗，储存，验证。settings.py：scrapy的全局配置。scrapy.cfg：配置文件。scrapy已经帮我们把大体框架写好了，我们主要要修改的文件是spider.py，items.py，pipelines.py，settings.py。这是爬虫spider的基本工作方式，想要深入了解的可以去网上查找资料。②开始写代码先来写items.py。123456789import scrapyclass MyscrapyItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() school = scrapy.Field() num = scrapy.Field() pass再来搞settings.py，这个只需要找到这个注释掉的语句，把#去掉就OK了，就像这样：pipelines.py就很好写了，基本可以当模板来用。12345678910111213141516171819import jsonclass MyscrapyPipeline(object): def open_spider(self, spider): try: # 这个就是爬虫生成的文件，可以支持好多种格式，这里使用的是json文件 self.file = open('MyData.json', 'w', encoding=\"utf-8\") except Exception as err: print(err) def process_item(self, item, spider): dict_item = dict(item) json_str = json.dumps(dict_item, ensure_ascii=False) + \"\\n\" self.file.write(json_str) return item def close_spider(self, spider): self.file.close()spider.py是我们主要写的核心部分。这里需要一些html的xpath相关知识来对项进行定位，可以自行查找相关资料。12345678910111213141516171819202122232425262728293031323334353637383940414243\"\"\"@Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved.@Project: xuetangzaixian@Description: @Version: @Author: 苇名一心@Date: 2020-04-08 20:31@LastEditors: 苇名一心@LastEditTime: 2020-04-08 20:31\"\"\"import scrapyimport refrom myScrapy.myScrapy.items import MyscrapyItemclass mySpider(scrapy.spiders.Spider): # spider的名字 name = \"xuetang\" # 限制spider爬取的域名 allowed_domains = [\"www.xuetangx.com/\"] # 爬虫要爬取的网页，是一个列表，按顺序爬取 start_urls = [\"http://www.xuetangx.com/partners\"] # 这是一种方式，可以爬取网页中所有的项 # def parse(self, response): # item = MyscrapyItem() # for each in response.xpath(\"/html/body/article[1]/section/ul/*\"): # item['school'] = each.xpath(\"a/div[2]/h3/text()\").extract() # item['num'] = each.xpath(\"a/div[2]/p[1]/text()\").extract() # if item['num']: # item['num'] = re.findall(r'\\d+', item['num'][0]) # if item['school'] and item['num']: # yield (item) # 这是第二种方式，使用for循环，制定爬取项的数目 def parse(self, response): item = MyscrapyItem() for i in range(1, 144): item['school'] = response.xpath \\ (\"/html/body/article[1]/section/ul/li[&#123;&#125;]/a/div[2]/h3/text()\".format(i)).extract() item['num'] = response.xpath \\ (\"/html/body/article[1]/section/ul/li[&#123;&#125;]/a/div[2]/p[1]/text()\".format(i)).extract() # 判断爬取的项目是否为空，把非空的项目提交 if item['school'] and item['num']: yield (item)③可以开始运行啦在运行前要先在项目根目录下建立一个begin.py文件来控制scrapy爬虫的运行。123from scrapy import cmdline# \"xuetang\"是我们上面spider.py中定义的爬虫名cmdline.execute(\"scrapy crawl xuetang\".split())最终的项目结构（__init__.py没啥用，删了）：运行begin.py就可以开始爬虫了。出现这些提示就表示成功了，运行完毕后会发现项目根目录出现了我们在pipelines.py中设置好的MyData.json。打开MyData.json看一下，Perfect！有了这个json文件，我们就可以利用Python的pandas、numpy等工具进行各种处理，然后用matplotlib等模块进行画图了。三、总结本文只是对Python的scrapy爬虫进行了简单的介绍和用一个小Demo讲述了如何使用scrapy爬取网页数据，希望对你有所帮助。","categories":[{"name":"Python","slug":"Python","permalink":"https://666wxy666.github.io/categories/Python/"},{"name":"爬虫","slug":"Python/爬虫","permalink":"https://666wxy666.github.io/categories/Python/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://666wxy666.github.io/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://666wxy666.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"数据处理","slug":"数据处理","permalink":"https://666wxy666.github.io/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"学堂在线","slug":"学堂在线","permalink":"https://666wxy666.github.io/tags/%E5%AD%A6%E5%A0%82%E5%9C%A8%E7%BA%BF/"},{"name":"课程","slug":"课程","permalink":"https://666wxy666.github.io/tags/%E8%AF%BE%E7%A8%8B/"}]},{"title":"Hello Blog","slug":"我的第一篇博客","date":"2020-03-19T03:08:51.637Z","updated":"2020-03-31T12:21:28.836Z","comments":true,"path":"2020/03/19/我的第一篇博客/","link":"","permalink":"https://666wxy666.github.io/2020/03/19/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"HELLO BLOG欢迎来到我的博客，这是我的第一篇博客测试文章。","text":"HELLO BLOG欢迎来到我的博客，这是我的第一篇博客测试文章。如果有什么问题，欢迎到我的Github提问我。","categories":[{"name":"其他","slug":"其他","permalink":"https://666wxy666.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"first","slug":"first","permalink":"https://666wxy666.github.io/tags/first/"}]}],"categories":[{"name":"现代交换原理","slug":"现代交换原理","permalink":"https://666wxy666.github.io/categories/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"},{"name":"习题","slug":"现代交换原理/习题","permalink":"https://666wxy666.github.io/categories/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/%E4%B9%A0%E9%A2%98/"},{"name":"大数据","slug":"大数据","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"习题","slug":"大数据/习题","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E4%B9%A0%E9%A2%98/"},{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/categories/Linux/"},{"name":"习题","slug":"Linux/习题","permalink":"https://666wxy666.github.io/categories/Linux/%E4%B9%A0%E9%A2%98/"},{"name":"拓展学习","slug":"Linux/拓展学习","permalink":"https://666wxy666.github.io/categories/Linux/%E6%8B%93%E5%B1%95%E5%AD%A6%E4%B9%A0/"},{"name":"Python","slug":"Python","permalink":"https://666wxy666.github.io/categories/Python/"},{"name":"爬虫","slug":"Python/爬虫","permalink":"https://666wxy666.github.io/categories/Python/%E7%88%AC%E8%99%AB/"},{"name":"其他","slug":"其他","permalink":"https://666wxy666.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"习题","slug":"习题","permalink":"https://666wxy666.github.io/tags/%E4%B9%A0%E9%A2%98/"},{"name":"易错点","slug":"易错点","permalink":"https://666wxy666.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"网课","slug":"网课","permalink":"https://666wxy666.github.io/tags/%E7%BD%91%E8%AF%BE/"},{"name":"MOOC","slug":"MOOC","permalink":"https://666wxy666.github.io/tags/MOOC/"},{"name":"现代交换原理","slug":"现代交换原理","permalink":"https://666wxy666.github.io/tags/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"},{"name":"大数据","slug":"大数据","permalink":"https://666wxy666.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Spark","slug":"Spark","permalink":"https://666wxy666.github.io/tags/Spark/"},{"name":"HDFS","slug":"HDFS","permalink":"https://666wxy666.github.io/tags/HDFS/"},{"name":"MapReduce","slug":"MapReduce","permalink":"https://666wxy666.github.io/tags/MapReduce/"},{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/tags/Linux/"},{"name":"拓展","slug":"拓展","permalink":"https://666wxy666.github.io/tags/%E6%8B%93%E5%B1%95/"},{"name":"难点","slug":"难点","permalink":"https://666wxy666.github.io/tags/%E9%9A%BE%E7%82%B9/"},{"name":"Python","slug":"Python","permalink":"https://666wxy666.github.io/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://666wxy666.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"数据处理","slug":"数据处理","permalink":"https://666wxy666.github.io/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"学堂在线","slug":"学堂在线","permalink":"https://666wxy666.github.io/tags/%E5%AD%A6%E5%A0%82%E5%9C%A8%E7%BA%BF/"},{"name":"课程","slug":"课程","permalink":"https://666wxy666.github.io/tags/%E8%AF%BE%E7%A8%8B/"},{"name":"first","slug":"first","permalink":"https://666wxy666.github.io/tags/first/"}]}