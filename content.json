{"meta":{"title":"苇名一心的博客","subtitle":null,"description":"经验分享和技术交流。","author":"苇名一心","url":"https://666wxy666.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-04-01T09:45:17.617Z","updated":"2020-03-25T08:57:28.904Z","comments":true,"path":"404.html","permalink":"https://666wxy666.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除，您可以留言告诉我您要访问哪个页面找不到了，谢谢。"},{"title":"所有分类","date":"2020-04-01T09:45:17.618Z","updated":"2020-03-22T10:40:41.483Z","comments":true,"path":"categories/index.html","permalink":"https://666wxy666.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-04-27T12:38:07.457Z","updated":"2020-04-27T12:38:07.457Z","comments":true,"path":"about/index.html","permalink":"https://666wxy666.github.io/about/index.html","excerpt":"","text":"这里是我的基本信息：我的博客（Github）：苇名一心 我的博客（Gitee）：苇名一心 我的Github主页：666WXY666 我的Gitee主页：wxy_666 我的B站：在下-苇名一心 我的知乎：苇名一心 我的网易云：在下-苇名一心 我的微博：在下-苇名一心 欢迎关注我，与我联系。"},{"title":"","date":"2020-04-01T09:45:17.618Z","updated":"2020-03-25T07:29:48.422Z","comments":true,"path":"faqs/index.html","permalink":"https://666wxy666.github.io/faqs/index.html","excerpt":"","text":"README"},{"title":"所有标签","date":"2020-04-01T09:45:17.619Z","updated":"2020-03-25T07:51:09.297Z","comments":true,"path":"tags/index.html","permalink":"https://666wxy666.github.io/tags/index.html","excerpt":"","text":""},{"title":"说说","date":"2020-07-13T03:29:08.028Z","updated":"2020-07-13T03:29:08.028Z","comments":false,"path":"shuoshuo/index.html","permalink":"https://666wxy666.github.io/shuoshuo/index.html","excerpt":"","text":""},{"title":"","date":"2020-04-01T09:45:17.618Z","updated":"2020-03-22T01:11:48.329Z","comments":true,"path":"mylist/index.html","permalink":"https://666wxy666.github.io/mylist/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-08-29T15:36:52.847Z","updated":"2020-08-29T15:36:52.847Z","comments":true,"path":"friends/index.html","permalink":"https://666wxy666.github.io/friends/index.html","excerpt":"这里是我的朋友和一些大佬，感兴趣的就点进去看看吧！","text":"这里是我的朋友和一些大佬，感兴趣的就点进去看看吧！ 想在这里展示或者有什么问题欢迎给我留言。"}],"posts":[{"title":"操作系统 内存管理","slug":"操作系统-内存管理","date":"2020-09-02T16:00:00.000Z","updated":"2020-09-02T09:30:07.995Z","comments":true,"path":"2020/09/03/操作系统-内存管理/","link":"","permalink":"https://666wxy666.github.io/2020/09/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","excerpt":"本文是操作系统内存管理的基本实验。","text":"本文是操作系统内存管理的基本实验。 一、实验目的在本次实验中，需要从不同的侧面了解Windows 的虚拟内存机制。在Windows操作系统中，可以通过一些API 操纵虚拟内存。主要需要了解以下几方面： Windows 虚拟存储系统的组织 如何控制虚拟内存空间 如何编写内存追踪和显示工具 详细了解与内存相关的API 函数的使用 二、实验需求编写一个包含两个线程的进程，一个线程用于模拟内存分配活动，一个线程用于跟踪第一个线程的内存行为。模拟内存活动的线程可以从一个文件中读出要进行的内存操作，每个内存操作包含如下内容： 时间：开始执行的时间 块数：分配内存的粒度 操作：包括保留一个区域、提交一个区域、释放一个区域、回收一个区域以及锁与解锁一个区域；可以将这些操作编号，存放于文件中 大小：指块的大小 访问权限：共五种PAGE_READONLY、PAGE_READWRITE、PAGE_EXCUTE、PAGE_EXECUTE_READ 和PAGE_EXECUTE_READWRITE。可以将这些权限编号，存放于文件中。跟踪线程将页面大小、已使用的地址范围、物理内存总量以及虚拟内存总量等信息显示出来。 二、运行环境电脑硬件配置： 处理器：Intel i7 7700HQ 显卡：NVIDIA GeForce GTX 1050 Ti 内存：16GB 软件： 编程语言：C++ IDE：Microsoft Visual Studio 2019 Windows SDK版本：10.0 平台工具集：Visual Studio 2019（v142） 三、实验原理内存管理是Windows执行体的一部分，位于Ntoskrnl.exe 文件中，是整个操作系统的重要组成部分。物理内存是固定的，内存条的容量多大，物理内存就有多大。但是如果程序运行很多或者程序本身很大的话，就会导致大量的物理内存占用，甚至导致物理内存消耗殆尽。 虚拟内存就是在硬盘上划分一块页面文件，充当内存。当程序在运行时，有一部分资源还没有用上或者同时打开几个程序却只操作其中一个程序时，系统没必要将程序所有的资源都放在物理内存中。于是，系统将这些暂时不用的资源放在虚拟内存上，等到需要时在调出来用。这也是虚拟内存的优点：需要的时候才真正分配内存。 默认情况下，32位Windows上每个用户进程可以占有2GB的私有地址空间，操作系统占有剩下的2GB。Windows在x86体系结构上利用二级页表结构来实现虚拟地址向物理地址的变换。一个32位虚拟地址被解释为三个独立的分量——页目录索引、页表索引和字节索引——它们用于找出描述页面映射结构的索引。页面大小及页表项的宽度决定了页目录和页表索引的宽度。比如，在x86 系统中，因为一页包含4096字节，于是字节索引被确定为12位宽（2^12=4096）。 应用程序有三种使用内存方法： 以页为单位的虚拟内存分配方法，适合于大型对象或结构数组 内存映射文件方法，适合于大型数据流文件以及多个进程之间的数据共享 内存堆方法，适合于大量的小型内存申请 本次实验主要是针对第一种使用方式。应用程序通过API函数 VirtualAlloc和VirtualAllocEx等实现以页为单位的虚拟内存分配方法。首先保留地址空间，然后向此地址空间提交物理页面，也可以同时实现保留和提交。保留地址空间是为线程将来使用保留一块虚拟地址。在已保留的区域中，提交页面必须指出将物理存储器提交到何处以及提交多少。提交页面在访问时会转变为物理内存中的有效页面。 四、实验步骤1、编译运行makefile.cpp，生成opfile文件。opfile里记录了几个不同的内存操作，包括时间、块数、操作、大小、访问权限。生成了包括5个权限和6个操作任意组合共30个操作。 2、将生成的opfile复制到memory-op的工程目录下 3、编译运行memory-op.cpp，产生两个线程，一个从opfile文件里读取内存操作，模拟内存活动，另一个跟踪第一个的内存行为，将结果输出，并保存在out.txt文件中。 4、输出结果 五、相关的API 函数12345678910111213141516171819202122232425262728293031323334353637383940414243//可以通过GetSystemInfo，GlobalMemoryStatus 和VirtualQuery 来查询进程虚空间的状态。主要的信息来源如下：VOID GetSystemInfo （ LPSYSTEM_INFO lpSystemInfo ）;//结构SYSTEMINFO 定义如下：typedef struct _SYSTEM_INFO &#123;DWORD dwOemld;DWORD dwPageSize;LPVOID lpMinimumApplicationAddress;LPVOID lpMaximumApplicationAddress;DWORD dwActiveProcessorMask;DWORD dwNumberOfProcessors;DWORD dwProcessorType;DWORD dwAllocationGranularity;DWORD dwReserved;&#125; SYSTEM_INFO, *LPSYSTEM_INFO;//函数VOID GlobalMemoryStatus （LPMEMORYSTATUS lpBuffer）;//数据结构MEMORYSTATUS 定义如下：typedef struct _ MEMORYSTATUS &#123;DWORD dwLength;DWORD dwMemoryLoad;DWORD dwTotalPhys;DWORD dwAvailPhys;DWORD dwTotalPageFile;DWORD dwAvailPageFile;DWORD dwTotalVirtual;DWORD dwAvailVirtual;&#125; MEMORYSTATUS, * LPMEMORYSTATUS;DWORD VirtualQuery （ LPCVOLD lpAddress,PMEMORY_BASIC_INFORMATION lpBuffer, DWORD dwLength）;//主要数据结构MEMORY_BASIC_INFORMATION 定义如下：typedef struct _ MEMORY_BASIC_INFORMATION &#123;PVOID BaseAddress;PVOID AllocationBase;DWORD AllocationProtect;DWORD RegionSize;DWORD State;DWORD Protect;DWORD Type;&#125; MEMORY_BASIC_INFORMATION;typedef MEMORY_BASIC_INFORMATION * PMEMORY_BASIC_INFORMATION;//还有一些函数，例如VirtualAlloc，VirtualAllocEx，VirtualFree 和VirtualFreeEx 等，用于虚拟内存的管理，详情请见Microsoft 的Win32 API Reference Manual。 六、项目地址本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看：","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://666wxy666.github.io/categories/C-C/"},{"name":"项目","slug":"C-C/项目","permalink":"https://666wxy666.github.io/categories/C-C/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"工程","slug":"工程","permalink":"https://666wxy666.github.io/tags/%E5%B7%A5%E7%A8%8B/"},{"name":"操作系统","slug":"操作系统","permalink":"https://666wxy666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"内存管理","slug":"内存管理","permalink":"https://666wxy666.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}]},{"title":"操作系统 读者写者(生产者消费者)","slug":"操作系统-读者写者(生产者消费者)","date":"2020-09-02T16:00:00.000Z","updated":"2020-09-02T09:27:02.333Z","comments":true,"path":"2020/09/03/操作系统-读者写者(生产者消费者)/","link":"","permalink":"https://666wxy666.github.io/2020/09/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85(%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85)/","excerpt":"本文是操作系统进程同步互斥关于读者写者(生产者消费者)的基本实验。","text":"本文是操作系统进程同步互斥关于读者写者(生产者消费者)的基本实验。 一、需求本课程实验内容引自《Windows 内核实验教程》(陈向群、林斌等编著，机械工业出版社，2002.9)。 在Windows 环境下，创建一个包含n 个线程的控制进程。用这n 个线程来表示n个读者或写者。每个线程按相应测试数据文件的要求，进行读写操作。请用信号量机制分别实现读者优先和写者优先的读者-写者问题。 读者-写者问题的读写操作限制： 写-写互斥 读-写互斥 读-读允许 读者优先的附加限制：如果一个读者申请进行读操作时已有另一读者正在进行读操作，则该读者可直接开始读操作。 写者优先的附加限制：如果一个读者申请进行读操作时已有另一写者在等待访问共享资源，则该读者必须等到没有写者处于等待状态后才能开始读操作。 运行结果显示要求：要求在每个线程创建、发出读写操作申请、开始读写操作和结束读写操作时分别显示一行提示信息，以确信所有处理都遵守相应的读写操作限制。 二、运行环境电脑硬件配置： 处理器：Intel i7 7700HQ 显卡：NVIDIA GeForce GTX 1050 Ti 内存：16GB 软件： 编程语言：C++ IDE：Microsoft Visual Studio 2019 Windows SDK版本：10.0 平台工具集：Visual Studio 2019（v142） 三、核心算法读者优先：12345678910111213141516171819//信号量：mutex=1;//对read_count的互斥操作RP_Write=1;//保证读者优先，读者与写者互斥//读者：wait(mutex);read_count++;if(read_count==1) wait(&amp;RP_Write);signal(mutex);读临界区……wait(mutex);read_count--;if(read_count==0) signal(&amp;RP_Write);signal(mutex);//写者：wait(&amp;RP_Write);写临界区……signal(&amp;RP_Write); 写者优先：123456789101112131415161718192021222324252627282930313233343536//信号量：mutex1=1;//保证每个读者按顺序依次进入临界区mutex2=1;//对read_count的互斥操作mutex3=1;//对write_count的互斥操作cs_Read =1;//保证写者优先，读者与写者互斥cs_Write=1;//保证如果有读者正在读，写者等待当前读者读完后再写//读者：wait(mutex1);wait(&amp;cs_Read);wait(mutex2);read_count++;if(read_count==1) wait(&amp;cs_Write);signal(mutex2);signal(&amp;cs_Read);signal(mutex1);读临界区……wait(mutex2);read_count--;if(read_count==0) signal(&amp;cs_Write);signal(mutex2);//写者：wait(mutex3);write_count++;if(write_count==1) wait(&amp;cs_Read);signal(mutex3);wait(&amp;cs_Write);写临界区……signal(&amp;cs_Write);wait(mutex3);write_count--;if(write_count==0) signal(&amp;cs_Read);signal(mutex3); 输入： 屏幕输入： 1则选择读者优先，调用ReaderPriority(“thread.dat”)函数； 2则选择写者优先，调用WriterPriority(“thread.dat”)函数； 3则退出。 从thread.dat文件读入读者写者线程信息。输出：屏幕输出各读者写者线程信息。 五、测试样例： 输入1 可以看出，写者进程4、2、6虽然都请求了写操作，但是却是等待所有的读者1、3、5读完了再按顺序进行的写入操作，符合读者优先的要求。 输入2 可以看出，除了第一个读者进程1在读文件外，虽然读者3、5都请求了读操作，但由于写者进程4、2、6请求了写操作，因为写者优先，所以读者3、5都要等待写者4、2、6写入完成才能读，而写者4、2、6必须等待读者进程1读操作完成后才能写。读者1读操作完成后，写者4、2、6按顺序写入文件，写入完成后，读者3、5同时读文件，符合写者优先的要求。 输入3 释放线程，程序退出。 六、项目地址本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看：","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://666wxy666.github.io/categories/C-C/"},{"name":"项目","slug":"C-C/项目","permalink":"https://666wxy666.github.io/categories/C-C/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"工程","slug":"工程","permalink":"https://666wxy666.github.io/tags/%E5%B7%A5%E7%A8%8B/"},{"name":"操作系统","slug":"操作系统","permalink":"https://666wxy666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"读者写者","slug":"读者写者","permalink":"https://666wxy666.github.io/tags/%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85/"},{"name":"生产者消费者","slug":"生产者消费者","permalink":"https://666wxy666.github.io/tags/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/"},{"name":"进程","slug":"进程","permalink":"https://666wxy666.github.io/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"同步互斥","slug":"同步互斥","permalink":"https://666wxy666.github.io/tags/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/"},{"name":"信号量","slug":"信号量","permalink":"https://666wxy666.github.io/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"}]},{"title":"操作系统 进程线程管理通信与同步互斥","slug":"操作系统-进程线程管理通信与同步互斥","date":"2020-09-02T16:00:00.000Z","updated":"2020-09-02T09:39:33.689Z","comments":true,"path":"2020/09/03/操作系统-进程线程管理通信与同步互斥/","link":"","permalink":"https://666wxy666.github.io/2020/09/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86%E9%80%9A%E4%BF%A1%E4%B8%8E%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/","excerpt":"本文是操作系统课程设计关于进程线程管理通信与同步互斥的综合实验（长文警告）。","text":"本文是操作系统课程设计关于进程线程管理通信与同步互斥的综合实验（长文警告）。 一、实验目的 以OpenEuler等Linux操作系统为实验对象，加深对Linux进程、线程概念的理解，掌握利用Linux系统调用创建、管理进程的方法，掌握利用POSIX线程（Pthread）库创建管理线程的方法，认识进程、线程并发执行的实质； 深入理解Linux内核提供的消息队列、共享内存、管道、软中断四种进程间通信机制，掌握利用系统调用实现进程间通信； 了解Pthread线程库提供的线程间通信机制，掌握使用Pthread API实现线程间通信的方法； 深入理解Linux系统提供的多种进程同步互斥机制，掌握使用信号量实现进程间的同步互斥的方法； 了解Pthread提供的线程同步互斥机制，掌握使用互斥变量和条件变量实现多线程间的同步互斥的方法 二、实验环境硬件： Intel i7 7700HQ，内存16GB 软件： 虚拟机：VMware Workstation Pro 15.5.6 Linux系统：华为openEuler-20.03-LTS-x86_64 Pthread线程库，POSIX接口 gcc编译 C语言 三、实验内容在Linux环境下，采用C/C++/Java（或其它语言）编程，完成以下实验内容。 1、第一组 进程的创建与管理 阅读Linux内核源码，分析Linux进程的组成，观察进PCB/task_struc等进程管理数据结构； 利用Linux内核提供的fork()、exec()、wait()等系统调用，创建管理多个进程，观察父子进程的结构和并发行为，掌握睡眠、撤销等进程控制方法； 掌握ps、top、pstree –h、vmstat、strace、ltrace、sleep x、kill、jobs等命令的功能和使用方式； 2、第二组 线程的创建与管理 了解POSIX 线程标准库（Pthread线程库）定义的线程结构和提供的线程管理API； 利用Pthread线程库API，创建管理多个线程，观察线程的结构和并发执行行为； 3、第三/四组 进程/线程通信 了解Linux提供的消息队列、共享内存、管道、软中断Signal等四种通信机制，编程实现进程间通信； 线程通信 了解Linux所支持的线程机制，在一个进程内创建多个主从线程，采用参数传递机制，实现线程间通信； 4、第五组 进程/线程同步互斥要求：参照2019-2020学年操作系统期末考试信号量题目，设计实现三个进程/线程A、B、C，分别模拟题目所描述的生产产品A、B、C的三个worker，观察并记录进程/线程的创建和同步互斥行为。重点分析信号量设计方案是否合理、符合预期，避免设计方案导致死锁或不符合题目要求。 期末考试试题如下： An assembly line is to produce a product C with four part As, and three part Bs. The worker of machining(加工) A and worker of machining B will produce two part As and one part B independently each time. Then the two part As or one part B will be moved to the station(工作台), which can hold at most 12 of part As and part Bs altogether. Two part As must be put onto the station simultaneously. The workers must exclusively put a part on the station or get it from the station. In addition, the worker to make C must get all part of As and Bs for one product once. Using semaphores to coordinate the three workers who are machining part A, part B and the product C to manufacture the product without deadlock. It is required that (1) definition and initial value of each semaphore, and (2) the algorithm to coordinate the production process for the three workers should be given. 进程同步互斥 创建3个Linux进程，分别模拟生产产品A、B、C的三个worker的行为，利用Linux内核信号量，实现三者间正确的同步互斥； 线程同步互斥 利用Pthread API，创建3个Linux线程，分别模拟生产产品A、B、C的三个worker的行为，采用Pthread提供的信号量/管程机制，现三者间正确的同步互斥； 四、实验步骤0、实验环境配置0-1. Linux 操作系统安装 选择OpenEuler等Linux发行版本，观察所采用的内核版本，采用硬盘分区模式安装Linux系统； 也可以先在本机操作系统上安装VitualBox、VMware、Virtual PC等虚拟机软件，在虚拟机之上安装Linux系统。 注意安装操作系统所需的软硬件环境和硬件配置要求。 0-2. Pthread 线程库安装观察确认所安装的Linux发行版本带有Pthread线程库，注意： 某些版本Ubuntu Linux默认不带Pthread线程库，即使在编译的度时候 加上-lpthread也不行，man不到相关Pthread函知数。此时，需要在/usr/lib/…下导入动态库libpthread.a，具体方法可以查阅网上相关资料。 后续编程时导入头文件：#include &lt;pthread.h&gt; 因为我电脑早已经安装了VMware虚拟机，就不重新安装了，直接下载安装OpenEuler。 1、下载OpenEuler 进入OpenEuler下载页面，下载openEuler-20.03-LTS-x86_64-dvd.iso镜像。 等待下载完成。 2、创建虚拟机 打开VMware Workstation Pro，选择“创建新的虚拟机”。 选择“自定义”。 设置虚拟机的硬件兼容性限制，按照默认选择。 选择下载好的openEuler-20.03-LTS-x86_64-dvd.iso镜像。 选择Linux 操作系统。 配置虚拟机的名称，位置，处理器，内存，网络连接、控制器、磁盘等。 创建完成。 3、安装OpenEuler 启动虚拟机。 选择第一项安装OpenEuler。 等待check完毕。 选择安装过程中所使用的语言。 选择分区和软件模块，点击“开始安装”后，开始安装系统，在安装期间可以设置Root密码以及创建用户。 安装完成。 重启后登录OpenEuler系统。 创建的wxy用户以及root用户均可以成功登录，安装OpenEuler完成。 1、第一组 进程的创建与管理实验1-1. 进程观察查阅相关资料，阅读Linux内核源码，分析Linux进程的组成，了解进程状态，观察进PCB/task_struc等进程管理数据结构； 实验1-2. 进程创建与管理参照**“【实验指导】1. 进程创建及管理示例”**中的程序，结合所查阅的参考资料，利用Linux内核提供的fork()、exec()、wait()、exit()、kill()等系统调用，创建管理多个进程，观察父子进程的结构和并发行为，掌握睡眠、撤销等进程控制方法； 要求：本组实验至少用到fork()、exec()、wait()、exit()、kill()、getpid()五个系统调用。 1-2-1 fork()123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char **argv)&#123; __pid_t pid; if ((pid = fork()) &gt; 0) &#123; printf(\"I am the parent process.\\n\"); /*父进程处理过程*/ &#125; else if (pid == 0) &#123; printf(\"I am the child process.\\n\"); /*子进程处理过程*/ &#125; else &#123; printf(\"fork error\\n\"); exit(0); &#125;&#125; fork的返回值如果是&gt;0，那么就是父进程，这个&gt;0的返回值就是创建的子进程的PID； fork的返回值如果是=0，那么就是子进程； fork的返回值如果是&lt;0，那么就是fork失败； 1-2-2 exec()123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char **argv)&#123; char *envp[] = &#123;\"PATH=/tmp\", \"USER = 1ei\", \"STATUS = testing\", NULL&#125;; char *argv_execv[] = &#123;\"echo\", \"excuted by execv\", NULL&#125;; char *argv_execvp[] = &#123;\"echo\", \"excuted by execvp\", NULL&#125;; char *argv_execve[] = &#123;\"env\", NULL&#125;; if (fork() == 0) &#123; if (execl(\"/bin/echo\", \"echo\", \"executed by execl\", NULL) &lt; 0) perror(\"Err on execl\"); &#125; if (fork() == 0) &#123; if (execlp(\"echo\", \"echo\", \"executed by execlp\", NULL) &lt; 0) perror(\"Err on execlp\"); &#125; if (fork() == 0) &#123; if (execle(\"/usr/bin/env\", \"env\", NULL, envp) &lt; 0) perror(\"Err on execle\"); &#125; if (fork() == 0) &#123; if (execv(\"/bin/echo\", argv_execv) &lt; 0) perror(\"Err on execv\"); &#125; if (fork() == 0) &#123; if (execvp(\"echo\", argv_execvp) &lt; 0) perror(\"Err on execvp\"); &#125; if (fork() == 0) &#123; if (execve(\"/usr/bin/env\", argv_execve, envp) &lt; 0) perror(\"Err on execve\"); &#125;&#125; exec用一个指定的程序文件,重新初始化一个进程。 可指定新的命令行参数和环境参数(初始化堆栈底部)。 exec不创建新进程,只是将当前进程重新初始化了指令段和用户数据段,堆栈段以及CPU的PC指针。 6种格式exec系统调用，exec前缀,后跟以下字母： l—list，v—vector l与v:指定命令行参数的两种方式，l以表的形式，v要事先组织成一个指针数组。 e—env 需要指定envp来初始化进程。 p—path 使用环境变量PATH查找可执行文件。 1-2-3 wait()12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char **argv)&#123; __pid_t pid; if ((pid = fork()) &gt; 0) &#123; int status, wait_pid; printf(\"I am the parent process.\\n\"); wait_pid = wait(&amp;status); printf(\"pid=%d,wait_pid=%d\\n\", pid, wait_pid); printf(\"status=%#X,WTERMSIG=%d,WEXITSTATUS=%d\\n\", status, WTERMSIG(status), WEXITSTATUS(status)); /*父进程处理过程*/ &#125; else if (pid == 0) &#123; int i; for (i = 0; i &lt; 3; i++) &#123; printf(\"I am the child process.\\n\"); sleep(1); &#125; /*子进程处理过程*/ exit(5); &#125; else &#123; printf(\"fork error\\n\"); exit(0); &#125;&#125; 函数返回值为已终止的子进程PID。 status中含有子进程终止的原因。 TERMSIG(status)为被杀信号。 EXITSTATUS(status)为退出码。 子进程正常退出，且退出码为5，因此wait的status退出码刚好是5。 1-2-4 kill()12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char **argv)&#123; __pid_t pid; if ((pid = fork()) &gt; 0) &#123; int status; printf(\"I am the parent process.\\n\"); sleep(3); kill(pid, 5); wait(&amp;status); printf(\"%#X,%d,%d\\n\", status, WTERMSIG(status), WEXITSTATUS(status)); /*父进程处理过程*/ &#125; else if (pid == 0) &#123; while (1) &#123; printf(\"I am the child process.\\n\"); sleep(1); &#125; /*子进程处理过程*/ exit(0); &#125; else &#123; printf(\"fork error\\n\"); exit(0); &#125;&#125; 可以发现子进程被父进程杀掉了，且终止码为5，刚好wait的终止码也是5。 1-2-5 getpid()12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char **argv)&#123; __pid_t pid; if ((pid = fork()) &gt; 0) &#123; printf(\"I am the parent process.\\tpid=%d,child_pid=%d\\n\", getpid(), pid); /*父进程处理过程*/ &#125; else if (pid == 0) &#123; printf(\"I am the child process.\\t\\tpid=%d,ppid=%d\\n\", getpid(), getppid()); /*子进程处理过程*/ exit(0); &#125; else &#123; printf(\"fork error\\n\"); exit(0); &#125;&#125; 可以发现，父进程打印的子进程pid和子进程的pid相等，子进程打印的父进程的pid也和父进程的pid相等。 实验1-3. 进程管理命令了解ps、top、pstree –h、vmstat、strace、ltrace、sleep x、kill、jobs等命令的功能，使用这些命令观察进程结构和行为； 1-3-1 ps查看正在运行的进程。 1-3-2 toptop查看进程相关信息。 1-3-3 pstree –hpstree查看进程树。 1-3-4 vmstatvmstat可以查看系统相关信息。 1-3-5 strace先运行这个程序（ltrace、kill、jobs也是一样）： 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char **argv)&#123; __pid_t pid; if ((pid = fork()) &gt; 0) &#123; while (1) &#123; printf(\"I am the parent process.\\tpid=%d,child_pid=%d\\n\", getpid(), pid); sleep(3); &#125; /*父进程处理过程*/ &#125; else if (pid == 0) &#123; while (1) &#123; printf(\"I am the child process.\\t\\tpid=%d,ppid=%d\\n\", getpid(), getppid()); sleep(3); &#125; /*子进程处理过程*/ exit(0); &#125; else &#123; printf(\"fork error\\n\"); exit(0); &#125;&#125; 屏幕输出： strace就相当于是调试信息： 1-3-6 ltraceltrace也是同理。 1-3-7 sleep x睡眠了3s后继续输出。 1-3-8 kill 运行kill后只有父进程输出，子进程被杀掉了。 1-3-9 jobs jobs查看已挂载的程序,不用携带任何参数，这里查看了正在后台运行的1-2-5程序。 2、第二组 线程的创建与管理实验2-1. Pthread线程库背景知识了解POSIX 线程标准库（Pthread线程库）相关知识，分析Pthread线程结构，掌握所提供的线程管理API，如pthread_create(), pthread_join(), pthread_self(), pthread_detach(), pthread_exit()； 实验2-2. 线程创建与管理参照**“【实验指导】 2. 线程创建及管理程序示例”**，查阅参考资料，利用Pthread API，创建和管理线程，观察线程的结构和并发执行行为； 要求：本组实验至少用到pthread_create(), pthread_exit(),pthread_join(), pthread_self()等四个API。 2-2-1 pthread_create()函数原型： 12#include&lt;pthread.h&gt;int pthread_create(pthread_t *thread，pthread_attr_t*attr，void*(*start_routine)(void *), void *arg) 函数说明：创建线程。 参数和返回值： 参数 说明 thread 该参数是指向线程标识符的指针，当线程创建成功时，用来返回创建的线程ID attr 该参数用于指定线程的属性，NULL表示使用默认属性 start_routine 该参数为一个函数指针，指向线程创建后要调用的函数，是一个以指向void的指针作为参数和返回值的函数指针，这个被线程调用的函数也被称为线程函数 arg 指向传递给线程函数的参数，NULL代表不传参数 返回值 成功：0出错：返回错误码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;void *mythread1(void *arg)&#123; int i; for (i = 0; i &lt; 5; i++) &#123; printf(\"I am thread 1\\n\"); sleep(2); &#125;&#125;void *mythread2(void *arg)&#123; int i; for (i = 0; i &lt; 5; i++) &#123; printf(\"I am thread 2\\n\"); sleep(2); &#125;&#125;int main(int argc, char const *argv[])&#123; pthread_t id1, id2; int res; res = pthread_create(&amp;id1, NULL, mythread1, NULL); if (res) &#123; printf(\"Create pthread error!\\n\"); return -1; &#125; res = pthread_create(&amp;id2, NULL, mythread2, NULL); if (res) &#123; printf(\"Create pthread error!\\n\"); return -2; &#125; pthread_join(id1, NULL); pthread_join(id2, NULL); return 0;&#125; 可以发现，创建了两个线程：thread1和thread2。两个线程分别打印自己的信息，等带2s后继续打印。 2-2-2 pthread_exit()函数原型： 12#include&lt;pthread.h&gt;void pthread_exit(void *retval) 函数说明：线程退出。 参数和返回值： 参数 说明 Rretval 线程结束时的返回值,可由其它函数如pthread_join0来获取 返回值 void 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;void *create(void *arg)&#123; printf(\"New thread is create...\\n\"); pthread_exit((void *)6);&#125;int main(int argc, char const *argv[])&#123; pthread_t tid; int res; void *temp; res = pthread_create(&amp;tid, NULL, create, NULL); printf(\"I am the main thread!\\n\"); if (res) &#123; printf(\"thread id not create...\\n\"); return -1; &#125; res = pthread_join(tid, &amp;temp); if (res) &#123; printf(\"thread is not exit...\\n\"); return -2; &#125; printf(\"Thread is exit code %ld \\n\", (long)temp); return 0;&#125; 可以发现，子线程退出，主线程接收到了子线程的退出码6。 2-2-3 pthread_join()函数原型： 12#include&lt;pthread.h&gt;int pthread_join(pthread_t thread，void **thread_return) 函数说明：线程等待。 参数和返回值： 参数 说明 thread 等待退出的线程ID thread_return 用于定义的指针，用来存储被等待线程结束时的返回值(不为NULL时) 返回值 成功：0出错：返回错误码 1234567891011121314151617181920212223242526272829#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;void *thread(void *str)&#123; int i; for (i = 0; i &lt; 4; ++i) &#123; sleep(2); printf(\"This is the thread:%d\\n\", i); &#125; return NULL;&#125;int main(int argc, char const *argv[])&#123; pthread_t pth; long i; int ret = pthread_create(&amp;pth, NULL, thread, (void *)(i)); pthread_join(pth, NULL); printf(\"123\\n\"); for (i = 0; i &lt; 3; ++i) &#123; sleep(1); printf(\"This is the main:%ld\\n\", i); &#125; return 0;&#125; 可以发现主线程在调用pthread_join后等待子线程输出完毕结束后再进行的输出，相当于是主线程被阻塞。 2-2-4 pthread_self()函数原型： 12#include&lt;pthread.h&gt;Pthread_t pthread_self(void) 函数说明：获取调用线程的标识ID。 参数和返回值： 参数 说明 void 无 返回值 返回调用该函数的线程的标识ID 123456789101112131415161718192021222324252627#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;void *create(void *arg)&#123; printf(\"New thread...\\n\"); printf(\"This thread's id is %u \\n\", (unsigned int)pthread_self()); printf(\"This thread process pid is %d\\n\", getpid()); return NULL;&#125;int main(int argc, char const *argv[])&#123; pthread_t tid; int res; printf(\"Main thread is starting...\\n\"); res = pthread_create(&amp;tid, NULL, create, NULL); if (res) &#123; printf(\"thread id not create...\\n\"); return -1; &#125; printf(\"The main process pid is %d\\n\", getpid()); sleep(1); return 0;&#125; 可以发现，子线程成功打印了自己的线程id，并且子线程的进程pid和主线程的进场pid相等，这也说明这两个线程属于同一个进程。 2-2-5 pthread_cleanup_push()，pthread_cleanup_pop()函数原型： 12#include&lt;pthread.h&gt;void pthread_cleanup_push(void (*rtn)(void *), void *arg) 函数说明：将清除函数压入清除栈 参数和返回值： 参数 说明 rtn 清除函数 arg 清除函数的参数 返回值 void 函数原型： 12#include&lt;pthread.h&gt;void pthread_cleanup_pop(int execute) 函数说明：将清除函数弹出清除栈 参数和返回值： 参数 说明 execute 执行到pthread_cleanup_pop()时是否在弹出清理函数的同时执行该函数。非0：执行；0：不执行 返回值 void 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;void *clean(void *arg)&#123; printf(\"Cleanup %s\\n\", (char *)arg); return (void *)0;&#125;void *thr_fn1(void *arg)&#123; printf(\"Thread1 start\\n\"); pthread_cleanup_push((void *)clean, \"Thread1 first handler\"); pthread_cleanup_push((void *)clean, \"Thread1 second handler\"); printf(\"Thread1 push complete\\n\"); if (arg) &#123; return ((void *)1); &#125; pthread_cleanup_pop(1); pthread_cleanup_pop(1); return (void *)2;&#125;void *thr_fn2(void *arg)&#123; printf(\"Thread2 start\\n\"); pthread_cleanup_push((void *)clean, \"Thread2 first handler\"); pthread_cleanup_push((void *)clean, \"Thread2 second handler\"); printf(\"Thread2 push complete\\n\"); if (arg) &#123; return ((void *)3); &#125; pthread_cleanup_pop(0); pthread_cleanup_pop(1); return (void *)4;&#125;int main(int argc, char const *argv[])&#123; int res; pthread_t tid1, tid2; void *tret; res = pthread_create(&amp;tid1, NULL, thr_fn1, (void *)1); if (res != 0) &#123; printf(\"Create theate error...\\n\"); return -1; &#125; res = pthread_create(&amp;tid2, NULL, thr_fn2, (void *)0); if (res != 0) &#123; printf(\"Create theate error...\\n\"); return -1; &#125; res = pthread_join(tid1, &amp;tret); if (res != 0) &#123; printf(\"Thread_join error...\\n\"); return -1; &#125; printf(\"Thread1 exit code %ld\\n\", (long)tret); res = pthread_join(tid2, &amp;tret); if (res != 0) &#123; printf(\"Thread_join error...\\n\"); return -1; &#125; printf(\"Thread2 exit code %ld\\n\", (long)tret); return 0;&#125; 对于Thread1，传入的参数是1，因此函数thr_fn1只执行了两个pthread_cleanup_push，在pthread_cleanup_pop之前就return 1了，因此Thread1没有Cleanup输出，且返回码是1。 对于Thread2，传入的参数是0，因此函数thr_fn2在执行了两个pthread_cleanup_push后又执行了两个pthread_cleanup_pop，但是第一个pthread_cleanup_pop传的参数是0，第二个pthread_cleanup_pop传的参数是1，而且这个是栈的结构，第一个出栈的“Thread2 second handler”，参数为0，不清理；第二个出栈的“Thread2 first handler”，参数为1，清理。因此Thread2只有一个Cleanup输出（Thread2 first handler），且返回码是4。 2-2-6 综合12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#define THREAD_NUMBER 3 //线程数#define REPEAT_NUMBER 5 //每个线程中的小任务数#define DELAY_TIME_LEVELS 10.0 //小任务之间的最大时间间隔void *thrd_func(void *arg)&#123; long thrd_num = (long)arg; int delay_time = 0; int count = 0; printf(\"Thread %ld is starting\\n\", thrd_num); for (count = 0; count &lt; REPEAT_NUMBER; count++) &#123; delay_time = (int)(rand() * DELAY_TIME_LEVELS / (RAND_MAX)) + 1; sleep(delay_time); printf(\"\\tThread %ld:job %d delay=%d\\n\", thrd_num, count, delay_time); &#125; printf(\"Thread %ld finished\\n\", thrd_num); pthread_exit(NULL);&#125;int main(int argc, char const *argv[])&#123; pthread_t thread[THREAD_NUMBER]; long no, res; void *thrd_ret; srand(time(NULL)); for (no = 0; no &lt; THREAD_NUMBER; no++) &#123; res = pthread_create(&amp;thread[no], NULL, thrd_func, (void *)no); if (res != 0) &#123; printf(\"Create thread %d failed\\n\", no); exit(res); &#125; &#125; printf(\"Creating threads success\\nWaiting for thread to finish...\\n\"); for (no = 0; no &lt; THREAD_NUMBER; no++) &#123; res = pthread_join(thread[no], &amp;thrd_ret); if (!res) &#123; printf(\"Thread %d joined\\n\", no); &#125; else &#123; printf(\"Thread %d joined failed\\n\", no); &#125; &#125; return 0;&#125; 这个综合案例就是创建了3个线程，让3个线程共用同一个执行函数。每个线程都有5次循环（可以看成5个小任务，也就是5个job），每次循环之间会随机等待1～10s的时间，意义在于模拟每个任务的到达时间是随机的，并没有任何特定的规律。最后就是三个线程相继完成了各自的任务，都成功join，最后主线程结束。 3、第三组 进程间通信了解Linux提供的消息队列（消息传递）、共享内存、管道/命名管道、信号(signal)/软中断四种进程间通信机制的实现原理和方法； 消息队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。具有一定权限的进程通过向消息队列中写入组织成消息的数据、从队列中读取数据，实现相互间通信。消息队列克服了信号signal承载信息量少，管道pipe只能承载无格式字节流以及缓冲区大小受限等缺点； 共享内存：多个进程通过访问同一块内存空间，实现快速的进程间通信是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥； 管道（Pipe）及命名管道（named pipe）：用于具有亲缘关系进程间的通信，命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还支持无亲缘关系进程间的通信； 信号（Signal：也称为软中断，是一种基于事件的通信机制，用于通知接受进程有某种事件发生。除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction； 参照**“【实验指导】 6.3 进程间通信示例”**，查阅参考资料，选择上述四种通信方式中的一种，编程实现进程间通信，观察进程间通信过程。 我选择的是消息队列（消息传递）方式。 消息结构体： 12345struct my_message&#123; long int message_type; /* The data you wish to transfer*/&#125;; 相关函数： 函数原型 说明 int msgget(key_t key, int msgflg); 创建和访问一个消息队列 int msgsend(int msgid, const void *msg_ptr, size_t msg_sz, int msgflg); 将消息添加到消息队列，即消息发送 int msgrcv(int msgid, void *msg_ptr, size_t msg_st, long int msgtype, int msgflg); 从一个消息队列获取消息，即消息接收 int msgctl(int msgid, int command, struct msgid_ds *buf); 控制消息队列 代码： 信息发送方：msgsend.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;sys/msg.h&gt;#include &lt;errno.h&gt;#define MAX_TEXT 512struct msg_st&#123; long int msg_type; char text[MAX_TEXT];&#125;;int main()&#123; int running = 1; struct msg_st data; char buffer[BUFSIZ]; int msgid = -1; //建立消息队列 msgid = msgget((key_t)1234, 0666 | IPC_CREAT); if (msgid == -1) &#123; fprintf(stderr, \"msgget failed with error: %d\\n\", errno); exit(EXIT_FAILURE); &#125; //向消息队列中写消息，直到写入end while (running) &#123; //输入数据 printf(\"Enter some text: \"); fgets(buffer, BUFSIZ, stdin); data.msg_type = 1; //注意2 strcpy(data.text, buffer); //向队列发送数据 if (msgsnd(msgid, (void *)&amp;data, MAX_TEXT, 0) == -1) &#123; fprintf(stderr, \"msgsnd failed\\n\"); exit(EXIT_FAILURE); &#125; //输入end结束输入 if (strncmp(buffer, \"end\", 3) == 0) running = 0; sleep(1); &#125; exit(EXIT_SUCCESS);&#125; 消息接受方：msgreceive.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;sys/msg.h&gt;struct msg_st&#123; long int msg_type; char text[BUFSIZ];&#125;;int main()&#123; int running = 1; int msgid = -1; struct msg_st data; long int msgtype = 0; //注意1 //建立消息队列 msgid = msgget((key_t)1234, 0666 | IPC_CREAT); if (msgid == -1) &#123; fprintf(stderr, \"msgget failed with error: %d\\n\", errno); exit(EXIT_FAILURE); &#125; //从队列中获取消息，直到遇到end消息为止 while (running) &#123; if (msgrcv(msgid, (void *)&amp;data, BUFSIZ, msgtype, 0) == -1) &#123; fprintf(stderr, \"msgrcv failed with errno: %d\\n\", errno); exit(EXIT_FAILURE); &#125; printf(\"You wrote: %s\\n\", data.text); //遇到end结束 if (strncmp(data.text, \"end\", 3) == 0) running = 0; &#125; //删除消息队列 if (msgctl(msgid, IPC_RMID, 0) == -1) &#123; fprintf(stderr, \"msgctl(IPC_RMID) failed\\n\"); exit(EXIT_FAILURE); &#125; exit(EXIT_SUCCESS);&#125; 在第一个终端中编译运行msgsend.c： 新开一个终端编译运行msgreceive.c： 在第一个终端的发送进程中输入，能在第二个终端的接收进程中显示： 在发送进程中输入end，接收进程接收到了end信号，就会删除消息队列，退出进程；发送进程也会在退出。 在同一个终端，发送进程后台运行也是同样的道理。但是如果开两个接收进程，一个发送进程，那么就会出现接收进程争抢使用消息队列的情况，并且每个消息只会被使用一次，不会出现被重复消费的情况。因此最后的end消息因为只会被一个接收方拿到，且将消息队列删除，发送方和接收方1正常退出，但是导致另一个接收方2找不到消息队列，出错退出。 msgsend： msgreceive1： msgreceive2： 4、第四组 线程间通信了解Linux中的线程概念、线程通信机制、线程间同步互斥模式，以及多线程编程方式； 参照*“【实验指导】 6.2.7 Linux c/c++线程间参数传递”**中的【示例2-3-3】～【示例2-3-5】***，编程实现线程间参数传递。 示例2-3-3 向新建的线程传递字符串代码： 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;void *create(void *arg)&#123; char *str; str = (char *)arg; printf(\"The parameter passed from main is %s\\n\", str); return (void *)0;&#125;int main()&#123; int error; pthread_t id1; char *str1 = \"Hello!\"; char *attr = str1; error = pthread_create(&amp;id1, NULL, create, (void *)attr); if (error != 0) &#123; printf(\"This pthread is not created!\\n\"); return -1; &#125; sleep(1); printf(\"pthread is created..\\n\"); return 0;&#125; 运行结果： 可以发现Hello字符串已经传到了子线程，并在子线程打印输出。 示例2-3-4 向新建的线程传递字符串代码： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;struct member&#123; int a; char *s;&#125;;void *create(void *arg)&#123; struct member *temp; temp = (struct member *)arg; printf(\"member-&gt;a = %d\\n\", temp-&gt;a); printf(\"member-&gt;s = %s\\n\", temp-&gt;s); return (void *)0;&#125;int main(int argc, char const *argv[])&#123; int error; pthread_t id1; struct member *p; p = (struct member *)malloc(sizeof(struct member)); p-&gt;a = 1; p-&gt;s = \"Robben!\"; error = pthread_create(&amp;id1, NULL, create, (void *)p); if (error) &#123; printf(\"pthread is not created!\\n\"); return -1; &#125; sleep(1); printf(\"pthread is created!\\n\"); free(p); p = NULL; return 0;&#125; 运行结果： 可以发现，结构体member传递到了子线程中，member中的int型a和char*型s，在子线程中被输出。 示例2-3-5 验证新建立的线程可以共享进程中的数据代码： 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;static int a = 5;void *create(void *arg)&#123; printf(\"New pthread...\\n\"); printf(\"a = %d\\n\", a); a = -1; return (void *)0;&#125;int main(int argc, const char *argv[])&#123; int error; pthread_t id1; a = 10; error = pthread_create(&amp;id1, NULL, create, NULL); if (error != 0) &#123; printf(\"new thread is not created!\\n\"); return -1; &#125; sleep(1); printf(\"a = %d\\n\", a); printf(\"New thread is created...\\n\"); return 0;&#125; 运行结果： 可以发现，定义了一个静态变量a=5，在主线程创建子线程之前a被赋值为10，然后主线程创建子线程，子线程读取a，读取到的是重新赋值后的a（10）,因此子线程中输出a = 10。然后子线程中将a修改为-1，因为主线程等待（sleep）了1s，因此主线程拿到的a是子线程修改后的a（-1），因此主线程中输出a = -1。这也证明了新建立的线程可以共享进程中的数据，同一进程中的主线程和子线程可以共享进程中的静态数据。 5、第五组 进程/线程间同步与互斥（二选一） 针对2019-2020学年操作系统期末考试信号量题目，定义合理的锁和信号量，设计生产产品A、B、C的三个worker三个进程/线程A、B、C的业务流程和同步互斥机制。 要求：给出具体的设计方案，并单独提交设计方案，类似期末考试答题形式； 参照**“【实验指导】 6.5 进程间同步互斥示例”**，根据上一步的设计方案，利用semget、semctl、semop等信号量原语，以进程方式编程实现该设计方案； 观察分析程序运行结果，重点分析信号量设计方案是否合理、程序运行是否符合预期，应避免设计方案导致死锁或不符合题目要求。 参照**“【实验指导】 6.6 线程间同步互斥示例”**，根据第一步的设计方案，利用Pthread提供的pthread_mutex_init()、pthread_mutex_lock()、pthread_mutex_unlock()等线程同步互斥API，以线程方式编程实现该设计方案； 观察分析程序运行结果。重点分析信号量设计方案是否合理、程序运行是否符合预期，应避免设计方案导致死锁或不符合题目要求。 要求： 基于进程和基于线程的同步互斥实现方案二选一，完成其中一个即可； 不论采用进程方式、还是线程方式，模拟A、B、C三个worker的三个进程/线程A、B、C应当多次循环反复执行，便于观察同步互斥效应； 根据设计方案，给出程序代码，程序运行结果，结果分析。 我选择的是基于进程的同步互斥实现方案。 1、设计方案方案1（采用二元互斥信号量+整形变量，效率比方案2高）：整型变量123int count_A=0; // 当前工作台中已有的A的数量int count_B=0; // 当前工作台中已有的B的数量int empty=12; // 工作台中空位数量，empty=12-(count_A+count_B) 信号量经分析题目，发现共需要4个信号量，分别为： 1234semaphore MUTEX_STATION = 0 // 二元信号量，控制对工作台和count_A、count_B、empty的互斥访问（取/放零件）semaphore SUSPEND_A = 1 // 控制台无足够空位时，挂起worker Asemaphore SUSPEND_B = 2 // 控制台无足够空位时，挂起worker Bsemaphore SUSPEND_C = 3 // 控制台无足够零件时，挂起worker C WorkerA1234567891011121314151617181920212223WorkerA()&#123; while (1) &#123; // 生产2个A P(MUTEX_STATION, -1); // 申请对count_A、empty和控制台的访问权 if (count_A &lt;= 7 &amp;&amp; empty &gt;= 2) &#123; // 同时放入工作台2个A count_A += 2; //修改count_A empty -= 2; //修改empty V(MUTEX_STATION, 1); //释放对控制台、count_A和empty的访问权 V(SUSPEND_C, 1); //控制台放入新零件，解挂/唤醒worker C &#125; else &#123; V(sem_id, MUTEX_STATION, 1); //释放对控制台和count_A、empty的访问权 P(sem_id, SUSPEND_A, -1); //控制台无足够空位，或不允许再放入A，转入waiting态，挂起自身 &#125; &#125;&#125; WorkerB1234567891011121314151617181920212223WorkerB()&#123; while (1) &#123; // 生产1个B P(MUTEX_STATION, -1); // 申请对count_B、empty和控制台的访问权 if (count_B &lt;= 7 &amp;&amp; empty &gt;= 1) &#123; // 放入工作台1个B count_B += 1; //修改count_B empty -= 1; //修改empty V(MUTEX_STATION, 1); //释放对控制台、count_B和empty的访问权 V(SUSPEND_C, 1); //控制台放入新零件，解挂/唤醒worker C &#125; else &#123; V(MUTEX_STATION, 1); //释放对控制台和count_B、empty的访问权 P(SUSPEND_B, -1); //控制台无足够空位，或不允许再放入B，转入waiting态，挂起自身 &#125; &#125;&#125; WorkerC123456789101112131415161718192021222324252627WorkerC()&#123; while (1) &#123; P(MUTEX_STATION, -1); // 申请对count_A、count_B和控制台的访问权 // 有足够多的A、B用于装配 if (count_A &gt;= 4 &amp;&amp; count_B &gt;= 3) &#123; // 同时从工作台取出4个A、3个B count_A -= 4; //修改count_A count_B -= 3; //修改count_B empty += 7; //修改empty V(MUTEX_STATION, 1); //释放对控制台、count_A、count_B的控制权 V(SUSPEND_A, 1); //控制台新增空位，解挂A V(SUSPEND_B, 1); //控制台新增空位，解挂B // 生产1个C &#125; else &#123; V(MUTEX_STATION, 1); //释放对控制台、count_A、count_B的控制权 P(SUSPEND_C, -1); //控制台无足够零件，转入waiting态，挂起自身 &#125; &#125;&#125; 编程实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339/* * @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. * @Description: 期末信号量题目 * @Version: 1.0 * @Author: 苇名一心 * @Date: 2020-05-28 16:22:53 * @LastEditors: 苇名一心 * @LastEditTime: 2020-07-11 23:57:27 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;signal.h&gt;#include &lt;time.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;#include &lt;sys/shm.h&gt;#define NUM_SEMAPHORE 4 // 信号量个数// 信号量ID#define MUTEX_STATION 0 // 二元信号量，控制对工作台和count_A、count_B、empty的互斥访问（取/放零件）#define SUSPEND_A 1 // 控制台无足够空位时，挂起worker A#define SUSPEND_B 2 // 控制台无足够空位时，挂起worker B#define SUSPEND_C 3 // 控制台无足够零件时，挂起worker C#define SEM_KEY 0x11223344 // 信号量组的KEY#define SHM_KEY1 0x11223355 // 共享内存的KEY1#define SHM_KEY2 0x11223366 // 共享内存的KEY2// 颜色#define NONE \"\\e[0m\" // 复原#define RED \"\\e[0;31m\" // ERROR#define YELLOW \"\\e[1;33m\" // WorkerA#define PINK \"\\e[1;35m\" // WorkerB#define GREEN \"\\e[1;32m\" // WorkerC#define CYAN \"\\e[0;36m\" // Share Memory#define BUF_SIZE 12char *buf;int *info; // 用于记录信息的3个整形变量int i, sv, sem_id, shm_id, info_shm_id, C_num = 0;union semun&#123; int val; // SETVAL使用的值 struct semid_ds *buf; // IPC_STAT、IPC_SET 使用缓存区 unsigned short *array; // GETALL,、SETALL 使用的数组 struct seminfo *__buf; // IPC_INFO(Linux特有) 使用缓存区&#125;;// 对信号量做减1操作，即P（wait）void P(int sem_id, int sem_num, int op)&#123; if (op &lt; 0) &#123; struct sembuf sem_buf; sem_buf.sem_num = sem_num; sem_buf.sem_op = op; //P() sem_buf.sem_flg = SEM_UNDO; if (semop(sem_id, &amp;sem_buf, 1) == -1) &#123; perror(RED \"Semaphore P\" NONE); exit(2); &#125; &#125; else &#123; perror(RED \"Semaphore P\" NONE); exit(3); &#125; return;&#125;// 对信号量做减1操作，即V（signal）void V(int sem_id, int sem_num, int op)&#123; if (op &gt; 0) &#123; struct sembuf sem_buf; sem_buf.sem_num = sem_num; sem_buf.sem_op = op; //V() sem_buf.sem_flg = SEM_UNDO; if (semop(sem_id, &amp;sem_buf, 1) == -1) &#123; perror(RED \"Semaphore V\" NONE); exit(2); &#125; &#125; else &#123; perror(RED \"Semaphore V\" NONE); exit(3); &#125; return;&#125;// 展示共享内存void show_shm()&#123; printf(CYAN \"[\"); for (i = 0; i &lt; BUF_SIZE - 1; i++) &#123; printf(\"%c,\", buf[i]); &#125; printf(\"%c]\\n\\n\" NONE, buf[BUF_SIZE - 1]);&#125;// 创建并初始化信号量和共享内存void create_ipc()&#123; union semun arg[NUM_SEMAPHORE]; arg[MUTEX_STATION].val = 1; arg[SUSPEND_A].val = 0; arg[SUSPEND_B].val = 0; arg[SUSPEND_C].val = 0; // 创建信号量 if ((sem_id = semget(SEM_KEY, NUM_SEMAPHORE, IPC_CREAT | IPC_EXCL | 0666)) == -1) &#123; perror(RED \"Create Semaphores\" NONE); exit(1); &#125; printf(\"Create Semaphores: OK\\n\"); printf(\"Sem_id = %d\\n\", sem_id); // 初始化信号量 for (i = 0; i &lt; NUM_SEMAPHORE; i++) &#123; semctl(sem_id, i, SETVAL, arg[i]); &#125; for (i = 0; i &lt; NUM_SEMAPHORE; i++) &#123; printf(\"The Sem[%d] = %d\\n\", i, semctl(sem_id, i, GETVAL, NULL)); &#125; printf(\"\\n\"); // 创建Info共享内存，用于记录信息 info_shm_id = shmget(SHM_KEY2, 3 * sizeof(int), IPC_CREAT | IPC_EXCL | 0666); if (info_shm_id == -1) &#123; perror(RED \"Create Info Share Memory\" NONE); exit(1); &#125; printf(\"Create Info Share Memory: OK\\n\"); // 初始化Info共享内存 info = (int *)shmat(info_shm_id, 0, 0); // 获取指向共享内存段的指针 if (info == (int *)-1) &#123; perror(RED \"Attach Info Share Memory\" NONE); exit(1); &#125; info[0] = 0; // 当前工作台中已有的A的数量（count_A） info[1] = 0; // 当前工作台中已有的B的数量（count_B） info[2] = 12; // 工作台中空位数量（empty=12-(count_A+count_B)） printf(\"Attach Info Share Memory: OK\\n\"); // 展示info共享内存 printf(\"count_A=%d, count_B=%d, empty=%d\\n\\n\", info[0], info[1], info[2]); // 创建Buffer共享内存 shm_id = shmget(SHM_KEY1, BUF_SIZE * sizeof(char), IPC_CREAT | IPC_EXCL | 0666); if (shm_id == -1) &#123; perror(RED \"Create Buffer Share Memory\" NONE); exit(1); &#125; printf(\"Create Buffer Share Memory: OK\\n\"); // 初始化Buffer共享内存 buf = (char *)shmat(shm_id, 0, 0); // 获取指向共享内存段的指针 if (buf == (char *)-1) &#123; perror(RED \"Attach Buffer Share Memory\" NONE); exit(1); &#125; for (i = 0; i &lt; BUF_SIZE; i++) &#123; buf[i] = ' '; &#125; printf(\"Initialize QUEUE: OK\\n\"); show_shm();&#125;// 删除信号量和共享内存void remove_ipc()&#123; // 删除信号量 if (semctl(sem_id, 0, IPC_RMID, 0) == -1) perror(RED \"Remove Semaphores\" NONE); else printf(\"Remove Semaphores: OK\\n\"); // 删除共享内存 if (shmctl(shm_id, IPC_RMID, 0) == -1) perror(RED \"Remove Buffer Share Memory\" NONE); else printf(\"Remove Buffer Share Memory: OK\\n\"); if (shmctl(info_shm_id, IPC_RMID, 0) == -1) perror(RED \"Remove Info Share Memory\" NONE); else printf(\"Remove Info Share Memory: OK\\n\");&#125;// CTRL-C回调函数void sig_handler(int sig)&#123; printf(\"\\n\"); remove_ipc(); printf(\"EXIT: OK\\n\");&#125;int main(int argc, char const *argv[])&#123; srand(time(NULL)); // 创建并初始化信号量和共享内存 create_ipc(); // WorkerA if (fork() == 0) &#123; while (1) &#123; sleep(1 + random() % 10); // 生产2个A P(sem_id, MUTEX_STATION, -1); // 申请对count_A、empty和控制台的访问权 // 还能再生产放置2个A，最多可放7+2=9个A，以便至少给B留下12-9=3个空位，防止工作台中没有足够多的B，导致worker C无法同时取出3个B if (info[0] &lt;= 7 &amp;&amp; info[2] &gt;= 2) &#123; // 同时放入工作台2个A for (i = 0; i &lt; 2; i++) &#123; char *c; c = strchr(buf, ' '); *c = 'A'; &#125; printf(YELLOW \"Worker A puts 2 As to the station\\n\" NONE); show_shm(); info[0] += 2; //修改count_A info[2] -= 2; //修改empty // 展示info共享内存 printf(\"count_A=%d, count_B=%d, empty=%d\\n\\n\", info[0], info[1], info[2]); V(sem_id, MUTEX_STATION, 1); //释放对控制台、count_A和empty的访问权 V(sem_id, SUSPEND_C, 1); //控制台放入新零件，解挂/唤醒worker C &#125; else &#123; V(sem_id, MUTEX_STATION, 1); //释放对控制台和count_A、empty的访问权 printf(\"Worker A suspended\\n\\n\"); P(sem_id, SUSPEND_A, -1); //控制台无足够空位，或不允许再放入A，转入waiting态，挂起自身 &#125; &#125; &#125; // WorkerB else if (fork() == 0) &#123; while (1) &#123; sleep(1 + random() % 10); // 生产1个B P(sem_id, MUTEX_STATION, -1); // 申请对count_B、empty和控制台的访问权 // 还能再生产并放置1个B，最多可放7+1=8个B，以便至少给A留下12-8=4个空位，防止工作台中没有足够多的A，导致worker C无法同时取出4个A if (info[1] &lt;= 7 &amp;&amp; info[2] &gt;= 1) &#123; // 放入工作台1个B char *c; c = strchr(buf, ' '); *c = 'B'; printf(PINK \"Worker B puts 1 B to the station\\n\" NONE); show_shm(); info[1] += 1; //修改count_B info[2] -= 1; //修改empty // 展示info共享内存 printf(\"count_A=%d, count_B=%d, empty=%d\\n\\n\", info[0], info[1], info[2]); V(sem_id, MUTEX_STATION, 1); //释放对控制台、count_B和empty的访问权 V(sem_id, SUSPEND_C, 1); //控制台放入新零件，解挂/唤醒worker C &#125; else &#123; V(sem_id, MUTEX_STATION, 1); //释放对控制台和count_B、empty的访问权 printf(\"Worker B suspended\\n\\n\"); P(sem_id, SUSPEND_B, -1); //控制台无足够空位，或不允许再放入B，转入waiting态，挂起自身 &#125; &#125; &#125; // WorkerC else if (fork() == 0) &#123; while (1) &#123; P(sem_id, MUTEX_STATION, -1); // 申请对count_A、count_B和控制台的访问权 // 有足够多的A、B用于装配 if (info[0] &gt;= 4 &amp;&amp; info[1] &gt;= 3) &#123; // 同时从工作台取出4个A、3个B for (i = 0; i &lt; 4; i++) &#123; char *c; c = strchr(buf, 'A'); *c = ' '; &#125; for (i = 0; i &lt; 3; i++) &#123; char *c; c = strchr(buf, 'B'); *c = ' '; &#125; printf(GREEN \"Worker C gets 4 As and 3 Bs from the station\\n\" NONE); show_shm(); info[0] -= 4; //修改count_A info[1] -= 3; //修改count_B info[2] += 7; //修改empty // 展示info共享内存 printf(\"count_A=%d, count_B=%d, empty=%d\\n\\n\", info[0], info[1], info[2]); V(sem_id, MUTEX_STATION, 1); //释放对控制台、count_A、count_B的控制权 V(sem_id, SUSPEND_A, 1); //控制台新增空位，解挂A V(sem_id, SUSPEND_B, 1); //控制台新增空位，解挂B // 生产1个C printf(GREEN \"Worker C is producing C-%d......\\n\\n\" NONE, ++C_num); sleep(1 + random() % 10); printf(GREEN \"C-%d is produced\\n\\n\" NONE, C_num); &#125; else &#123; V(sem_id, MUTEX_STATION, 1); //释放对控制台、count_A、count_B的控制权 printf(\"Worker C suspended\\n\\n\"); P(sem_id, SUSPEND_C, -1); //控制台无足够零件，转入waiting态，挂起自身 &#125; &#125; &#125; // Main else &#123; // CTRL-C信号自行处理 signal(SIGINT, sig_handler); wait(&amp;sv); wait(&amp;sv); wait(&amp;sv); printf(\"THANKS\\n\"); return 0; &#125;&#125; 方案2（采用多元信号量，效率不如方案1高）：信号量经分析题目，发现共需要6个信号量，分别为： 123456semaphore MUTEX = 1; // 用于WorkerA、WorkerB和WorkerC对Station的互斥访问semaphore A_FULL = 0; // 用于限制WorkerC取Asemaphore A_EMPTY = 9; // 用于限制WorkerA生产A的数量semaphore B_FULL = 0; // 用于限制WorkerC取Bsemaphore B_EMPTY = 8; // 用于限制WorkerB生产B的数量semaphore ALL_EMPTY = 12; // 用于限制整个Station的生产数量 分析： WorkerA最多生产9个A，如果生产A的个数大于9，则B的个数就会小于3，导致C永远从Station中拿不到4个A和3个B，产生死锁。但是由于WorkerA一次生产2个A，则WorkerA最多生产8（2×4）个A，因此使用信号量A_EMPTY来控制。A_EMPTY初始值可以设置为8，但是A_EMPTY初始值也可以设置为9，都是可以的。 同理，WorkerB最多生产8个B，如果生产B的个数大于8，则A的个数就会小于4，导致C永远从Station中拿不到4个A和3个B，产生死锁。因此使用信号量B_EMPTY来控制。 WorkerA和WorkerB一起最多生产12个A和B，因此使用信号量B_EMPTY来控制。 需要一个互斥量MUTEX，用于WorkerA、WorkerB和WorkerC对Station的互斥访问。 WorkerA12345678910111213WorkerA()&#123; while (1) &#123; // 生产2个A P(A_EMPTY,-2); P(ALL_EMPTY,-2); P(MUTEX,-1); // 同时放入工作台2个A V(MUTEX,1); V(A_FULL,2); &#125;&#125; WorkerB12345678910111213WorkerB()&#123; while (1) &#123; // 生产1个B P(B_EMPTY,-1); P(ALL_EMPTY,-1); P(MUTEX,-1); // 放入工作台1个B V(MUTEX,1); V(B_FULL,1); &#125;&#125; WorkerC123456789101112131415WorkerC()&#123; while (1) &#123; P(A_FULL,-4); P(B_FULL,-3); P(MUTEX,-1); // 同时从工作台取出4个A、3个B V(MUTEX,1); V(ALL_EMPTY,7); V(B_EMPTY,3); V(A_EMPTY,4); // 生产1个C &#125;&#125; 编程实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263/* * @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. * @Description: 期末信号量题目 * @Version: 1.0 * @Author: 苇名一心 * @Date: 2020-05-28 16:22:53 * @LastEditors: 苇名一心 * @LastEditTime: 2020-07-11 21:08:57 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;signal.h&gt;#include &lt;time.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;#include &lt;sys/shm.h&gt;#define NUM_SEMAPHORE 6 // 信号量个数// 信号量ID#define MUTEX 0 // 用于WorkerA、WorkerB和WorkerC对Station的互斥访问#define A_FULL 1 // 用于限制WorkerC取A#define A_EMPTY 2 // 用于限制WorkerA生产A的数量#define B_FULL 3 // 用于限制WorkerC取B#define B_EMPTY 4 // 用于限制WorkerB生产B的数量#define ALL_EMPTY 5 // 用于限制整个Station的生产数量#define SEM_KEY 0x11223344 // 信号量组的KEY#define SHM_KEY 0x11223355 // 共享内存的KEY// 颜色#define NONE \"\\e[0m\" // 复原#define RED \"\\e[0;31m\" // ERROR#define YELLOW \"\\e[1;33m\" // WorkerA#define PINK \"\\e[1;35m\" // WorkerB#define GREEN \"\\e[1;32m\" // WorkerC#define CYAN \"\\e[0;36m\" // Share Memory#define BUF_SIZE 12 // 工作台大小char *buf;int i, sv, sem_id, shm_id, C_num = 0;union semun&#123; int val; // SETVAL使用的值 struct semid_ds *buf; // IPC_STAT、IPC_SET 使用缓存区 unsigned short *array; // GETALL,、SETALL 使用的数组 struct seminfo *__buf; // IPC_INFO(Linux特有) 使用缓存区&#125;;// 对信号量做减1操作，即P（wait）void P(int sem_id, int sem_num, int op)&#123; struct sembuf sem_buf; sem_buf.sem_num = sem_num; sem_buf.sem_op = op; //P() sem_buf.sem_flg = SEM_UNDO; if (semop(sem_id, &amp;sem_buf, 1) == -1) &#123; perror(RED \"Semaphore P\" NONE); exit(2); &#125; return;&#125;// 对信号量做减1操作，即V（signal）void V(int sem_id, int sem_num, int op)&#123; struct sembuf sem_buf; sem_buf.sem_num = sem_num; sem_buf.sem_op = op; //V() sem_buf.sem_flg = SEM_UNDO; if (semop(sem_id, &amp;sem_buf, 1) == -1) &#123; perror(RED \"Semaphore V\" NONE); exit(2); &#125; return;&#125;// 展示共享内存void show_shm()&#123; printf(CYAN \"[\"); for (i = 0; i &lt; BUF_SIZE - 1; i++) &#123; printf(\"%c,\", buf[i]); &#125; printf(\"%c]\\n\\n\" NONE, buf[BUF_SIZE - 1]);&#125;// 创建并初始化信号量和共享内存void create_ipc()&#123; union semun arg[NUM_SEMAPHORE]; arg[MUTEX].val = 1; arg[A_FULL].val = 0; arg[A_EMPTY].val = 9; arg[B_FULL].val = 0; arg[B_EMPTY].val = 8; arg[ALL_EMPTY].val = 12; // 创建信号量 if ((sem_id = semget(SEM_KEY, NUM_SEMAPHORE, IPC_CREAT | IPC_EXCL | 0666)) == -1) &#123; perror(RED \"Create Semaphores\" NONE); exit(1); &#125; printf(\"Create Semaphores: OK\\n\"); printf(\"Sem_id = %d\\n\", sem_id); // 初始化信号量 for (i = 0; i &lt; NUM_SEMAPHORE; i++) &#123; semctl(sem_id, i, SETVAL, arg[i]); &#125; for (i = 0; i &lt; NUM_SEMAPHORE; i++) &#123; printf(\"The Sem[%d] = %d\\n\", i, semctl(sem_id, i, GETVAL, NULL)); &#125; // 创建共享内存 shm_id = shmget(SHM_KEY, BUF_SIZE * sizeof(char), IPC_CREAT | IPC_EXCL | 0666); if (shm_id == -1) &#123; perror(RED \"Create Share Memory\" NONE); exit(1); &#125; printf(\"Create Share Memory: OK\\n\"); // 初始化共享内存 buf = (char *)shmat(shm_id, 0, 0); // 获取指向共享内存段的指针 if (buf == (char *)-1) &#123; perror(RED \"Attach Share Memory\" NONE); exit(1); &#125; for (i = 0; i &lt; BUF_SIZE; i++) &#123; buf[i] = ' '; &#125; printf(\"Initialize QUEUE: OK\\n\"); show_shm();&#125;// 删除信号量和共享内存void remove_ipc()&#123; // 删除信号量 if (semctl(sem_id, 0, IPC_RMID, 0) == -1) perror(RED \"Remove Semaphores\" NONE); else printf(\"Remove Semaphores: OK\\n\"); // 删除共享内存 if (shmctl(shm_id, IPC_RMID, 0) == -1) perror(RED \"Remove Share Memory\" NONE); else printf(\"Remove Share Memory: OK\\n\");&#125;// CTRL-C回调函数void sig_handler(int sig)&#123; printf(\"\\n\"); remove_ipc(); printf(\"EXIT: OK\\n\");&#125;int main(int argc, char const *argv[])&#123; srand(time(NULL)); // 创建并初始化信号量和共享内存 create_ipc(); // WorkerA if (fork() == 0) &#123; while (1) &#123; sleep(1 + random() % 10); // 生产2个A P(sem_id, A_EMPTY, -2); P(sem_id, ALL_EMPTY, -2); P(sem_id, MUTEX, -1); // 同时放入工作台2个A for (i = 0; i &lt; 2; i++) &#123; char *c; c = strchr(buf, ' '); *c = 'A'; &#125; printf(YELLOW \"Worker A puts 2 As to the station\\n\" NONE); show_shm(); V(sem_id, MUTEX, 1); V(sem_id, A_FULL, 2); &#125; &#125; // WorkerB else if (fork() == 0) &#123; while (1) &#123; sleep(1 + random() % 10); // 生产1个B P(sem_id, B_EMPTY, -1); P(sem_id, ALL_EMPTY, -1); P(sem_id, MUTEX, -1); // 放入工作台1个B char *c; c = strchr(buf, ' '); *c = 'B'; printf(PINK \"Worker B puts 1 B to the station\\n\" NONE); show_shm(); V(sem_id, MUTEX, 1); V(sem_id, B_FULL, 1); &#125; &#125; // WorkerC else if (fork() == 0) &#123; while (1) &#123; P(sem_id, A_FULL, -4); P(sem_id, B_FULL, -3); P(sem_id, MUTEX, -1); // 同时从工作台取出4个A、3个B for (i = 0; i &lt; 4; i++) &#123; char *c; c = strchr(buf, 'A'); *c = ' '; &#125; for (i = 0; i &lt; 3; i++) &#123; char *c; c = strchr(buf, 'B'); *c = ' '; &#125; printf(GREEN \"Worker C gets 4 As and 3 Bs from the station\\n\" NONE); show_shm(); V(sem_id, MUTEX, 1); V(sem_id, ALL_EMPTY, 7); V(sem_id, B_EMPTY, 3); V(sem_id, A_EMPTY, 4); // 生产1个C printf(GREEN \"Worker C is producing C-%d......\\n\\n\" NONE, ++C_num); sleep(1 + random() % 10); printf(GREEN \"C-%d is produced\\n\\n\" NONE, C_num); &#125; &#125; // Main else &#123; // CTRL-C信号自行处理 signal(SIGINT, sig_handler); wait(&amp;sv); wait(&amp;sv); wait(&amp;sv); printf(\"THANKS\\n\"); return 0; &#125;&#125; 2、运行结果及分析两种方案的运行情况只选择了其中一种方案的运行结果，如果工作时间一致的话，两种方案的运行情况基本一致，但是因为使用了随机工作时间，每次运行的结果可能不一样，因此只选择了其中的一次运行结果。 1、编译 2、运行方案一： 方案二： 3、分析从运行结果来看，完全没有死锁现象，程序完全正常运行，输出结果也正常，创建和初始化信号量和共享内存，释放和删除信号量和共享内存都正常结束。 方案一的输出中有count_A、count_B、和empty的值，以及Worker A、Worker B和Worker C在进入阻塞状态时的输出，整个过程比较清晰。 方案二的基本过程在输出中，共享内存的状态也很清晰： 2A-B-2A-B-2A-B-C-2A-B-2A-B-2A-B-C-2A-B-2A-B-B-C-2A-B-2A-B-B-C-2A…… 方案一和方案二多次运行都没有产生死锁，并且因为设置了随机等待时间模拟生产，每次的结果都有所不同，但都符合预期。但是经过分析，方案二可能会导致Worker A和Worker B都等待Worker C，但是此时工作台却还有一个空位的情况，但是并没有产生死锁，只是效率相较于方案一会低一些。 五、实验总结这次操作系统课程设计的5组实验，虽然难度可能不是那么高，但是结合了操作系统理论课所学的知识，很有实践意义。经过这5组实验，我首先认识了华为最新的OpenEuler开源Linux操作系统，学习了Linux操作系统的安装、基本操作和使用。这次实验还加深了我对操作系统进程、线程概念和消息队列、共享内存、管道、软中断四种进程间通信机制的理解，掌握了利用Linux系统调用创建、管理进程的方法、利用POSIX线程（Pthread）库创建管理线程的方法和实现进程间通信和线程间通信的方法，深刻地认识了进程、线程并发执行的实质，并掌握了编程使用互斥变量和条件变量实现多线程间的同步互斥。 在实验的过程中，也遇到了各种各样的小问题，比如Linux的命令报错啊，编程gcc编译不通过等等，但经过上网查找资料和与同学讨论交流，都完美解决了问题，总体上看实验过程比较顺利。经过这次的课程设计，明显加深了对操作系统理论课知识的理解，并拓展了很多新的知识和内容，让我受益匪浅。 六、项目源码本项目的源码已经存放于我的Github，欢迎下载查看：","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://666wxy666.github.io/categories/C-C/"},{"name":"项目","slug":"C-C/项目","permalink":"https://666wxy666.github.io/categories/C-C/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/tags/Linux/"},{"name":"C++","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"工程","slug":"工程","permalink":"https://666wxy666.github.io/tags/%E5%B7%A5%E7%A8%8B/"},{"name":"操作系统","slug":"操作系统","permalink":"https://666wxy666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"进程","slug":"进程","permalink":"https://666wxy666.github.io/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"同步互斥","slug":"同步互斥","permalink":"https://666wxy666.github.io/tags/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/"},{"name":"线程","slug":"线程","permalink":"https://666wxy666.github.io/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"通信","slug":"通信","permalink":"https://666wxy666.github.io/tags/%E9%80%9A%E4%BF%A1/"}]},{"title":"编译原理 语法分析 LL1","slug":"编译原理-语法分析-LL1","date":"2020-09-01T16:00:00.000Z","updated":"2020-09-02T01:54:09.069Z","comments":true,"path":"2020/09/02/编译原理-语法分析-LL1/","link":"","permalink":"https://666wxy666.github.io/2020/09/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-LL1/","excerpt":"本文是编译原理C语言LL1语法分析器的简单实现项目。","text":"本文是编译原理C语言LL1语法分析器的简单实现项目。 一、需求 拓展需求：还能自动够造LL1文法的first集和follow集，为LL1文法自动构造预测分析表。 二、运行环境电脑硬件配置： 处理器：Intel i7 7700HQ 显卡：NVIDIA GeForce GTX 1050 Ti 内存：16GB 软件： 编程语言：C++ IDE：Microsoft Visual Studio 2019 Windows SDK版本：10.0 平台工具集：Visual Studio 2019（v142） 三、核心算法1、整个程序的模型如图所示 分析栈、分析表的数据结构详见【变量和函数】。 2、first集的构造使用深度优先遍历递归的方法，当遍历完所有的非终结符的产生式右部，first集构造完成。详见注释。 3、follow集的构造不能采用深度优先遍历的方法，否则求给出的测试样例【其它文法1】会无限循环，因为非终结符之间的follow集是互相依赖的，因而采用了另一种方法解决了这个问题。就是无限循环求所有非终结符的follow集，直到所有的follow集都不再增大为止，跳出循环。详见注释。 4、预测分析表的构造算法利用课本上的算法4.2 5、预测分析控制程序算法利用课本上的算法 但是该算法有点小瑕疵，就是最后while循环的出口判断条件有问题，不应该是只是【栈顶文法符号X不为‘$’】，而应为【栈顶文法符号X不为‘$’&amp;&amp;所指向的输入符号a不为‘$’】。 6、输入形式：先输入文法的产生式个数，然后输入产生式，该文法必须为LL1文法（消除左递归和左公因子），然后输入1或0，决定是否要进行分析，然后再输入要分析的字符串，该字符串需要用i代表数字，以‘$’结尾。输入的文法默认第一个输入的产生式的左部为起始符，非终结符仅为一个大写字母，终结符仅为一个小写字母和各种符号，且用~代替epsilon,且输入的文法必须满足LL1文法的条件。输入的要分析的字符串需要用i代表数字，以‘$’结尾。我认为没有必要把i也就是题目中的num细化为数字，因为这些操作已经在词法分析中完成了，语法分析只需完成分析类似于这种字符串的输入是否被接受就可以了。 7、输出形式：先输出该文法的first集和follow集，再输出该文法的LL1预测分析表，最后输出用户输入的待分析字符串的分析过程 四、变量和函数1、类1234567891011121314class PF//Production formula,产生式的类&#123;public: string left;//产生式的左部 set&lt;string&gt; right;//产生式的右部 PF(char s[])//构造函数，确定产生式左部 &#123; left = s; &#125; void insert(char s[])//插入产生式右部的函数 &#123; right.insert(s); &#125;&#125;; 2、全局变量123456789101112vector&lt;PF&gt; PF_vector;//产生式使用一个vector数组，每个元素为PF类的对象，来存放输入的产生式。map&lt;string, set&lt;char&gt; &gt; first;//first集map&lt;string, set&lt;char&gt; &gt; follow;//follow集使用了map哈希key的类型为string，存放产生式的左部，value的类型为char的set,用来存放对应key的first集和follow集。vector&lt;map&lt;char, string&gt;&gt; predict_table;//LL1分析表//使用一个vector数组，每个元素为一个map，该vector的每一个map分别对应PF_vector中每个产生式的左部的非终结符所在的预测分析表的行，map的key为终结符，value为对应表项中的产生式的右部vector&lt;char&gt; A;//分析栈vector&lt;char&gt; B;//剩余串map&lt;string, int&gt; PF_map;//存储每个非终结符对应的编号，key为非终结符，value为编号vector&lt;char&gt; letter;//所有的终结符,在构造预测分析表的时候创建完毕int B_point = 0, input_len = 0;//B_point为输入串指针，input_len为输入串长度 3、函数1234567891011121314151617181920//first集的构造：void first_construction() //构造并输出first集void DFS(int x)//为构造first集深度优先遍历PF，递归调用//follow集的构造：void follow_construction()//构造并输出follow集void add_follow(const string&amp; str1, const string&amp; str2)//将str1的follow集加入到str2的follow集中//预测分析表的构造：void predict_table_construction()//构造并输出LL1分析表bool check_first(const string&amp; str, char ch)//检查ch是否属于str的FIRST集合bool check_follow(const string&amp; str, char ch)//检查ch是否属于str的FOLLOW集合//预测分析控制程序：void analyse()//预测分析控制程序void print_A()//输出分析栈void print_B()//输出剩余串//主函数：int main() PS：关于每个函数内部详细实现详见main.cpp中写好了详细的注释，我几乎对每一步操作的目的和函数的目的都写了详细的注释。 五、测试样例：这个语法分析程序普适性较高，不仅对课本上的算数运算文法能实现求first集和follow集，自动生成预测分析表，以及对字符串进行分析，还对几乎所有的LL1文法都可以实现，只要输入的文法按照【核心算法】中的【输入形式】的要求即可。 在这里我以课本上的算数运算文法为例。其它文法1为follow集循环依赖文法（求follow集不可以用递归求，否则该文法会无限循环），其它文法2为起始符可推空文法（如果不按严格算法4.2构造分析表，也就是作业中把A-&gt;~产生式加入到A的follow集所对应的终结符的表项中的做法其实是不准确的，而应把A可以推空的产生式加入到A的follow集所对应的终结符的表项中，否则就会导致无法识别某些字符串的错误，例如其它文法2就是无法识别空串的错误，但该文法确实可以识别空串）。 六、项目地址本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看：","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://666wxy666.github.io/categories/C-C/"},{"name":"项目","slug":"C-C/项目","permalink":"https://666wxy666.github.io/categories/C-C/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"工程","slug":"工程","permalink":"https://666wxy666.github.io/tags/%E5%B7%A5%E7%A8%8B/"},{"name":"编译原理","slug":"编译原理","permalink":"https://666wxy666.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"语法分析","slug":"语法分析","permalink":"https://666wxy666.github.io/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"},{"name":"LL1","slug":"LL1","permalink":"https://666wxy666.github.io/tags/LL1/"}]},{"title":"编译原理 语法分析 LR","slug":"编译原理-语法分析-LR","date":"2020-09-01T16:00:00.000Z","updated":"2020-09-02T01:54:18.747Z","comments":true,"path":"2020/09/02/编译原理-语法分析-LR/","link":"","permalink":"https://666wxy666.github.io/2020/09/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-LR/","excerpt":"本文是编译原理C语言LR语法分析器的简单实现项目。","text":"本文是编译原理C语言LR语法分析器的简单实现项目。 一、需求 拓展需求：除题目的基础要求外，还额外实现了对任意SLR1文法，自动生成拓广文法，且求该文法的first集和follow集，并且自动生成LR0项目集规范簇和识别该文法所有活前缀的DFA，然后根据该DFA自动生成SLR1分析表。 二、运行环境电脑硬件配置： 处理器：Intel i7 7700HQ 显卡：NVIDIA GeForce GTX 1050 Ti 内存：16GB 软件： 编程语言：C++ IDE：Microsoft Visual Studio 2019 Windows SDK版本：10.0 平台工具集：Visual Studio 2019（v142） 三、核心算法1、整个程序的模型如图所示手动分析： 首先对文法进行拓广，求first集和follow集，发现该文法是一个SLR1文法。 构造LR0项目集规范簇及识别该文法所有活前缀的DFA 构造识别该文法的SLR0分析表 整个程序的模型如图所示 预测分析控制程序算法 6、输入形式：文件输入，格式为： 产生式个数n { …… 第i(1&lt;=i&lt;=n)个产生式（例如A-&gt;a，按照输入顺序分别从1到n编号，拓广产生式为0号，规定终结符和非终结符都是一个字符且非终结符都为大写字母） …… } 要分析的字符串个数n { …… 第i(1&lt;=i&lt;=n)个要分析的字符串（要求以$结尾） …… } 7、输出形式：先输出该文法的拓广文法，再输出该拓广文法的first集和follow集，再输出SLR0分析表，然后输出用户输入的待分析字符串的分析过程。 四、变量和函数1、类和枚举：12345678910111213141516171819202122232425262728293031323334353637enum RS//动作的枚举&#123; shift,//移进 reduce,//规约 accept//接受&#125;;//假定非终结符仅为一个大写字母，终结符仅为一个小写字母和各种符号，且用~代替epsilonclass PF//Production formula,产生式的类&#123;public: char left;//产生式的左部 string right;//产生式的右部 PF(char l, string r)//构造函数 &#123; left = l; right = r; &#125;&#125;;class ITEM//项目集&#123;public: ITEM();//默认构造函数 ITEM(int NO);//构造函数 int NO;//项目集编号 set&lt;pair&lt;int, int&gt;&gt; production;//项目，第一个int代表产生式编号，第二个int代表.的位置 set&lt;pair&lt;char, int&gt;&gt; go_to;//该项目集指向的项目集，第一个char代表箭头上的字符，第二个int代表指向的项目集编号 bool operator&lt;(const ITEM&amp; item)const;//重载&lt;操作符，以便使用set&#125;;class action//动作类&#123;public: action(RS rs,int num);//重写构造函数 string ret_action();//返回该动作 action();//初始 RS rs;//动作 int num;//移进到哪个状态，或者用哪个产生式规约&#125;; 2、全局变量123456789101112vector&lt;PF&gt; PF_vector;//产生式map&lt;char, set&lt;char&gt; &gt; first;//first集map&lt;char, set&lt;char&gt; &gt; follow;//follow集set&lt;ITEM&gt; DFA;//DFA项目集规范簇vector&lt;map&lt;char, action&gt;&gt; predict_table_action;//SLR1分析表actionvector&lt;map&lt;char, int&gt;&gt; predict_table_goto;//SLR1分析表gotovector&lt;char&gt; A_1;//符号栈vector&lt;int&gt; A_2;//状态栈vector&lt;char&gt; B;//剩余串set&lt;char&gt; terminal;//所有的终结符+'$'set&lt;char&gt; non_terminal;//所有的非终结符int B_point = 0, input_len = 0;//B_point为输入串指针，input_len为输入串长度 3、函数123456789101112131415ITEM::ITEM()//默认构造函数ITEM::ITEM(int NO)//构造函数bool ITEM::operator&lt;(const ITEM&amp; item)const//重载&lt;操作符，以便使用setaction::action(RS rs, int num) //构造函数action::action()//默认构造函数string action::ret_action()//返回该动作void first_construction()//构造并输出first集void add_follow(const char&amp; ch1, const char&amp; ch2)//将ch1的follow集加入到ch2的follow集中void follow_construction()//构造并输出follow集void DFA_construction()//构造DFAvoid predict_table_construction()//构造并输出SLR1预测分析表void print_A()//输出分析栈void print_B()//输出剩余串void analyse()//预测分析控制程序int main() PS：关于每个函数内部详细实现详见main.cpp中写好了详细的注释，我几乎对每一步操作的目的和函数的目的都写了详细的注释。 五、测试样例： 六、项目地址本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看：","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://666wxy666.github.io/categories/C-C/"},{"name":"项目","slug":"C-C/项目","permalink":"https://666wxy666.github.io/categories/C-C/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"工程","slug":"工程","permalink":"https://666wxy666.github.io/tags/%E5%B7%A5%E7%A8%8B/"},{"name":"编译原理","slug":"编译原理","permalink":"https://666wxy666.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"语法分析","slug":"语法分析","permalink":"https://666wxy666.github.io/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"},{"name":"LR","slug":"LR","permalink":"https://666wxy666.github.io/tags/LR/"}]},{"title":"编译原理 词法分析","slug":"编译原理-词法分析","date":"2020-08-31T16:00:00.000Z","updated":"2020-09-02T01:53:58.318Z","comments":true,"path":"2020/09/01/编译原理-词法分析/","link":"","permalink":"https://666wxy666.github.io/2020/09/01/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/","excerpt":"本文是编译原理C语言词法分析器的简单实现项目。","text":"本文是编译原理C语言词法分析器的简单实现项目。 一、需求词法分析程序的设计和实现。 设计并实现C语言的词法分析程序，要求如下： 可以识别出用C语言编写的源程序中的每个单词符号，并以记号的形式输出每个单词符号。 可以识别并读取源程序中的注释。 可以统计源程序汇总的语句行数、各类单词的个数、以及字符个数，并输出统计结果。 检查源程序中存在的词法错误，并报告错误所在的位置。 对源程序中存在的错误进行适当的恢复，使词法分析可以继续进行，对源程序进行一次扫描即可检查并报告源程序中存在的所有词法错误。 二、运行环境电脑硬件配置： 处理器：Intel i7 7700HQ 显卡：NVIDIA GeForce GTX 1050 Ti 内存：16GB 软件： 编程语言：C++ IDE：Microsoft Visual Studio 2019 Windows SDK版本：10.0 平台工具集：Visual Studio 2019（v142） 三、核心算法读入源程序，将源程序拆分为单词，同时去除空格和空行并存入vector中，一个字符一个字符的读入自动机，文件输出单词和类型，并在最后输出统计结果，在屏幕输出错误。 PS:不支持中文字符 源程序的记号和表达式： 标识符：字母或“_”开头，后跟字母或数字或“_”组成的符号串 关键字：标识符集合的子集。C语言有32个关键字，分别为： 1&#123;\"do\",\"double\",\"auto\",\"break\",\"case\",\"char\",\"const\",\"continue\",\"default\",\"else\",\"enum\",\"extern\",\"float\",\"for\",\"goto\",\"if\",\"int\",\"long\",\"register\",\"return\",\"struct\",\"switch\",\"typedef\",\"short\",\"signed\",\"sizeof\",\"static\",\"union\",\"unsigned\",\"void\",\"volatile\",\"while\" &#125; 数字：由整数部分、可选小数部分和可选整数部分构成 运算符： 1. ( ) ~ &amp; ^ % &lt;= &lt;&lt; &lt; &gt;= &gt;&gt; &gt; = == / != ! &amp;&amp; &amp; || | -&gt; - : ? 分隔符： 1; # ’ ” [ ] &#123; &#125; , 转义符：\\ 状态转换图： 输入形式：文件输入。 输出形式：分两部分：文件输出和屏幕输出。文件输出分析内容，分四部分：按文件顺序输出类型和表达式，每种表达式数量统计，每种类型数量统计，行数、单词数、字符数统计；屏幕输出错误。详见输出样例部分。 四、变量和函数12345678910111213141516171819202122232425262728293031323334int start = 0, over = 0, first = 0;//指针int letters = 0, lines = 0, words = 0;//统计单词数，行数和字符数的变量int state;//状态变量class str//单词类&#123;public: int linenum;//行号 string Str;//单词 &#125;;//输出文件名string file_name;//返回单词或符号,从位置i开始查找，引用参数j返回这个单词最后一个字符在str的位置。string GetWord(string str, int i, int&amp; j);//除去字符串中连续的空格和换行。第一个参数为目标字符串，第二个参数为开始位置。返回值为第一个有效字符在字符串的位置int get_nbc(string str, int i);//文件输出函数，成功输出返回true，失败返回falsebool Output(vector&lt;pair&lt;string, string&gt; &gt; v);//词法分析主要算法函数，返回一个pair型数组vector&lt;pair&lt;string, string&gt; &gt; analyse(vector&lt;str&gt;&amp; vec);//此函数判断str是否为关键字，是的话，返回真，反之返回假bool IsKey(string str);//此函数判断C是否为字母，是的话，返回真，反之返回假bool letter(char C);//此函数判断C是否为数字，是的话，返回真，反之返回假bool digit(char C); 详细代码见文末github项目。 五、测试样例： 六、项目地址本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看：","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://666wxy666.github.io/categories/C-C/"},{"name":"项目","slug":"C-C/项目","permalink":"https://666wxy666.github.io/categories/C-C/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"工程","slug":"工程","permalink":"https://666wxy666.github.io/tags/%E5%B7%A5%E7%A8%8B/"},{"name":"编译原理","slug":"编译原理","permalink":"https://666wxy666.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"词法分析","slug":"词法分析","permalink":"https://666wxy666.github.io/tags/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"}]},{"title":"杂项工程项目集锦","slug":"杂项工程项目集锦","date":"2020-08-14T16:00:00.000Z","updated":"2020-09-02T02:07:35.156Z","comments":true,"path":"2020/08/15/杂项工程项目集锦/","link":"","permalink":"https://666wxy666.github.io/2020/08/15/%E6%9D%82%E9%A1%B9%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE%E9%9B%86%E9%94%A6/","excerpt":"本文是一些我曾经写过的项目工程集锦。","text":"本文是一些我曾经写过的项目工程集锦。 这些项目的源码、可执行程序、报告等已经存放于我的Github，欢迎下载查看： 1、Python爬虫、数据处理、数据分析、数据可视化 学校和房价爬虫小项目 数据预处理小项目 房价数据分析小项目 数据可视化小项目 京东淘宝手机爬虫分析项目","categories":[{"name":"杂项","slug":"杂项","permalink":"https://666wxy666.github.io/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"工程","slug":"工程","permalink":"https://666wxy666.github.io/tags/%E5%B7%A5%E7%A8%8B/"},{"name":"C","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://666wxy666.github.io/tags/Python/"},{"name":"项目","slug":"项目","permalink":"https://666wxy666.github.io/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"机器学习 实验 花卉识别","slug":"机器学习-实验-花卉识别","date":"2020-08-09T16:00:00.000Z","updated":"2020-09-02T02:06:00.331Z","comments":true,"path":"2020/08/10/机器学习-实验-花卉识别/","link":"","permalink":"https://666wxy666.github.io/2020/08/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%AE%9E%E9%AA%8C-%E8%8A%B1%E5%8D%89%E8%AF%86%E5%88%AB/","excerpt":"本文是机器学习人工智能实验，利用华为云ModelArts平台实现花卉分类识别。","text":"本文是机器学习人工智能实验，利用华为云ModelArts平台实现花卉分类识别。 一、实验目的通过该实验，实现以下目标 熟悉ModelArts平台，能够调用平台的简单物体识别算法进行物体检测； 熟悉ModelArts平台特征提取方法，提取数据集的视觉特征； 熟悉ModelArts的神经网络架构，改进架构算法，进行目标检测算法的设计与实现。 学会评价检测算法的基本方法，对所设计的算法进行评估。 二、实验环境ModelArts平台 三、实验内容 四、实验步骤由于时间久远，详细内容请前往Github项目查看实验报告。 五、项目地址本项目的实验报告已经存放于我的Github，欢迎下载查看： 源码仓库","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://666wxy666.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"实验","slug":"机器学习/实验","permalink":"https://666wxy666.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://666wxy666.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"实验","slug":"实验","permalink":"https://666wxy666.github.io/tags/%E5%AE%9E%E9%AA%8C/"},{"name":"华为云","slug":"华为云","permalink":"https://666wxy666.github.io/tags/%E5%8D%8E%E4%B8%BA%E4%BA%91/"},{"name":"人工智能","slug":"人工智能","permalink":"https://666wxy666.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"AI","slug":"AI","permalink":"https://666wxy666.github.io/tags/AI/"},{"name":"分类","slug":"分类","permalink":"https://666wxy666.github.io/tags/%E5%88%86%E7%B1%BB/"}]},{"title":"大数据实战 Spark 自选日志分析","slug":"大数据实战-Spark-自选日志分析","date":"2020-07-20T16:00:00.000Z","updated":"2020-09-02T02:05:18.459Z","comments":true,"path":"2020/07/21/大数据实战-Spark-自选日志分析/","link":"","permalink":"https://666wxy666.github.io/2020/07/21/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%88%98-Spark-%E8%87%AA%E9%80%89%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/","excerpt":"本文是关于大数据通过Java进行Spark编程实现自选日志处理分析。","text":"本文是关于大数据通过Java进行Spark编程实现自选日志处理分析。 一、实验环境： 虚拟机数量：1 系统版本：Centos 7.5 Spark版本：Apache Spark 2.1.1 Eclipse版本：Neno.3 （4.6.3） 二、实验内容： 收集一组自选日志，构造mydata.log数据集，上传到实验环境中，重新完成对自选日志分析。 三、主要步骤： 获取自选数据集 自选数据集计算的需求分析 编程设计实现 运行程序 四、实验步骤：4.1获取自选数据集以及数据字段格式解释说明我受到平台的第一个实验和uber日志文件的启发，想到了自己用python生成uber日志文件，首先是日志的格式： 字段 数据类型 说明信息 dispatching_base_number String 区域编号 date String 日期 active_vehicles int 使用的机动车数量 trips int 旅游次数 定义好了日志的格式，只要编写python程序，让他自己按照这个格式生产日志即可，具体代码见附录，下面是部分代码截图和运行结果： 4.2自选数据集计算的需求分析因为是汽车和旅游日志信息，并且有不同日期，不同地区的信息，主要需求就是选取从开始时间到截止时间使用的机动车数量和旅游次数最多的前10个地区，以及他们的机动车总数量和旅游总次数。 主要步骤就是（与实验一大体相同，又有所区别）： 按照 Serrializable 接口实现自定义排序的 Key； 将要进行二次排序的文件加载进来生成 key-value 类型的 RDD 使用 sortByKey 基于自定义的 Key 进行二次排序 去除掉排序的 key，只保留排序结果 排序规则如下： 以区域编号dispatching_base_number为基准，分别按照active_vehicles，trips，date进行降序排序。即先按照active_vehicles排序，如果active_vehicles相同，再比较trips，如果trips相同，再比较date，最后选择前10条记录输出。 4.3编程设计实现4.3.1创建工程4.3.1.1打开Eclipse IDE 12cd eclipse/./eclipse &amp; 4.3.1.2点击 File -&gt; New -&gt;Other 4.3.1.3搜索 maven -&gt; 点击 Maven Project -&gt; Next-&gt;Next 4.3.1.4选中maven-archetype-quickstart -&gt;Next 4.3.1.5输入Group Id 为 org.zkpk；Artifact Id 为 spark ；Package为org.zkpk.spark；-&gt;Finish 4.3.1.6升级maven工程 升级完成： 4.3.1.7更改JRE，右键JRE System Library-&gt; Properties 4.3.1.8选中jdk1.8.0_131-&gt; OK 4.3.1.9点击spark项目-&gt;修改pom.xml-&gt; 保存会自动下载jar包 4.3.1.10下载Jar包： 4.3.1.11最终 pom.xml 如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.zkpk&lt;/groupId&gt; &lt;artifactId&gt;spark&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;spark&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-core_2.10&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-sql_2.10&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-hive_2.10&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-streaming_2.10&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-streaming-kafka_2.10&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-streaming-flume_2.10&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.3.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpcore&lt;/artifactId&gt; &lt;version&gt;4.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;sourceDirectory&gt;src/main/java&lt;/sourceDirectory&gt; &lt;testSourceDirectory&gt;src/main/test&lt;/testSourceDirectory&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;archive&gt; &lt;manifest&gt; &lt;mainClass&gt;&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-assembly&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;exec&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;executable&gt;java&lt;/executable&gt; &lt;includeProjectDependencies&gt;true&lt;/includeProjectDependencies&gt; &lt;includePluginDependencies&gt;false&lt;/includePluginDependencies&gt; &lt;classpathScope&gt;compile&lt;/classpathScope&gt; &lt;mainClass&gt;cn.com.syl.spark.App&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.6&lt;/source&gt; &lt;target&gt;1.6&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 4.3.1.12删除工程生成的App.java和AppTest.java 利用实验一的实验环境编写java程序，同样是SecondarySortKey.java和SecondarySortDemo.java两个java文件。其中SecondarySortKey.java中有两个类，一个是serDemo类，用于存储未排序的数据，一个是SecondarySortKey类，里面重写了一系列排序函数，用于按照自己的规则排序；SecondarySortDemo.java有一个类SecondarySortDemo，里面有主函数和创建Spark RDD，求和，sortByKey等函数，是主要的逻辑运行的地方。 4.3.2这里只挑出关键的代码进行解释注释和说明，详细的带注释的代码见附录：这是排序的数据存放的类，有三个字段，全参构造函数，getter和setter，以及toString，hashCode和equal方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class SecondarySortKey implements Ordered&lt;SecondarySortKey&gt;, Serializable &#123; private static final long serialVersionUID = 3702442700882342403L; //日期 private String date; //使用的机动车数量 private int activeVehicles; //旅游次数 private int trips; public SecondarySortKey() &#123; super(); &#125; public SecondarySortKey(String date, int activeVehicles, int trips) &#123; super(); this.date = date; this.activeVehicles = activeVehicles; this.trips = trips; &#125; ...... @Override public boolean equals(Object o) &#123; if (this == o) &#123; return true; &#125; if (o == null || getClass() != o.getClass()) &#123; return false; &#125; SecondarySortKey that = (SecondarySortKey) o; return activeVehicles == that.activeVehicles &amp;&amp; trips == that.trips &amp;&amp; Objects.equals(date, that.date); &#125; @Override public int hashCode() &#123; return Objects.hash(date, activeVehicles, trips); &#125; @Override public String toString() &#123; return \"SortResult&#123;\" + \"截止日期：\" + date + \", 使用的机动车总数量：\" + activeVehicles + \", 旅游总次数：\" + trips + '&#125;'; &#125;&#125; 最主要的是$greater，$less等一系列比较函数和compare和compareTo函数用于RDD的sortByKey。 12345678910111213141516171819202122232425262728293031323334...... public boolean $greater(SecondarySortKey other) &#123; if (activeVehicles &gt; other.activeVehicles) &#123; return true; &#125; else if (activeVehicles == other.activeVehicles &amp;&amp; trips &gt; other.trips) &#123; return true; &#125; else if (activeVehicles == other.activeVehicles &amp;&amp; trips == other.trips &amp;&amp; date.compareTo(other.date) &gt; 0) &#123; return true; &#125; return false; &#125;...... public int compare(SecondarySortKey other) &#123; if (activeVehicles - other.activeVehicles != 0) &#123; return activeVehicles - other.activeVehicles; &#125; else if (trips - other.trips != 0) &#123; return trips - other.trips; &#125; return 0; &#125; public int compareTo(SecondarySortKey other) &#123; if (activeVehicles - other.activeVehicles != 0) &#123; return activeVehicles - other.activeVehicles; &#125; else if (trips - other.trips != 0) &#123; return trips - other.trips; &#125; return 0; &#125; 下面的类是主方法所在的类，也是主要的对数据进行处理计算的类： 他有四个函数（算上主函数），分别为： main： 用于打开文件，创建SparkConf和SparkContext对象，调用函数对RDD进行操作，并输出结果。 12345678910111213141516public static void main(String[] args) throws Exception &#123; SparkConf conf = new SparkConf().setAppName(\"SecondarySortDemo\").setMaster(\"local\"); JavaSparkContext jsc = new JavaSparkContext(conf); jsc.setLogLevel(\"WARN\"); JavaRDD&lt;String&gt; textfile = jsc.textFile(\"/home/zkpk/experiment/mydata.log\"); JavaPairRDD&lt;String, serDemo&gt; pairRdd = mapTfRDD2Pair(textfile); JavaPairRDD&lt;String, serDemo&gt; getlines = aggregateByDeviceID(pairRdd); JavaPairRDD&lt;SecondarySortKey, String&gt; telval = mapRDDKey2SortKey(getlines); JavaPairRDD&lt;SecondarySortKey, String&gt; sortedRdd = telval.sortByKey(false); List&lt;Tuple2&lt;SecondarySortKey, String&gt;&gt; getTop = sortedRdd.take(10); System.out.println(\"============ result ============\"); for (Tuple2&lt;SecondarySortKey, String&gt; dt : getTop) &#123; System.out.println(\"区域编号：\" + dt._2 + \", \" + dt._1); &#125; jsc.close(); &#125; mapTfRDD2Pair： 用于从文件中读取数据，并将其转化为JavaPairRDD，key为区域编号dispatchingBaseNumber，value为以文件每一行生成的serDemo对象。 123456789101112131415private static JavaPairRDD&lt;String, serDemo&gt; mapTfRDD2Pair(JavaRDD&lt;String&gt; accessLogRDD) &#123; return accessLogRDD.mapToPair(new PairFunction&lt;String, String, serDemo&gt;() &#123; private static final long serialVersionUID = 1L; public Tuple2&lt;String, serDemo&gt; call(String lines) throws Exception &#123; String[] split = lines.split(\",\"); String dispatchingBaseNumber = split[0]; String date = split[1]; int activeVehicles = Integer.valueOf(split[2]); int trips = Integer.valueOf(split[3]); serDemo dataInfo = new serDemo(date, activeVehicles, trips); return new Tuple2&lt;String, serDemo&gt;(dispatchingBaseNumber, dataInfo); &#125; &#125;); &#125; aggregateByRegionID： 用于将mapTfRDD2Pair生成好的JavaPairRDD按照key对使用的机动车数量activeVehicles和旅游次数trips求和，获得JavaPairRDD，key为区域编号dispatchingBaseNumber，value为已经求和聚集完成的serDemo对象。 12345678910111213141516private static JavaPairRDD&lt;String, serDemo&gt; aggregateByDeviceID(JavaPairRDD&lt;String, serDemo&gt; accessLogPairRDD) &#123; return accessLogPairRDD.reduceByKey(new Function2&lt;serDemo, serDemo, serDemo&gt;() &#123; private static final long serialVersionUID = 1L; public serDemo call(serDemo d1, serDemo d2) throws Exception &#123; String date = d1.getDate().compareTo(d2.getDate()) &gt; 0 ? d1.getDate() : d2.getDate(); int activeVehicles = d1.getActiveVehicles() + d2.getActiveVehicles(); int trips = d1.getTrips() + d2.getTrips(); serDemo accessLogInfo = new serDemo(); accessLogInfo.setDate(date); accessLogInfo.setActiveVehicles(activeVehicles); accessLogInfo.setTrips(trips); return accessLogInfo; &#125; &#125;);&#125; mapRDDKey2SortKey： 用于将aggregateByRegionID生成好的JavaPairRDD按照上面定义好的规则进行排序，获得排好序的JavaPairRDD，用于输出。 123456789101112131415private static JavaPairRDD&lt;SecondarySortKey, String&gt; mapRDDKey2SortKey( JavaPairRDD&lt;String, serDemo&gt; aggrAccessLogPairRDD) &#123; return aggrAccessLogPairRDD.mapToPair( new PairFunction&lt;Tuple2&lt;String, serDemo&gt;, SecondarySortKey, String&gt;() &#123; private static final long serialVersionUID = 1L; public Tuple2&lt;SecondarySortKey, String&gt; call(Tuple2&lt;String, serDemo&gt; tuple) throws Exception &#123; String dispatchingBaseNumber = tuple._1; serDemo accessLogInfo = tuple._2; SecondarySortKey accessLogSortKey = new SecondarySortKey(accessLogInfo.getDate(), accessLogInfo.getActiveVehicles(), accessLogInfo.getTrips()); return new Tuple2&lt;SecondarySortKey, String&gt;(accessLogSortKey, dispatchingBaseNumber); &#125; &#125;);&#125; 4.4运行程序4.4.1将生成好的mydata.log发送到平台。 4.4.2运行程序，查看结果。可以发现，程序正常运行得出了结果，并且已经求和和排序，成功！ 五、附录1、SecondarySortKey.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200package org.zkpk.spark;import scala.math.Ordered;import java.io.Serializable;import java.util.Objects;class serDemo implements Serializable &#123; private static final long serialVersionUID = 5749943279909593929L; //日期 private String date; //使用的机动车数量 private int activeVehicles; //旅游次数 private int trips; public serDemo() &#123; super(); &#125; public serDemo(String date, int activeVehicles, int trips) &#123; super(); this.date = date; this.activeVehicles = activeVehicles; this.trips = trips; &#125; public static long getSerialVersionUID() &#123; return serialVersionUID; &#125; public String getDate() &#123; return date; &#125; public void setDate(String date) &#123; this.date = date; &#125; public int getActiveVehicles() &#123; return activeVehicles; &#125; public void setActiveVehicles(int activeVehicles) &#123; this.activeVehicles = activeVehicles; &#125; public int getTrips() &#123; return trips; &#125; public void setTrips(int trips) &#123; this.trips = trips; &#125;&#125;public class SecondarySortKey implements Ordered&lt;SecondarySortKey&gt;, Serializable &#123; private static final long serialVersionUID = 3702442700882342403L; //日期 private String date; //使用的机动车数量 private int activeVehicles; //旅游次数 private int trips; public SecondarySortKey() &#123; super(); &#125; public SecondarySortKey(String date, int activeVehicles, int trips) &#123; super(); this.date = date; this.activeVehicles = activeVehicles; this.trips = trips; &#125; public static long getSerialVersionUID() &#123; return serialVersionUID; &#125; public String getDate() &#123; return date; &#125; public void setDate(String date) &#123; this.date = date; &#125; public int getActiveVehicles() &#123; return activeVehicles; &#125; public void setActiveVehicles(int activeVehicles) &#123; this.activeVehicles = activeVehicles; &#125; public int getTrips() &#123; return trips; &#125; public void setTrips(int trips) &#123; this.trips = trips; &#125; public boolean $greater(SecondarySortKey other) &#123; if (activeVehicles &gt; other.activeVehicles) &#123; return true; &#125; else if (activeVehicles == other.activeVehicles &amp;&amp; trips &gt; other.trips) &#123; return true; &#125; else if (activeVehicles == other.activeVehicles &amp;&amp; trips == other.trips &amp;&amp; date.compareTo(other.date) &gt; 0) &#123; return true; &#125; return false; &#125; public boolean $greater$eq(SecondarySortKey other) &#123; if ($greater(other)) &#123; return true; &#125; else if (activeVehicles == other.activeVehicles &amp;&amp; trips == other.trips &amp;&amp; date.compareTo(other.date) == 0) &#123; return true; &#125; return false; &#125; public boolean $less(SecondarySortKey other) &#123; if (activeVehicles &lt; other.activeVehicles) &#123; return true; &#125; else if (activeVehicles == other.activeVehicles &amp;&amp; trips &lt; other.trips) &#123; return true; &#125; else if (activeVehicles == other.activeVehicles &amp;&amp; trips == other.trips &amp;&amp; date.compareTo(other.date) &lt; 0) &#123; return true; &#125; return false; &#125; public boolean $less$eq(SecondarySortKey other) &#123; if ($less(other)) &#123; return true; &#125; else if (activeVehicles == other.activeVehicles &amp;&amp; trips == other.trips &amp;&amp; date.compareTo(other.date) == 0) &#123; return true; &#125; return false; &#125; public int compare(SecondarySortKey other) &#123; if (activeVehicles - other.activeVehicles != 0) &#123; return activeVehicles - other.activeVehicles; &#125; else if (trips - other.trips != 0) &#123; return trips - other.trips; &#125; return 0; &#125; public int compareTo(SecondarySortKey other) &#123; if (activeVehicles - other.activeVehicles != 0) &#123; return activeVehicles - other.activeVehicles; &#125; else if (trips - other.trips != 0) &#123; return trips - other.trips; &#125; return 0; &#125; @Override public boolean equals(Object o) &#123; if (this == o) &#123; return true; &#125; if (o == null || getClass() != o.getClass()) &#123; return false; &#125; SecondarySortKey that = (SecondarySortKey) o; return activeVehicles == that.activeVehicles &amp;&amp; trips == that.trips &amp;&amp; Objects.equals(date, that.date); &#125; @Override public int hashCode() &#123; return Objects.hash(date, activeVehicles, trips); &#125; @Override public String toString() &#123; return \"SortResult&#123;\" + \"截止日期：\" + date + \", 使用的机动车总数量：\" + activeVehicles + \", 旅游总次数：\" + trips + '&#125;'; &#125;&#125; 2、SecondarySortDemo.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package org.zkpk.spark;import org.apache.spark.SparkConf;import org.apache.spark.api.java.JavaPairRDD;import org.apache.spark.api.java.JavaRDD;import org.apache.spark.api.java.JavaSparkContext;import org.apache.spark.api.java.function.Function2;import org.apache.spark.api.java.function.PairFunction;import scala.Tuple2;import java.util.List;public class SecondarySortDemo &#123; public static void main(String[] args) throws Exception &#123; SparkConf conf = new SparkConf().setAppName(\"SecondarySortDemo\").setMaster(\"local\"); JavaSparkContext jsc = new JavaSparkContext(conf); jsc.setLogLevel(\"WARN\"); JavaRDD&lt;String&gt; textfile = jsc.textFile(\"/home/zkpk/experiment/mydata.log\"); JavaPairRDD&lt;String, serDemo&gt; pairRdd = mapTfRDD2Pair(textfile); JavaPairRDD&lt;String, serDemo&gt; getlines = aggregateByRegionID(pairRdd); JavaPairRDD&lt;SecondarySortKey, String&gt; telval = mapRDDKey2SortKey(getlines); JavaPairRDD&lt;SecondarySortKey, String&gt; sortedRdd = telval.sortByKey(false); List&lt;Tuple2&lt;SecondarySortKey, String&gt;&gt; getTop = sortedRdd.take(10); System.out.println(\"============ result ============\"); for (Tuple2&lt;SecondarySortKey, String&gt; dt : getTop) &#123; System.out.println(\"区域编号：\" + dt._2 + \", \" + dt._1); &#125; jsc.close(); &#125; //从文件读取生成PairRDD private static JavaPairRDD&lt;String, serDemo&gt; mapTfRDD2Pair(JavaRDD&lt;String&gt; accessLogRDD) &#123; return accessLogRDD.mapToPair(new PairFunction&lt;String, String, serDemo&gt;() &#123; private static final long serialVersionUID = 1L; public Tuple2&lt;String, serDemo&gt; call(String lines) throws Exception &#123; String[] split = lines.split(\",\"); String dispatchingBaseNumber = split[0]; String date = split[1]; int activeVehicles = Integer.valueOf(split[2]); int trips = Integer.valueOf(split[3]); serDemo dataInfo = new serDemo(date, activeVehicles, trips); return new Tuple2&lt;String, serDemo&gt;(dispatchingBaseNumber, dataInfo); &#125; &#125;); &#125; //对PairRDD进行reduceByKey聚集操作求和 private static JavaPairRDD&lt;String, serDemo&gt; aggregateByRegionID(JavaPairRDD&lt;String, serDemo&gt; accessLogPairRDD) &#123; return accessLogPairRDD.reduceByKey(new Function2&lt;serDemo, serDemo, serDemo&gt;() &#123; private static final long serialVersionUID = 1L; public serDemo call(serDemo d1, serDemo d2) throws Exception &#123; String date = d1.getDate().compareTo(d2.getDate()) &gt; 0 ? d1.getDate() : d2.getDate(); int activeVehicles = d1.getActiveVehicles() + d2.getActiveVehicles(); int trips = d1.getTrips() + d2.getTrips(); serDemo accessLogInfo = new serDemo(); accessLogInfo.setDate(date); accessLogInfo.setActiveVehicles(activeVehicles); accessLogInfo.setTrips(trips); return accessLogInfo; &#125; &#125;); &#125; //对PairRDD进行排序，用于最后输出 private static JavaPairRDD&lt;SecondarySortKey, String&gt; mapRDDKey2SortKey( JavaPairRDD&lt;String, serDemo&gt; aggrAccessLogPairRDD) &#123; return aggrAccessLogPairRDD.mapToPair( new PairFunction&lt;Tuple2&lt;String, serDemo&gt;, SecondarySortKey, String&gt;() &#123; private static final long serialVersionUID = 1L; public Tuple2&lt;SecondarySortKey, String&gt; call(Tuple2&lt;String, serDemo&gt; tuple) throws Exception &#123; String dispatchingBaseNumber = tuple._1; serDemo accessLogInfo = tuple._2; SecondarySortKey accessLogSortKey = new SecondarySortKey(accessLogInfo.getDate(), accessLogInfo.getActiveVehicles(), accessLogInfo.getTrips()); return new Tuple2&lt;SecondarySortKey, String&gt;(accessLogSortKey, dispatchingBaseNumber); &#125; &#125;); &#125;&#125; 3、log_generate.py1234567891011121314151617181920212223242526272829303132333435363738394041\"\"\"@Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved.@Project: log_generate@Description: @Version: @Author: 苇名一心@Date: 2020-06-03 11:20@LastEditors: 苇名一心@LastEditTime: 2020-06-03 11:20\"\"\"# -*- coding: UTF-8 -*-import randomimport stringimport timefile = open(\"mydata.log\", mode='a')ch = string.ascii_uppercasedispatching_base_number_list = []for j in range(20): dispatching_base_number_list.append(random.choice(ch) + str(random.randint(1, 9)))for i in range(100): for dispatching_base_number in dispatching_base_number_list: file.write(dispatching_base_number + \",\" + time.strftime(\"%Y-%m-%d\", time.gmtime( time.mktime( time.strptime(\"2020-01-02\", \"%Y-%m-%d\")) + 86400 * i)) + \",\" + str(random.randint(100, 10000)) + \",\" + str(random.randint(1000, 100000)) + \"\\n\") if i == 99 and dispatching_base_number == dispatching_base_number_list[len(dispatching_base_number_list) - 1]: file.write(dispatching_base_number + \",\" + time.strftime(\"%Y-%m-%d\", time.gmtime( time.mktime( time.strptime(\"2020-01-02\", \"%Y-%m-%d\")) + 86400 * i)) + \",\" + str(random.randint(100, 10000)) + \",\" + str(random.randint(1000, 100000)))file.close()","categories":[{"name":"大数据","slug":"大数据","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"实战","slug":"大数据/实战","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"实战","slug":"实战","permalink":"https://666wxy666.github.io/tags/%E5%AE%9E%E6%88%98/"},{"name":"大数据","slug":"大数据","permalink":"https://666wxy666.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Spark","slug":"Spark","permalink":"https://666wxy666.github.io/tags/Spark/"},{"name":"流计算","slug":"流计算","permalink":"https://666wxy666.github.io/tags/%E6%B5%81%E8%AE%A1%E7%AE%97/"},{"name":"单词计数","slug":"单词计数","permalink":"https://666wxy666.github.io/tags/%E5%8D%95%E8%AF%8D%E8%AE%A1%E6%95%B0/"},{"name":"Streaming","slug":"Streaming","permalink":"https://666wxy666.github.io/tags/Streaming/"},{"name":"Scala","slug":"Scala","permalink":"https://666wxy666.github.io/tags/Scala/"},{"name":"Kafka","slug":"Kafka","permalink":"https://666wxy666.github.io/tags/Kafka/"}]},{"title":"大数据实战 Spark 分析流量日志","slug":"大数据实战-Spark-分析流量日志","date":"2020-07-19T16:00:00.000Z","updated":"2020-09-02T02:05:09.581Z","comments":true,"path":"2020/07/20/大数据实战-Spark-分析流量日志/","link":"","permalink":"https://666wxy666.github.io/2020/07/20/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%88%98-Spark-%E5%88%86%E6%9E%90%E6%B5%81%E9%87%8F%E6%97%A5%E5%BF%97/","excerpt":"本文是关于大数据通过Java进行Spark编程实现日志处理分析。","text":"本文是关于大数据通过Java进行Spark编程实现日志处理分析。 一、实验环境： 虚拟机数量：1 系统版本：Centos 7.5 Spark版本：Apache Spark 2.1.1 Eclipse版本：Neno.3 （4.6.3） 二、实验目的：掌握 Spark原理 Hadoop原理 Shell Spark Streaming 二次排序 序列化 Spark RDD 三、实验结果： 以下是分析后的流量日志结果： 四、实验内容： 使用SparkStreaming构建实时数据处理系统，来分析手机流量日志。 五、主要步骤： 日志分析 代码实现 运行程序 六、实验步骤：6.1数据日志介绍6.1.1数据字段 6.1.1.1reportTime（报告时间戳） 6.1.1.2telNum（手机号） 6.1.1.3upwardflow（上行总流量） 6.1.1.4downwardflow（下行总流量） 6.2需求分析6.2.1对文本中数据记录进行排序，排序规则如下： 以telNum为基准，分别按照 upwardflow，downwardflow，reportTime进行降序排序，即先按照upwardflow排序，如果upwardflow相同，再比较downwardflow，如果downwardflow相同，再比较reportTime，最后选择前10条记录输出。 6.2.2具体实现步骤： 6.2.2.1按照 Serrializable 接口实现自定义排序的 Key 6.2.2.2将要进行二次排序的文件加载进来生成 key-value 类型的 RDD 6.2.2.3使用 sortByKey 基于自定义的 Key 进行二次排序 6.2.2.4去除掉排序的 key，只保留排序结果 6.3代码实现：6.3.1创建maven项目6.3.1.1打开Eclipse IDE 12cd eclipse/./eclipse &amp; 6.3.1.2点击 File -&gt; New -&gt;Other 6.3.1.3搜索 maven -&gt; 点击 Maven Project -&gt; Next-&gt;Next 6.3.1.4选中maven-archetype-quickstart -&gt;Next 6.3.1.5输入Group Id 为 org.zkpk；Artifact Id 为 spark ；Package为org.zkpk.spark；-&gt;Finish 6.3.1.6升级maven工程 升级完成： 6.3.1.7更改JRE，右键JRE System Library-&gt; Properties 6.3.1.8选中jdk1.8.0_131-&gt; OK 6.3.1.9点击spark项目-&gt;修改pom.xml-&gt; 保存会自动下载jar包 6.3.1.10下载Jar包： 6.3.1.11最终 pom.xml 如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.zkpk&lt;/groupId&gt; &lt;artifactId&gt;spark&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;spark&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-core_2.10&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-sql_2.10&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-hive_2.10&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-streaming_2.10&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-streaming-kafka_2.10&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-streaming-flume_2.10&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.3.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpcore&lt;/artifactId&gt; &lt;version&gt;4.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;sourceDirectory&gt;src/main/java&lt;/sourceDirectory&gt; &lt;testSourceDirectory&gt;src/main/test&lt;/testSourceDirectory&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;archive&gt; &lt;manifest&gt; &lt;mainClass&gt;&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-assembly&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;exec&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;executable&gt;java&lt;/executable&gt; &lt;includeProjectDependencies&gt;true&lt;/includeProjectDependencies&gt; &lt;includePluginDependencies&gt;false&lt;/includePluginDependencies&gt; &lt;classpathScope&gt;compile&lt;/classpathScope&gt; &lt;mainClass&gt;cn.com.syl.spark.App&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.6&lt;/source&gt; &lt;target&gt;1.6&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 6.3.1.12删除工程生成的App.java和AppTest.java 6.3.2编写代码6.3.2.1在src/main/java中创建类，并命名为SecondarySortKey.java，然后按Finish 6.3.2.1.1创建SecondarySortKey.java，代码见附录 6.3.2.1.2在src/main/java中创建类，并命名为SecondarySortDemo，然后按Finish 6.3.2.1.3创建SecondarySortDemo.java代码见附录 6.3.2.1.4运行SecondarySortDemo，观察控制台输出 6.3.2.1.5右键SecondarySortDemo.java -&gt; Run As -&gt; Java Application 最终结果： 七、附录1、SecondarySortKey.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174package org.zkpk.spark;import java.io.Serializable;import scala.math.Ordered;class serDemo implements Serializable &#123; private static final long serialVersionUID = 5749943279909593929L; private long reportTime; // 时间戳 private long upwardflow; // 上行总流量 private long downwardflow; // 下行总流量 public serDemo() &#123; super(); // TODO Auto-generated constructor stub &#125; public serDemo(long reportTime, long upwardflow, long downwardflow) &#123; super(); this.reportTime = reportTime; this.upwardflow = upwardflow; this.downwardflow = downwardflow; &#125; public long getReportTime() &#123; return reportTime; &#125; public void setReportTime(long reportTime) &#123; this.reportTime = reportTime; &#125; public long getUpwardflow() &#123; return upwardflow; &#125; public void setUpwardflow(long upwardflow) &#123; this.upwardflow = upwardflow; &#125; public long getDownwardflow() &#123; return downwardflow; &#125; public void setDownwardflow(long downwardflow) &#123; this.downwardflow = downwardflow; &#125; public static long getSerialversionuid() &#123; return serialVersionUID; &#125;&#125;public class SecondarySortKey implements Ordered&lt;SecondarySortKey&gt;, Serializable &#123; private static final long serialVersionUID = 3702442700882342403L; private long upwardflow; private long downwardflow; private long reportTime; public SecondarySortKey() &#123; super(); // TODO Auto-generated constructor stub &#125; public SecondarySortKey(long upwardflow, long downwardflow, long reportTime) &#123; super(); this.upwardflow = upwardflow; this.downwardflow = downwardflow; this.reportTime = reportTime; &#125; public long getUpwardflow() &#123; return upwardflow; &#125; public void setUpwardflow(long upwardflow) &#123; this.upwardflow = upwardflow; &#125; public long getDownwardflow() &#123; return downwardflow; &#125; public void setDownwardflow(long downwardflow) &#123; this.downwardflow = downwardflow; &#125; public long getReportTime() &#123; return reportTime; &#125; public void setReportTime(long reportTime) &#123; this.reportTime = reportTime; &#125; public static long getSerialversionuid() &#123; return serialVersionUID; &#125; public boolean $greater(SecondarySortKey other) &#123; if(upwardflow &gt; other.upwardflow) &#123; return true; &#125; else if(upwardflow == other.upwardflow &amp;&amp; downwardflow &gt; other.downwardflow) &#123; return true; &#125; else if(upwardflow == other.upwardflow &amp;&amp; downwardflow == other.downwardflow &amp;&amp; reportTime &gt; other.reportTime) &#123; return true; &#125; return false; &#125; public boolean $greater$eq(SecondarySortKey other) &#123; if($greater(other)) &#123; return true; &#125; else if(upwardflow == other.upwardflow &amp;&amp; downwardflow == other.downwardflow &amp;&amp; reportTime == other.reportTime) &#123; return true; &#125; return false; &#125; public boolean $less(SecondarySortKey other) &#123; if(upwardflow &lt; other.upwardflow) &#123; return true; &#125; else if(upwardflow == other.upwardflow &amp;&amp; downwardflow &lt; other.downwardflow) &#123; return true; &#125; else if(upwardflow == other.upwardflow &amp;&amp; downwardflow == other.downwardflow &amp;&amp; reportTime &lt; other.reportTime) &#123; return true; &#125; return false; &#125; public boolean $less$eq(SecondarySortKey other) &#123; if($less(other)) &#123; return true; &#125; else if(upwardflow == other.upwardflow &amp;&amp; downwardflow == other.downwardflow &amp;&amp; reportTime == other.reportTime) &#123; return true; &#125; return false; &#125; public int compare(SecondarySortKey other) &#123; if(upwardflow - other.upwardflow != 0) &#123; return (int) (upwardflow - other.upwardflow); &#125; else if(downwardflow - other.downwardflow != 0) &#123; return (int) (downwardflow - other.downwardflow); &#125; else if(reportTime - other.reportTime != 0) &#123; return (int) (reportTime - other.reportTime); &#125; return 0; &#125; public int compareTo(SecondarySortKey other) &#123; if(upwardflow - other.upwardflow != 0) &#123; return (int) (upwardflow - other.upwardflow); &#125; else if(downwardflow - other.downwardflow != 0) &#123; return (int) (downwardflow - other.downwardflow); &#125; else if(reportTime - other.reportTime != 0) &#123; return (int) (reportTime - other.reportTime); &#125; return 0; &#125; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + (int) (downwardflow ); result = prime * result + (int) (reportTime ); result = prime * result + (int) (upwardflow ); return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; SecondarySortKey other = (SecondarySortKey) obj; if (downwardflow != other.downwardflow) return false; if (reportTime != other.reportTime) return false; if (upwardflow != other.upwardflow) return false; return true; &#125; @Override public String toString() &#123; return \"SortResult： [上行总流量： \" + upwardflow + \", 下行总流量： \" + downwardflow + \", 时间戳：\" + reportTime + \"]\"; &#125;&#125; 2、SecondarySortDemo.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package org.zkpk.spark;import java.util.List;import org.apache.spark.SparkConf;import org.apache.spark.api.java.JavaPairRDD;import org.apache.spark.api.java.JavaRDD;import org.apache.spark.api.java.JavaSparkContext;import org.apache.spark.api.java.function.Function2;import org.apache.spark.api.java.function.PairFunction;import scala.Tuple2;public class SecondarySortDemo &#123; public static void main(String[] args) throws Exception &#123; // 创建sparkcontext对象，sparkcontext是程序的唯一入口 SparkConf conf = new SparkConf().setAppName(\"SecondarySortDemo\").setMaster(\"local\"); JavaSparkContext jsc = new JavaSparkContext(conf); // 去掉WARN类的输出信息 jsc.setLogLevel(\"WARN\"); // 调用textFile()方法，读取日志文件，这里指定本地磁盘文件 JavaRDD&lt;String&gt; textfile = jsc.textFile(\"/home/zkpk/experiment/data.log\"); // 调用mapTfRDD2Pair方法 将tf映射为键值对 JavaPairRDD&lt;String, serDemo&gt; pairRdd = mapTfRDD2Pair(textfile); // 获取每个手机号的总上行流量、总下行流量、最早报告时间戳 JavaPairRDD&lt;String, serDemo&gt; getlines = aggregateByDeviceID(pairRdd); // 聚合，封装的RDD作为key,手机号作为值 JavaPairRDD&lt;SecondarySortKey, String&gt; telval = mapRDDKey2SortKey(getlines); // 依次按照上行流量、下行流量以及时间戳倒序排序 JavaPairRDD&lt;SecondarySortKey, String&gt; sortedRdd = telval.sortByKey(false); // 根据您的需要获得输出，这里仅显示前10行 List&lt;Tuple2&lt;SecondarySortKey, String&gt;&gt; getTop = sortedRdd.take(10); System.out.println(\"============ result ============\"); for (Tuple2&lt;SecondarySortKey, String&gt; dt : getTop) &#123; System.out.println(\"telNum: \" + dt._2 + \", \" + dt._1); &#125; // 执行结束关闭资源 jsc.close(); &#125; // mapTfRDD2Pair方法，封装键值对 private static JavaPairRDD&lt;String, serDemo&gt; mapTfRDD2Pair(JavaRDD&lt;String&gt; accessLogRDD) &#123; return accessLogRDD.mapToPair(new PairFunction&lt;String, String, serDemo&gt;() &#123; private static final long serialVersionUID = 1L; @Override public Tuple2&lt;String, serDemo&gt; call(String lines) throws Exception &#123; // 根据数据格式进行切分 String[] split = lines.split(\"\\t\"); // 获取切分的字段 long reportTime = Long.valueOf(split[0]); String telNum = split[1]; long upwardflow = Long.valueOf(split[2]); long downwardflow = Long.valueOf(split[3]); // 创建cmbInfo对象，有参构造 ，将上行流量、下行流量，报告时间戳封装为自定义的可序列化对象 serDemo dataInfo = new serDemo(reportTime, upwardflow, downwardflow); return new Tuple2&lt;String, serDemo&gt;(telNum, dataInfo); &#125; &#125;); &#125; // 根据手机号进行聚合，依次按照上行流量、下行流量以及报告时间戳倒序排序 private static JavaPairRDD&lt;String, serDemo&gt; aggregateByDeviceID(JavaPairRDD&lt;String, serDemo&gt; accessLogPairRDD) &#123; return accessLogPairRDD.reduceByKey(new Function2&lt;serDemo, serDemo, serDemo&gt;() &#123; private static final long serialVersionUID = 1L; @Override public serDemo call(serDemo d1, serDemo d2) throws Exception &#123; long reportTime = d1.getReportTime() &lt; d2.getReportTime() ? d1.getReportTime() : d2.getReportTime(); long upwardflow = d1.getUpwardflow() + d2.getUpwardflow(); long downwardflow = d1.getDownwardflow() + d2.getDownwardflow(); serDemo accessLogInfo = new serDemo(); accessLogInfo.setReportTime(reportTime); accessLogInfo.setUpwardflow(upwardflow); accessLogInfo.setDownwardflow(downwardflow); return accessLogInfo; &#125; &#125;); &#125; // 二次排序，手机号作为值 private static JavaPairRDD&lt;SecondarySortKey, String&gt; mapRDDKey2SortKey( JavaPairRDD&lt;String, serDemo&gt; aggrAccessLogPairRDD) &#123; return aggrAccessLogPairRDD.mapToPair( new PairFunction&lt;Tuple2&lt;String, serDemo&gt;, SecondarySortKey, String&gt;() &#123; private static final long serialVersionUID = 1L; @Override public Tuple2&lt;SecondarySortKey, String&gt; call(Tuple2&lt;String, serDemo&gt; tuple) throws Exception &#123; // 获取元祖里的数据 String telNum = tuple._1; serDemo accessLogInfo = tuple._2; // 封装为二次排序key SecondarySortKey accessLogSortKey = new SecondarySortKey(accessLogInfo.getUpwardflow(), accessLogInfo.getDownwardflow(), accessLogInfo.getReportTime()); // 返回新的Tuple return new Tuple2&lt;SecondarySortKey, String&gt;(accessLogSortKey, telNum); &#125; &#125;); &#125;&#125;","categories":[{"name":"大数据","slug":"大数据","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"实战","slug":"大数据/实战","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"实战","slug":"实战","permalink":"https://666wxy666.github.io/tags/%E5%AE%9E%E6%88%98/"},{"name":"大数据","slug":"大数据","permalink":"https://666wxy666.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Spark","slug":"Spark","permalink":"https://666wxy666.github.io/tags/Spark/"},{"name":"流计算","slug":"流计算","permalink":"https://666wxy666.github.io/tags/%E6%B5%81%E8%AE%A1%E7%AE%97/"},{"name":"Streaming","slug":"Streaming","permalink":"https://666wxy666.github.io/tags/Streaming/"},{"name":"Java","slug":"Java","permalink":"https://666wxy666.github.io/tags/Java/"},{"name":"日志分析","slug":"日志分析","permalink":"https://666wxy666.github.io/tags/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"}]},{"title":"C和C++的struct使用总结","slug":"C和C++的struct使用总结","date":"2020-07-14T16:00:00.000Z","updated":"2020-09-02T01:48:36.334Z","comments":true,"path":"2020/07/15/C和C++的struct使用总结/","link":"","permalink":"https://666wxy666.github.io/2020/07/15/C%E5%92%8CC++%E7%9A%84struct%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/","excerpt":"简单的写了一下关于C语言和C++中的Struct结构体的定义的疑惑点和C99新增的柔性数组的使用和理解。","text":"简单的写了一下关于C语言和C++中的Struct结构体的定义的疑惑点和C99新增的柔性数组的使用和理解。 一、关于C语言和C++中的Struct结构体的定义1、C语言对于C语言，结构体的定义可以是以下的标准定义法： 1234567891011121314151617181920212223/* * @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. * @Description: * @Version: * @Author: 苇名一心 * @Date: 2020-07-15 08:17:32 * @LastEditors: 苇名一心 * @LastEditTime: 2020-07-15 11:29:00 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct TEST&#123; int a;&#125;;int main(int argc, char const *argv[])&#123; struct TEST test; test.a = 1; printf(\"%d\\n\", test.a); return 0;&#125; 像这样就定义了一个结构体TEST，在声明新结构体变量时，需要使用“struct TEST test”，“struct”必须有，不写会报错，“struct TEST”就相当于是“int”。 直接在结构体里赋初值是不允许的，例如： 12345678910111213141516171819202122/* * @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. * @Description: * @Version: * @Author: 苇名一心 * @Date: 2020-07-15 08:17:32 * @LastEditors: 苇名一心 * @LastEditTime: 2020-07-15 11:32:27 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct TEST&#123; int a = 1;&#125;;int main(int argc, char const *argv[])&#123; struct TEST test; printf(\"%d\\n\", test.a); return 0;&#125; 会产生如下错误： 另外，除了标准定义法，C语言还支持直接在定义结构体的时候声明变量，以及给结构体重命名： 123456789101112131415161718192021222324252627282930313233/* * @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. * @Description: * @Version: * @Author: 苇名一心 * @Date: 2020-07-15 08:17:32 * @LastEditors: 苇名一心 * @LastEditTime: 2020-07-15 11:37:59 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct TEST1&#123; int a;&#125; test1;typedef struct TEST2&#123; int a;&#125; TEST2;int main(int argc, char const *argv[])&#123; struct TEST1 test11; TEST2 test2; struct TEST2 test22; test1.a = 1; test2.a = 2; test11.a = 11; test22.a = 22; printf(\"%d,%d,%d,%d\\n\", test1.a, test2.a, test11.a, test22.a); return 0;&#125; 可以看出，TEST1是直接在定义结构体时就声明了一个变量test1，在下面可以直接使用test1访问结构体成员a，另外你仍然可以在后面使用标准方法定义新的TEST1结构体。 而对于TEST2，则是使用“typedef”将“struct TEST2”起了个别名叫“TEST2”，因此后面既可以使用struct TEST2”也可以使用“TEST2”声明TEST2结构体变量。 在定义结构体的时候，你也可以省略TEST1或者TEST2不写，但是这样对于没有起别名的TEST1就只能在定义结构体的时候声明结构体变量，在后面不能定义（因为没有名字，很好理解），相当于是一次性的结构体。但是对于起了别名的TEST2，在后面就只能使用TEST2来声明结构体变量，而不能再使用标准的“struct TEST2”。 1234567891011121314151617181920212223242526272829/* * @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. * @Description: * @Version: * @Author: 苇名一心 * @Date: 2020-07-15 08:17:32 * @LastEditors: 苇名一心 * @LastEditTime: 2020-07-15 11:52:58 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct&#123; int a;&#125; test1;typedef struct&#123; int a;&#125; TEST2;int main(int argc, char const *argv[])&#123; TEST2 test2; test1.a = 1; test2.a = 2; printf(\"%d,%d\\n\", test1.a, test2.a); return 0;&#125; 2、C++对于C++，因为C++是面向对象的程序设计语言，结构体struct就相当于是C++的类class，只是默认继承访问权限不同，class默认的是private，strcut默认的是public。你甚至可以在结构体定义函数，这是在C语言里不允许的，并且C++也允许声明结构体变量时省略“struct”，这个在C语言里也不允许，除非使用typedef起别名。 12345678910111213141516171819202122232425262728/* * @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. * @Description: * @Version: * @Author: 苇名一心 * @Date: 2020-07-15 08:28:24 * @LastEditors: 苇名一心 * @LastEditTime: 2020-07-15 11:48:50 */#include &lt;iostream&gt;using namespace std;struct TEST&#123; int a = 1; void hello() &#123; cout &lt;&lt; \"hello world\" &lt;&lt; endl; &#125;;&#125;;int main(int argc, char const *argv[])&#123; struct TEST test1; TEST test2; cout &lt;&lt; test1.a &lt;&lt; endl; test2.hello(); return 0;&#125; 当然，C++也允许对类或者结构体起别名： 123456789101112131415161718192021222324252627282930/* * @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. * @Description: * @Version: * @Author: 苇名一心 * @Date: 2020-07-15 08:28:24 * @LastEditors: 苇名一心 * @LastEditTime: 2020-07-15 11:58:18 */#include &lt;iostream&gt;using namespace std;typedef struct TEST&#123; int a = 1; void hello() &#123; cout &lt;&lt; \"hello world\" &lt;&lt; endl; &#125;;&#125; T;int main(int argc, char const *argv[])&#123; struct TEST test1; TEST test2; T test3; cout &lt;&lt; test1.a &lt;&lt; endl; test2.hello(); test3.hello(); return 0;&#125; 直接在定义结构体的时候声明变量也可以： 1234567891011121314151617181920212223242526272829/* * @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. * @Description: * @Version: * @Author: 苇名一心 * @Date: 2020-07-15 08:28:24 * @LastEditors: 苇名一心 * @LastEditTime: 2020-07-15 11:59:23 */#include &lt;iostream&gt;using namespace std;struct TEST&#123; int a = 1; void hello() &#123; cout &lt;&lt; \"hello world\" &lt;&lt; endl; &#125;;&#125; test3;int main(int argc, char const *argv[])&#123; struct TEST test1; TEST test2; cout &lt;&lt; test1.a &lt;&lt; endl; test2.hello(); test3.hello(); return 0;&#125; 二、关于C99新增的柔性数组在C99中，结构中的最后一个元素允许是未知大小的数组，这就叫做柔性数组成员，但结构中的柔性数组成员前面必须至少一个其他成员。柔性数组成员允许结构中包含一个大小可变的数组。sizeof返回的这种结构大小不包括柔性数组的内存。包含柔性数组成员的结构用malloc函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。 例如： 12345678910111213141516171819202122232425/* * @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. * @Description: * @Version: * @Author: 苇名一心 * @Date: 2020-07-15 08:17:32 * @LastEditors: 苇名一心 * @LastEditTime: 2020-07-15 12:12:45 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct TEST&#123; int a; char b[];&#125; T;int main(int argc, char const *argv[])&#123; T test; T *test_ptr; test.a = 1; printf(\"%d,%d,%d,%d\\n\", test.a, sizeof(T), sizeof(test), sizeof(*test_ptr)); return 0;&#125; 我们可以发现，结构体的大小确实等于一个整型的大小4字节，也就是a的大小，b数组是没有占空间的。对于编译器来说，此时长度为0的数组并不占用空间，因为数组名本身不占空间，它只是一个偏移量，数组名这个符号本身代表了一个不可修改的地址常量 ，但对于这个数组的大小，我们可以进行动态分配。当我们对结构体指针test_ptr进行malloc分配内存空间，分配的空间减去sizeof(T)就是柔性数组b的空间，我们就可以对b操作了。其实，b就是柔性数组，或者叫动态数组。这个操作常用于缓冲区或者网络通信中构造不定长数据包。 例如： 12345678910111213141516171819202122232425262728/* * @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. * @Description: * @Version: * @Author: 苇名一心 * @Date: 2020-07-15 08:17:32 * @LastEditors: 苇名一心 * @LastEditTime: 2020-07-15 12:20:33 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct TEST&#123; int a; char b[];&#125; T;int main(int argc, char const* argv[])&#123; T* test_ptr; test_ptr = (T*)malloc(sizeof(T) + 10 * sizeof(char)); test_ptr-&gt;a = 10; strcpy(test_ptr-&gt;b, \"aaaaaaaaa\"); printf(\"%d,%d,%s\\n\", sizeof(*test_ptr), test_ptr-&gt;a, test_ptr-&gt;b); free(test_ptr); return 0;&#125; 可以发现T的大小依然是4字节，因此b明确来说不算是结构体成员。但是我们却可以使用长度为10的数组b。但为什么我只能复制9个a到数组b呢，其实9个a的字符串长度就是10，因为常量字符串最后一个字符是‘\\0’，用于标志字符串而结束，因此实际上b[9]是‘\\0’。那如果我们此时强制访问越界会怎么样呢？ 12345678910111213141516171819202122232425262728/* * @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. * @Description: * @Version: * @Author: 苇名一心 * @Date: 2020-07-15 08:17:32 * @LastEditors: 苇名一心 * @LastEditTime: 2020-07-15 12:20:33 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct TEST&#123; int a; char b[];&#125; T;int main(int argc, char const* argv[])&#123; T* test_ptr; test_ptr = (T*)malloc(sizeof(T) + 10 * sizeof(char)); test_ptr-&gt;a = 10; strcpy(test_ptr-&gt;b, \"aaaaaaaaabbbbbbbbbb\"); printf(\"%d,%d,%s\\n\", sizeof(*test_ptr), test_ptr-&gt;a, test_ptr-&gt;b); free(test_ptr); return 0;&#125; 可以发现产生了异常，但是后面的b却被成功打印了出来。经过调试，发现是free语句产生的异常，如果我们把free语句注释掉，就能正常跑了，但是显然不应该这么做，原因是什么呢？ 12345678910111213141516171819202122232425262728/* * @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. * @Description: * @Version: * @Author: 苇名一心 * @Date: 2020-07-15 08:17:32 * @LastEditors: 苇名一心 * @LastEditTime: 2020-07-15 12:20:33 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct TEST&#123; int a; char b[];&#125; T;int main(int argc, char const* argv[])&#123; T* test_ptr; test_ptr = (T*)malloc(sizeof(T) + 10 * sizeof(char)); test_ptr-&gt;a = 10; strcpy(test_ptr-&gt;b, \"aaaaaaaaabbbbbbbbbb\"); printf(\"%d,%d,%s\\n\", sizeof(*test_ptr), test_ptr-&gt;a, test_ptr-&gt;b); // free(test_ptr); return 0;&#125; 其实，在动态分配的时候，会在数组界限外加一个用来标识数组范围的标志，例如b数组，就会在b[-1]和b[10]有两个标志，如果我们在这两个位置赋值，赋值和调用时并不会出错，而是在freed掉b申请的内存时出错，错误的名称就是“before Normal block”或“after Normal block”，一般是后者居多。 那么这个柔性数组相比与在结构体里的动态数组有什么优势呢？从上面的代码也能看出，如果使用普通的动态数组，需要分配两块内存，即动态数组的内存和结构体的内存，在释放时也要先释放b的内存，再释放test_ptr的内存，比较麻烦。但是柔性数组就完全不需要，直接申请结构体的内存即可，释放时也只需要释放结构体申请的内存，非常方便。 还有一点要说明的是：在C99之前是不支持灵活数组成员（Fleible Array Member，int a[]）的，C99把它作为一种特例加入了标准。但是，C99所支持的是Incomplete Type（int a[]），而不是Zero Array（int a[0]）。也就是说类似“int a[0];”这种形式是非法的，只不过有些编译器把“int a[0];”作为非标准扩展来支持，而且在C99发布之前已经有了这种非标准扩展了，C99发布之后，有些编译器把两者合而为一了而已。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://666wxy666.github.io/categories/C-C/"},{"name":"拓展学习","slug":"C-C/拓展学习","permalink":"https://666wxy666.github.io/categories/C-C/%E6%8B%93%E5%B1%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"C","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"难点","slug":"难点","permalink":"https://666wxy666.github.io/tags/%E9%9A%BE%E7%82%B9/"},{"name":"C99","slug":"C99","permalink":"https://666wxy666.github.io/tags/C99/"},{"name":"Struct","slug":"Struct","permalink":"https://666wxy666.github.io/tags/Struct/"}]},{"title":"C++工程项目 单词消除游戏","slug":"C++工程项目-单词消除游戏","date":"2020-07-11T16:00:00.000Z","updated":"2020-09-02T01:58:51.050Z","comments":true,"path":"2020/07/12/C++工程项目-单词消除游戏/","link":"","permalink":"https://666wxy666.github.io/2020/07/12/C++%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE-%E5%8D%95%E8%AF%8D%E6%B6%88%E9%99%A4%E6%B8%B8%E6%88%8F/","excerpt":"本文是C++面向对象的程序设计实战项目，实现单词消除游戏，具体项目及要求请点击查看。","text":"本文是C++面向对象的程序设计实战项目，实现单词消除游戏，具体项目及要求请点击查看。 一、单词消除游戏总体要求单词消除游戏由两类参与者组成：闯关者（即游戏玩家），出题者（为游戏增加游戏中使用单词）。游戏规则为，游戏每一轮，程序会根据该关卡难度，显示一个单词，一定时间后单词消失。闯关者需要在相应地方输入刚刚显示并消失的单词，如果闯关者输入正确（即闯关者输入的单词与刚刚显示的单词完全一致，包含大小写）则为通过。一关可以由一轮或者多轮组成。 二、单词消除游戏具体要求 Version1 实现闯关者，出题者本地的注册、登录。 程序支持多人注册，同一时间只有一人可以登录。 实现游戏规则：出题者增加游戏中使用单词。游戏每一关，程序会根据该关卡难度，显示一个单词，一定时间后单词消失。闯关者需要在相应地方输入刚刚显示并消失的单词，如果闯关者输入正确则为通过。 任何角色均可查询所有闯关者、出题者，按照属性查找相应闯关者、出题者。 采用面向对象的方式，使用类设计。 在设计类时请注意类的继承关系，关注闯关者、出题者的关联（闯关者与出题者有共同的基类）。 使用文件或者数据库作为存储对象，自行设计文件格式，或者数据库表结构。 Version2 在Version1的基础上增加： 可以根据闯关者闯过关卡数、经验、等级等对闯关者排名，根据出题者出题数目、等级对出题者排名。 请根据要求设计每一关的出题方式，注意随着关卡数增加，题目难度增加 计闯关者经验值，等级增加策略。设计出题者等级升级策略。 Version3 在Version2的基础上增加： 使用socket进行通信，实现局域网通信游玩。 需要完成服务器端程序，以及客户端程序。客户端可以启动多个同时与服务器交互，要求服务器具有并发处理能力。 在题目的要求下自行扩展功能，功能扩展适当者酌情加分。 三、运行环境电脑硬件配置： 处理器：Intel i7 7700HQ 显卡：NVIDIA GeForce GTX 1050 Ti 内存：16GB 编程语言：C++ QT：Qt Creator 4.11.1 Based on Qt 5.14.1 (MSVC 2017, 32 bit) 编译器：Desktop Qt 5.14.2 MinGW 7.3.0 64-bit 数据库：mysql Ver 8.0.20 for Win64 on x86_64 (MySQL Community Server - GPL) 其它说明： 关于QT数据库驱动 libmysql.dll和libqsqlmysql.a放入【…\\Qt5.14.2\\5.14.2\\mingw73_64\\bin】下。 qsqlmysql.dll和qsqlmysql.dll.debug放入【…\\Qt5.14.2\\5.14.2\\mingw73_64\\plugins\\sqldrivers】下。 数据库信息： 需要修改请自行修改代码，以下是默认用户名和密码。 用户名：wxy 密码：123456 由于QT的限制，编译构建时路径不允许有中文。 服务器默认IP地址是本地127.0.0.1，有需要请自行修改代码。 四、模块设计1、游戏客户端模块清单 编号 模块名称 模块标识 模块功能 1 主界面模块 Widget 主界面，包括登录等 2 用户类模块 User 闯关者，出题人类 3 注册模块 Register 注册用户 4 用户信息模块 Info 展示用户信息，包括等级、经验等 5 游戏模块 Game 单词消除游戏游玩界面 6 出题模块 Create 出题人出题界面 7 查询模块 Check 查询用户，排名界面 用户界面1、主界面 2、注册界面 3、用户信息界面（出题人与闯关者文字略有不同） 4、游戏界面 5、出题界面 Version2： Version3： 6、查询界面 函数具体功能1、Widget1234567891011121314void init_UI();//初始化图形界面void connect_event();//信号，槽函数链接void user_registe_show();//显示闯关者注册界面void creater_registe_show();//显示出题人注册界面void check_user_show(); //显示查询闯关者界面void check_creater_show();//显示查询出题人界面void info_show();//显示用户信息界面void check_close();//关闭查询界面void registe_close();//关闭注册界面void info_close();//关闭用户信息界面void showEvent(QShowEvent *);//显示界面void close_Widget();//关闭界面void type_changed();//闯关者，出题人切换void init_database();//初始化数据库 2、userplayer和creater继承于user类，升级函数采用虚函数，分别在各自类中实现。 3、register12345void init_UI();//初始化图形界面void connect_event();//信号，槽函数链接void showEvent(QShowEvent *);//显示界面void close_Widget();//关闭界面void send_change_signal();//改变界面信号 4、info123456789void init_UI();//初始化图形界面void connect_event();//信号，槽函数链接void showEvent(QShowEvent *);//显示界面void close_Widget();//关闭界面void send_change_signal();//改变界面信号void game_show();//游戏界面显示void game_close();//游戏界面关闭void create_show();//出题界面显示 void create_close();//出题界面关闭 5、game123456789void init_UI();//初始化图形界面void connect_event();//信号，槽函数链接void showEvent(QShowEvent *);//显示界面void close_Widget();//关闭界面void send_change_signal();//改变界面信void init_timer();//计时器初始化void init_ms_timer();//计时器初始化void timeup();//超时void ms_timeup();//超时 6、create12345void init_UI();//初始化图形界面void connect_event();//信号，槽函数链接void showEvent(QShowEvent *);//显示界面void close_Widget();//关闭界面void send_change_signal();//改变界面信号 6、check123456void init_UI();//初始化图形界面void connect_event();//信号，槽函数链接void showEvent(QShowEvent *);//显示界面void close_Widget();//关闭界面void send_change_signal();//改变界面信号void search();//搜索信息 2、服务器端模块清单 编号 模块名称 模块标识 模块功能 1 主界面模块 Widget 主界面 2 线程模块 My_thread 实现多线程 用户界面 函数具体功能1、Widget1234void init_UI();//初始化图形界面void tcpserver_connect();//tcpserver连接void tcpsocket_connect();//tcpsocket连接void showEvent(QShowEvent *);//界面显示 2、My_thread当收到客户端的请求后，根据客户端发送的字符串判断是什么请求，在屏幕上输出，同时新建线程，在线程中处理这些请求，从而实现并发处理。 1void init_database();//初始化数据库 五、项目地址本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看：","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://666wxy666.github.io/categories/C-C/"},{"name":"项目","slug":"C-C/项目","permalink":"https://666wxy666.github.io/categories/C-C/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"工程","slug":"工程","permalink":"https://666wxy666.github.io/tags/%E5%B7%A5%E7%A8%8B/"},{"name":"QT","slug":"QT","permalink":"https://666wxy666.github.io/tags/QT/"},{"name":"小游戏","slug":"小游戏","permalink":"https://666wxy666.github.io/tags/%E5%B0%8F%E6%B8%B8%E6%88%8F/"}]},{"title":"Python 爬虫小Demo 学堂在线课程","slug":"Python-爬虫小Demo-学堂在线课程","date":"2020-07-04T16:00:00.000Z","updated":"2020-09-02T02:02:06.495Z","comments":true,"path":"2020/07/05/Python-爬虫小Demo-学堂在线课程/","link":"","permalink":"https://666wxy666.github.io/2020/07/05/Python-%E7%88%AC%E8%99%AB%E5%B0%8FDemo-%E5%AD%A6%E5%A0%82%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/","excerpt":"本文是关于Python中的Spider的小Demo，通过Python的scrapy爬取学堂在线课程的相关数据。","text":"本文是关于Python中的Spider的小Demo，通过Python的scrapy爬取学堂在线课程的相关数据。 一、编译环境：PyCharm 2019.3.4 (Professional Edition) Build #PY-193.6911.25, built on March 18, 2020 Runtime version: 11.0.6+8-b520.43 amd64 VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o Windows 10 10.0 GC: ParNew, ConcurrentMarkSweep Memory: 725M Cores: 8 Registry: ide.balloon.shadow.size=0 Non-Bundled Plugins: GrepConsole,Statistic,cn.yiiguxing.plugin.translate,com.chrisrm.idea.MaterialThemeUI,com.notime.intellijPlugin.backgroundImagePlus,com.wakatime.intellij.plugin,izhangzhihao.rainbow.brackets,mobi.hsz.idea.gitignore, net.vektah.codeglance, org.intellij.gitee Python Version：3.7（Anaconda3） Package： scrapy==2.0.1 二、详细步骤①准备工作 在Pycharm中新建一个Pure Python项目（记得要按照一中的要求配好Python环境）。 打开Pycharm的下方的终端（Terminal），当然这些也可以在系统终端里操作，不过可能需要的步骤多一些，还是直接在Pycharm里方便一些。 在终端里输入 1scrapy startproject myScrapy 本来是可以在我们刚刚创建的项目里新建一个名为“myScrapy”的scrapy项目的，但是不知道为什么竟然报错了： 这是什么奇奇怪怪的错误，我都没有“d:\\bld\\scrapy_1584555997548_h_env\\python.exe”这个目录，经过查找相关问题的资料，问题可能是出在Python环境上，因为我上一次新建项目时并没有报错，这一次我直接用的上一个项目的环境，网上还有一种说法是Scrapy的bug，详见 Fatal error launching scrapy&gt;1.6.0 from Anaconda Prompt Issue with conda-forge scrapy&gt;1.6.0 on Windows 目前找到了两种解决方案： 把python环境复制到报错的那个目录（d:\\bld\\scrapy_1584555997548_h_env\\python.exe），然后在创建scrapy项目，但这个解决方法有点愚蠢，就没有采用。 在scrapy命令前面添加“python -m”选项： 1python -m scrapy startproject myScrapy 就可以正常创建了。 关于Python的-m选项，官方给出的解释是“run library module as a script”，简单来说就是将库中的Python模块当作脚本去运行。 特别感谢简书的大佬ccw1078提供的解释，很清晰明了，有兴趣的可以去瞅一下，因为和本文的主题爬虫没啥关系，在这里就不赘述了。 出现这些提示就代表创建成功了。 然后在spiders文件里新建一个spider.py文件，用于写爬虫。 我们来看一下目前scrapy项目的目录结构。 __init__.py：pycharm生成的文件，简化导入语句用的，可以忽略，没啥用，建议删了，留着可能会出问题。 spiders：存放你Spider爬虫源文件 ​ spider.py：代码主要在这里写。 items.py：数据容器。 middlewares.py：Downloader Middlewares(下载器中间件)和Spider Middlewares(蜘蛛中间件)实现的地方。 pipelines.py：项目管道文件，相当于数据中转站。实现数据的清洗，储存，验证。 settings.py：scrapy的全局配置。 scrapy.cfg：配置文件。 scrapy已经帮我们把大体框架写好了，我们主要要修改的文件是spider.py，items.py，pipelines.py，settings.py。 这是爬虫spider的基本工作方式，想要深入了解的可以去网上查找资料。 ②开始写代码 先来写items.py。 123456789import scrapyclass MyscrapyItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() school = scrapy.Field() num = scrapy.Field() pass 再来搞settings.py，这个只需要找到这个注释掉的语句，把#去掉就OK了，就像这样： pipelines.py就很好写了，基本可以当模板来用。 12345678910111213141516171819import jsonclass MyscrapyPipeline(object): def open_spider(self, spider): try: # 这个就是爬虫生成的文件，可以支持好多种格式，这里使用的是json文件 self.file = open('MyData.json', 'w', encoding=\"utf-8\") except Exception as err: print(err) def process_item(self, item, spider): dict_item = dict(item) json_str = json.dumps(dict_item, ensure_ascii=False) + \"\\n\" self.file.write(json_str) return item def close_spider(self, spider): self.file.close() spider.py是我们主要写的核心部分。这里需要一些html的xpath相关知识来对项进行定位，可以自行查找相关资料。 12345678910111213141516171819202122232425262728293031323334353637383940414243\"\"\"@Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved.@Project: xuetangzaixian@Description: @Version: @Author: 苇名一心@Date: 2020-04-08 20:31@LastEditors: 苇名一心@LastEditTime: 2020-04-08 20:31\"\"\"import scrapyimport refrom myScrapy.myScrapy.items import MyscrapyItemclass mySpider(scrapy.spiders.Spider): # spider的名字 name = \"xuetang\" # 限制spider爬取的域名 allowed_domains = [\"www.xuetangx.com/\"] # 爬虫要爬取的网页，是一个列表，按顺序爬取 start_urls = [\"http://www.xuetangx.com/partners\"] # 这是一种方式，可以爬取网页中所有的项 # def parse(self, response): # item = MyscrapyItem() # for each in response.xpath(\"/html/body/article[1]/section/ul/*\"): # item['school'] = each.xpath(\"a/div[2]/h3/text()\").extract() # item['num'] = each.xpath(\"a/div[2]/p[1]/text()\").extract() # if item['num']: # item['num'] = re.findall(r'\\d+', item['num'][0]) # if item['school'] and item['num']: # yield (item) # 这是第二种方式，使用for循环，制定爬取项的数目 def parse(self, response): item = MyscrapyItem() for i in range(1, 144): item['school'] = response.xpath \\ (\"/html/body/article[1]/section/ul/li[&#123;&#125;]/a/div[2]/h3/text()\".format(i)).extract() item['num'] = response.xpath \\ (\"/html/body/article[1]/section/ul/li[&#123;&#125;]/a/div[2]/p[1]/text()\".format(i)).extract() # 判断爬取的项目是否为空，把非空的项目提交 if item['school'] and item['num']: yield (item) ③可以开始运行啦 在运行前要先在项目根目录下建立一个begin.py文件来控制scrapy爬虫的运行。 123from scrapy import cmdline# \"xuetang\"是我们上面spider.py中定义的爬虫名cmdline.execute(\"scrapy crawl xuetang\".split()) 最终的项目结构（__init__.py没啥用，删了）： 运行begin.py就可以开始爬虫了。 出现这些提示就表示成功了，运行完毕后会发现项目根目录出现了我们在pipelines.py中设置好的MyData.json。 打开MyData.json看一下，Perfect！ 有了这个json文件，我们就可以利用Python的pandas、numpy等工具进行各种处理，然后用matplotlib等模块进行画图了。 三、总结本文只是对Python的scrapy爬虫进行了简单的介绍和用一个小Demo讲述了如何使用scrapy爬取网页数据，希望对你有所帮助。 四、项目地址本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看：","categories":[{"name":"Python","slug":"Python","permalink":"https://666wxy666.github.io/categories/Python/"},{"name":"爬虫","slug":"Python/爬虫","permalink":"https://666wxy666.github.io/categories/Python/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://666wxy666.github.io/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://666wxy666.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"数据处理","slug":"数据处理","permalink":"https://666wxy666.github.io/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"学堂在线","slug":"学堂在线","permalink":"https://666wxy666.github.io/tags/%E5%AD%A6%E5%A0%82%E5%9C%A8%E7%BA%BF/"},{"name":"课程","slug":"课程","permalink":"https://666wxy666.github.io/tags/%E8%AF%BE%E7%A8%8B/"}]},{"title":"机器学习 实验 RNN 为baby起名字","slug":"机器学习-实验-RNN-为baby起名字","date":"2020-07-02T16:00:00.000Z","updated":"2020-09-02T02:07:10.419Z","comments":true,"path":"2020/07/03/机器学习-实验-RNN-为baby起名字/","link":"","permalink":"https://666wxy666.github.io/2020/07/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%AE%9E%E9%AA%8C-RNN-%E4%B8%BAbaby%E8%B5%B7%E5%90%8D%E5%AD%97/","excerpt":"本文是关于经典RNN的应用为baby起名字的代码实现。","text":"本文是关于经典RNN的应用为baby起名字的代码实现。 一、任务定义采用 RNN 为小 Baby 起个英文名字吧 神经网络语言模型，即通过神经网络，计算一项自然语言（例如一条句子）的出现概率，或者根据上文中的词推断句子中某个词的出现概率。例如，下图采用了一个具有一个输入层、一个隐藏层和一个输出层的 MLP 网络，建模三元文法模型： 本作业提供了8000多个英文名字，试训练一个环神经网络语言模型，进而给定若干个开始字母，由语言模型自动生成后续的字母，直到生成一个名字的结束符。从模型生成的名字中，挑选你最喜欢的一个，并采用一种可视化技术，绘制出模型为每个时刻预测的前5个最可能的候选字母。 事实上，你也可以给定结尾的若干个字母，或者随意给出中间的若干个字母，让 RNN 补全其它字母，从而得到一个完整的名字。因此，你也可以尝试设计并实现一个这样的 RNN 模型，从模型生成的名字中，挑选你最喜欢的一个，并采用可视化技术，绘制出模型为每个时刻预测的前5个最可能的候选字母。 二、输入输出1、输入 male和female数据集作为训练集。 【PS】注意，两个数据集的格式必须是一行一个英文名字，不能有其他文字说明，在使用前请先将male.txt和female.txt中的文字说明删除，例如： 超参数总迭代次数，打印精度（每隔多少次迭代打印一次损失日志），绘图精度（每隔多少次迭代求和取平均作为一个数据点）。 （类别，姓名的起始字母）对。 2、输出 RNN神经网络模型。 该模型的损失等日志信息。 该模型的损失-(迭代次数/画图精度)函数图像。 根据这个神经网络模型和输入的（类别，姓名的起始字母）对生成的姓名。 三、实验环境硬件： 处理器：Intel i7 7700HQ 显卡：NVIDIA GeForce GTX 1050 Ti 内存：16GB 软件： 编程语言： Python 3.7（Anaconda3） 模块： pytorch 1.5 numpy 1.18.1 matplotlib 3.1.3 编译器： PyCharm 2020.1.1 (Professional Edition)Build #PY-201.7223.92, built on April 30, 2020For educational use only.Runtime version: 11.0.6+8-b765.40 amd64VM: OpenJDK 64-Bit Server VM by JetBrains s.r.oWindows 10 10.0GC: ParNew, ConcurrentMarkSweepMemory: 725MCores: 8Registry: ide.balloon.shadow.size=0Non-Bundled Plugins: com.dubreuia, GrepConsole, Statistic, com.chrisrm.idea.MaterialThemeUI, org.intellij.gitee, com.mallowigi, com.wakatime.intellij.plugin, mobi.hsz.idea.gitignore, net.vektah.codeglance, tanvd.grazi, com.jetbrains.intellij.datalore, izhangzhihao.rainbow.brackets, cn.yiiguxing.plugin.translate, org.nik.presentation-assistant 四、方法描述1、数据集处理对老师的male.txt和female.txt数据集进行处理，保证每行只能由一个姓名，不得出现其他类似下图的说明信息。 我们将行分割成数组, 并把 Unicode 转换成 ASCII 编码, 最后放进一个字典里 {language: [names ...]} 2、创建网络输出设定为下一个字母的概率，采样测试的时候，概率最大的输出字母被当做下一个输入。 输出层采用softmax函数，为了让网络更加有效工作，添加了第二个线性层o2o（在合并了隐藏层和输出层的后面）。还有一个 Dropout 层，使输入的部分值以给定的概率值随机的变成 0（这里概率取0.1）, 为了模糊输入以防止过拟合，在网络的最末端使用它，从而故意添加一些混乱和增加采样的多样化。 3、训练前的准备首先读取文件，产生随机的（类别，文件行[也就是姓名]）对。对每一个时间点（也就是说在训练集中词的每个字母）网络的输入是（类别，当前字母，隐藏层状态），输出是（下一个字母，下一个隐藏层状态）。 因为在每一步，我们从当前的字母预测下一个字母，这样的字母对是在原有行中连续字母的集合，例如： 类别张量是一个大小为$1\\times{categories}$的one-hot tensor张量，在训练的每一个时间点把它提供给网络。 4、开始训练使用自动求导（autograd）辅助计算损失。循环调用train，每隔一段时间打印损失等Log，直到到达规定输入的迭代次数。在训练完成后绘制损失-(迭代次数/画图精度)函数图像折线图，用于性能评估分析。 5、测试采样输入（类别，姓名起始字母）对，返回生成的姓名。 五、结果分析与性能评价PS: []中的为每一次迭代的最可能的字母前五，如果为空，就是已经到达迭代终点。 下面是100000次迭代的测试采样结果，可以发现生成的姓名非常好，完全符合日常的姓名样式，RNN神经网络性能很好。 100次的因为迭代次数太少，网络非常不好，完全不能生成所需的姓名： 1000次还算可以接受： 如果是10000次迭代，基本能满足生成姓名的要求: 观察并对比不同迭代次数的损失-(迭代次数/画图精度)函数折线图可以看出迭代次数越多损失越小，性能越好，且一开始损失下降较快，当迭代次数大到一定程度后，损失下降较慢。 100次 1000次 10000次 100000次 查看并对比不同迭代次数的损失日志输出，很明显能发现最大的区别就是训练时间。可以看出迭代次数越多花费时间越多，所需的电脑性能显然也需要更高，100次和1000次由于网络不好，可以先排除在外。100000次迭代的所需时间是10min左右，而10000次迭代所需的时间为1min左右，相差10倍，如果迭代次数更多，可能相差更多，因此选择合适的迭代次数很重要，避免不必要的性能时间浪费。 100次 1000次 10000次 100000次 六、项目地址本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看： 七、附录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251\"\"\"@Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved.@Project: rnn-name@Description: 用RNN网络为baby起名字@Version: 1.0@Author: 苇名一心@Date: 2020-06-05 17:13@LastEditors: 苇名一心@LastEditTime: 2020-06-05 17:13\"\"\"from __future__ import unicode_literals, print_function, divisionimport globimport mathimport osimport randomimport stringimport timefrom io import openimport matplotlib.pyplot as pltimport torchimport torch.nn as nnimport unicodedata################################################## 全局参数#################################################all_letters = string.ascii_letters + \" .,;'-\"n_letters = len(all_letters) + 1criterion = nn.NLLLoss()learning_rate = 0.0005 # 学习率max_length = 20path = \"data/names/*.txt\"################################################## 数据集操作################################################## 将Unicode转为ASCII# https://stackoverflow.com/a/518232/2809427def Unicode_to_ASCII(s): return ''.join( c for c in unicodedata.normalize('NFD', s) if unicodedata.category(c) != 'Mn' and c in all_letters )# 将行分割成数组, 并把 Unicode 转换成 ASCII 编码, 最后放进一个字典里 &#123;category: [names ...]&#125;category_lines = &#123;&#125;all_categories = []for file_name in glob.glob(path): category = os.path.splitext(os.path.basename(file_name))[0] all_categories.append(category) line_list = open(file_name, encoding='utf-8').read().strip().split('\\n') lines = [Unicode_to_ASCII(line) for line in line_list] category_lines[category] = linescategory_num = len(all_categories)if category_num == 0: raise RuntimeError(\"未找到数据集！\")print(\"数据集类别：\", category_num, all_categories)################################################## 构建RNN网络#################################################class RNN(nn.Module): def __init__(self, input_size, hidden_size, output_size): super(RNN, self).__init__() self.hidden_size = hidden_size self.i2h = nn.Linear(category_num + input_size + hidden_size, hidden_size) self.i2o = nn.Linear(category_num + input_size + hidden_size, output_size) self.o2o = nn.Linear(hidden_size + output_size, output_size) self.dropout = nn.Dropout(0.1) self.softmax = nn.LogSoftmax(dim=1) def forward(self, category, input, hidden): input_combined = torch.cat((category, input, hidden), 1) hidden = self.i2h(input_combined) output = self.i2o(input_combined) output_combined = torch.cat((hidden, output), 1) output = self.o2o(output_combined) output = self.dropout(output) output = self.softmax(output) return output, hidden def init_hidden(self): return torch.zeros(1, self.hidden_size)################################################## 训练前的准备################################################## 输入串从第一个字母到最后一个字母（不包括 EOS ）的 one-hot 矩阵def generate_input_tensor(letters): tensor = torch.zeros(len(letters), 1, n_letters) for i in range(len(letters)): letter = letters[i] tensor[i][0][all_letters.find(letter)] = 1 return tensor# 目标的第k个字母到结尾（EOS）的 LongTensordef generate_target_Tensor(letters): letter_indexes = [all_letters.find(letters[i]) for i in range(1, len(letters))] letter_indexes.append(n_letters - 1) # EOS return torch.LongTensor(letter_indexes)# 类别的One-hot向量def generate_category_tensor(category): i = all_categories.index(category) tensor = torch.zeros(1, category_num) tensor[0][i] = 1 return tensor# 利用辅助函数从数据集中获取随机的category和linedef random_pair(): category = all_categories[random.randint(0, len(all_categories) - 1)] line = category_lines[category][random.randint(0, len(category_lines[category]) - 1)] return category, line# 从随机的（category, line）对中生成 category, input, 和 target Tensordef randomTrainingExample(): category, line = random_pair() category_tensor = generate_category_tensor(category) input_tensor = generate_input_tensor(line) target_tensor = generate_target_Tensor(line) return category_tensor, input_tensor, target_tensor################################################## 训练RNN网络#################################################def train(category_tensor, input_tensor, target_tensor): target_tensor.unsqueeze_(-1) hidden = rnn.init_hidden() rnn.zero_grad() loss = 0 for i in range(input_tensor.size(0)): output, hidden = rnn(category_tensor, input_tensor[i], hidden) l = criterion(output, target_tensor[i]) loss += l loss.backward() for p in rnn.parameters(): p.data.add_(p.grad.data, alpha=-learning_rate) return output, loss.item() / input_tensor.size(0)# 秒转时间戳def time_format(since): now = time.time() s = now - since m = math.floor(s / 60) s -= m * 60 return '%dm %ds' % (m, s)# 从一个类中获取一个以start_letters开头的名字def sample(category, start_letters='Al'): with torch.no_grad(): category_tensor = generate_category_tensor(category) input = generate_input_tensor(start_letters) hidden = rnn.init_hidden() output_name = start_letters for i in range(max_length): output, hidden = rnn(category_tensor, input[0], hidden) topv, topi_temp = output.topk(5) topi = topi_temp[0][0].item() if topi == n_letters - 1: break else: print(\"[\", end=\"\") for j in range(5): if j != 4: if topi_temp[0][j].item() &gt;= n_letters - 1: print(\" \", end=\",\") else: print(all_letters[topi_temp[0][j].item()], end=\",\") else: if topi_temp[0][j].item() &gt;= n_letters - 1: print(\" \", end=\"]\\n\") else: print(all_letters[topi_temp[0][j].item()], end=\"]\\n\") letter = all_letters[topi] output_name += letter input = generate_input_tensor(letter) print(output_name)################################################## 开始运行#################################################rnn = RNN(n_letters, 128, n_letters)all_losses = []total_loss = 0# 超参数参考值# n_its = 100000# print_every = 5000# plot_every = 500print(\"请分别输入总迭代次数,打印精度,绘图精度(按空格分隔): \", end=\"\")n_its, print_every, plot_every = map(int, input().split())print(\"开始训练......\")start = time.time()print(\"[时间戳]\\t\\t百分比\\t\\t已迭代数\\t\\t损失\")for it in range(1, n_its + 1): output, loss = train(*randomTrainingExample()) total_loss += loss if it % print_every == 0: print(\"[%10s] &lt;%3d%%&gt; %10d %.4f\" % (time_format(start), it / n_its * 100, it, loss)) if it % plot_every == 0: all_losses.append(total_loss / plot_every) total_loss = 0print(\"训练完成！\")# 画出损失图像print(\"绘制损失图像......\")plt.figure()plt.plot(all_losses)plt.show()# 生成测试print(\"请输入是否要进行网络采样测试(1,是;0,否): \", end=\"\")flag = int(input())while flag: print(\"请输入类别和姓名首字母(按空格分割,例: female Al): \", end=\"\") cat, letters = input().split() sample(cat, letters) print(\"要继续吗(1,继续;0,停止)？\", end=\"\") flag = int(input())","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://666wxy666.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"实验","slug":"机器学习/实验","permalink":"https://666wxy666.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://666wxy666.github.io/tags/Python/"},{"name":"机器学习","slug":"机器学习","permalink":"https://666wxy666.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"实验","slug":"实验","permalink":"https://666wxy666.github.io/tags/%E5%AE%9E%E9%AA%8C/"},{"name":"RNN","slug":"RNN","permalink":"https://666wxy666.github.io/tags/RNN/"},{"name":"起名字","slug":"起名字","permalink":"https://666wxy666.github.io/tags/%E8%B5%B7%E5%90%8D%E5%AD%97/"}]},{"title":"Linux 拓展学习","slug":"Linux-拓展学习","date":"2020-06-23T16:00:00.000Z","updated":"2020-09-02T02:01:39.322Z","comments":true,"path":"2020/06/24/Linux-拓展学习/","link":"","permalink":"https://666wxy666.github.io/2020/06/24/Linux-%E6%8B%93%E5%B1%95%E5%AD%A6%E4%B9%A0/","excerpt":"简单的写了一些Linux的课外拓展学习的相关知识和问题。","text":"简单的写了一些Linux的课外拓展学习的相关知识和问题。 一、命令的参数编写一个小程序，可以显示命令的选项和参数 1234567891011#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int i; for (i = 0; i &lt; argc; i++) &#123; printf(\"%d:%p [%s]\\n\", i, argv[i], argv[i]); &#125; return 0;&#125; 效果： 二、关于控制printf输出的颜色编写程序hello.c，编译和运行程序，得到类似以下结果： 可以通过 1\\033[ 来控制printf输出的颜色，格式为： 1printf(\"\\033[字背景颜色;字体颜色m 字符串 \\033[0m\" ); 注意，一定要在printf最后使用 1\\033[0m 来消除前面的作用，否则前面的设置对后面的printf都有效果。 ANSI控制码 效果 \\033[0m 关闭所有属性 \\033[1m 设置高亮度 \\033[4m 下划线 \\033[5m 闪烁 \\033[7m 反显 \\033[8m 消隐 \\033[30m —\\033[37m 设置前景色 \\033[40m—\\033[47m 设置背景色 \\033[nA 光标上移n行 \\03[nB 光标下移n行 \\033[nC 光标右移n行 \\033[nD 光标左移n行 字背景颜色范围: 40–49 字颜色范围: 30—39 字背景颜色代号 字背景颜色 字颜色代号 字颜色 40 黑 30 黑 41 红 31 红 42 绿 32 绿 43 黄 33 黄 44 蓝 34 蓝 45 紫 35 紫 46 青 36 青 47 白 37 白 小程序具体代码： 12345678910#define NONE \"\\e[0m\"#define RED \"\\e[0;31m\"#define CYAN \"\\e[0;36m\"#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; printf(RED \"Hello \" CYAN \"World!\\n\" NONE); printf(\"\\e[0;31mHello \\e[0;36mWorld!\\n\\e[0m\"); return 0;&#125; 在这里\\e和\\033是一个意思，e的八进制代码就是033，这两个print其实效果是一样的，前面那个printf中多个连续的“xxx”字符串会被自动整合为一个字符串，其实最终执行的就是第二个printf。 效果： 三、关于Linux中bash的变量、替换和元字符要求只列出所有bash进程的状态，使用命令 1ps -ef | grep bash 但grep进程自身也被输出了： 使用以下的命令： 12345ps -ef | grep [b]ashps -ef | grep \\\\bashps -ef | grep b\\\\ashps -ef | grep b\\ashps -ef | grep ba\\\\sh 可以 上面这5个命令的核心目的其实是改变grep在 1ps -ef 命令中的显示形式，例如这一个，我们使用三通（tee）命令将在grep命令过滤之前的输出定向到一个文件中。 先将原命令试一下： 12ps -ef | tee 1.txt | grep bashcat 1.txt 与1这个命令进行一下对比： 12ps -ef | tee 1.txt | grep [b]ashcat 1.txt 我们可以很明显的看到，grep命令确实改变了，因为正则表达式 1[b]ash 是可以匹配bash的，但是却不能匹配[b]ash，因此第一行的-bash这一行被取了出来，而最后grep这一行，由于不匹配[b]ash，就取不出来了，刚好实现了我们只列出所有bash进程的状态的目的，下面的几个命令大同小异。 不可以 12ps -ef | tee 1.txt | grep \\\\bashcat 1.txt 首先，\\是Shell的元字符，先被\\转义为真正的单个字符\\，因此传给grep的正则表达式其实是\\bash，而在正则表达式中，\\b有特殊含义，是单词边界，因此就连bash和\\bash全部都没有匹配到。 可以 12ps -ef | tee 1.txt | grep b\\\\ashcat 1.txt 和2一样，传给grep的正则表达式为b\\ash，在正则表达式中\\a是没有意义的，因此\\被丢弃，正则表达式其实就是bash，所以第一行的-bash这一行被取了出来，而最后grep这一行，由于不匹配b\\ash，就取不出来了。 不可以 12ps -ef | tee 1.txt | grep b\\ashcat 1.txt 首先，\\a先经过Shell的替换，因\\a是没有特殊含义的，因此\\被直接丢掉，传给grep的正则表达式为bash，这就和使用这个命令是一样的： 1ps -ef | grep bash 显然是不能实现目的。 不可以 12ps -ef | tee 1.txt | grep ba\\\\shcat 1.txt 这个和2基本是一样的，和3唯一的区别就是，第3个中\\a对正则表达式而言是没有特殊含义的，但是\\s对正则表达式而言是有特殊含义的，\\s代表空白字符（可能是空格、制表符、其他空白），也就是说，grep匹配到的应该是类似于： 1ba h 这种的字符串，显然-bash和ba\\sh都不符合，因此就什么都没取到。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/categories/Linux/"},{"name":"拓展学习","slug":"Linux/拓展学习","permalink":"https://666wxy666.github.io/categories/Linux/%E6%8B%93%E5%B1%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/tags/Linux/"},{"name":"C","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"难点","slug":"难点","permalink":"https://666wxy666.github.io/tags/%E9%9A%BE%E7%82%B9/"},{"name":"Shell","slug":"Shell","permalink":"https://666wxy666.github.io/tags/Shell/"},{"name":"拓展","slug":"拓展","permalink":"https://666wxy666.github.io/tags/%E6%8B%93%E5%B1%95/"}]},{"title":"Linux MOOC习题 11~15章","slug":"Linux-MOOC习题-11~15章","date":"2020-06-19T16:00:00.000Z","updated":"2020-09-02T01:58:23.943Z","comments":true,"path":"2020/06/20/Linux-MOOC习题-11~15章/","link":"","permalink":"https://666wxy666.github.io/2020/06/20/Linux-MOOC%E4%B9%A0%E9%A2%98-11~15%E7%AB%A0/","excerpt":"自己随便整理了一下在学习Linux网课时遇到的一些习题，易错点之类的，接上文Linux MOOC习题 6~10章。","text":"自己随便整理了一下在学习Linux网课时遇到的一些习题，易错点之类的，接上文Linux MOOC习题 6~10章。 十一、进程的基本概念 int a[N] = { 2 };的意思是把a[N]第一个元素赋值为2，其他的赋值为0，也就是说，所有的元素都被赋值了，因此占空间很大。 int a[N];的a[N]没有赋初值，只需记录a的长度即可，占用空间很小。 从图中（test是第一种赋值的，test2是第二种不赋值的）也可以看出，差别巨大： 忙等待主要是占用CPU，和内存没啥关系。 十二、进程的创建和重定向 注意，这个程序是持续不间断运行的，也就是说，不能停止后再重启，但是重定向是只能在程序运行的时候进行的操作，程序一旦开始运行就没办法重定向了，因此不能实现。并且重定向是“当前进程”做的，不是父进程做的。但是如果foo可以终止后重启，确实可以用shell脚本等程序实现上述功能。修改foo程序也可以实现上述功能。 执行的大致流程，只是各进程执行情况，并不代表真实执行顺序： 父进程（0）： 输出：i=0 父进程0产生第一个子进程0-1 0-1： 到下一轮for循环，i=1 输出：i=1 子进程0-1产生第一个子进程0-1-1 0-1-1： 到下一轮for循环，i=2 输出：i=2 进程0-1-1产生第一个子进程0-1-1-1 0-1-1-1： 到下一轮for循环，i=3 输出：i=3 进程0-1-1-1产生第一个子进程0-1-1-1-1 0-1-1-1-1： 到下一轮for循环，i=4 0-1-1-1-1结束 到下一轮for循环，i=4 0-1-1-1结束 到下一轮for循环，i=3 输出：i=3 进程0-1-1产生第二个子进程0-1-1-2 0-1-1-2： 到下一轮for循环，i=4 0-1-1-2结束 到下一轮for循环，i=4 0-1-1结束 到下一轮for循环，i=2 输出：i=2 子进程0-1产生第二个子进程0-1-2 0-1-2： 到下一轮for循环，i=3 输出：i=3 进程0-1-2产生第一个子进程0-1-2-1 0-1-2-1： 到下一轮for循环，i=4 0-1-2-1结束 到下一轮for循环，i=4 0-1-2结束 到下一轮for循环，i=3 输出：i=3 子进程0-1产生第三个子进程0-1-3 0-1-3： 到下一轮for循环，i=4 0-1-3结束 到下一轮for循环，i=4 0-1结束 到下一轮for循环，i=1 输出：i=1 父进程0产生第二个子进程0-2 0-2： 到下一轮for循环，i=2 输出：i=2 进程0-2产生第一个子进程0-2-1 0-2-1： 到下一轮for循环，i=3 输出：i=3 进程0-2-1产生第一个子进程0-2-1-1 0-2-1-1： 到下一轮for循环，i=4 0-2-1-1结束 到下一轮for循环，i=4 0-2-1结束 到下一轮for循环，i=3 输出：i=3 进程0-2产生第二个子进程0-2-2 0-2-2： 到下一轮for循环，i=4 0-2-2结束 到下一轮for循环，i=4 0-2结束 到下一轮for循环，i=2 输出：i=2 父进程0产生第三个子进程0-3 0-3： 到下一轮for循环，i=3 输出：i=3 进程0-3产生第一个子进程0-3-1 0-3-1： 到下一轮for循环，i=4 0-3-1结束 到下一轮for循环，i=4 0-3结束 到下一轮for循环，i=3 输出：i=3 父进程0产生第四个子进程0-4 0-4： 到下一轮for循环，i=4 0-4结束 到下一轮for循环，i=4 父进程0结束 共15行输出，分别为： 输出 次数 i=0 $2^0=1$ i=1 $2^1=2$ i=2 $2^2=4$ i=3 $2^3=8$ 在linux下的实际执行情况： 可以发现确实是15行，但是却有两个问题： 为什么最后产生了一个空行，在等待用户输入？ shell提示符其实是主进程死了以后，shell给出来的。因为实际运行结果是子进程死得晚，父进程死的早。其实，你不按回车，大家也都运行结束了，只是shell提示符出现得比某个子进程早。你看起来这个效果，其实这个提示符已经在上面显示了，那个时候主进程结束，shell给出了提示符，但此时子进程还没有结束，因此会继续输出，但这个时候shell已经进入了等待下一个命令的状态了，就像这样： ​ 可以发现，echo命令已经可以被shell接受了。 程序为什么分两部分输出了？ 这是因为后面的子进程因为他的父进程先死掉了，变成了孤儿进程，打印出他们的父进程pid，发现是1，也证明了这一点： 因此我们可以对程序进行如下修改： 1234567891011121314151617181920212223242526/* * @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. * @Description: * @Version: * @Author: 苇名一心 * @Date: 2020-05-11 20:02:00 * @LastEditors: 苇名一心 * @LastEditTime: 2020-05-14 11:18:43 */#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;unistd.h&gt;int main(int argc, char const *argv[])&#123; int i,status,wait_pid; for (i = 0; i &lt; 4; i++) &#123; printf(\"i=%d,pid=%d,ppid=%d\\n\", i,getpid(),getppid()); if(fork()&gt;0) &#123; wait_pid = wait(&amp;status); &#125; &#125; return 0;&#125; 对每个fork加上wait语句，就可以完全按照上面的进程树执行顺序执行，且不会有任何问题了。 PS：对于wait，如果其所有子进程都还在运行，则阻塞；如果是一部分子进程终止，而另一部分还在运行，那么父进程还会阻塞吗？答案是不会，只要有一个进程终止，wait就会返回。也就是说只要wait接收到一个SIGCHLD信号，wait()就会返回。对于两个或多个子进程的情况，需要调用wait两次或多次。说白了在每一个fork后面的父进程分支中都要有一个wait与之对应。与wait相关的详细知识请参照这位兄弟的博客：wait()函数的详细分析。 十三、重定向和管道，信号 xsh2.c是一个简易的模拟shell程序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* * @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. * @Description: * @Version: * @Author: 苇名一心 * @Date: 2020-05-21 09:44:26 * @LastEditors: 苇名一心 * @LastEditTime: 2020-05-21 09:51:41 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char const *argv[])&#123; char buf[256], *argv1[256], **p, *cmd2, *argv2[256]; int sv, fd[2]; for (;;) &#123; printf(\"=&gt; \"); if (fgets(buf, sizeof(buf), stdin) == NULL) exit(0); if ((cmd2 = strstr(buf, \"|\")) == NULL) exit(0); *cmd2++ = '\\0'; for (p = &amp;argv1[0], *p = strtok(buf, \" \\t\\n\"); *p != NULL; *++p = strtok(NULL, \" \\t\\n\")) ; for (p = &amp;argv2[0], *p = strtok(cmd2, \" \\t\\n\"); *p != NULL; *++p = strtok(NULL, \" \\t\\n\")) ; if (argv1[0] == NULL || argv2[0] == NULL) exit(0); pipe(fd); if (fork() == 0)// | 左边的写端进程 &#123; dup2(fd[1], 1); close(fd[1]); close(fd[0]); execvp(argv1[0], argv1); fprintf(stderr, \"** bad command 1: %m\\n\"); exit(1); &#125; else if (fork() == 0)// | 右边的读端进程 &#123; dup2(fd[0], 0); close(fd[0]); close(fd[1]);// 和第二题的类似，也不能省略 execvp(argv2[0], argv2); fprintf(stderr, \"** bad command 2: %m\\n\"); exit(1); &#125; close(fd[0]);// 第一题要省略的操作 close(fd[1]);// 第二题要省略的操作 wait(&amp;sv); wait(&amp;sv); &#125; return 0;&#125; 如果省略了这一条，对程序执行是没有什么影响的，但是循环多次以后，文件描述符一直不会被回收，导致资源耗尽，程序无法正常运行。 如果省略了这一条，就会产生重大问题。在写端进程写入结束后正常退出，读端在读取管道时，因为有个写入端一直没有关闭，导致读端的管道一直收不到结束信号，一直在等待读取，导致了死锁，读端程序不能正常结束。 goto只能在函数内跳转，全局跳转则可以跳转到保存的程序运行状态（包括堆栈等），就可以理解为玩游戏的SavePoint。但是如果你没保存，那就没法跳转，因此全局跳转只能跳转到执行过的位置。但是这个题目是有点问题的，goto语句也可以向前和向后跳转，因此此题可以忽略。 十四、进程间协作，Socket概述 也就是说，mmap()需要一个已经打开的文件的文件描述符，当然需要open()打开文件，至于为什么需要，解析说的很明白。 如果你打开的文件不关闭，你的程序一直执行，一直打开文件，打开的太多就会导致文件描述符资源耗尽，无法打开文件，但是当你程序退出时（正常退出或者异常终止），操作系统都会自动检测你已经打开的文件，自行关闭应该关闭的文件，因此也能正常持久化到磁盘文件。 咨询式锁定是很关键的，也就是你不自己调用fcntl()，你是不会被阻塞的，也就是说Linux给你提供了互斥访问的途径，你自己不用或者使用不当，还是会导致出现问题，这也是Linux“策略和机制相分离”的设计方法。它是一个重要的设计思路，当系统不能大包大揽时，系统提供“机制”，把“策略”留给程序员，简化了操作系统的设计，程序员正确操作，应该完成的功能也都能实现。这是一个典型的合理的“甩锅”行为。因特网和Linux设计上都遵循了这样的理念。SUID，bash中的条件判断，四则运算，都是相同的理念，它们简化了自己，仅提供“机制”，把“策略”留给应用程序，不失必备功能。C语言也一样，printf在C语言里也会是个函数，与语言本身无关，C语言自己设计得很简单，以至于常用C语言的程序员，不需要查阅任何手册，都能把语法记下来。C++，你试试？ 注意是以命令行参数方式传递，exec()虽然会清空原来的代码段，但是对文件描述符和信号的处理有所不同。 关于fork()和exec()父子进程对文件描述符和信号的继承问题总结如下： 信号 仅fork时子进程会继承父进程fork之前所设置的信号处理方式。 当有exec加载新程序时 子进程继承的处理方式是忽略或默认处理方式时，exec新程序后设置依然有效。 如果子进程继承是捕获处理方式时，exec新程序后将被还原为默认处理方式。 文件描述符 当你用fork建立一个子进程，父进程的所有内容会被“完完整整”的复制到子进程中。子进程是父进程的一个clone体，除了pid不同，其余一切相同。在fork后父、子进程对于每一个打开的文件描述符共享同一个文件表项，此时可能有多个文件描述符项指向同一文件表项。即使exec也会保留文件描述符，但是有时子进程不需要继承父进程的文件描述符，并且有时在exec后子进程继承下来的文件描述符有的是毫无意义的，Linux使用close_on_exec标志位来实现。当父进程打开文件时，只需要应用程序设置FD_CLOSEXEC标志位，则当fork后exec其他程序的时候，内核自动会将其继承的父进程FD关闭。因此原则上只要你不设置这个标志位，你fork子进程后，exec新程序依然可以用你在父进程或者原来的子进程中打开的文件。 十五、Socket编程 bind设置本地端点名，也可以用在客户端程序，不会阻塞； listen仅仅是给内核一个通知，开始监听到达的连接请求，不会阻塞； connect建立连接，设定远端端点名，进程阻塞，直到TCP连接建立（第二次握手）； accept接受一个连接请求，阻塞等待新连接的到来，直到TCP三次握手结束返回； 不执行signal(SIGCLD,SIG_ING)会产生僵尸进程。 所有的习题： Linux MOOC习题 1~5章Linux MOOC习题 6~10章Linux MOOC习题 11~15章","categories":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/categories/Linux/"},{"name":"习题","slug":"Linux/习题","permalink":"https://666wxy666.github.io/categories/Linux/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/tags/Linux/"},{"name":"习题","slug":"习题","permalink":"https://666wxy666.github.io/tags/%E4%B9%A0%E9%A2%98/"},{"name":"易错点","slug":"易错点","permalink":"https://666wxy666.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"网课","slug":"网课","permalink":"https://666wxy666.github.io/tags/%E7%BD%91%E8%AF%BE/"},{"name":"MOOC","slug":"MOOC","permalink":"https://666wxy666.github.io/tags/MOOC/"}]},{"title":"现代交换原理 MOOC习题 5~6章","slug":"现代交换原理-MOOC习题-5~6章","date":"2020-06-19T16:00:00.000Z","updated":"2020-09-02T02:08:03.112Z","comments":true,"path":"2020/06/20/现代交换原理-MOOC习题-5~6章/","link":"","permalink":"https://666wxy666.github.io/2020/06/20/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86-MOOC%E4%B9%A0%E9%A2%98-5~6%E7%AB%A0/","excerpt":"自己随便整理了一下在学习“现代交换原理”网课时遇到的一些习题，易错点之类的。接上一部分现代交换原理 MOOC习题 1~4章。","text":"自己随便整理了一下在学习“现代交换原理”网课时遇到的一些习题，易错点之类的。接上一部分现代交换原理 MOOC习题 1~4章。 第五章 信令与协议 通话所需的媒体资源可以理解为控制呼叫的接续和拆线和通信网管理和维护的信息资源。 通信网中为用户建立连接和拆除连接，需要网中各个相关设备协调工作，为此在各个设备间传输的控制信号和规约称为信令。 路由标记供MTP3级进行消息寻址和路由，而MTP3的路由标记是由信令点编码实现的。 电信网（现代通信网）的三大支撑网络：同步网，管理网，信令网。 SIP与普通电话用户进行通话时要进行协议转换，SIP-&gt;七号信令。SIP协议中SDP的媒体端口号由网关（中继网关）保存。中继网关是分组网和电路网边界设备，实现不同媒体协议的转换。 注意中继网关（Trunk Gateway）跟代理服务器（Proxy Server）不是一个东西。 中继网关也叫落地设备，简称TG。用于VOIP网络电话系统或呼叫中心、软交换等，将模拟信号与数字信号相互转换。是voip解决方案的重要组成部分，它位于NGN网络的边缘接入层，连接PSTN和voip网络，实现IP包转TDM的功能。 承载着IP域与电路域的语音汇接任务。 常识问题。 显然错误，MTP1的通路也要经过TST交换网络。 错误，不多解释。 模拟用户信令：主要包括用户向交换机发送的监视信令和选择信令，交换机向用户发送的铃流和忙音等音信号。**用于PSTN**。 状态信令：用户线的忙闲状态，如主、被叫的摘、挂机状态； 地址信令：主叫所拨的被叫号码，直流脉冲或双音频； 铃流和信号音：交换机向用户发送的信号。振铃信号、信号音、来电显示的FSK信号； 数字用户信令：通过消息的形式传送以上信息，**用于ISDN用户**。例如：DSS1 30B+D 在用户线上传输的信令叫用户线信令，No.7信令是专为电话局之间交互控制信息而设计的，所以是局间信令，也就是在中继线上交互的信令，以数字信号方式传送。它跟能否携带电话号码没关系。 第六章 移动交换 MSC是移动交换中心，主要功能有： 信道的管理和分配； 呼叫的处理和控制； 用户位置信息的登记与管理； 越区切换和漫游的控制； 号码的登记和管理； 服务类型的鉴权； 用户的鉴权； 提供链路接口； 相关签约信息及4G位置信息不是存在MME中，而是HSS。 所有的习题： 现代交换原理 MOOC习题 1~4章现代交换原理 MOOC习题 5~6章","categories":[{"name":"现代交换原理","slug":"现代交换原理","permalink":"https://666wxy666.github.io/categories/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"},{"name":"习题","slug":"现代交换原理/习题","permalink":"https://666wxy666.github.io/categories/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"习题","slug":"习题","permalink":"https://666wxy666.github.io/tags/%E4%B9%A0%E9%A2%98/"},{"name":"易错点","slug":"易错点","permalink":"https://666wxy666.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"网课","slug":"网课","permalink":"https://666wxy666.github.io/tags/%E7%BD%91%E8%AF%BE/"},{"name":"MOOC","slug":"MOOC","permalink":"https://666wxy666.github.io/tags/MOOC/"},{"name":"现代交换原理","slug":"现代交换原理","permalink":"https://666wxy666.github.io/tags/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"}]},{"title":"大数据 习题","slug":"大数据-习题","date":"2020-06-17T16:00:00.000Z","updated":"2020-09-02T02:05:35.690Z","comments":true,"path":"2020/06/18/大数据-习题/","link":"","permalink":"https://666wxy666.github.io/2020/06/18/%E5%A4%A7%E6%95%B0%E6%8D%AE-%E4%B9%A0%E9%A2%98/","excerpt":"自己随便整理了一下在学习“大数据”时遇到的一些习题，易错点之类的。","text":"自己随便整理了一下在学习“大数据”时遇到的一些习题，易错点之类的。 1、关于Spark中task，block，partition，split，core的关系 每一个过程的任务数，对应一个inputSplit, Partition输入可能以多个文件的形式存储在HDFS上，每个File都包含了很多块，称为Block。 当Spark读取这些文件作为输入时，会根据具体数据格式对应的InputFormat进行解析，一般是将若干个Block合并成一个输入分片，称为InputSplit，注意InputSplit不能跨越文件。 随后将为这些输入分片生成具体的Task。InputSplit与Task是一一对应的关系。随后这些具体的Task每个都会被分配到集群上的某个节点的某个Executor去执行。 每个节点可以起一个或多个Executor。 每个Executor由若干core组成，每个Executor的每个core一次只能执行一个Task。 注意： 这里的core是虚拟的core而不是机器的物理CPU核，可以理解为就是Executor的一个工作线程。 每个Task执行的结果就是生成了目标RDD的一个partiton。 Task被执行的并发度 = Executor数目$\\times$每个Executor核数（=core总个数） 至于partition的数目： 对于数据读入阶段，例如sc.textFile，输入文件被划分为多少InputSplit就会需要多少初始Task。 在Map阶段partition数目保持不变。 在Reduce阶段，RDD的聚合会触发shuffle操作，聚合后的RDD的partition数目跟具体操作有关，例如repartition操作会聚合成指定分区数，还有一些算子是可配置的。 RDD在计算的时候，每个分区都会起一个task，所以rdd的分区数目决定了总的task数目。申请的计算节点（Executor）数目和每个计算节点核数，决定了你同一时刻可以并行执行的task。比如：RDD有100个分区，那么计算的时候就会生成100个task，你的资源配置为10个计算节点，每个2个核，同一时刻可以并行的task数目为20，计算这个RDD就需要5个轮次。如果计算资源不变，你有101个task的话，就需要6个轮次，在最后一轮中，只有一个task在执行，其余核都在空转。如果资源不变，你的RDD只有2个分区，那么同一时刻只有2个task运行，其余18个核空转，造成资源浪费。这就是在spark调优中，增大RDD分区数目，增大任务并行度的原因。 2、HDFS体系架构HDFS采用了主从（Master/Slave）结构 模型，一个HDFS集群是由一个 NameNode和若干个 DataNode 组成的。其中 NameNode 作为主服务器，管理文件系统的命名空间和客户端对文件的 访问操作；集群中的 DataNode 管理存储的数据。HDFS 允许用户以文件的形 式存储数据。从内部来看，文件被分成 若干个数据块，而且这若干个数据块存 放在一组 DataNode 上。NameNode 执行文件系统的命名空间操作，比如打开、关闭、重命名文件或目录等，它也负责数据块到具体 DataNode 的映射。 DataNode 负责处理文件系统客户端的文件读写请求，并在 NameNode 的统 一调度下进行数据块的创建、删除和复制工作。 3、HDFS的读操作流程 初始化FileSystem，然后客户端用函数 open()打开文件。 FileSystem调用元数据节点，得到数据 块信息，并对每一个数据块、元数据节点返回，保存数据块的数据节点地址。 客户端调用Stream的read()函数开始读 取数据。 FSDataInputStream连接保存此文件第 一个数据块的最近的数据节点Datanode， data从数据节点读到客户端。 当第一个数据块读取完毕时， FSDataInputStream关闭和此数据节点的 连接，然后连接此文件下一个数据块的 最近的数据节点。 当客户端读取完毕数据的时候，调用 FSDataInputStream的close()函数，关闭连接。 4、HDFS的写操作流程 5、习题","categories":[{"name":"大数据","slug":"大数据","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"习题","slug":"大数据/习题","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"习题","slug":"习题","permalink":"https://666wxy666.github.io/tags/%E4%B9%A0%E9%A2%98/"},{"name":"易错点","slug":"易错点","permalink":"https://666wxy666.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"大数据","slug":"大数据","permalink":"https://666wxy666.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Spark","slug":"Spark","permalink":"https://666wxy666.github.io/tags/Spark/"},{"name":"HDFS","slug":"HDFS","permalink":"https://666wxy666.github.io/tags/HDFS/"},{"name":"MapReduce","slug":"MapReduce","permalink":"https://666wxy666.github.io/tags/MapReduce/"}]},{"title":"机器学习 实验 DNN 手写识别","slug":"机器学习-实验-DNN-手写识别","date":"2020-06-10T16:00:00.000Z","updated":"2020-09-02T02:06:57.356Z","comments":true,"path":"2020/06/11/机器学习-实验-DNN-手写识别/","link":"","permalink":"https://666wxy666.github.io/2020/06/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%AE%9E%E9%AA%8C-DNN-%E6%89%8B%E5%86%99%E8%AF%86%E5%88%AB/","excerpt":"本文是关于经典深度神经网络DNN的应用手写识别的思路样例。","text":"本文是关于经典深度神经网络DNN的应用手写识别的思路样例。 一、题目请描述一个深度神经网络模型解决实际问题的例子。 包括问题描述，输入输出数据，训练、测试数据集，深度网络模型结构图，损失函数，训练方法，以及其他需要说明的内容。 二、问题描述下面将描述一个深度神经网络的典型经典例子：手写数字识别（OCR）。 ⼈类视觉系统是世界上众多奇迹之一。下面的手写数字序列： 大多数人毫不费力就能够认出这些数字为 504192。识别手写数字不是一件简单的事。尽管⼈类在理解我们眼睛展示出来的信息上非常擅长，但如果你尝试写出计算机程序来识别诸如上面的数字，就会明显感受到视觉模式识别的困难。看起来人类一下子就能完成的任务变得特别困难。关于我们识别形状——“9 顶上有一个圈，右下方则是一条竖线”这样的简单直觉——实际上算法上就很难轻易表达出来了。而在你试着让这些识别规则越发精准时，就会很快陷入各种混乱的异常或者特殊情形的困境中。实现一个可以识别手写数字的神经网络。这个神经网络不需要人类帮助便可以超过 96% 的准确率识别数字。实际上，最优的商业神经网络已经足够好到被银行和邮局分别用在账单核查和识别地址上了。 二、输入输出数据 1、输入数据一系列手写的数字，例如： 2、输出数据识别出的数字：504192 三、训练、测试数据集使用经典的MNIST 数据集作为数据源。MNIST 数据分为两个部分。第一部分包含 60,000 幅用于训练数据的图像。这些图像扫描⾃250 ⼈的手写样本。这些图像是28 × 28 ⼤小的灰度图像。第二部分是 10,000 幅用于测试数据的图像，同样是 28 × 28 的灰度图像。 训练集测试集样例 四、深度网络模型结构图我们可以把识别手写数字的问题分成两个子问题。首先，我们希望有个方式把包含许多数字的图像分成一系列单独的图像，每个包含单个数字。例如，我们想要把图像 分成六个单独的图像 一旦图像被分割，那么程序需要把每个单独的数字分类。例如，我们想要我们的程序能识别上面的第一个数字是 5。 有很多途径可以解决分割的问题。一种方法是尝试不同比分割方式，用数字分类器对每一个切分片段打分。如果数字分类器对每一个片段的置信度都较高，那么这个分割方式就能得到较高的分数；如果数字分类器在一或多个片段中出现问题，那么这种分割方式就会得到较低的分数。这种方法的思想是，如果分类器有问题，那么很可能是由于图像分割出错导致的。这种思想以及它的变化形式能够比较好地解决分割问题。因此，与其关心分割问题，我们不如把精力集中在解决第二个问题即分类单独的数字。 我们可以使用一个三层神经网络来识别单个数字： 标准的DNN的模型结构： 网络的输入层包含给输入像素的值进行编码的神经元。我们给网络的训练数据会有很多扫描得到的 28 × 28 的手写数字的图像组成，所有输入层包含有 784 = 28 × 28个神经元。为了简化，上图中我已经忽略了 784 中⼤部分的输入神经元。输入像素是灰度级的，值为 0.0 表示白色，值为 1.0 表示黑色，中间数值表示逐渐暗淡的灰色。 网络的中间层是隐藏层。我们用 n 来表示神经元的数量，我们将给 n 实验不同的数值。示例中用一个小的隐藏层来说明，仅仅包含 n = 15 个神经元。 网络的输出层包含有 10 个神经元。如果第一个神经元激活，即输出$\\approx1$，那么表明网络认为数字是一个 0。如果第二个神经元激活，就表明网络认为数字是一个 1。依此类推。更确切地说，我们把输出神经元的输出赋予编号 0 到 9，并计算出那个神经元有最高的激活值。比如，如果编号为 6 的神经元激活，那么我们的网络会猜到输入的数字是 6。其它神经元相同。 这里使用 10 个输出神经元，因为任务是能让神经网络告诉我们哪个数字（0, 1, 2, . . . , 9 ）能和输入图片匹配，但是使用 4 个输出神经元，即把每一个当做一个二进制值，结果取决于它的输出更靠近 0 还是 1 。四个神经元足够编码这个问题了，因为 24 = 16 ⼤于 10 种可能的输入。但是10 个输出神经元的神经网络比 4 个的识别效果更好。 在上述的三层神经网络加一个额外的一层就可以实现按位表示数字。额外的一层把原来的输出层转化为一个二进制表示： 将上述网络详细展开来说，我们可以选择两个大小为100的隐层和一个大小为10的输出层，因为MNIST数据集是手写0到9的灰度图像，类别有10个，所以最后的输出大小是10。隐层的激活函数可以使用ReLU，最后输出层的激活函数是Softmax，所以最后的输出层相当于一个分类器。加上一个输入层的话，多层感知器的结构是：输入层–&gt;隐层–&gt;隐层–&gt;输出层。 五、损失函及训练方法我们使用DNN反向传播算法和梯度下降算法进行学习训练。我们将用符号$x$来表示一个训练输入。为了方便，把每个训练输入$x$看作一个表示$28\\times28=784$维的向量。每个向量中的项目代表图像中单个像素的灰度值。我们用$y=y(x)$表示对应的期望输出，这里$y$是一个 10 维的向量。例如，如果有一个特定的画成6的训练图像$x$，那么$y(x) = (0, 0, 0, 0, 0, 0, 1, 0, 0, 0)^T$则是网络的期望输出。 我们希望有一个算法，能让我们找到权重和偏置，以⾄于网络的输出$y(x)$能够拟合所有的训练输入$x$。为了量化我们如何实现这个目标，我们定义一个代价损失函数：$$C(w,b)\\equiv{\\frac{1}{2n}}\\sum_x||y(x)-a||^2$$这里$w$表示所有的网络中权重的集合，$b$是所有的偏置，$n$是训练输入数据的个数，$a$是表示当输入为 $x$时输出的向量，输出$a$取决于$x$，$w$和$b$，求和则是在总的训练输入$x$上进行的。符号$||v||$是指向量 v 的模。我们的训练算法的目的是最小化权重和偏置的代价函数$C(w,b)$。换句话说，我们想要找到一系列能让代价尽可能小的权重和偏置。 也可以使用的是交叉熵损失函数，该函数在分类任务上比较常用。定义了一个损失函数之后，还有对它求平均值，训练程序必须返回平均损失作为第一个返回值，因为它会被后面反向传播算法所用到。同时我们还可以定义一个准确率函数，这个可以在我们训练的时候输出分类的准确率。$$H(p,q)=-\\sum_{i=1}^{n}p(x_i)\\log(q(x_i))$$ 梯度下降算法的基本步骤： 六、总结上述神经网络在测试集的准确度能达到95%左右，非常准确。 相较于SVM，准确度和性能均有较大提升。 深度神经网络（Deep Neural Networks，DNN）是一个非常有前景和创新的研究方向。除了手写识别（OCR），还有各个行业的经典样例，比如：图像方面的黑白照片变彩色照片的图像着色（LetThereBeColor）、图像风格化，将一幅图像的内容与另一幅图像的风格相结合（neural-style）、通过深度学习极大提高模糊图片的分辨率（srez）、实时捕获面部表情，调换到另外一个人的面部（Face2Face）、雅虎出品的成人图片分类器（open_nsfw）、成人视频分类器（Miles Deep）等等，就不一一列举了。总之深度神经网络和深度学习给出了在图像识别、语音识别和自然语言处理领域中众多问题的最好解决方案，重要性不言而喻。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://666wxy666.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"实验","slug":"机器学习/实验","permalink":"https://666wxy666.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://666wxy666.github.io/tags/Python/"},{"name":"机器学习","slug":"机器学习","permalink":"https://666wxy666.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"实验","slug":"实验","permalink":"https://666wxy666.github.io/tags/%E5%AE%9E%E9%AA%8C/"},{"name":"DNN","slug":"DNN","permalink":"https://666wxy666.github.io/tags/DNN/"},{"name":"手写识别","slug":"手写识别","permalink":"https://666wxy666.github.io/tags/%E6%89%8B%E5%86%99%E8%AF%86%E5%88%AB/"}]},{"title":"大数据实战 Python可视化 Matplotlib可视化","slug":"大数据实战-Python可视化-Matplotlib可视化","date":"2020-06-09T16:00:00.000Z","updated":"2020-09-02T02:04:55.801Z","comments":true,"path":"2020/06/10/大数据实战-Python可视化-Matplotlib可视化/","link":"","permalink":"https://666wxy666.github.io/2020/06/10/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%88%98-Python%E5%8F%AF%E8%A7%86%E5%8C%96-Matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96/","excerpt":"本文是关于大数据通过Python的Matplotlib实现数据可视化。","text":"本文是关于大数据通过Python的Matplotlib实现数据可视化。 一、实验环境： 虚拟机数量：1 系统版本：Centos 7.5 Anaconda版本：4.4.0 二、实验内容： 通过创建Kafka topic，使用Kafka Producer产生消息，然后通过编写sparkStreaming程序处理这些消息。 主要步骤： Matplotlib的介绍 基本绘图函数 图表的修饰项介绍 子图绘制 图像的保存 三、实验步骤：3.1Matplotlib的介绍：在Python中，主要运用matplotlib库进行数据可视化。matplotlib是Python最著名的绘图库，它提供了一整套和matlab相似的命令API，十分适合交互式地进行制图。而且也可以方便地将它作为绘图控件，嵌入GUI应用程序中。 3.2基本绘图函数：matplotlib的pyplot子库提供了和matlab类似的绘图API，方便用户快速绘制2D图表。pyplot模块中常见的用来绘制图形的主要有以下几种函数： 3.2.1plot:常用于绘制线型图，该方法具有可变长参数，参数color指定颜色，参数linestyle设置线的样式、参数marker设置标记类型，结果返回一个lines.Line2D对象的列表，lines.Line2D对象的属性可通过plot的关键字参数设置。 3.2.2scatter: 用于绘制散点图； 3.2.3hist:用于绘制直方图，其参数中较为重要的是bins，该参数指定bin(箱子)的个数，即柱状图中柱子的总数，该值默认为10； 3.2.4show: 显示图像。 3.3图表的修饰项介绍：对于大多数的图表装饰项，其主要实现方式主要有使用过程型的pyplot接口和面向对象的原生matplotlib API两种，分别对应的是函数编程和对象编程两种思想。 3.3.1title：设置或者获取图表标题； 3.3.2xlim：设置或者获取X轴范围； 3.3.3xlabel：设置或者获取X轴标签； 3.3.4**xticks(&lt;刻度&gt;,&lt;标签&gt;)**：设置或者获取X轴刻度和刻度标签； 3.3.5**text(x,y,z)**：将文本z绘制在图表的指定坐标(x,y) 3.3.6legend：自动创建图例，可以通过设置loc参数指定图例的位置。需要事先在添加图像时设置label参数。 3.3.7**twinx(ax)**：返回一个与子图对象ax的x轴一致y轴在右侧的子图对象ax2，用于绘制双轴图表。使用实例方法的形式为ax2=ax.twinx()。 3.3.8除了上面特别说明的，其它方法各自对应子图对象的的两个实例方法，以xlim为例，就是Axes.get_xlim和Axes.set_xlim。 3.4子图绘制：简单类型的Artists为标准的绘图元件，例如Line2D、Rectangle、Text、AxesImage等等。而容器类型则可以包含许多简单类型的Artists，使它们组织成一个整体，例如Axis、Axes、Figure等。 3.4.1figure：用来创建一个绘图对象，通常也可以不创建绘图对象而调用plot之类的函数直接绘图，matplotlib会自动创建一个绘图对象。通过figsize参数可以指定绘图对象的宽度和高度。如果需要同时绘制多幅图表的话，可以是给figure传递一个整数参数指定图表的序号，如果所指定序号的绘图对象已经存在的话，将不创建新的对象，而只是让它成为当前绘图对象； 3.4.2subplot：创建一个新的Figure，并返回一个含有已创建的subplot对象的NumPy数组。该方法的调用形式为：subplot(numRows,numCols, plotNum)，将整个绘图区域等分为numRows行、numCols列个子区域，然后按照从左到右，从上到下的顺序对每个子区域进行编号，左上的子区域的编号为1。如果numRows，numCols和plotNum的值都小于10，可以把它们缩写为一个整数，例如 subplot(321)和subplot(3,2,1)是相同的；对于绘图对象有add_subplot方法用于添加subplot对象； 3.4.3subplots：创建一个包含多个子图的Figure，返回Figure和一个或多个ax（子图）对象，可以通过设置sharex/sharey参数指定共享x轴/y轴； 3.4.4axes：同样往图表添加子图，不同之处在于子图可以设定在绘图区域的任意位置，axes的参数是一个形如[left,bottom, width,height]的列表，这些数值分别指定所创建的Axes对象相对于绘图对象的位置和大小，取值范围都在0到1之间。对于绘图对象有add_axes方法用于添加subplot对象。 3.5图像的保存：利用plt.savefig可以将当前图表保存到文件，该方法相当于Figure对象的实例方法savefig。具体参数如下： 3.5.1 fname：含有文件路径的字符串或Python的文件型对象； 3.5.2 dpi：图像分辨率（每英寸点数），默认为100； 3.5.3 facecolor，edgecolor，图像的背景色，默认为”w”，即白色； 3.5.4 format：显式设置文件格式（”png”、”pdf”、”svg”等）； 3.5.5 bbox_inches：图表需要保存的部分。 3.6Matplotlib 绘图示例3.6.1执行如下命令打开编程环境 12cdipython 3.6.2绘制世界人口与年份的关系图： 3.6.2.1导入实验所需的库 1234from datetime import datetimeimport matplotlib.dates as mdatesimport matplotlib.pyplot as plt 3.6.2.2year 和pop为年份和对应的全世界人口数辆（单位10亿） 123yearInt = [2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020]year = [str(item) for item in yearInt] # 将yearInt中的数字转换成strpop = [6.49, 6.558, 6.656, 6.725, 6.804, 6.884, 6.965, 7.043, 7.125, 7.207, 7.356, 7.380, 7.405, 7.440, 7.468, 8.020] 3.6.2.3绘图 123456xs = [datetime.strptime(d, '%Y').date() for d in year] # 将year中的每个如'2005'的字符串转换成只包含年的日期plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y')) # gca()获得坐标轴；plt.gca().xaxis.set_major_locator(mdates.YearLocator()) # 年份plt.plot(xs, pop) # 绘制图表plt.gcf().autofmt_xdate() # 将x轴的日期自动旋转角度plt.show() # 显示图表 3.7在上一幅图表中添加另一条关于中国人品与年份关系的线，并对新图添加对应的修饰项3.7.1添加中国人口数量关系 123plt.figure()pop_cn = [1.30756, 1.31448, 1.32129, 1.32802, 1.33450, 1.34091, 1.34735, 1.35404, 1.36072, 1.36782, 1.36790, 1.36801, 1.36813, 1.36832, 1.36845, 1.36860] 3.7.2绘制人口数量和年份关系；year与pop仍然用之前的数据 12plt.plot(year, pop, color=\"g\", label=\"World population\")plt.plot(year, pop_cn, linestyle=\"--\", color=\"r\", label=\"China population\") 3.7.3添加修饰项 3.7.3.1添加x，y轴标签 3.7.3.2添加注解。注解点为(2008, 6.725)，内容为年(2013) 3.7.3.3添加图例，loc=1,表示图例出现在恰当的位置 3.7.3.4添加title 12345plt.xlabel('year')plt.ylabel('Population')plt.text('2008', 6.725, '2013')plt.legend(loc=1)plt.title(\"World Population Summary\") 3.7.4显示图片 1plt.show() 3.8子图的绘制：利用plt.subplots函数创建包含多个子图的绘图对象，还可以设置子图个数。 3.8.1绘制x轴共享子图， 3.8.1.1子图个数设置为2，并且共享x轴 1f, (ax1, ax2) = plt.subplots(2, sharex=True) # f是Figure对象；ax1,ax2分别是Axes 3.8.1.2使用散点图绘制 12ax1.scatter(year, pop) # 绘制散点图ax2.scatter(year, pop_cn) 3.8.1.3添加修饰项：标题， 12ax1.set_title('World Population Summary') # 设置标题ax2.set_title(\"China Population Summary\") 3.8.1.4显示图像 1plt.show() 3.8.2绘制双y轴子图，共享x轴。 3.8.2.1创建绘图对象fig 1fig = plt.figure() 3.8.2.2使用fig.add_subplot函数为绘图对象fig添加两个子图，ax4通过使用ax3的twinx方法创建，且与ax3共享x中，放置在y轴右侧 12ax3 = fig.add_subplot(111) # 参数是1个3位的整数或3个分隔的整数，描述子图的位置，分别是nrows,ncols,indexax4 = ax3.twinx() # 创建一个x轴，并创建一个与原y轴处于相对位置的新y轴 3.8.2.3绘制子图ax3， ax4 12ax3.plot(year, pop, color=\"g\", label=\"World population\")ax4.plot(year, pop_cn, linestyle=\"--\", color=\"r\", label=\"China population\") 3.8.2.4添加修饰项：添加x,y轴标签、 标题 1234ax3.set_ylabel('World population')ax3.set_title(\"Double Y axis\")ax4.set_ylabel('China population')ax4.set_xlabel('Year') 3.8.2.5显示图像 1plt.show() 3.9图像的保存：3.9.1代码使用双y轴的代码，代码末尾show（）方法改成保存方法即可 3.9.2使用plt.savfig()函数保存图像 3.9.2.1制定保存的名称，格式，像素，以及是否修渐空白区域。 1234567891011fig = plt.figure()ax3 = fig.add_subplot(111)ax3.plot(year, pop, color=\"g\", label=\"World population\")ax3.set_ylabel('World population')ax3.set_title(\"Double Y axis\")ax4 = ax3.twinx()ax4.plot(year, pop_cn, linestyle=\"--\", color=\"r\", label=\"China population\")ax4.set_ylabel('China population')ax4.set_xlabel('Year')plt.savefig('figure.pdf', dpi=400, bbox_inches='tight') # 去除空白区域plt.show() 3.9.2.2点击关闭弹出的效果图 3.9.2.3查看保存的文件：打开火狐浏览器，地址栏键入如下内容（生成图片的绝对路径） 四、附录所有的代码汇总plt.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566\"\"\"@Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved.@Project: plt_5@Description: @Version: @Author: 苇名一心@Date: 2020-06-02 11:46@LastEditors: 苇名一心@LastEditTime: 2020-06-02 11:46\"\"\"from datetime import datetimeimport matplotlib.dates as mdatesimport matplotlib.pyplot as pltyearInt = [2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020]year = [str(item) for item in yearInt] # 将yearInt中的数字转换成strpop = [6.49, 6.558, 6.656, 6.725, 6.804, 6.884, 6.965, 7.043, 7.125, 7.207, 7.356, 7.380, 7.405, 7.440, 7.468, 8.020]xs = [datetime.strptime(d, '%Y').date() for d in year] # 将year中的每个如'2005'的字符串转换成只包含年的日期plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y')) # gca()获得坐标轴；plt.gca().xaxis.set_major_locator(mdates.YearLocator()) # 年份plt.plot(xs, pop) # 绘制图表plt.gcf().autofmt_xdate() # 将x轴的日期自动旋转角度plt.show() # 显示图表plt.figure()pop_cn = [1.30756, 1.31448, 1.32129, 1.32802, 1.33450, 1.34091, 1.34735, 1.35404, 1.36072, 1.36782, 1.36790, 1.36801, 1.36813, 1.36832, 1.36845, 1.36860]plt.plot(year, pop, color=\"g\", label=\"World population\")plt.plot(year, pop_cn, linestyle=\"--\", color=\"r\", label=\"China population\")plt.xlabel('year')plt.ylabel('Population')plt.text('2008', 6.725, '2013')plt.legend(loc=1)plt.title(\"World Population Summary\")plt.show()f, (ax1, ax2) = plt.subplots(2, sharex=True) # f是Figure对象；ax1,ax2分别是Axesax1.scatter(year, pop) # 绘制散点图ax2.scatter(year, pop_cn)ax1.set_title('World Population Summary') # 设置标题ax2.set_title(\"China Population Summary\")plt.show()fig = plt.figure()ax3 = fig.add_subplot(111) # 参数是1个3位的整数或3个分隔的整数，描述子图的位置，分别是nrows,ncols,indexax4 = ax3.twinx() # 创建一个x轴，并创建一个与原y轴处于相对位置的新y轴ax3.plot(year, pop, color=\"g\", label=\"World population\")ax4.plot(year, pop_cn, linestyle=\"--\", color=\"r\", label=\"China population\")ax3.set_ylabel('World population')ax3.set_title(\"Double Y axis\")ax4.set_ylabel('China population')ax4.set_xlabel('Year')plt.show()fig = plt.figure()ax3 = fig.add_subplot(111)ax3.plot(year, pop, color=\"g\", label=\"World population\")ax3.set_ylabel('World population')ax3.set_title(\"Double Y axis\")ax4 = ax3.twinx()ax4.plot(year, pop_cn, linestyle=\"--\", color=\"r\", label=\"China population\")ax4.set_ylabel('China population')ax4.set_xlabel('Year')plt.savefig('figure.pdf', dpi=400, bbox_inches='tight') # 去除空白区域plt.show()","categories":[{"name":"大数据","slug":"大数据","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"实战","slug":"大数据/实战","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"实战","slug":"实战","permalink":"https://666wxy666.github.io/tags/%E5%AE%9E%E6%88%98/"},{"name":"Python","slug":"Python","permalink":"https://666wxy666.github.io/tags/Python/"},{"name":"大数据","slug":"大数据","permalink":"https://666wxy666.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"可视化","slug":"可视化","permalink":"https://666wxy666.github.io/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"name":"iPython","slug":"iPython","permalink":"https://666wxy666.github.io/tags/iPython/"},{"name":"Matplotlib","slug":"Matplotlib","permalink":"https://666wxy666.github.io/tags/Matplotlib/"}]},{"title":"Linux 上机实战4 SimpleShell","slug":"Linux-上机实战4-SimpleShell","date":"2020-05-31T16:00:00.000Z","updated":"2020-09-02T02:01:19.978Z","comments":true,"path":"2020/06/01/Linux-上机实战4-SimpleShell/","link":"","permalink":"https://666wxy666.github.io/2020/06/01/Linux-%E4%B8%8A%E6%9C%BA%E5%AE%9E%E6%88%984-SimpleShell/","excerpt":"本文是关于Linux中的一个简单的shell，支持运行多个命令以[;]分割，支持管道和重定向，支持CTRL-C终止内部命令而不终止simple shell本身，有完善的错误处理及醒目的颜色提示。","text":"本文是关于Linux中的一个简单的shell，支持运行多个命令以[;]分割，支持管道和重定向，支持CTRL-C终止内部命令而不终止simple shell本身，有完善的错误处理及醒目的颜色提示。 一、实验环境硬件： Intel i7 7700HQ，内存16GB； 软件： 基于Arch Linux的Manjaro Linux内核：Linux 5.4.39-1-MANJARO x86_64 C语言 二、基本步骤 编写代码grep+wc.c（代码源码见附件grep+wc.c或本文最后的附录）： 编译 在grep+wc.c的基础上进行拓展，编写代码simple_shell.c（代码源码见附件simple_shell.c或本文最后的附录）： 在编写时遇到了一个棘手的问题，就是关于“子进程对父进程信号的继承情况”。总结一下就是： 仅fork时子进程会继承父进程fork之前所设置的信号处理方式。 当有exec加载新程序时 子进程继承的处理方式是忽略或默认处理方式时，exec新程序后设置依然有效。 如果子进程继承是捕获处理方式时，exec新程序后将被还原为默认处理方式。 详细请查看这位大佬的文章子进程对父进程信号的继承情况详细分析（信号）【linux】（zs）。 编译 三、测试样例0、在Shell（zsh）里运行所给命令 1、grep+wc 2、simple_shell1.特殊命令 2.普通命令 3.重定向命令 4.管道命令 5.综合命令 6.错误命令 7.CTRL-C输入find / -name hello，在运行期间输入CTRL-C杀死正在运行的find程序。可以发现find命令停止，但是Simple Shell并没有退出（输入exit可以正常退出）。 四、项目地址本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看： 源码仓库 五、附录PS:程序源码均有详细的注释 1、grep+wc.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/* * @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. * @Description: grep -v usr &lt; /etc/passwd | wc –l &gt; r.txt; cat r.txt * @Version: 1.0 * @Author: 苇名一心 * @Date: 2020-05-21 09:44:26 * @LastEditors: 苇名一心 * @LastEditTime: 2020-05-21 21:23:57 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char const *argv[])&#123; int sv; int fd[2]; pipe(fd); if (fork() == 0) &#123; // 输入重定向 int fd0 = -1; fd0 = open(\"/etc/passwd\", O_RDONLY); if (fd0 != -1) &#123; dup2(fd0, 0); close(fd0); &#125; // 管道输入端 dup2(fd[1], 1); close(fd[1]); close(fd[0]); // 执行管道前的命令 execlp(\"grep\", \"grep\", \"-v\", \"usr\", 0); exit(1); &#125; else &#123; if (fork() == 0) &#123; // 输出重定向 int fd1 = -1; fd1 = open(\"r.txt\", O_CREAT | O_WRONLY | O_TRUNC, 0666); if (fd1 != -1) &#123; dup2(fd1, 1); close(fd1); &#125; // 管道输出端 dup2(fd[0], 0); close(fd[0]); close(fd[1]); // 执行管道后的命令 execlp(\"wc\", \"wc\", \"-l\", 0); exit(1); &#125; &#125; close(fd[0]); close(fd[1]); wait(&amp;sv); wait(&amp;sv); // 执行第二个命令 execlp(\"cat\", \"cat\", \"r.txt\", 0); return 0;&#125; 2、simple_shell.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235/* * @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. * @Description: Simple Shell * @Version: 1.0 * @Author: 苇名一心 * @Date: 2020-05-21 09:44:26 * @LastEditors: 苇名一心 * @LastEditTime: 2020-05-21 21:56:34 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;setjmp.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;// 颜色#define NONE \"\\e[0m\" // 复原#define RED \"\\e[0;31m\" // ERRORchar version[] = \"1.0\"; // 版本号int pipe_flag = 0; // 是否使用管道static jmp_buf env;int sv;// CTRL-C回调函数void sig_handler(int sig)&#123; if (pipe_flag) &#123; wait(&amp;sv); wait(&amp;sv); &#125; else &#123; wait(&amp;sv); &#125; printf(\"\\n\"); siglongjmp(env, 1);&#125;// 打印帮助void help()&#123; printf(\"**********************************************************\\n\"); printf(\"%27sHELP%27s\\n**********************************************************\\n\", \"\", \"\"); printf(\"Simple Shell %s by 苇名一心 May 21 2020\\n\", version); printf(\"Usage: [COMMAND] [OPTION]... (&lt; [INFILE]) (| [COMMAND] [OPTION]... (&gt; [OUTFILE])) (;...;...)\\n\"); printf(\"Simple shell with redirect and pipe(Can also run multiple commands)\\nSpecial commands:\\n\"); printf(\"\\thelp\\tDisplay this help and continue\\n\"); printf(\"\\texit\\tExit simple shell\\n\"); printf(\"**********************************************************\\n\");&#125;int main(int argc, char const *argv[])&#123; char buffer[256], *argv1[256], **p, *argv2[256], *buf, *end, *cmd2, *in, *out; int fd[2]; // CTRL-C信号自行处理 signal(SIGINT, sig_handler); for (;;) &#123; sigsetjmp(env, 1); // 打印提示符 printf(\"=&gt; \"); // 获取命令 if (fgets(buffer, sizeof(buffer), stdin) == NULL) exit(0); //没有输入任何命令 if (strlen(buffer) == 1) &#123; continue; &#125; // 命令最后加;用于判断 if (buffer[strlen(buffer) - 2] != ';') &#123; buffer[strlen(buffer) - 1] = ';'; &#125; // 获取每一条;分割的命令，依次执行 for (buf = buffer; end = strstr(buf, \";\"); buf = end) &#123; *end++ = '\\0'; pipe_flag = 0; // 获取管道命令，输入重定向文件和输出重定向文件 // note:必须先获取管道命令，in和out在进行分词操作，因为分词会修改buf，导致获取管道命令，in和out出错 cmd2 = strstr(buf, \"|\"); in = strstr(buf, \"&lt;\"); out = strstr(buf, \"&gt;\"); if (in != NULL) &#123; *in++ = '\\0'; in = strtok(in, \" \\t\\n\"); &#125; if (out != NULL) &#123; *out++ = '\\0'; out = strtok(out, \" \\t\\n\"); &#125; if (cmd2 != NULL) &#123; pipe_flag = 1; *cmd2++ = '\\0'; for (p = &amp;argv2[0], *p = strtok(cmd2, \" \\t\\n\"); *p != NULL; *++p = strtok(NULL, \" \\t\\n\")) ; if (argv2[0] == NULL) &#123; fprintf(stderr, RED \"** No command 2 input!\\n\" NONE); continue; &#125; &#125; for (p = &amp;argv1[0], *p = strtok(buf, \" \\t\\n\"); *p != NULL; *++p = strtok(NULL, \" \\t\\n\")) ; // 没有命令输入 if (argv1[0] == NULL) &#123; fprintf(stderr, RED \"** No command 1 input!\\n\" NONE); continue; &#125; // 输入了exit if (strcmp(argv1[0], \"exit\") == 0) exit(0); // 输入了help if (strcmp(argv1[0], \"help\") == 0) &#123; help(); continue; &#125; // 使用了管道 if (pipe_flag) &#123; pipe(fd); if (fork() == 0) &#123; // 输入重定向 int fd0 = -1; if (in != NULL) fd0 = open(in, O_RDONLY); if (fd0 != -1) &#123; dup2(fd0, 0); close(fd0); &#125; else if (in != NULL) &#123; fprintf(stderr, RED \"** No such file or directory: %s\\n\" NONE, in); help(); exit(1); &#125; // 管道输入端 dup2(fd[1], 1); close(fd[1]); close(fd[0]); // 执行管道前的命令 execvp(argv1[0], argv1); fprintf(stderr, RED \"** Bad command 1: %m\\n\" NONE); help(); exit(1); &#125; else &#123; if (fork() == 0) &#123; // 输出重定向 int fd1 = -1; if (out != NULL) fd1 = open(out, O_CREAT | O_WRONLY | O_TRUNC, 0666); if (fd1 != -1) &#123; dup2(fd1, 1); close(fd1); &#125; // 管道输出端 dup2(fd[0], 0); close(fd[0]); close(fd[1]); // 执行管道后的命令 execvp(argv2[0], argv2); fprintf(stderr, RED \"** Bad command 2: %m\\n\" NONE); help(); exit(1); &#125; &#125; close(fd[0]); close(fd[1]); wait(&amp;sv); wait(&amp;sv); &#125; // 没有使用管道 else &#123; if (fork() == 0) &#123; int fd0 = -1, fd1 = -1; // 输入重定向 if (in != NULL) fd0 = open(in, O_RDONLY); if (fd0 != -1) &#123; dup2(fd0, 0); close(fd0); &#125; else if (in != NULL) &#123; fprintf(stderr, RED \"** No such file or directory: %s\\n\" NONE, in); help(); exit(1); &#125; // 输出重定向 if (out != NULL) fd1 = open(out, O_CREAT | O_WRONLY | O_TRUNC, 0666); if (fd1 != -1) &#123; dup2(fd1, 1); close(fd1); &#125; // 执行命令 execvp(argv1[0], argv1); fprintf(stderr, RED \"** Bad command 1: %m\\n\" NONE); help(); exit(1); &#125; wait(&amp;sv); &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/categories/Linux/"},{"name":"上机实战","slug":"Linux/上机实战","permalink":"https://666wxy666.github.io/categories/Linux/%E4%B8%8A%E6%9C%BA%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/tags/Linux/"},{"name":"C","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"实战","slug":"实战","permalink":"https://666wxy666.github.io/tags/%E5%AE%9E%E6%88%98/"},{"name":"Shell","slug":"Shell","permalink":"https://666wxy666.github.io/tags/Shell/"}]},{"title":"机器学习 实验 K-Means聚类","slug":"机器学习-实验-K-Means聚类","date":"2020-05-16T16:00:00.000Z","updated":"2020-09-02T02:06:46.893Z","comments":true,"path":"2020/05/17/机器学习-实验-K-Means聚类/","link":"","permalink":"https://666wxy666.github.io/2020/05/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%AE%9E%E9%AA%8C-K-Means%E8%81%9A%E7%B1%BB/","excerpt":"本文是关于经典聚类算法K-Means的代码实现。","text":"本文是关于经典聚类算法K-Means的代码实现。 一、实验目标数据说明：目标是对 cluster.dat 里的数据进行聚类分析。其中，cluster.dat 包含了若干二维输入数据（但不包含其输出）。 使用 K-means 模型进行聚类，尝试使用不同的类别个数 K，并分析聚类结果。 按照 8:2 的比例随机将数据划分为训练集和测试集，至少尝试 3 个不同的 K 值，并画出不同 K 下的聚类结果，及不同模型在训练集和测试集上的损失。对结果进行讨论，发现能解释数据的最好的 K值。 二、实验环境 语言：Python 3.7（Anaconda3） IDE：PyCharm 2020.1.1 (Professional Edition) Packages： numpy：1.18.1 matplotlib：3.1.3 三、算法原理聚类是一种典型无监督学习，K-means算法是聚类的经典算法。目标是将原始数据集划分为k个簇，最小化损失函数（目标函数）是：$$SSE=\\sum_{n=1}^{N}\\sum_{k=1}^{K}r_{nk}dist(x_n-\\mu_k)$$ $\\mu_k$表示簇$C_k$的中心点（或其他能代表$C_k$的点）。 $x_n$被划分到簇$C_k$则$r_{nk}=1$，否则$r_{nk}=0$。 目标是找到簇的中心点$\\mu_k$及簇的划分$r_{nk}$使得目标函数SSE最小。 要解决上述问题就需要遍历所有可能的簇划分，显然这是不合适的。K-means算法使用了贪心策略求一个近似解，具体步骤如下： 将全部数据随机分为k类，计算每类的重心作为初始点。 计算所有数据点与各个簇中心之间的距离，将数据点划到与它距离最近的簇中。 根据簇中已有的样本点，重新计算簇中心（一般使用重心）。 重复2、3，直到数据点的簇划分不在变化或者达到了规定的最大迭代次数。 这是k-means算法的基本步骤，但是，这个算法有个很严重的问题，就是在将数据点划到与它距离最近的簇后，由于初始簇心选择不当，可能产生空簇，导致计算簇中心无法进行（簇的size=0，除数为0），我的解决方法是在计算簇心时，如果簇的size=0就先忽略，后面单独处理。计算完非空簇心后，依次选取与自己簇中心最远、次远……的点（因为距离自己的簇心越远，这个点分到该簇的概率越低）作为空簇的簇心，直到没有空簇，即所有的簇都有簇心，然后继续算法。 四、算法流程图这只是算法函数（algorithm）和其他一些部分的流程图，不是整个程序的流程图，整个程序要更复杂。 五、实验结果及分析 输入k的范围是[2,10]，测试集所占比例为0.2，最大迭代次数为20。 聚类结果 k=2 k=3 k=4 k=5 k=6 k=7 k=8 k=9 k=10 k从2~10的数据集、训练集和测试集的SSE如图： 可以发现k=2~4时SSE下降较快，k=4~10时下降较慢，由于我们的目标是使SSE减小，因此由图可以得出k=4为解释数据较好的k。并且在k=2时，重复实验甚至会出现完全不同的聚类结果，说明k=2太小。在k&gt;=6之后，SSE基本不下降，说明k再加大没有多大意义。 六、项目地址本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看： 七、附录kmeans.py： 基本配置、全局参数 123456789101112131415161718192021222324252627282930313233343536\"\"\"@Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved.@Project: kmeans@Description: k-means算法@Version: 1.0@Author: 苇名一心@Date: 2020-05-22 21:25@LastEditors: 苇名一心@LastEditTime: 2020-05-22 21:25\"\"\"import randomimport sysimport matplotlib.pyplot as pltimport numpy as npfrom sklearn.model_selection import train_test_split######################################################### 全局变量######################################################### 显示中文标签plt.rcParams['font.sans-serif'] = ['SimHei']# 显示负号plt.rcParams['axes.unicode_minus'] = False# 簇个数范围k_min = 1k_max = 1max_iteration = 10 # 最大迭代次数test_rate = 0.2 # 训练集所占比例all_point_num = 0data_x = [] # 点的x坐标列表data_y = [] # 点的y坐标列表data_SSE_list = [] # 数据集损失目标函数列表train_SSE_list = [] # 训练集损失目标函数列表test_SSE_list = [] # 测试集损失目标函数列表 读入数据 123456789101112131415161718192021222324252627282930######################################################### 读入数据########################################################def read_data(path): global all_point_num global test_rate global max_iteration global k_min global k_max data = open(path) # 打开数据文件 for line in data: # 将数据文件的每一行按空格分隔，分别添加到x,y列表 data_x.append(float(line.split()[0])) data_y.append(float(line.split()[1])) all_point_num += 1 print(\"请输入k的范围（空格分隔，例如2 5，代表闭区间[2,5]）：\", end=\"\") k_min, k_max = map(int, input().split()) if k_min &gt; k_max or k_min &lt; 1 or k_max &lt; 1: print(\"ERROR: 簇的个数输入错误！\") sys.exit(1) print(\"请输入测试集所占比例：\", end=\"\") test_rate = float(input()) if test_rate &lt; 0 or test_rate &gt; 1: print(\"ERROR: 测试集所占比例输入错误！\") sys.exit(1) print(\"请输入最大迭代次数：\", end=\"\") max_iteration = int(input()) if max_iteration &lt; 0: print(\"ERROR: 最大迭代次数输入错误！\") sys.exit(1) 算法计算 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081######################################################### 算法########################################################def algorithm(x, y, k): # 初始化 n = 0 # 迭代次数 SSE = 0 # 损失（目标）函数 point_array = np.array([x, y]) # 生成点的numpy数组，例如三个点(1，-1),(2，-2),(3，-3)生成[[ 1 2 3 ][ -1 -2 -3 ]] point_num = point_array.shape[1] # 获取点的个数，所给的数据集为1000个点，取0.8为800个 # 如果点的个数&lt;簇的个数，则报错异常退出 if point_num &lt; k: print(\"ERROR: 点的个数&lt;簇的个数！\") sys.exit(1) distance = np.zeros(k) # 初始化k维0向量，用来存储这个点到的k个簇中心的距离 point_distance = np.zeros(point_num) # 初始化point_num维0向量，用来存储每个点到其簇中心的距离 center = np.zeros((2, k)) # 生成2*k的零矩阵，初始化k个簇的中心点，后面将先计算每个簇的重心作为初始簇中心 point_k1 = np.arange(0, k, 1) # 先生成0~k-1的数组，保证每个簇至少有一个点 point_k2 = np.random.randint(0, k, size=point_num - k) # 将剩下的点随机分到任意一个簇，返回长度为point_num-k的向量，每个为0~k-1的随机整数 point_k = np.concatenate((point_k1, point_k2)) # 将前两个数组合成为一个 np.random.shuffle(point_k) # 最后再打乱一次point_k数组，保证随机性 point_k_bak = point_k.copy() # point_k的备份，用于判断前后两次迭代是否发生变化 # 输出相关信息 print(\"点个数为：\", point_num, sep=\"\") # 开始K-means算法的迭代 # 只要迭代次数没有超过最大迭代次数上限max_iteration并且两次迭代的结果还有变化，就继续迭代 while n &lt;= max_iteration: # 计算每个簇的中心 size = np.bincount(point_k, minlength=k) # 计算每个簇的规模，k维向量，每一维为每个簇里点的个数 for i in range(k): # 对于k个簇中的每一个簇i # 不是空簇，防止出现除数为0，空簇下面单独处理 if size[i] != 0: # point_sum是一个二维向量，代表i簇中的所有点的x,y坐标值的和 point_sum = np.zeros(2) # 初始化为0 # 计算i簇中的所有点的x,y坐标值的和 for point in range(point_num): # 对于每一个点point if point_k[point] == i: # 如果这个点point属于簇i point_sum = point_sum + point_array[:, point] # 将这个点的x,y坐标加到point_sum上 # note: array[:, i]就是取array的第i列，刚好就是这个点 # 求平均数，因此要/这个簇中点的个数size[i] # 将计算出的簇中心存在center矩阵中的第i列，代表第i个簇的中心点 center[:, i] = point_sum / size[i] # 对所有的空簇单独处理 # 处理方式为把与自己所在的簇中心距离最大的点作为空簇的簇中心 for c in np.where(size == 0)[0]: # 将距离最大的点的所在簇改为空簇的簇号 point_k[np.argmax(point_distance)] = c # 将空簇中心改为这个点 center[:, c] = point_array[:, np.argmax(point_distance)] # 将每一个点分到与簇中心最近的簇 for point in range(point_num): # 对于每一个点point for i in range(k): # 对于k个簇中的每一个簇i # 计算该点point到该簇i的距离 # note: 使用矩阵的2范式，来计算欧氏距离 # point_array[:, point] - center[:, i]得到向量[p_x-c_x, p_y-c_y] # 对该向量求2范式刚好是欧式距离sqrt((p_x-c_x)^2+(p_y-c_y)^2) distance[i] = np.linalg.norm(point_array[:, point] - center[:, i]) # 使用numpy的argmin()返回distance中最小值的下标，也就是点point到簇中心距离最小的簇 point_k[point] = np.argmin(distance) # 将该点到其簇中心的距离记录下来 point_distance[point] = distance[point_k[point]] # 迭代次数+1 n += 1 # 判断两次迭代是否有变化，没有变化就跳出迭代循环 if (point_k == point_k_bak).all(): break # 将point_k备份 point_k_bak = point_k.copy() # 输出每次迭代目标函数值 SSE = np.sum(point_distance) print(\"n=\", n - 1, \"，SSE=\", SSE, sep=\"\") # 输出相关信息 print(\"总迭代次数为：\", n - 1, sep=\"\") print(\"每个簇的中心：\", sep=\"\") for i in range(k): print(\"(\", center[0, i], \",\", center[1, i], \")\", sep=\"\") print(\"===================================================\") return SSE, point_k 画图展示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566######################################################### 画图展示######################################################### 根据每个点所在的簇，获取点的颜色，返回一个列表def get_color_list(point_k, k): # 随机生成k个颜色 RGB = ['1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'] colors = [] i = 0 while i &lt; k: color = \"\" for j in range(6): color += RGB[random.randint(0, 14)] # 只有随机产生的颜色不相同，才加到colors中，颜色个数+1 if \"#\" + color not in colors and color != \"FFFFFF\": colors.append(\"#\" + color) i += 1 # 对每个点，根据point_k中记录的点所在的簇，将颜色添加到列表中 color_list = [] for c in point_k: color_list.append(colors[c]) return color_list# 画散点图展示聚类结果（数据集，训练集、测试集）def show(x, y, result, x1, y1, result1, x2, y2, result2, k): # 数据集图 plt.subplot(131) # 设置标题 plt.title(\"K-Means数据集\") # 绘制散点图 # note: scatter函数支持传入颜色列表，对每一个点使用列表相应下标对应的颜色 plt.scatter(x, y, c=get_color_list(result, k)) # 训练集图 plt.subplot(132) # 设置标题 plt.title(\"K-Means训练集\") # 绘制散点图 plt.scatter(x1, y1, c=get_color_list(result1, k)) # 测试集图 plt.subplot(133) # 设置标题 plt.title(\"K-Means测试集\") # 绘制散点图 plt.scatter(x2, y2, c=get_color_list(result2, k)) # 展示散点图 plt.show()# 画折线图展示SSE对比def show_SSE(): # 设置标题 plt.title(\"K-Means在不同k下的损失\") # 设置x轴坐标 plt.xlim(k_min - 1, k_max + 2) plt.xlabel(\"k\") # 设置x轴标注 plt.ylabel(\"SSE\") # 设置y轴标注 # 绘制K-Means在不同k下训练集和测试集的损失 plt.plot(range(k_min, k_max + 1), data_SSE_list, lw=1, c='blue', marker='v', ms=4, label='数据集') plt.plot(range(k_min, k_max + 1), train_SSE_list, lw=1, c='red', marker='s', ms=4, label='训练集') plt.plot(range(k_min, k_max + 1), test_SSE_list, lw=1, c='green', marker='o', label='测试集') plt.legend() # 图例 plt.show() 开始运行 12345678910111213141516171819202122232425262728293031######################################################### 开始运行######################################################### 读入数据read_data(\"cluster.dat\")# 划分训练集和测试集train_x, test_x, train_y, test_y = train_test_split(data_x, data_y, test_size=test_rate, random_state=1)# 对k从2~5进行聚类for k_num in range(k_min, k_max + 1): print(\"###################################################\") print(\"簇个数为：\", k_num, sep=\"\") # 数据集 print(\"数据集：\") data_SSE, data_result = algorithm(data_x, data_y, k_num) data_SSE_list.append(data_SSE) # 训练集 print(\"训练集：\") train_SSE, train_result = algorithm(train_x, train_y, k_num) train_SSE_list.append(train_SSE) # 测试集 print(\"测试集：\") test_SSE, test_result = algorithm(test_y, test_y, k_num) test_SSE_list.append(test_SSE) # 输出平均SSE print(\"数据集最终平均损失函数AVG_SSE：\", data_SSE / all_point_num) print(\"训练集最终平均损失函数AVG_SSE：\", train_SSE / (all_point_num * (1 - test_rate))) print(\"测试集最终平均损失函数AVG_SSE：\", test_SSE / (all_point_num * test_rate)) # 画图 show(data_x, data_y, data_result, train_x, train_y, train_result, test_x, test_y, test_result, k_num)# 画图展示SSEshow_SSE()","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://666wxy666.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"实验","slug":"机器学习/实验","permalink":"https://666wxy666.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://666wxy666.github.io/tags/Python/"},{"name":"机器学习","slug":"机器学习","permalink":"https://666wxy666.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"实验","slug":"实验","permalink":"https://666wxy666.github.io/tags/%E5%AE%9E%E9%AA%8C/"},{"name":"K-Means","slug":"K-Means","permalink":"https://666wxy666.github.io/tags/K-Means/"},{"name":"聚类","slug":"聚类","permalink":"https://666wxy666.github.io/tags/%E8%81%9A%E7%B1%BB/"}]},{"title":"大数据实战 Spark Streaming 实时计算Kafka数据","slug":"大数据实战-Spark-Streaming-实时计算Kafka数据","date":"2020-05-13T16:00:00.000Z","updated":"2020-09-02T02:04:41.714Z","comments":true,"path":"2020/05/14/大数据实战-Spark-Streaming-实时计算Kafka数据/","link":"","permalink":"https://666wxy666.github.io/2020/05/14/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%88%98-Spark-Streaming-%E5%AE%9E%E6%97%B6%E8%AE%A1%E7%AE%97Kafka%E6%95%B0%E6%8D%AE/","excerpt":"本文是关于大数据通过Spark Streaming实现流计算Kafka数据进行单词计数。","text":"本文是关于大数据通过Spark Streaming实现流计算Kafka数据进行单词计数。 一、实验环境： 虚拟机数量：3(一主两从，主机名分别为：master、slave01、slave02) 系统版本：Centos 7.5 Zookeeper版本： Apache Zookeeper 3.4.10 Kafka版本：kafka_2.11-0.10.2.1 Spark版本：Apache Spark 2.1.1 二、实验内容： 通过创建Kafka topic，使用Kafka Producer产生消息，然后通过编写sparkStreaming程序处理这些消息。 主要步骤： 创建Spark Streaming项目工程 编写streaming程序 启动Zookeeper，Kafka集群 创建topic 启动Kafka生产者 准备作业环境 提交作业 三、实验步骤：3.1打开IDEA软件123cdcd idea-IC-172.4574.19/bin/idea.sh &amp; 3.2创建项目3.2.1创建同之前章节结构一致的项目spark_test, 设置语言级别为8。 3.2.2点击 Create New Project，进入如下图界面，按照图标依次点击，最后点击next。 3.2.3依次输入GroupId和ArtifactId和Version的值，随后点击next。 3.2.4进入如下界面，设置本地Maven项目的setting.xml文件和warehouse仓库，点击next按钮。 3.2.4.1本地setting.xml文件在/home/zkpk/apache-maven-3.5.0/conf目录下。 3.2.4.2本地仓库文件夹warehouse在/home/zkpk/apache-maven-3.5.0/warehouse。 3.2.5进入如下界面，输入工程名称spark_test，然后点击next，OK。 3.2.6工程创建完成后会自动打开一个名为zkpk的xml文件，按照以下修改： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.zkpk.lab&lt;/groupId&gt; &lt;artifactId&gt;zkpk&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;inceptionYear&gt;2008&lt;/inceptionYear&gt; &lt;properties&gt; &lt;scala.version&gt;2.11.11&lt;/scala.version&gt; &lt;spark.version&gt;2.1.1&lt;/spark.version&gt; &lt;hadoop.version&gt;2.7.3&lt;/hadoop.version&gt; &lt;kafka.version&gt;0.10.2.1&lt;/kafka.version&gt; &lt;/properties&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;scala-tools.org&lt;/id&gt; &lt;name&gt;Scala-Tools Maven2 Repository&lt;/name&gt; &lt;url&gt;http://scala-tools.org/repo-releases&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;scala-tools.org&lt;/id&gt; &lt;name&gt;Scala-Tools Maven2 Repository&lt;/name&gt; &lt;url&gt;http://scala-tools.org/repo-releases&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.scala-lang&lt;/groupId&gt; &lt;artifactId&gt;scala-library&lt;/artifactId&gt; &lt;version&gt;$&#123;scala.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-core_2.11&lt;/artifactId&gt; &lt;version&gt;$&#123;spark.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-sql_2.11&lt;/artifactId&gt; &lt;version&gt;$&#123;spark.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-streaming_2.11&lt;/artifactId&gt; &lt;version&gt;$&#123;spark.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-streaming-kafka-0-10_2.11&lt;/artifactId&gt; &lt;version&gt;$&#123;spark.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt; &lt;artifactId&gt;kafka_2.11&lt;/artifactId&gt; &lt;version&gt;$&#123;kafka.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;sourceDirectory&gt;src/main/scala&lt;/sourceDirectory&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.scala-tools&lt;/groupId&gt; &lt;artifactId&gt;maven-scala-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;goal&gt;testCompile&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;scalaVersion&gt;$&#123;scala.version&#125;&lt;/scalaVersion&gt; &lt;args&gt; &lt;arg&gt;-target:jvm-1.5&lt;/arg&gt; &lt;/args&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-eclipse-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;downloadSources&gt;true&lt;/downloadSources&gt; &lt;buildcommands&gt; &lt;buildcommand&gt;ch.epfl.lamp.sdt.core.scalabuilder&lt;/buildcommand&gt; &lt;/buildcommands&gt; &lt;additionalProjectnatures&gt; &lt;projectnature&gt;ch.epfl.lamp.sdt.core.scalanature&lt;/projectnature&gt; &lt;/additionalProjectnatures&gt; &lt;classpathContainers&gt; &lt;classpathContainer&gt;org.eclipse.jdt.launching.JRE_CONTAINER&lt;/classpathContainer&gt; &lt;classpathContainer&gt;ch.epfl.lamp.sdt.launching.SCALA_CONTAINER&lt;/classpathContainer&gt; &lt;/classpathContainers&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;reporting&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.scala-tools&lt;/groupId&gt; &lt;artifactId&gt;maven-scala-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;scalaVersion&gt;$&#123;scala.version&#125;&lt;/scalaVersion&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/reporting&gt;&lt;/project&gt; 3.2.7保存修改的pom.xml文件后，点击工程名，依次选择Maven——&gt;Reimport，即可根据pom.xml文件导入依赖包。 3.2.8设置语言环境language level，点击菜单栏中的file，选择Project Structure，弹出如下对话框，选择Modules，选择Language level为8，然后点击Apply，点击OK。 3.2.9设置Java Compiler环境，点击菜单栏中的file，选择Setting，弹出如下对话框，依次选择Build，Execution——&gt;Compiler——&gt;Java Compiler，设置图中的Project bytecode version为1.8，设置图中的Target bytecode version为1.8，然后依次点击Apply和OK。 至此，Spark Maven工程创建完毕。 3.2.10在项目sclaa文件下的org.zkpk.lab下新建“kafka_streaming”Object。 创建完成后的工程结构： 3.3编写scala代码下面是部分代码截图，具体代码在本文的附录中。 3.4使用maven打包程序开始打包。 打包完成。 3.5启动Zookeeper集群3.5.1分别登录master和slave01、slave02节点，进入zookeeper安装目录，启动服务。 3.5.2在三个节点上分别运行bin/zkServer.sh status命令查看状态，出现follower或leader表示ZK启动成功。 3.6启动Kafka集群在 master 和 slave01、slave02节点分别启动 Kafka。 3.7创建Kafka topic名称需要和代码中保持一致。 3.8在一个终端上启动一个生产者,准备生产 3.9使用spark-submit提交spark 应用3.9.1将生成的jar包文件复制到/home/zkpk下。 3.9.2提交sparkjob之前需要将spark-streaming-kafka-0-10_2.11-2.1.0，kafka-clients-0.10.2.这两个jar添加到spark_home/jars/路径下，否则程序提交会报错。 3.9.3新开一个终端，在/home/zkpk目录下提交程序。 1spark-submit --class org.zkpk.lab.kafka_streaming zkpk-1.0.jar 3.10输入内容，查看结果切换到之前的Kafka生产者终端中输入如下内容，然后切换到sparkStreaming任务界面查看结果。 输入： 结果： 输入： 结果： 输入： 结果： 四、附录kafka_streaming.scala12345678910111213141516171819202122232425262728293031323334353637383940414243package org.zkpk.labimport org.apache.kafka.common.serialization.StringDeserializerimport org.apache.spark.streaming.&#123;Seconds, StreamingContext&#125;import org.apache.spark.SparkConfimport org.apache.spark.streaming.kafka010._import org.apache.spark.streaming.kafka010.LocationStrategies.PreferConsistentimport org.apache.spark.streaming.kafka010.ConsumerStrategies.Subscribeobject kafka_streaming &#123; def main(args: Array[String]): Unit = &#123; val conf = new SparkConf().setMaster(\"local[2]\").setAppName(\"kafka_test\") val ssc = new StreamingContext(conf, Seconds(3)) val kafkaParams = Map[String, Object]( \"bootstrap.servers\" -&gt; \"master:9092\", \"key.deserializer\" -&gt; classOf[StringDeserializer], \"value.deserializer\" -&gt; classOf[StringDeserializer], \"group.id\" -&gt; \"example\", \"auto.offset.reset\" -&gt; \"latest\", \"enable.auto.commit\" -&gt; (false: java.lang.Boolean) ) val topics = List(\"test_kafka\").toSet val stream = KafkaUtils.createDirectStream [String,String]( ssc, PreferConsistent, Subscribe[String,String](topics,kafkaParams) ) val lines = stream.map(_.value) val words = lines.flatMap(_.split(\" \")) val wordcounts = words.map((_,1)).reduceByKey(_+_) wordcounts.print() ssc.start() ssc.awaitTermination() &#125;&#125;","categories":[{"name":"大数据","slug":"大数据","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"实战","slug":"大数据/实战","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"实战","slug":"实战","permalink":"https://666wxy666.github.io/tags/%E5%AE%9E%E6%88%98/"},{"name":"大数据","slug":"大数据","permalink":"https://666wxy666.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Spark","slug":"Spark","permalink":"https://666wxy666.github.io/tags/Spark/"},{"name":"流计算","slug":"流计算","permalink":"https://666wxy666.github.io/tags/%E6%B5%81%E8%AE%A1%E7%AE%97/"},{"name":"单词计数","slug":"单词计数","permalink":"https://666wxy666.github.io/tags/%E5%8D%95%E8%AF%8D%E8%AE%A1%E6%95%B0/"},{"name":"Streaming","slug":"Streaming","permalink":"https://666wxy666.github.io/tags/Streaming/"},{"name":"Scala","slug":"Scala","permalink":"https://666wxy666.github.io/tags/Scala/"},{"name":"Kafka","slug":"Kafka","permalink":"https://666wxy666.github.io/tags/Kafka/"}]},{"title":"Linux MOOC习题 6~10章","slug":"Linux-MOOC习题-6~10章","date":"2020-05-11T16:00:00.000Z","updated":"2020-09-02T01:58:11.538Z","comments":true,"path":"2020/05/12/Linux-MOOC习题-6~10章/","link":"","permalink":"https://666wxy666.github.io/2020/05/12/Linux-MOOC%E4%B9%A0%E9%A2%98-6~10%E7%AB%A0/","excerpt":"自己随便整理了一下在学习Linux网课时遇到的一些习题，易错点之类的，接上文Linux MOOC习题 1~5章。","text":"自己随便整理了一下在学习Linux网课时遇到的一些习题，易错点之类的，接上文Linux MOOC习题 1~5章。 PS：第七章是上机实验。 六、Linux命令风格和文件系统 这两个题都忽略了“符号链接”的作用。 这俩没啥好说的。 在Linux中，一般是-1代表失败，&gt;=0的值代表成功。 八、文件和目录的权限，Shell 目录有执行权限（即x权限）意味着分析路径名过程中可检索该目录。 九、替换，元字符和转义 如果你是执行这个命令的操作员，估计你马上就心情不好了。由于拼错了单词，把DATABASE不小心写成了DATEBASE，灾难来了。未命名的变量被bash替换为空字符串，实际上你以root身份执行了最邪恶的一条命令： 1rm -rf /* 永远不要盲目自信，谁也保证不了自己不会犯错误，怎么才能避免这样的悲剧发生？ 尽量不要以root身份登录。 bash有选项，引用未定义的变量会出错而不是替换为空字符串，可以打开这个选项。早期的编程语言把引用的未定义过的变量自动加上定义，这种做法实际上太糟糕，最早的FORTRAN语言就这种做法，据说曾因此导致一次太空任务失败。 在设计你自己的系统时，建库命令能够从目录名开始建库，就是说要求建库之前/opt/data下不需要存在目录puma，而不是要求建库之前/opt/data有个空目录puma，这样的话，即使你的命令变成了 1rm -rf $DATEBASE 因为你的失误，会导致rm命令抱怨缺少参数而什么都不做，这个结果是可以接受的。 在Linux中，目前我已知的Shell的元字符有： 1空格 制表符 回车 &gt; &lt; | ; &amp; $ * [ ] ? \\ ( ) '' \" \" 反撇号` 第11题中，这三个命令都可以取消文件通配符*的特殊作用，让echo直接打印字符*，并且这个替换是Shell进行的，也就是说，echo拿到的命令都是一样的，他是分不清操作员输入的是哪个命令，这三个命令的参数： 而对于不转义的命令的参数： 1echo * 因此结果就很明显了： 十、shell流程控制：条件，循环与函数 B选项：明显的错误，then要么另起一行，要么前面加;。 C选项和D选项：都是没加fi，C选项还有其他的错误，这明显是和C语言之类的给混了。 所有的习题： Linux MOOC习题 1~5章Linux MOOC习题 6~10章Linux MOOC习题 11~15章","categories":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/categories/Linux/"},{"name":"习题","slug":"Linux/习题","permalink":"https://666wxy666.github.io/categories/Linux/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/tags/Linux/"},{"name":"习题","slug":"习题","permalink":"https://666wxy666.github.io/tags/%E4%B9%A0%E9%A2%98/"},{"name":"易错点","slug":"易错点","permalink":"https://666wxy666.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"网课","slug":"网课","permalink":"https://666wxy666.github.io/tags/%E7%BD%91%E8%AF%BE/"},{"name":"MOOC","slug":"MOOC","permalink":"https://666wxy666.github.io/tags/MOOC/"}]},{"title":"计算机系统结构 实验 指令调度与延迟分支","slug":"计算机系统结构-实验-指令调度与延迟分支","date":"2020-05-10T16:00:00.000Z","updated":"2020-09-02T02:09:29.190Z","comments":true,"path":"2020/05/11/计算机系统结构-实验-指令调度与延迟分支/","link":"","permalink":"https://666wxy666.github.io/2020/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AE%9E%E9%AA%8C-%E6%8C%87%E4%BB%A4%E8%B0%83%E5%BA%A6%E4%B8%8E%E5%BB%B6%E8%BF%9F%E5%88%86%E6%94%AF/","excerpt":"本文是关于计算机系统结构实验五，指令调度与延迟分支。","text":"本文是关于计算机系统结构实验五，指令调度与延迟分支。 一、实验目的 加深对指令调度技术的理解。 加深对延迟分支技术的理解。 熟练掌握用指令调度技术解决流水线中的数据冲突的方法。 进一步理解指令调度技术对 CPU 性能的改进。 进一步理解延迟分支技术对 CPU 性能的改进。 二、实验步骤及结果分析1、启动 MIPSsim。 2、根据实验2的相关知识中关于流水线各段操作的描述，进一步理解流水线窗口中各段的功能，掌握各流水线寄存器的含义（双击各段，就可以看到各流水线寄存器中的内容）。①IF段： ②ID段： ③EX段： ④MEM段： ⑤WB段： 3、选择“配置”→“流水方式”选项，使模拟器工作在流水方式下。4、用指令调度技术解决流水线中的结构冲突与数据冲突： 启动 MIPSsim。用 MIPSsim 的“文件”-&gt;“载入程序”选项来加载 schedule.s（在模拟器所在文件夹下的“样例程序”文件夹中）。关闭定向功能，这是通过“配置“-&gt;”定向“选项来实现的。执行所载入的程序，通过查看统计数据和时钟周期图，找出并记录程序执行过程中各种冲突发生的次数，发生冲突的指令组合以及程序执行的总时钟周期数。 载入的程序： 执行结果： 寄存器的值 部分时钟周期图 统计 发现总共执行了33个周期，执行了15条指令，8次RAW停顿，RAW停顿有16个周期，RAW停顿占周期总数的百分比为48.48485%，所有的停顿为17个周期，占周期总数的百分比为51.51515%。$$吞吐率TP_1=\\frac{15}{33\\Delta{t}}$$ $$加速比S_1=\\frac{15\\times{5\\Delta{t}}}{33\\Delta{t}}\\approx{2.27}$$ 冲突的指令组合： 1-1和2-1，2-1和2-2，2-2和2-3，3-1和3-2，4-1和4-2，4-2和4-3，4-3和4-4，5-1和5-2共8对冲突，1-5组组内冲突，组间没有关联。 schedule.s： 1234567891011121314151617181920212223242526.textmain:ADDIU $r1,$r0,A # 1-1LW $r2,0($r1) # 2-1ADD $r4,$r0,$r2 # 2-2SW $r4,0($r1) # 2-3LW $r6,4($r1) # 3-1ADD $r8,$r6,$r1 # 3-2MUL $r12,$r10,$r1 # 4-1ADD $r16,$r12,$r1 # 4-2ADD $r18,$r16,$r1 # 4-3SW $r18,16($r1) # 4-4LW $r20,8($r1) # 5-1MUL $r22,$r20,$r14 # 5-2MUL $r24,$r26,$r14 # 6-1TEQ $r0,$r0 # 7-1.dataA: .word 4,6,8 自己采用调度技术对程序进行指令调度，消除冲突（自己修改源程序）。将调度（修改）后的程序重新命名为 afer-schedule.s。（注意：调度方法灵活多样，在保证程序正确性的前提下自己随意调度，尽量减少冲突即可，不要求要达到最优。）载入 afer-schedule.s，执行该程序，观察程序在流水线中的执行情况，记录程序执行的总时钟周期数。 比较调度前和调度后的性能，论述指令调度对提高 CPU 性能的作用。 PS：调度后的程序见附录。 载入的程序： 执行结果： 寄存器的值 与不调度前完全一致，调度没有改变结果，调度正确。 时钟周期图 统计 发现总共执行了18个周期，执行了15条指令，1次RAW停顿，RAW停顿有1个周期，RAW停顿占周期总数的百分比为5.555555%，较没有静态调度的48.48485%少了很多，所有的停顿为2个周期，占周期总数的百分比为11.111111%，较没有静态调度的51.51515%也少了很多。$$吞吐率TP_2=\\frac{15}{18\\Delta{t}}$$ $$加速比S_2=\\frac{15\\times{5\\Delta{t}}}{18\\Delta{t}}\\approx{4.17}$$ 吞吐率和加速比是没有静态调度时的$\\frac{33}{18}\\approx{1.83}$倍。 5、用延迟分支技术减少分支指令对性能的影响： 在 MIPSsim 中载入 branch.s 样例程序（在本模拟器目录的“样例程序”文件夹中。关闭延迟分支功能。这是通过在“配置”-&gt;“延迟槽”选项来实现的。执行该程序，观察并记录发生分支延迟的时刻，记录该程序执行的总时钟周期数。 载入的程序： 执行结果： 寄存器的值 部分时钟周期图 统计 发现总共执行了38个周期，执行了18条指令，8次RAW停顿，RAW停顿有16个周期，RAW停顿占周期总数的百分比为42.10526%，控制停顿有2个周期，占周期总数的百分比为5.263158%，所有的停顿为19个周期，占周期总数的百分比为50%。发生分支延迟的时刻为第15个周期，延迟了2个周期。 $$ 吞吐率TP_1=\\frac{18}{38\\Delta{t}} $$ $$加速比S_1=\\frac{18\\times{5\\Delta{t}}}{38\\Delta{t}}\\approx{2.37}$$ 冲突的指令组合： 2-1和2-2，2-2和2-3，3-1和3-2，3-2和3-3共4对冲突，2组和3组组内冲突，组间没有关联。 branch.s： 123456789101112131415161718.textmain:ADDI $r2,$r0,1024 # 1-1ADD $r3,$r0,$r0 # 1-2ADDI $r4,$r0,8 # 1-3loop: LW $r1,0($r2) # 2-1ADDI $r1,$r1,1 # 2-2SW $r1,0($r2) # 2-3ADDI $r3,$r3,4 # 3-1SUB $r5,$r4,$r3 # 3-2BGTZ $r5,loop # 3-3ADD $r7,$r0,$r6 # 4-1TEQ $r0,$r0 # 5-1 假设延迟槽为一个，自己对 branch.s 程序进行指令调度（自己修改源程序），将调度后的程序重新命名为 delayed-branch.s。 载入 delayed-branch.s，打开延迟分支功能，执行该程序，观察其时钟周期图，记录程序执行的总时钟周期数。 PS：调度后的程序见附录。 载入的程序： 执行结果： 寄存器的值 与不调度前完全一致，调度没有改变结果，调度正确。 部分时钟周期图 统计 发现总共执行了25个周期，执行了19条指令，4次RAW停顿，RAW停顿有4个周期，RAW停顿占周期总数的百分比为16%，较没有静态调度的42.10526%少了很多，控制停顿有0个周期，占周期总数的百分比为0%，比没有使用延迟分支技术的5.263158%少了，所有的停顿为5个周期，占周期总数的百分比为20%，较没有静态调度和延迟分支技术的50%也减少了。可以发现使用延迟分支技术后，控制停顿消失了。$$吞吐率TP_2=\\frac{19}{25\\Delta{t}}$$ $$加速比S_2=\\frac{19\\times{5\\Delta{t}}}{25\\Delta{t}}={3.8}$$ 吞吐率和加速比是没有静态调度和延迟分支技术时的$\\frac{19\\times{38}}{25\\times{18}}\\approx{1.60}$倍。 四、实验结论​ 静态调度优化代码和定向技术都能在一定程度上减少甚至消除数据冲突，尤其是RAW停顿，可以很好地提高性能，但是这两种方法对分支控制停顿没有任何帮助。但是延迟分支技术是由编译器通过重排指令序列，在分支指令后紧跟一条或几条延迟槽指令，不管分支是否成功，都顺序执行延迟槽中的指令，从而逻辑上“延长”分支指令的执行时间，减少甚至消除了控制停顿。因此这几种方法都能大幅度的减少停顿，从而提高CPU性能。 ​ 在查看延迟分支技术的统计信息时，发现使用延迟分支技术比不使用延迟分支技术多执行了一条指令，可能是由于分支取消机制当分支的实际执行方向和事先所预测的一样时，执行分支延迟槽中的指令，否则就将分支延迟槽中的指令转化成一个空操作，这条指令确实已经执行了，只是分支条件判断完后发现不该执行，然后就将执行的回滚，因此比不使用延迟分支技术多执行了一条指令。 五、附录1、after-schedule.s123456789101112131415161718192021222324.textmain:ADDIU $r1,$r0,A # 1-1MUL $r24,$r26,$r14 # 6-1MUL $r12,$r10,$r1 # 4-1LW $r2,0($r1) # 2-1LW $r6,4($r1) # 3-1ADD $r16,$r12,$r1 # 4-2ADD $r4,$r0,$r2 # 2-2LW $r20,8($r1) # 5-1ADD $r18,$r16,$r1 # 4-3SW $r4,0($r1) # 2-3MUL $r22,$r20,$r14 # 5-2SW $r18,16($r1) # 4-4ADD $r8,$r6,$r1 # 3-2TEQ $r0,$r0 # 7-1.dataA: .word 4,6,8 2、delay-branch.s1234567891011121314151617.textmain:ADDI $r2,$r0,1024 # 1-1ADD $r3,$r0,$r0 # 1-2ADDI $r4,$r0,8 # 1-3loop: LW $r1,0($r2) # 2-1ADDI $r3,$r3,4 # 3-1ADDI $r1,$r1,1 # 2-2SUB $r5,$r4,$r3 # 3-2SW $r1,0($r2) # 2-3BGTZ $r5,loop # 3-3ADD $r7,$r0,$r6 # 4-1TEQ $r0,$r0 # 5-1","categories":[{"name":"计算机系统结构","slug":"计算机系统结构","permalink":"https://666wxy666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"},{"name":"实验","slug":"计算机系统结构/实验","permalink":"https://666wxy666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"实验","slug":"实验","permalink":"https://666wxy666.github.io/tags/%E5%AE%9E%E9%AA%8C/"},{"name":"计算机系统结构","slug":"计算机系统结构","permalink":"https://666wxy666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"},{"name":"汇编","slug":"汇编","permalink":"https://666wxy666.github.io/tags/%E6%B1%87%E7%BC%96/"},{"name":"MIPS","slug":"MIPS","permalink":"https://666wxy666.github.io/tags/MIPS/"}]},{"title":"Linux 上机实战3 shell脚本程序设计","slug":"Linux-上机实战3-shell脚本程序设计","date":"2020-05-09T16:00:00.000Z","updated":"2020-09-02T02:00:42.550Z","comments":true,"path":"2020/05/10/Linux-上机实战3-shell脚本程序设计/","link":"","permalink":"https://666wxy666.github.io/2020/05/10/Linux-%E4%B8%8A%E6%9C%BA%E5%AE%9E%E6%88%983-shell%E8%84%9A%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","excerpt":"本文是关于Linux中的shell脚本程序设计，有几个小Demo。","text":"本文是关于Linux中的shell脚本程序设计，有几个小Demo。 一、题目要求1、生成TCP 活动状况报告​ netstat –statistics 命令可以列出tcp等协议的统计信息。编写 shell 脚本程序，每隔1分钟生成1行信息：当前时间；这一分钟内 TCP 发送了多少报文；接收了多少报文；收发报文总数；行尾给出符号+或-或空格（+表示这分钟收发报文数比上分钟多10包以上，差别在 10 包或以内用空格，否则用符号-）。 运行示例如下： 2、下载bing 图库中图片​ 编写脚本程序bing.sh ，将访问这个图库中照片全部下载下来存放到本地 bing 目录中，上面 URL 中p=23 可以换成 p=1 到p=126 可访问 126 个页，每页有 12 个图，每个图的日期，中文说明信息和下载地址及文件名 html 文件中可提取。要求下载后的文件命名为“ 日期 中文说明 .jpg ” 例如 2019-08-03 野花草甸上的一只欧亚雕鸮，德国莱茵兰 普法尔茨 .jpg 命令行参数./bing.sh 后面可以跟两个参数，通过指定页号区间限定下载范围，没有参数时页号区间为 1-126。 要允许多个程序并发 例如：一个终端上启动 ./bing.sh 1 63 ，另一个终端上启动 ./bing.sh 64 126 ，这样在两个终端上同时下载，以加快任务完成的速度。 不重复下载已下载的图片 检查图片是否已下载，如果已下载，则不再下载，这样在一定程度上支持批量任务在被中断后可以从断点继续。 考虑下载文件出现故障的情况 如果一 个图片有 5MB ，接收 1.5MB 后网络断开，则残存一个不完整的图片文件。避免这种现象发生的一种方法是， wget 下载时使用一个临时文件名。判断 wget 是否成功，若成功则将文件改名为正式名称；若失败，删除临时文件。临时文件名的选取要考虑前述的并发问题，至少不可以固定一个名字导致两进程的争夺。 3、选做：获取更多图片对已设计好的bing sh 进一步扩充，允许下面的命令行参数： 1./bing.sh rand 500 实现的功能为：执行500 次随机获取。每次成功的随机获取会得到一个图片，检查一下这个图片是否本地已存在。如果已存在，丢弃，否则保存。 访问https ://bing.ioliu.cn/v1/rand? json 可得到一个 json 数据，每次得到的内容是随机的，其中含有图片的日期、说明信息和获取它的 url 网址。新获得的文件命名方式与以前的程序相同。要求：文件名不同但是内容完全相同的图片丢弃，例如，下面两个文件虽然名字不同，但是内容是一样的，只保留其中一个文件。 2019-05-03 Ruff male displaying its plumage, Varanger Peninsula, Norway.jpg 2019-05-02 挪威瓦朗厄尔半岛上一只展示翎颌的雄性涉禽.jpg 二、实验环境系统：Manjaro 20.0 基于 Arc Linux 编辑器：Visual Studio Code 三、实验步骤1、生成TCP 活动状况报告 先在终端中运行命令查看输出 1netstat --statistics 可以在Tcp下看到相关信息，我们感兴趣的内容是的上图红框圈起的部分，因此我们可以使用正则表达式配合grep、sed、awk命令，将它取出来。 1netstat --statistics | grep segments 发现还不够，继续使用grep提取： 1netstat --statistics | grep '[0-9][0-9]* segments 再添加一个过滤条件，最终成功获取了所需信息。 1netstat --statistics | grep '[0-9][0-9]* segments [rs][e][cn] 这样，我们就可以直接使用awk命令，获取所需的列即可。 1netstat --statistics | awk '/[0-9][0-9]* segments [rs][e][cn]/ &#123;print $1&#125;' 使用date命令，可以获取当前日期时间。 1date '+%Y-%m-%d %H:%M' 因为要隔一分钟获取一次，程序的基本框架就是： 详细的代码以及注释在最后的附录中，这里不再展示。 编写完后运行net.sh，发现不能运行，加上可执行权限即可。 1chmod u+x net.sh 运行程序 1./net.sh 2、下载bing 图库中图片 先去bing图库看一下网页的源码。 打开开发者工具。 我们感兴趣的内容即为下图中用红框圈起的3个部分。 使用wget命令尝试下载网页和图片。 12wget -O 1.html https://bing.ioliu.cn/\\?p\\=1wget -O photo.jpg http://h1.ioliu.cn/bing/WhiteStorksNest_ZH-CN9809680903_640x480.jpg\\?imageslim 查看下载的内容。 网页： 1vi 1.html 图片： 下面进行把html中我们感兴趣的内容通过正则表达式配合grep、sed、awk命令，将它取出来。 文字介绍 先将无用的标签删除。 1cat 1.html | sed 's/&lt;[^&lt;&gt;]*&gt;/\\n/g' | more 发现我们想要的文字介绍都有符号“©”，因此使用awk可以轻松取出。 1cat 1.html | sed 's/&lt;[^&lt;&gt;]*&gt;/\\n/g' | awk '/©/ &#123; print $0 &#125;' | more 最后，使用sed把后面无用的（）中的内容去掉即可。 1cat 1.html | sed 's/&lt;[^&lt;&gt;]*&gt;/\\n/g' | awk '/©/ &#123; print $0 &#125;' | sed 's/(.*)//g' | more 日期 同样是先将无用的标签去掉，发现日期有共同的特点就是“数字-数字-数字”，因此用awk即可取出。 1cat 1.html | sed 's/&lt;[^&lt;&gt;]*&gt;/\\n/g' | awk '/[0-9][0-9]*-[0-9][0-9]*-[0-9][0-9]*/ &#123; print $0 &#125;' | more 网址 因为网址在标签中，我们就不能先将标签取出了。发现我们所需的内容在一行中，不好操作，因此先将“src=””替换为换行，刚好使我们所需的网址位于每行的开头。 1cat 1.html | sed 's/src=\"/\\n/g' | more 发现所有的网址都以“http:”开头，因此使用awk即可轻松取出。 1cat 1.html | sed 's/src=\"/\\n/g' | awk '/^http:/ &#123; print $1 &#125;' | more 最后，用sed删掉行尾无用的内容即可。 1cat 1.html | sed 's/src=\"/\\n/g' | awk '/^http:/ &#123; print $1 &#125;' | sed 's/\"&gt;&lt;a//g' | more 最新版本修复了分辨率的问题，再使用sed将640x480改为1920x1080即可。 1cat 1.html | sed 's/src=\"/\\n/g' | awk '/^http:/ &#123; print $1 &#125;' | sed -e 's/\"&gt;&lt;a//g' -e 's/640x480/1920x1080/g' | more 详细的代码和注释见最后的附录。 运行程序，依然需要先赋予执行权限。 1sudo chmod u+x bing.sh 不带参数 1./bing.sh 发现程序正常运行。 在运行过程中故意强制退出。 因为程序强制退出，会留下一个下载未完全的文件。但是完全不会受到影响，下一次运行时，会自动接续下载。 两个参数 1./bing.sh 1 3 因为上一个命令已经下载了一部分，已经下载过的不会再下载，接着上一次下载的位置继续下载。 下载完成。 查看下载的图片，发现是刚好36张，1-3页。 一个参数（自己额外实现的功能） 如果只输入一个参数，那么将从第一页下载到输入的参数页数。 1./bing 2 因为上面已经下载了1-3页，因此不会重复下载。 并发执行（自己额外实现的功能，下载的内容有冲突） 终端1： 1./bing.sh 终端2： 1./bing.sh 1 3 我写的代码，专门考虑了并发的情况，使用当前进程id作为缓冲文件名，从而不会与其他的程序产生冲突。我额外实现了，并发执行时，即使下载的内容有冲突，也不会产生错误。但是可能有一个小问题就是如果第一个程序检测到了a图片没有下载，开始下载了，但是在第一个程序还没下载完成时，刚好第二个程序也检测到了a图片没有下载，可能会重复下载，但是如果第二个程序检测到了a图片已经下载完成，则不会重复下载，所以也无伤大雅，不会产生致命错误。 查看下载的图片： 并发执行（下载的内容无冲突） 终端1： 1./bing.sh 1 3 终端2： 1./bing.sh 4 6 如果下载的内容没有冲突就更不会产生任何问题了。 完美下载完成。 查看下载的图片，刚好是72张，1-6页。 差错处理 各种错误处理的情况： 3、选做：获取更多图片 先访问网址https://bing.ioliu.cn/v1/rand?type=json查看json文件的格式 把json中我们感兴趣的内容通过正则表达式配合grep、sed、awk命令，将它取出来： 这些都比较简单，根据json的key就很轻松的取出来了 文字介绍 1cat bing/$$.json | sed 's/.*\"copyright\":\"\\(.*\\)(.*©.*)\"&#125;,.*/\\1/g' 日期 1cat bing/$$.json | sed 's/.*\"enddate\":\"\\([0-9][0-9][0-9][0-9]\\)\\([0-9][0-9]\\)\\([0-9][0-9]\\)\",.*/\\1-\\2-\\3/g' 网址 1cat bing/$$.json | sed 's/.*\"url\":\"\\(http:.*imageslim\\)\",.*/\\1/g' 详细的代码和注释见最后的附录。 运行程序，依然需要先赋予执行权限。 PS：v2.0在v1.0的基础上进行了修改，优化了部分代码，除了这次的功能，完全保留了v1.0的功能，并且random模式也可以并发，就不展示了。 查看下载的图片： 差错处理 各种错误处理的情况： 4、升级版bing.sh在bing2.sh的基础上升级的v3.0版的bing3.sh，优化了bing2.sh的部分判断逻辑和代码，相较于bing2.sh移除了diff和cmp比较，使用了更为高效的md5比较，且将md5校验信息存到文件中，供下次使用，加速判断。 运行截图： 这里都是展示了更为高级的并发下载的情况，非并发就不再展示了。 两个终端分别进行： 1./bing3.sh 1 3 1./bing3.sh 1 4 结果： 完美执行成功，且已经下载过的不会重复下载： 查看图片： 刚好1-4页48个图片加1个md5校验文件，共49个文件 md5校验文件md5.txt也成功生成了。 两个终端分别进行： 1./bing3.sh rand 10 1./bing3.sh rand 10 结果： 查看图片： 5、小修复修复了分辨率过小，导致下载的图片不清晰的问题，现在分辨率统一为1920x1080。 由文件大小也可以看出，分辨率已经给更改。 打开图片查看，图片已经很清晰了，分辨率为1920x1080。 四、实验总结及感受​ 在这次实验中，明显感受到了shell脚本程序的编程和C语言等有很大的差别，尤为要注意各种双引号，单引号，空格啊之类的，拉下来就完全错误。在实验中还遇到了一个很有意思的小问题，就是echo命令如果后面的变量中有换行的话，直接使用： 1echo $xxx 会将换行变成空格，但是如果加上双引号括起来，就能正常输出换行了： 1echo \"$xxx\" 在实验中还熟悉了各种分支循环命令的使用，在shell中的printf格式化输出，并且复习了前面学习的正则表达式和grep、sed、awk文本处理三剑客，收获很大。 五、项目地址本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看： 源码仓库 六、附录1、net.sh12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273### # @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. # @Description: 生成TCP 活动状况报告 # @Version: v1.0 # @Author: 苇名一心 # @Date: 2020-04-30 11:26:28 # @LastEditors: 苇名一心 # @LastEditTime: 2020-05-01 23:19:04 #### 获取时间date_time=`date '+%Y-%m-%d %H:%M'`# 这一分钟开始时的TCP报文数data1=`netstat --statistics | grep '[0-9][0-9]* segments [rs][e][cn]'`# 发送send1=`echo $data1 | awk '&#123;print $4&#125;'`# 接收recv1=`echo $data1 | awk '&#123;print $1&#125;'`# 等60ssleep 60# 这一分钟结束时的TCP报文数data_temp=`netstat --statistics | grep '[0-9][0-9]* segments [rs][e][cn]'`# 发送send_temp=`echo $data_temp | awk '&#123;print $4&#125;'`# 接收recv_temp=`echo $data_temp | awk '&#123;print $1&#125;'`# 这一分钟内发送的TCP报文数send=`expr $send_temp - $send1`# 这一分钟内接收的TCP报文数recv=`expr $recv_temp - $recv1`# 这一分钟内收发TCP报文总数sum_temp=`expr $send + $recv`# 输出,第一次输出不加最后的符号printf '%-16s%8s%8s%8s\\n' \"$date_time\" \"$send\" \"$recv\" \"$sum_temp\"while truedo # 获取时间 date_time=`date '+%Y-%m-%d %H:%M'` # 等60s sleep 60 # 一分钟后的TCP报文数 data2=`netstat --statistics | grep '[0-9][0-9]* segments [rs][e][cn]'` # 发送 send2=`echo $data2 | awk '&#123;print $4&#125;'` # 接收 recv2=`echo $data2 | awk '&#123;print $1&#125;'` # 这一分钟内发送的TCP报文数 send=`expr $send2 - $send_temp` # 这一分钟内接收的TCP报文数 recv=`expr $recv2 - $recv_temp` # 这一分钟内收发TCP报文总数 sum2=`expr $send + $recv` # 判断最后的符号 # 后-前&gt;10,为+ if [ `expr $sum2 - $sum_temp` -gt 10 ] then sign='+' # 前-后&gt;10,为- elif [ `expr $sum_temp - $sum2` -gt 10 ] then sign='-' # 其他情况,为空格 else sign=' ' fi # 输出 printf '%-16s%8s%8s%8s%5s\\n' \"$date_time\" \"$send\" \"$recv\" \"$sum2\" \"$sign\" # 保留上一次的数据,用于下一次比较 send_temp=$send2 recv_temp=$recv2 sum_temp=$sum2done 2、bing.sh123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144### # @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. # @Description: 下载bing 图库中图片 # @Version: 1.0 # @Author: 苇名一心 # @Date: 2020-05-01 08:54:37 # @LastEditors: 苇名一心 # @LastEditTime: 2020-05-05 21:55:22 #### 错误代号:# 1: 参数输入格式错误# 2: 输入的页数非整数# 3: 输入的页数范围不在[1,126]# 4: 开始页数&lt;结束页数# 5: 获取下载页面失败# 6: 获取下载图片失败NONE=\"\\e[0m\"RED=\"\\e[0;31m\"# 读取命令行参数，并进行错误处理if [ $# = 0 ]then start_page=1 end_page=126# 额外增加了一个，如果只输入一个参数，代表从第1页到输入的参数的页数elif [ $# = 1 ]then start_page=1 end_page=$1elif [ $# = 2 ]then start_page=$1 end_page=$2else printf $RED'Error: Please input the right arguments\\n'$NONE echo \"Usage: $0 [start page] [end page] download photos in pages from [start page] to [end page]\" echo \" or: $0 [end page] download photos in pages from [1] to [end page]\" echo \" or: $0 (with no arguments) download photos in pages from 1 to 126 by default\" exit 1fi# 输入的页数非整数if ! expr $start_page + 0 &gt; /dev/null 2&gt;&amp;1 || ! expr $end_page + 0 &gt; /dev/null 2&gt;&amp;1then printf $RED'Error: Your input page is not an integer\\n'$NONE echo \"Usage: $0 [start page] [end page] download photos in pages from [start page] to [end page]\" echo \" or: $0 [end page] download photos in pages from [1] to [end page]\" echo \" or: $0 (with no arguments) download photos in pages from 1 to 126 by default\" exit 2fi# 输入的页数范围不在[1,126]if [ $start_page -lt 1 -o $end_page -lt 1 -o $start_page -gt 126 -o $end_page -gt 126 ]then printf $RED'Error: Your input page not in the range [1,126]\\n'$NONE echo \"Usage: $0 [start page] [end page] download photos in pages from [start page] to [end page]\" echo \" or: $0 [end page] download photos in pages from [1] to [end page]\" echo \" or: $0 (with no arguments) download photos in pages from 1 to 126 by default\" exit 3fi# 开始页数&lt;结束页数if [ $start_page -gt $end_page ]then printf $RED'Error: Your input [start_page] &gt; [end page]\\n'$NONE echo \"Usage: $0 [start page] [end page] download photos in pages from [start page] to [end page]\" echo \" or: $0 [end page] download photos in pages from [1] to [end page]\" echo \" or: $0 (with no arguments) download photos in pages from 1 to 126 by default\" exit 4fiecho \"Your input page range is [$start_page,$end_page]\"# 判断并创建目录if [ ! -d bing ]then mkdir bing echo \"Work directory bing is created\"fi# 缓存目录这里使用当前进程ID号作为区分，防止受到影响，下面下载图片使用$$.jpg作为缓存也是同样的道理if [ ! -d bing/html_$$ ]then mkdir bing/html_$$ echo \"Cache directory bing/html_$$ is created\"fi# 对页范围内的循环下载for i in `seq $start_page $end_page`do # 判断是否已经下载 if [ ! -f bing/html_$$/$i.html ] then echo \"Download page $i……\" if wget -O bing/html_$$/$i.html \"https://bing.ioliu.cn/?p=$i\" &gt; /dev/null 2&gt;&amp;1 then echo \"Page $i download successfully\" else if [ -f bing/html_$$/$i.html ] then rm bing/html_$$/$i.html fi printf $RED\"Error: Page $i download failed\\n\"$NONE exit 5 fi else echo \"Page $i already exists\" fi # 获取该页所以图片信息 name_list=`cat bing/html_$$/$i.html | sed 's/&lt;[^&lt;&gt;]*&gt;/\\n/g' | awk '/©/ &#123; print $0 &#125;' | sed 's/(.*)//g'` date_list=`cat bing/html_$$/$i.html | sed 's/&lt;[^&lt;&gt;]*&gt;/\\n/g' | awk '/[0-9][0-9]*-[0-9][0-9]*-[0-9][0-9]*/ &#123; print $0 &#125;'` url_list=`cat bing/html_$$/$i.html | sed 's/src=\"/\\n/g' | awk '/^http:/ &#123; print $1 &#125;' | sed -e 's/\"&gt;&lt;a//g' -e 's/640x480/1920x1080/g'` # 对该页内图片循环下载 for j in `seq 1 12` do # 获取图片信息 name=`echo \"$name_list\" | awk \"NR==$j\"` date=`echo \"$date_list\" | awk \"NR==$j\"` url=`echo \"$url_list\" | awk \"NR==$j\"` file_name=\"$date $name.jpg\" # 清理残留缓存 if [ -f \"bing/$$.jpg\" ] then rm \"bing/$$.jpg\" fi # 判断是否已经下载 if [ ! -f \"bing/$file_name\" ] then echo \"Download photo $i-$j……\" if wget -O bing/$$.jpg \"$url\" &gt; /dev/null 2&gt;&amp;1 then mv \"bing/$$.jpg\" \"bing/$file_name\" echo \"Photo $i-$j download successfully\" else printf $RED\"Error: Photo $i-$j download failed\\n\"$NONE exit 6 fi else echo \"Photo $i-$j already exists\" fi donedone# 清理缓存echo \"Cleaning……\"if [ -d bing/html_$$ ]then rm -r bing/html_$$fiecho \"All done,Thanks for using!\" 3、bing2.sh123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261### # @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. # @Description: # @Version: 2.0 # @Author: 苇名一心 # @Date: 2020-05-01 08:54:37 # @LastEditors: 苇名一心 # @LastEditTime: 2020-05-08 22:01:41 #### 错误代号:# 1: 参数输入格式错误# 2: 输入的页数非整数# 3: 输入的页数范围不在[1,126]# 4: 开始页数&lt;结束页数# 5: 下载页面失败# 6: 下载图片失败# 7: 输入的随机次数非整数# 8: 输入的随机次数&lt;1# 9: 下载json失败# 10: 未知错误NONE=\"\\e[0m\"RED=\"\\e[0;31m\"# rand=0，代表普通模式；rand&gt;0代表随机模式，rand的数值代表随机的次数rand=0# 读取命令行参数，并进行错误处理if [ $# = 0 ]then start_page=1 end_page=126# 额外增加了一个，如果只输入一个参数，代表从第1页到输入的参数的页数elif [ $# = 1 ]then start_page=1 end_page=$1elif [ $# = 2 ]then # 随机模式 if [ $1 = 'rand' ] then # 判断第二个参数是否为整数 if expr $2 + 0 &gt; /dev/null 2&gt;&amp;1 then # 输入的随机次数&lt;1 if [ $2 -lt 1 ] then printf $RED'Error: Your input [rand times] &lt; 1\\n'$NONE echo \"Usage: $0 [start page] [end page] download photos in pages from [start page] to [end page]\" echo \" or: $0 [end page] download photos in pages from [1] to [end page]\" echo \" or: $0 (with no arguments) download photos in pages from [1] to [126] by default\" echo \" or: $0 rand [rand times] rand download photos of [rand times]\" exit 8 else rand=$2 fi # 输入的随机次数非整数 else printf $RED'Error: Your input [rand times] is not an integer\\n'$NONE echo \"Usage: $0 [start page] [end page] download photos in pages from [start page] to [end page]\" echo \" or: $0 [end page] download photos in pages from [1] to [end page]\" echo \" or: $0 (with no arguments) download photos in pages from [1] to [126] by default\" echo \" or: $0 rand [rand times] rand download photos of [rand times]\" exit 7 fi # 普通模式 else start_page=$1 end_page=$2 # 输入的页数非整数 if ! expr $start_page + 0 &gt; /dev/null 2&gt;&amp;1 || ! expr $end_page + 0 &gt; /dev/null 2&gt;&amp;1 then printf $RED'Error: Your input page is not an integer\\n'$NONE echo \"Usage: $0 [start page] [end page] download photos in pages from [start page] to [end page]\" echo \" or: $0 [end page] download photos in pages from [1] to [end page]\" echo \" or: $0 (with no arguments) download photos in pages from [1] to [126] by default\" echo \" or: $0 rand [rand times] rand download photos of [rand times]\" exit 2 fi # 输入的页数范围不在[1,126] if [ $start_page -lt 1 -o $end_page -lt 1 -o $start_page -gt 126 -o $end_page -gt 126 ] then printf $RED'Error: Your input page not in the range [1,126]\\n'$NONE echo \"Usage: $0 [start page] [end page] download photos in pages from [start page] to [end page]\" echo \" or: $0 [end page] download photos in pages from [1] to [end page]\" echo \" or: $0 (with no arguments) download photos in pages from [1] to [126] by default\" echo \" or: $0 rand [rand times] rand download photos of [rand times]\" exit 3 fi # 开始页数&lt;结束页数 if [ $start_page -gt $end_page ] then printf $RED'Error: Your input [start_page] &gt; [end page]\\n'$NONE echo \"Usage: $0 [start page] [end page] download photos in pages from [start page] to [end page]\" echo \" or: $0 [end page] download photos in pages from [1] to [end page]\" echo \" or: $0 (with no arguments) download photos in pages from [1] to [126] by default\" echo \" or: $0 rand [rand times] rand download photos of [rand times]\" exit 4 fi fi# 参数输入格式错误else printf $RED'Error: Please input the right arguments\\n'$NONE echo \"Usage: $0 [start page] [end page] download photos in pages from [start page] to [end page]\" echo \" or: $0 [end page] download photos in pages from [1] to [end page]\" echo \" or: $0 (with no arguments) download photos in pages from [1] to [126] by default\" echo \" or: $0 rand [rand times] rand download photos of [rand times]\" exit 1fi# 判断并创建工作目录if [ ! -d bing ]then mkdir bing echo \"Work directory bing is created\"fi# 普通模式if [ $rand -eq 0 ]then echo \"##############Regular Mode##############\" echo \"Your input page range is [$start_page,$end_page]\" # 对页范围内的循环下载 for i in `seq $start_page $end_page` do # 缓存文件使用当前进程ID号$$.html命名，防止受到影响，下面下载图片使用$$.jpg作为缓存也是同样的道理 echo \"Download page $i……\" if wget -O bing/$$.html \"https://bing.ioliu.cn/?p=$i\" &gt; /dev/null 2&gt;&amp;1 then echo \"Page $i download successfully\" else if [ -f bing/$$.html ] then rm bing/$$.html fi printf $RED\"Error: Page $i download failed\\n\"$NONE exit 5 fi # 获取该页所以图片信息 name_list=`cat bing/$$.html | sed 's/&lt;[^&lt;&gt;]*&gt;/\\n/g' | awk '/©/ &#123; print $0 &#125;' | sed 's/(.*)//g'` date_list=`cat bing/$$.html | sed 's/&lt;[^&lt;&gt;]*&gt;/\\n/g' | awk '/[0-9][0-9]*-[0-9][0-9]*-[0-9][0-9]*/ &#123; print $0 &#125;'` url_list=`cat bing/$$.html | sed 's/src=\"/\\n/g' | awk '/^http:/ &#123; print $1 &#125;' | sed -e 's/\"&gt;&lt;a//g' -e 's/640x480/1920x1080/g'` # 对该页内图片循环下载 for j in `seq 1 12` do # 获取图片信息 name=`echo \"$name_list\" | awk \"NR==$j\"` date=`echo \"$date_list\" | awk \"NR==$j\"` url=`echo \"$url_list\" | awk \"NR==$j\"` file_name=\"$date $name.jpg\" # 判断是否已经下载 if [ ! -f \"bing/$file_name\" ] then echo \"Download photo $i-$j……\" if wget -O bing/$$.jpg \"$url\" &gt; /dev/null 2&gt;&amp;1 then mv \"bing/$$.jpg\" \"bing/$file_name\" echo \"Photo $i-$j download successfully\" else printf $RED\"Error: Photo $i-$j download failed\\n\"$NONE exit 6 fi else echo \"Photo $i-$j already exists\" fi done done # 清理缓存 echo \"Cleaning……\" rm bing/$$.html# 随机模式elif [ $rand -gt 0 ]then echo \"##############Random Mode##############\" echo \"Your input rand times is $rand\" # 循环随机下载 for k in `seq 1 $rand` do # 获取json if wget -O bing/$$.json \"https://bing.ioliu.cn/v1/rand?type=json\" &gt; /dev/null 2&gt;&amp;1 then # 获取图片信息 name=`cat bing/$$.json | sed 's/.*\"copyright\":\"\\(.*\\)(.*©.*)\"&#125;,.*/\\1/g'` date=`cat bing/$$.json | sed 's/.*\"enddate\":\"\\([0-9][0-9][0-9][0-9]\\)\\([0-9][0-9]\\)\\([0-9][0-9]\\)\",.*/\\1-\\2-\\3/g'` url=`cat bing/$$.json | sed 's/.*\"url\":\"\\(http:.*imageslim\\)\",.*/\\1/g'` file_name=\"$date $name.jpg\" # 判断是否已经下载，先用文件名判断 if [ ! -f \"bing/$file_name\" ] then echo \"Download photo $k……\" if wget -O bing/$$ \"$url\" &gt; /dev/null 2&gt;&amp;1 then # 文件名不存在的，判断是否有文件大小相同的和内容相同的 same=0 for file in bing/*.jpg do # 先判断bing文件夹中是否有.jpg文件，如果没有的话*不会被替换，会出错 if [ \"$file\" = 'bing/*.jpg' ] then break fi # 先比较文件大小是否相同，加快速度 if [ `stat -c%s \"$file\"` = `ls -l \"bing/$$\" | awk '&#123; print $5 &#125;'` ] then # 大小相同再比较内容 # diff命令主要用于比较文本文件，比较二进制文件效率较低 # if diff \"$file\" \"bing/$$\" &gt; /dev/null # then # # 相同 # same=1 # break # fi # md5sum计算文件md5值，进行比较 # if [ `md5sum \"$file\" | awk '&#123; print $1 &#125;'` = `md5sum \"bing/$$\" | awk '&#123; print $1 &#125;'` ] # then # # 相同 # same=1 # break # fi # cmp命令是逐字节比较 if cmp -s \"$file\" \"bing/$$\" then # 相同 same=1 break fi fi done if [ $same = 1 ] then rm bing/$$ echo \"Photo $k already exists\" else mv \"bing/$$\" \"bing/$file_name\" echo \"Photo $k download successfully\" fi else printf $RED\"Error: Photo $k download failed\\n\"$NONE exit 6 fi else echo \"Photo $k already exists\" fi else if [ -f bing/$$.json ] then rm bing/$$.json fi printf $RED\"Error: Json $k download failed\\n\"$NONE exit 9 fi done # 清理缓存 echo \"Cleaning……\" rm bing/$$.json# 未知错误else printf $RED\"Error: Unkonwn error\\n\"$NONE exit 10fiecho \"All done,Thanks for using!\" 3、bing3.sh123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275### # @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. # @Description: # @Version: 3.0 # @Author: 苇名一心 # @Date: 2020-05-01 08:54:37 # @LastEditors: 苇名一心 # @LastEditTime: 2020-05-08 22:04:23 #### 错误代号:# 1: 参数输入格式错误# 2: 输入的页数非整数# 3: 输入的页数范围不在[1,126]# 4: 开始页数&lt;结束页数# 5: 下载页面失败# 6: 下载图片失败# 7: 输入的随机次数非整数# 8: 输入的随机次数&lt;1# 9: 下载json失败# 10: 未知错误NONE=\"\\e[0m\"RED=\"\\e[0;31m\"# rand=0，代表普通模式；rand&gt;0代表随机模式，rand的数值代表随机的次数rand=0# 读取命令行参数，并进行错误处理if [ $# = 0 ]then start_page=1 end_page=126# 额外增加了一个，如果只输入一个参数，代表从第1页到输入的参数的页数elif [ $# = 1 ]then start_page=1 end_page=$1elif [ $# = 2 ]then # 随机模式 if [ $1 = 'rand' ] then # 判断第二个参数是否为整数 if expr $2 + 0 &gt; /dev/null 2&gt;&amp;1 then # 输入的随机次数&lt;1 if [ $2 -lt 1 ] then printf $RED'Error: Your input [rand times] &lt; 1\\n'$NONE echo \"Usage: $0 [start page] [end page] download photos in pages from [start page] to [end page]\" echo \" or: $0 [end page] download photos in pages from [1] to [end page]\" echo \" or: $0 (with no arguments) download photos in pages from [1] to [126] by default\" echo \" or: $0 rand [rand times] rand download photos of [rand times]\" exit 8 else rand=$2 fi # 输入的随机次数非整数 else printf $RED'Error: Your input [rand times] is not an integer\\n'$NONE echo \"Usage: $0 [start page] [end page] download photos in pages from [start page] to [end page]\" echo \" or: $0 [end page] download photos in pages from [1] to [end page]\" echo \" or: $0 (with no arguments) download photos in pages from [1] to [126] by default\" echo \" or: $0 rand [rand times] rand download photos of [rand times]\" exit 7 fi # 普通模式 else start_page=$1 end_page=$2 # 输入的页数非整数 if ! expr $start_page + 0 &gt; /dev/null 2&gt;&amp;1 || ! expr $end_page + 0 &gt; /dev/null 2&gt;&amp;1 then printf $RED'Error: Your input page is not an integer\\n'$NONE echo \"Usage: $0 [start page] [end page] download photos in pages from [start page] to [end page]\" echo \" or: $0 [end page] download photos in pages from [1] to [end page]\" echo \" or: $0 (with no arguments) download photos in pages from [1] to [126] by default\" echo \" or: $0 rand [rand times] rand download photos of [rand times]\" exit 2 fi # 输入的页数范围不在[1,126] if [ $start_page -lt 1 -o $end_page -lt 1 -o $start_page -gt 126 -o $end_page -gt 126 ] then printf $RED'Error: Your input page not in the range [1,126]\\n'$NONE echo \"Usage: $0 [start page] [end page] download photos in pages from [start page] to [end page]\" echo \" or: $0 [end page] download photos in pages from [1] to [end page]\" echo \" or: $0 (with no arguments) download photos in pages from [1] to [126] by default\" echo \" or: $0 rand [rand times] rand download photos of [rand times]\" exit 3 fi # 开始页数&lt;结束页数 if [ $start_page -gt $end_page ] then printf $RED'Error: Your input [start_page] &gt; [end page]\\n'$NONE echo \"Usage: $0 [start page] [end page] download photos in pages from [start page] to [end page]\" echo \" or: $0 [end page] download photos in pages from [1] to [end page]\" echo \" or: $0 (with no arguments) download photos in pages from [1] to [126] by default\" echo \" or: $0 rand [rand times] rand download photos of [rand times]\" exit 4 fi fi# 参数输入格式错误else printf $RED'Error: Please input the right arguments\\n'$NONE echo \"Usage: $0 [start page] [end page] download photos in pages from [start page] to [end page]\" echo \" or: $0 [end page] download photos in pages from [1] to [end page]\" echo \" or: $0 (with no arguments) download photos in pages from [1] to [126] by default\" echo \" or: $0 rand [rand times] rand download photos of [rand times]\" exit 1fi# 判断并创建工作目录if [ ! -d bing ]then mkdir bing echo \"Work directory bing is created\"fi# 普通模式if [ $rand -eq 0 ]then echo \"##############Regular Mode##############\" echo \"Your input page range is [$start_page,$end_page]\" # 对页范围内的循环下载 for i in `seq $start_page $end_page` do # 缓存文件使用当前进程ID号$$.html命名，防止受到影响，下面下载图片使用$$.jpg作为缓存也是同样的道理 echo \"Download page $i……\" if wget -O bing/$$.html \"https://bing.ioliu.cn/?p=$i\" &gt; /dev/null 2&gt;&amp;1 then echo \"Page $i download successfully\" else if [ -f bing/$$.html ] then rm bing/$$.html fi printf $RED\"Error: Page $i download failed\\n\"$NONE exit 5 fi # 获取该页所以图片信息 name_list=`cat bing/$$.html | sed 's/&lt;[^&lt;&gt;]*&gt;/\\n/g' | awk '/©/ &#123; print $0 &#125;' | sed 's/(.*)//g'` date_list=`cat bing/$$.html | sed 's/&lt;[^&lt;&gt;]*&gt;/\\n/g' | awk '/[0-9][0-9]*-[0-9][0-9]*-[0-9][0-9]*/ &#123; print $0 &#125;'` url_list=`cat bing/$$.html | sed 's/src=\"/\\n/g' | awk '/^http:/ &#123; print $1 &#125;' | sed -e 's/\"&gt;&lt;a//g' -e 's/640x480/1920x1080/g'` # 对该页内图片循环下载 for j in `seq 1 12` do # 获取图片信息 name=`echo \"$name_list\" | awk \"NR==$j\"` date=`echo \"$date_list\" | awk \"NR==$j\"` url=`echo \"$url_list\" | awk \"NR==$j\"` file_name=\"$date $name.jpg\" # 判断是否已经下载 if [ ! -f \"bing/$file_name\" ] then echo \"Download photo $i-$j……\" if wget -O bing/$$.jpg \"$url\" &gt; /dev/null 2&gt;&amp;1 then same=0 # 先判断md5文件是否存在，如果不存在，说明bing空目录，直接改名 if [ -f \"bing/md5.txt\" ] then # 文件名不存在的，判断是否有文件大小相同的和md5相同的 cat bing/md5.txt | while read line do # 先比较文件大小是否相同，加快速度 if [ `stat -c%s \"bing/$$.jpg\"` = `echo \"$line\" | awk '&#123; print $1 &#125;'` ] then # md5sum计算文件md5值，进行比较 if [ `md5sum \"bing/$$.jpg\" | awk '&#123; print $1 &#125;'` = `echo \"$line\" | awk '&#123; print $2 &#125;'` ] then # 相同 same=1 break fi fi done fi if [ $same = 1 ] then rm \"bing/$$.jpg\" echo \"Photo $i-$j already exists\" else mv \"bing/$$.jpg\" \"bing/$file_name\" echo \"Photo $i-$j download successfully\" # 生成文件大小和MD5校验信息 echo \"`stat -c%s \"bing/$file_name\"` \"`md5sum \"bing/$file_name\"` &gt;&gt; bing/md5.txt fi else printf $RED\"Error: Photo $i-$j download failed\\n\"$NONE exit 6 fi else echo \"Photo $i-$j already exists\" fi done done # 清理缓存 echo \"Cleaning……\" rm bing/$$.html# 随机模式elif [ $rand -gt 0 ]then echo \"##############Random Mode##############\" echo \"Your input rand times is $rand\" # 循环随机下载 for k in `seq 1 $rand` do # 获取json if wget -O \"bing/$$.json\" \"https://bing.ioliu.cn/v1/rand?type=json\" &gt; /dev/null 2&gt;&amp;1 then # 获取图片信息 name=`cat bing/$$.json | sed 's/.*\"copyright\":\"\\(.*\\)(.*©.*)\"&#125;,.*/\\1/g'` date=`cat bing/$$.json | sed 's/.*\"enddate\":\"\\([0-9][0-9][0-9][0-9]\\)\\([0-9][0-9]\\)\\([0-9][0-9]\\)\",.*/\\1-\\2-\\3/g'` url=`cat bing/$$.json | sed 's/.*\"url\":\"\\(http:.*imageslim\\)\",.*/\\1/g'` file_name=\"$date $name.jpg\" # 判断是否已经下载，先用文件名判断 if [ ! -f \"bing/$file_name\" ] then echo \"Download photo $k……\" if wget -O \"bing/$$.jpg\" \"$url\" &gt; /dev/null 2&gt;&amp;1 then same=0 # 先判断md5文件是否存在，如果不存在，说明bing空目录，直接改名 if [ -f \"bing/md5.txt\" ] then # 文件名不存在的，判断是否有文件大小相同的和md5相同的 cat bing/md5.txt | while read line do # 先比较文件大小是否相同，加快速度 if [ `stat -c%s \"bing/$$.jpg\"` = `echo \"$line\" | awk '&#123; print $1 &#125;'` ] then # md5sum计算文件md5值，进行比较 if [ `md5sum \"bing/$$.jpg\" | awk '&#123; print $1 &#125;'` = `echo \"$line\" | awk '&#123; print $2 &#125;'` ] then # 相同 same=1 break fi fi done fi if [ $same = 1 ] then rm \"bing/$$.jpg\" echo \"Photo $k already exists\" else mv \"bing/$$.jpg\" \"bing/$file_name\" echo \"Photo $k download successfully\" # 生成文件大小和MD5校验信息 echo \"`stat -c%s \"bing/$file_name\"` \"`md5sum \"bing/$file_name\"` &gt;&gt; bing/md5.txt fi else printf $RED\"Error: Photo $k download failed\\n\"$NONE exit 6 fi else echo \"Photo $k already exists\" fi else if [ -f bing/$$.json ] then rm bing/$$.json fi printf $RED\"Error: Json $k download failed\\n\"$NONE exit 9 fi done # 清理缓存 echo \"Cleaning……\" rm bing/$$.json# 未知错误else printf $RED\"Error: Unkonwn error\\n\"$NONE exit 10fiecho \"All done,Thanks for using!\"","categories":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/categories/Linux/"},{"name":"上机实战","slug":"Linux/上机实战","permalink":"https://666wxy666.github.io/categories/Linux/%E4%B8%8A%E6%9C%BA%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/tags/Linux/"},{"name":"实战","slug":"实战","permalink":"https://666wxy666.github.io/tags/%E5%AE%9E%E6%88%98/"},{"name":"Shell","slug":"Shell","permalink":"https://666wxy666.github.io/tags/Shell/"},{"name":"脚本","slug":"脚本","permalink":"https://666wxy666.github.io/tags/%E8%84%9A%E6%9C%AC/"}]},{"title":"机器学习 实验 决策树","slug":"机器学习-实验-决策树","date":"2020-04-25T16:00:00.000Z","updated":"2020-09-02T02:06:24.939Z","comments":true,"path":"2020/04/26/机器学习-实验-决策树/","link":"","permalink":"https://666wxy666.github.io/2020/04/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%AE%9E%E9%AA%8C-%E5%86%B3%E7%AD%96%E6%A0%91/","excerpt":"本文是关于20问读心游戏的决策树代码实现。","text":"本文是关于20问读心游戏的决策树代码实现。 一、问题：以20问读心游戏为例，以ID3算法（即信息增益算法）为基础，构造并绘制决策树，最后可以进行简单的测试游玩. 二、实验环境 语言：Python 3.6（Anaconda3） IDE：PyCharm 2020.1.1 (Professional Edition) Packages： python standard library numpy：1.16.2 scipy：1.2.1 pandas：0.24.2 networkx：2.4 graphviz：0.13.2 matplotlib：3.2.1 三、实验结果 四、项目地址本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看： 五、附录数据集data_set.txt： 男 运动员 70后 光头 80后 离婚 选秀 篮球 内地 演员是 是 否 否 是 否 否 是 是 否 姚明是 是 否 否 是 是 否 否 是 否 刘翔是 是 是 是 否 否 否 是 否 否 科比是 是 否 否 是 否 否 否 否 否 c罗是 否 否 否 否 否 否 否 否 是 刘德华是 否 否 否 否 否 是 否 是 否 毛不易是 否 是 否 否 否 否 否 否 是 周杰伦是 否 是 否 否 否 否 否 是 是 黄渤是 否 是 是 否 否 否 否 是 是 徐峥否 是 否 否 是 否 否 否 是 否 张怡宁否 是 否 否 否 是 否 否 是 否 郎平否 是 否 否 否 否 否 否 是 否 朱婷否 否 否 否 否 否 是 否 是 是 杨超越否 否 否 否 是 是 否 否 是 是 杨幂否 否 否 否 否 否 否 否 否 否 邓紫棋否 否 否 否 是 否 是 否 否 否 徐佳莹否 否 否 否 是 否 否 否 是 是 赵丽颖 代码decision_tree.py： 全局配置 123456789101112131415161718192021222324252627# @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved.# @Project: DecisionTree# @Description: 以20问读心游戏为例，以ID3算法（即信息增益算法）为基础，构造并绘制决策树，最后进行测试# @Version: 2.0# @Author: 苇名一心# @Date: 2020-03-10 8:30# @LastEditors: 苇名一心# @LastEditTime: 2020-04-05 10:55# -*- coding: utf-8 -*-from math import logimport matplotlib.pyplot as plt######################################################### 基本配置######################################################### 显示中文标签plt.rcParams['font.sans-serif'] = ['SimHei']# 设置决策树样式# boxstyle为文本框的类型，sawtooth是锯齿形，fc是边框线粗细# arrowstyle是树的线为箭头样式decision_node = dict(boxstyle=\"sawtooth\", fc=\"0.8\")leaf_node = dict(boxstyle=\"round4\", fc=\"0.8\")arrow = dict(arrowstyle=\"&lt;-\") 构造决策树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157######################################################### 构造决策树######################################################### 读入并创建数据集def create_data_set(): data_set = [] # 数据从文件获取 # f = open(r'data_set.txt', encoding='UTF-8') # text = f.read().splitlines() # print(\"data_set.txt的内容为：\") # for line in text: # temp = line.split('\\t') # print(temp) # data_set.append(temp) # 数据在程序中写死 data_set.append([\"男\", \"运动员\", \"70后\", \"光头\", \"80后\", \"离婚\", \"选秀\", \"篮球\", \"内地\", \"演员\"]) data_set.append([\"是\", \"是\", \"否\", \"否\", \"是\", \"否\", \"否\", \"是\", \"是\", \"否\", \"姚明\"]) data_set.append([\"是\", \"是\", \"否\", \"否\", \"是\", \"是\", \"否\", \"否\", \"是\", \"否\", \"刘翔\"]) data_set.append([\"是\", \"是\", \"是\", \"是\", \"否\", \"否\", \"否\", \"是\", \"否\", \"否\", \"科比\"]) data_set.append([\"是\", \"是\", \"否\", \"否\", \"是\", \"否\", \"否\", \"否\", \"否\", \"否\", \"c罗\"]) data_set.append([\"是\", \"否\", \"否\", \"否\", \"否\", \"否\", \"否\", \"否\", \"否\", \"是\", \"刘德华\"]) data_set.append([\"是\", \"否\", \"否\", \"否\", \"否\", \"否\", \"是\", \"否\", \"是\", \"否\", \"毛不易\"]) data_set.append([\"是\", \"否\", \"是\", \"否\", \"否\", \"否\", \"否\", \"否\", \"否\", \"是\", \"周杰伦\"]) data_set.append([\"是\", \"否\", \"是\", \"否\", \"否\", \"否\", \"否\", \"否\", \"是\", \"是\", \"黄渤\"]) data_set.append([\"是\", \"否\", \"是\", \"是\", \"否\", \"否\", \"否\", \"否\", \"是\", \"是\", \"徐峥\"]) data_set.append([\"否\", \"是\", \"否\", \"否\", \"是\", \"否\", \"否\", \"否\", \"是\", \"否\", \"张怡宁\"]) data_set.append([\"否\", \"是\", \"否\", \"否\", \"否\", \"是\", \"否\", \"否\", \"是\", \"否\", \"郎平\"]) data_set.append([\"否\", \"是\", \"否\", \"否\", \"否\", \"否\", \"否\", \"否\", \"是\", \"否\", \"朱婷\"]) data_set.append([\"否\", \"否\", \"否\", \"否\", \"否\", \"否\", \"是\", \"否\", \"是\", \"是\", \"杨超越\"]) data_set.append([\"否\", \"否\", \"否\", \"否\", \"是\", \"是\", \"否\", \"否\", \"是\", \"是\", \"杨幂\"]) data_set.append([\"否\", \"否\", \"否\", \"否\", \"否\", \"否\", \"否\", \"否\", \"否\", \"否\", \"邓紫棋\"]) data_set.append([\"否\", \"否\", \"否\", \"否\", \"是\", \"否\", \"是\", \"否\", \"否\", \"否\", \"徐佳莹\"]) data_set.append([\"否\", \"否\", \"否\", \"否\", \"是\", \"否\", \"否\", \"否\", \"是\", \"是\", \"赵丽颖\"]) attr = data_set[0] del (data_set[0]) print(\"属性集：\") print(attr) print(\"数据集：\") print(data_set) return data_set, attr# 如果数据集中的axis列，值为value，那么取出这一行，且去掉这一列，加入子数据集中def split_data_set(data_set, axis, value): sub_data_set = [] for line in data_set: if line[axis] == value: # 去掉这一列 # note: 用循环，较为麻烦 # newline = [] # for i in range(len(line)): # if i != axis: # newline.append(line[i]) # sub_data_set.append(newline) # note: 易错点，如果直接newline = line，其实是newline和line指向同一个地址，会修改data_set中的值 newline = line[:] del newline[axis] sub_data_set.append(newline) return sub_data_set# 计算信息熵def calc_info_ent(data_set): # 数据集样本条数n num = len(data_set) # 标签计数字典 count = &#123;&#125; for i in data_set: # 获取样本最后一列的标签 current_label = i[-1] # 如果当前标签不在计数字典里，则初始化 if current_label not in count.keys(): count[current_label] = 0 count[current_label] += 1 # 信息熵初始化 info_ent = 0.0 # 计算信息熵:sum(-P(X)log(P(x))) for key in count.keys(): # 计算概率 probability = float(count[key]) / num # -P(X)log(P(x)) info_ent -= probability * log(probability, 2) return info_ent# 选出信息增益最大的最优属性def best_split(data_set): # 属性个数，data_set最后一列是标签，不是属性 feature_num = len(data_set[0]) - 1 # 初始信息熵,也就是根节点的信息熵 base_ent = calc_info_ent(data_set) # 初始化 best_info_gain = 0.0 best_index = -1 # axis为列号 for axis in range(feature_num): # 获取每一列数据并去重 row = [] for line in data_set: row.append(line[axis]) unique_row = set(row) new_ent = 0.0 # value为列可能的取值，在20问读心游戏里为：是/否 for value in unique_row: # 取出axis列的值为value的子数据集 sub_data_set = split_data_set(data_set, axis, value) # 计算条件概率 probability = float(len(sub_data_set)) / len(data_set) # 计算条件熵 new_ent += probability * calc_info_ent(sub_data_set) # 计算信息增益 info_gain = base_ent - new_ent if info_gain &gt; best_info_gain: best_info_gain = info_gain best_index = axis return best_index# 递归方式创建决策树# data_set为当前数据集，attr为剩余的还未用过的属性集def create_tree(data_set, attr): # 获取标签，data_set的最后一列 # note: 因为递归，data_set会改变，每次要从新的data_set中获取 true_labels = [] for line in data_set: true_labels.append(line[-1]) # 递归终止条件：标签全部相同（例如全是‘姚明’），或者只有一个标签，没必要再进行下去，直接返回这个标签 if true_labels.count(true_labels[0]) == len(true_labels): return true_labels[0] # 递归终止条件：数据集中只有一个属性（只有一列，标签列，实际没有意义），没必要继续下去，直接返回列中相同值最多的标签 if len(data_set[0]) == 1: return max(true_labels, key=true_labels.count) # 从当前数据集和剩余的属性集attr中获取最优属性(信息增益最大)的索引和属性名 best_index = best_split(data_set) best_attr = attr[best_index] # 开始创建决策树 # 初始化字典，创建根节点，第一个属性对应的也是一个字典 root = &#123;best_attr: &#123;&#125;&#125; # 获取最优属性对应的列并去重 best_row = [] for line in data_set: best_row.append(line[best_index]) unique_row = set(best_row) # value为列可能的取值，在20问读心游戏里为：是/否 for value in unique_row: # 新建子属性集合，并且将用完的属性从属性集中删除 # note: 最好是不要改变attr的内容，新建一个sub_attr拷贝attr，对sub_attr做删除操作 sub_attr = attr[:] del sub_attr[best_index] # 递归构造决策树 # note: root[best_attr]是一个字典 # 根据当前best_attr属性的所有可能的取值value进行构造，在20问读心游戏里为：是/否 # 也就是说构造出的决策树是二叉树 root[best_attr][value] = create_tree(split_data_set(data_set, best_index, value), sub_attr) return root 绘制决策树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159######################################################### 绘制决策树（ps: 为了让画出来的树更美观，借鉴学习了《机器学习实战》中的好思路）######################################################### 获取树的层数def get_depth(decision_tree): max_depth = 0 # 将决策树dict的key转化为list并获取根结点属性名称 root_attr = list(decision_tree.keys())[0] # 根据根节点属性获取子树 sub_tree = decision_tree[root_attr] # 对子树字典所有的key，也就是root_attr所有的取值（在20问读心游戏里为：是/否）遍历 for key in sub_tree.keys(): # 如果是字典对象，说明还未到叶子，继续递归 if isinstance(sub_tree[key], dict): depth = get_depth(sub_tree[key]) + 1 # 如果不是字典对象，说明已经到达叶子，停止递归 else: depth = 1 # 判断深度是否大于最大深度 if depth &gt; max_depth: max_depth = depth return max_depth# 获取树的叶子节点个数，也就是标签数def get_leaf_num(decision_tree): num = 0 # 将决策树dict的key转化为list并获取根结点属性名称 root_attr = list(decision_tree.keys())[0] # 根据根节点属性获取子树 sub_tree = decision_tree[root_attr] # 对子树字典所有的key，也就是root_attr所有的取值（在20问读心游戏里为：是/否）遍历 for key in sub_tree.keys(): # 如果是字典对象，说明还未到叶子，继续递归 if isinstance(sub_tree[key], dict): num += get_leaf_num(sub_tree[key]) # 如果不是字典对象，说明已经到达叶子，停止递归 else: num += 1 return num# 创建图对象，初始化，画图def create_plot(decision_tree): # 定义一个背景为白色的画布，并把画布清空 fig = plt.figure(1, facecolor='white') fig.clf() # ax_prop为图形的样式，没有坐标轴标签 ax_prop = dict(xticks=[], yticks=[]) # 使用subplot为定义了一个图，一行一列一个图， # frameon=False代表没有矩形边框 # note: 在python里，[函数名称].[变量名]相当于是全局变量 # ax1相当于是图对象，在其它函数中使用 create_plot.ax1 = plt.subplot(111, frameon=False, **ax_prop) # total_width和total_depth分别代表初始决策树的叶子节点数目和深度，不改变 plot_tree.total_width = float(get_leaf_num(decision_tree)) plot_tree.total_depth = float(get_depth(decision_tree)) # 图的大小是长0~1，宽0~1 # note: x_offset实质是每个叶子的x坐标的位置 # 第一片叶子的x为0.5/叶子数目，因此初始的x_offset设为-0.5/叶子数目 # 每次将x_offset+(1/x_offset)，也就是第一个叶子不紧贴边框，有0.5/叶子数目的内边距 # 例如绘制3个叶子，坐标应为1/3、2/3、3/3 # 但这样整个图形会偏右，因此将初始的x_offset设为-0.5/3 # 这样的话，每个叶子向左移了0.5/3，坐标变成了0.5/3、1.5/3、2.5/3，就刚好让图形在正中间了 # 初始的y_offset显然为1，也就是最高点，每下降一层将y_offset-(1/深度)即可 plot_tree.x_offset = -0.5 / plot_tree.total_width plot_tree.y_offset = 1.0 # 初始根节点位置为图形的正中间最上方，即(0.5, 1.0) # 初始节点文本为空，等待获取 plot_tree(decision_tree, (0.5, 1.0), '') plt.show()# 递归画出决策树# parent_pos为父节点位置，也就是当前决策树根节点的父节点位置# arrow_text为父节点指来的箭头上的内容（在20问读心游戏里为：是/否）def plot_tree(decision_tree, parent_pos, arrow_text): # 获取当前决策树叶子数目 # note: leaf_num与plot_tree.total_depth不同，前者针对的是当前的决策树，后者是针对的原来的整个决策树 leaf_num = get_leaf_num(decision_tree) # 将决策树dict的key转化为list并获取根结点属性名称 root_attr = list(decision_tree.keys())[0] # root_pos为当前决策树的根节点的位置 # note: 计算方法为 # 拆分为三部分： # 1. plot_tree.x_offset：初始的x偏移，基准值 # 2. float(numLeafs) / 2.0 / plotTree.totalW： # float(numLeafs) * (1 / plotTree.totalW)为该决策树所包含的所有叶子所占的横坐标宽度 # / 2.0就是这个宽度的中间点 # 3. 0.5 / plotTree.totalW：因为x_offset初始有-0.5/plotTree.totalW的偏移 # 导致该节点并不是在区域中点，而是向左有个0.5/plotTree.totalW偏移 # 因此+0.5 / plotTree.totalW，使其位于区域正中 # 最终的公式经过合并就是下式： root_pos = (plot_tree.x_offset + (1.0 + float(leaf_num)) / 2.0 / plot_tree.total_width, plot_tree.y_offset) # 画出由当前子决策树父节点指来的箭头和箭头上的文本（在20问读心游戏里为：是/否）以及箭头指向的当前决策树的根节点 plot_arrow_text(root_pos, parent_pos, arrow_text) # 节点类型为决策类型decision_node，不是叶子 plot_node(root_pos, parent_pos, decision_node, root_attr) # 根据根节点属性获取子树 sub_tree = decision_tree[root_attr] # note: 每下降一层，将y_offset减1.0 / plot_tree.total_depth plot_tree.y_offset = plot_tree.y_offset - 1.0 / plot_tree.total_depth # 对子树字典所有的key，也就是root_attr所有的取值（在20问读心游戏里为：是/否）遍历 for key in sub_tree.keys(): # 如果是字典对象，说明还未到叶子，继续递归 if isinstance(sub_tree[key], dict): # note: 子决策树为sub_tree[key] # 子决策树的父节点为当前决策树的根节点 # 当前决策树指向子决策树的箭头上的文本为key，因为key不是字符串，要进行类型转换 plot_tree(sub_tree[key], root_pos, str(key)) # 如果不是字典对象，说明已经到达叶子，停止递归 else: # 每到一个叶子，就把x_offset加1.0 / plot_tree.total_width plot_tree.x_offset = plot_tree.x_offset + 1.0 / plot_tree.total_width # 画出叶子、箭头 # (plot_tree.x_offset, plot_tree.y_offset)刚好是叶子的坐标 # root_pos为当前决策树的根节点坐标 # 节点类型为叶子类型leaf_node # 因为是叶子，sub_tree[key]为字符串类型，也就是标签 plot_node((plot_tree.x_offset, plot_tree.y_offset), root_pos, leaf_node, sub_tree[key]) # 画出箭头上的文本 # 当前决策树指向叶子的箭头上的文本为key，因为key不是字符串，要进行类型转换 plot_arrow_text((plot_tree.x_offset, plot_tree.y_offset), root_pos, str(key)) # note: 易错点，每次递归结束需要将y_offset加1.0 / plot_tree.total_depth，回到上一层 plot_tree.y_offset = plot_tree.y_offset + 1.0 / plot_tree.total_depth# 画节点和指向节点的箭头的函数# root_pos为子节点的位置，也就是箭头指向的位置# parent_pos为父节点的位置，也就是箭头尾部所在的位置# node_type为节点类型，两种：决策节点（decision_node）和叶节点（leaf_node）# node_text为要显示的文本，也就是节点的内容，即属性的名称（例如：男、运动员……）def plot_node(root_pos, parent_pos, node_type, node_text): # note: annotate用于在图形上给数据添加文本注解，支持带箭头的划线工具 # 参数如下： # s：注释文本的内容 # xy：被注释的坐标点，二维元组形如(x,y) # xytext：注释文本的坐标点，也就是文本写的地方，也是二维元组，默认与xy相同 # xycoords：被注释点的坐标系属性，axes fraction是以子绘图区左下角为参考，单位是百分比 # textcoords：注释文本的坐标系属性，默认与xycoords属性值相同 # va=\"center\"，ha=\"center\"表示注释的坐标以注释框的正中心为准，而不是注释框的左下角(v代表垂直方向，h代表水平方向) # bbox是注释框的风格和颜色深度，fc越小，注释框的颜色越深，支持输入一个字典 # arrowprops：箭头的样式，字典型数据，在画图的开头定义了 create_plot.ax1.annotate(node_text, xy=parent_pos, xycoords='axes fraction', xytext=root_pos, textcoords='axes fraction', va=\"center\", ha=\"center\", bbox=node_type, arrowprops=arrow)# 画箭头上文本的函数# root_pos为子节点的位置，也就是箭头指向的位置# parent_pos为父节点的位置，也就是箭头尾部所在的位置# text为要显示的文本，也就是箭头上写的内容，即属性的取值（在20问读心游戏里为：是/否）def plot_arrow_text(root_pos, parent_pos, arrow_text): # 文本的位置应该处于箭头中间，也就是文本坐标=箭头头坐标+（箭头尾坐标-箭头头坐标）/2，因为箭头是向下指的 x_mid = root_pos[0] + (parent_pos[0] - root_pos[0]) / 2.0 y_mid = root_pos[1] + (parent_pos[1] - root_pos[1]) / 2.0 create_plot.ax1.text(x_mid, y_mid, arrow_text, va=\"center\", ha=\"center\", rotation=30) 测试函数 12345678910111213141516171819202122232425262728293031######################################################### 测试函数######################################################### 根据决策树decision_tree(决策树字典对象)和标签列表labels对输入的测试向量test进行分类，输出类别# test为列表，样例：['是', '否', '否', '否', '否', '否', '否', '否', '否', '是']# note: 与决策树建立一样，也是使用递归，从根节点查起，直到叶子def classify(decision_tree, labels, test): # 将决策树dict的key转化为list并获取根结点属性名称 # note: 易错点，如果不转化为list会产生错误： # TypeError: 'dict_keys' object does not support indexing # 原因是python3改变了dict.keys，返回的是dict_keys对象，支持iterable # 但不支持indexable，我们可以将其明确的转化成list来解决 root_attr = list(decision_tree.keys())[0] # 根据根节点属性获取子树 # note: 子树也是一个字典对象，key为该属性的取值（在20问读心游戏里为：是/否） # value也是一个字典对象，key为下一个属性，value为下一个属性对应的子树 sub_tree = decision_tree[root_attr] # 根据根节点属性名称获取在标签列表中对应的索引，并根据索引获取测试向量test该属性对应的值（在20问读心游戏里为：是/否） value = test[labels.index(root_attr)] # 根据value的值（在20问读心游戏里为：是/否）获取决策树的子树字典 tree_of_value = sub_tree[value] # 用isinstance判断得到的对象是不是字典对象 # 如果是字典，就不是叶子，继续递归 # 如果不是字典，就是叶子，停止递归，tree_of_value就是分类结果 if isinstance(tree_of_value, dict): label = classify(tree_of_value, labels, test) else: label = tree_of_value return label 开始运行 1234567891011121314151617######################################################### 开始运行######################################################### 读入并创建数据集和属性集data_set, attr = create_data_set()# 复制一份属性集attr用于递归，因为递归会将attr内容改变attr_copy = attr.copy()decision_tree = create_tree(data_set, attr_copy)print(\"决策树结构为：\")print(decision_tree)# 绘制决策树print(\"绘制决策树……\")create_plot(decision_tree)print(\"决策树的深度为：%d\" % get_depth(decision_tree))print(\"决策树叶子数目为：%d\" % get_leaf_num(decision_tree)) 测试游玩 123456789101112131415######################################################### 测试########################################################print(\"是否要进行测试（1是，0否）：\")flag = int(input())while flag == 1: print(\"请输入测试向量（以空格分隔每个问题的答案）：\") test = input().split() result = classify(decision_tree, attr, test) print(\"测试结果为：%s\" % result) print(\"是否要进行测试（1是，0否）：\") flag = int(input())print(\"程序成功退出，感谢使用……\")","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://666wxy666.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"实验","slug":"机器学习/实验","permalink":"https://666wxy666.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://666wxy666.github.io/tags/Python/"},{"name":"机器学习","slug":"机器学习","permalink":"https://666wxy666.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"实验","slug":"实验","permalink":"https://666wxy666.github.io/tags/%E5%AE%9E%E9%AA%8C/"},{"name":"决策树","slug":"决策树","permalink":"https://666wxy666.github.io/tags/%E5%86%B3%E7%AD%96%E6%A0%91/"}]},{"title":"计算机系统结构 实验 使用MIPS指令实现求两个数组的点积","slug":"计算机系统结构-实验-使用MIPS指令实现求两个数组的点积","date":"2020-04-24T16:00:00.000Z","updated":"2020-09-02T02:09:14.387Z","comments":true,"path":"2020/04/25/计算机系统结构-实验-使用MIPS指令实现求两个数组的点积/","link":"","permalink":"https://666wxy666.github.io/2020/04/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AE%9E%E9%AA%8C-%E4%BD%BF%E7%94%A8MIPS%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E7%82%B9%E7%A7%AF/","excerpt":"本文是关于计算机系统结构实验三，使用MIPS指令实现求两个数组的点积。","text":"本文是关于计算机系统结构实验三，使用MIPS指令实现求两个数组的点积。 一、实验目的 通过实验熟悉实验 1 和实验 2 的内容。 增强汇编语言编程能力。 学会使用模拟器中的定向功能进行优化。 了解对代码进行优化的方法。 二、实验原理​ 通过编写MIPS汇编程序，实现向量点积的功能。在模拟器MIPSsim上执行所写的汇编程序，连续执行，查看寄存器相关结果，判断所写的汇编程序是否正确。然后观察时钟周期图窗口的执行过程和冲突的指令，查看统计窗口的信息，来判断定向前后和优化前后的执行效率高低。 三、实验步骤及结果分析1、自行编写一个计算两个向量点积的汇编程序，该程序要求可以实现求两个向量点积计算后的结果。 向量的点积：假设有两个 n 维向量 a、b，则 a 与 b 的点积为：$$a{\\cdot}b=\\sum_{i=1}^na_ib_i=a_1b_1+a_2b_2+\\cdots+a_nb_n$$两个向量元素使用数组进行数据存储，要求向量的维度不得小于10 PS：汇编程序见附录。 2、启动 MIPSsim。 3、载入自己编写的程序，观察流水线输出结果。 载入的代码： 执行： 执行到结束： 寄存器 我编写的汇编程序是向量$(1,2,3,4,5,6,7,8,9,10,11,12)\\cdot(1,2,3,4,5,6,7,8,9,10,11,12)$=650，R7为结果寄存器，发现结果符合预期，说明编写的汇编程序正确。 时钟周期图 可以看到有较多停顿，主要是LW命令与MUL命令，MUL命令与ADD命令和一些控制停顿。 统计 发现RAW停顿有72个周期，停顿次数较多，可以进行优化。共执行了187个周期，RAW停顿占周期总数的百分比为38.50267%，所有的停顿为84个周期，占周期总数的百分比为44.91978%，效率很低。$$吞吐率TP_1=\\frac{102}{187\\Delta{t}}$$ $$加速比S_1=\\frac{102\\times{5\\Delta{t}}}{187\\Delta{t}}\\approx{2.73}$$ 4、使用定向功能再次执行代码，与刚才执行结果进行比较，观察执行效率的不同。 寄存器 结果正确。 时钟周期图 在使用定向技术后，发现停顿明显减少。 统计 发现RAW停顿有24个周期，停顿次数比没有定向技术时的72个少了很多。共执行了139个周期，比没有定向技术时的187个也少了很多，RAW停顿占周期总数的百分比为17.26619%，所有的停顿为36个周期，占周期总数的百分比为25.89928%，较没有定向技术时的44.91978%也减少了很多。 $$ 吞吐率TP_2=\\frac{102}{139\\Delta{t}} $$ $$ 加速比S_2=\\frac{102\\times{5\\Delta{t}}}{139\\Delta{t}}\\approx{3.67} $$ 吞吐率和加速比是没有定向技术时的$\\frac{187}{139}\\approx{1.35}$倍。 5、采用静态调度方法重排指令序列，减少相关，优化程序PS：静态调度后的汇编程序见附录。 载入代码 寄存器 结果正确。 时钟周期图 在使用静态调度后，发现停顿几乎没有了。 统计 发现RAW停顿有12个周期，停顿次数比没有静态调度时的72个少了很多。共执行了127个周期，比没有静态调度时的187个也少了很多，RAW停顿占周期总数的百分比为9.448819%，所有的停顿为24个周期，占周期总数的百分比为18.89764%，较没有静态调度时的44.91978%也减少了很多。 $$ 吞吐率TP_3=\\frac{102}{127\\Delta{t}} $$ $$ 加速比S_2=\\frac{102\\times{5\\Delta{t}}}{127\\Delta{t}}\\approx{4.02} $$ 吞吐率和加速比是没有静态调度时的$\\frac{187}{127}\\approx{1.47}$倍。 6、对优化后的程序使用定向功能执行，与刚才执行结果进行比较，观察执行效率的不同。 寄存器 结果正确。 时钟周期图 在使用静态调度和分支技术后，发现所有的RAW停顿都没有了，只剩下了控制停顿。 统计 发现没有RAW停顿。共执行了115个周期，比没有静态调度和定向技术时的187个也少了非常多，RAW停顿占周期总数的百分比为0%，所有的停顿为12个周期，全都是控制停顿，占周期总数的百分比为10.43478%，较没有静态调度和定向技术时的44.91978%也减少了非常多，没有RAW停顿也说明这个静态调度是最优调度。 $$ 吞吐率TP_4=\\frac{102}{115\\Delta{t}} $$ $$ 加速比S_2=\\frac{102\\times{5\\Delta{t}}}{115\\Delta{t}}\\approx{4.43} $$ 吞吐率和加速比是没有静态调度和定向技术时的$\\frac{187}{115}\\approx{1.63}$倍。 四、附录1、初始的汇编代码12345678910111213141516171819.textmain:ADDIU $r1,$r0,array1ADDIU $r2,$r0,array2ADDIU $r3,$r0,12ADDIU $r7,$r0,0loop:LW $r4,0($r1)LW $r5,0($r2)MUL $r6,$r4,$r5ADD $r7,$r7,$r6ADDI $r1,$r1,4ADDI $r2,$r2,4ADDI $r3,$r3,-1BGTZ $r3,loopTEQ $r0,$r0.dataarray1: .word 1,2,3,4,5,6,7,8,9,10,11,12array2: .word 1,2,3,4,5,6,7,8,9,10,11,12 2、经过静态调度后的汇编代码12345678910111213141516171819.textmain:ADDIU $r1,$r0,array1ADDIU $r2,$r0,array2ADDIU $r3,$r0,12ADDIU $r7,$r0,0loop:LW $r4,0($r1)LW $r5,0($r2)ADDI $r1,$r1,4ADDI $r2,$r2,4MUL $r6,$r4,$r5ADDI $r3,$r3,-1ADD $r7,$r7,$r6BGTZ $r3,loopTEQ $r0,$r0.dataarray1: .word 1,2,3,4,5,6,7,8,9,10,11,12array2: .word 1,2,3,4,5,6,7,8,9,10,11,12","categories":[{"name":"计算机系统结构","slug":"计算机系统结构","permalink":"https://666wxy666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"},{"name":"实验","slug":"计算机系统结构/实验","permalink":"https://666wxy666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"实验","slug":"实验","permalink":"https://666wxy666.github.io/tags/%E5%AE%9E%E9%AA%8C/"},{"name":"计算机系统结构","slug":"计算机系统结构","permalink":"https://666wxy666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"},{"name":"汇编","slug":"汇编","permalink":"https://666wxy666.github.io/tags/%E6%B1%87%E7%BC%96/"},{"name":"MIPS","slug":"MIPS","permalink":"https://666wxy666.github.io/tags/MIPS/"}]},{"title":"Linux 上机实战2 遍历目录","slug":"Linux-上机实战2-遍历目录","date":"2020-04-19T16:00:00.000Z","updated":"2020-09-02T02:00:15.875Z","comments":true,"path":"2020/04/20/Linux-上机实战2-遍历目录/","link":"","permalink":"https://666wxy666.github.io/2020/04/20/Linux-%E4%B8%8A%E6%9C%BA%E5%AE%9E%E6%88%982-%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95/","excerpt":"本文是关于Linux中的ls的简化版，遍历目录小程序。","text":"本文是关于Linux中的ls的简化版，遍历目录小程序。 一、题目要求编程实现程序list.c，列表普通磁盘文件，包括文件名和文件大小。 使用vi编辑文件，熟悉工具vi。 使用Linux的系统调用和库函数。 体会Shell文件通配符的处理方式以及命令对选项的处理方式。 对选项的处理，自行编程逐个分析命令行参数。不考虑多选项挤在一个命令行参数内的情况。 与ls命令类似，处理对象可以有0到多个 0个：列出当前目录下所有文件 普通文件：列出文件 目录：列出目录下所有文件 实现自定义选项r,a,l,h,m以及– r 递归方式列出子目录（每项要含路径，类似find的-print输出风格，需 要设计递归程序） a 列出文件名第一个字符为圆点的普通文件（默认情况下不列出文件名 首字符为圆点的文件） l 后跟一整数，限定文件大小的最小值（字节） h 后跟一整数，限定文件大小的最大值（字节） m 后跟一整数n，限定文件的最近修改时间必须在n天内 – 显式地终止命令选项分析 编辑，编译 vi list.c make list 或者gcc list.c –o list 运行举例 ./list –l 100 –h 5000 /bin /etc 列出大小在100~5000之间的文件 ./list –a -r -l 50000 –m 2 递归式列出当前目录树下大小超50KB且2天内修改过的文件（包括文件名首字符为圆点的文件） ./list – -l ./list * 二、基本步骤 使用**Xshell**登录到Ubuntu服务器 开始编写代码**list.c**： 1vim list.c 编写代码（代码源码见附件list.c和list2.c和本文最后的附录） 编写完成后保存退出 1:wq 编译 1gcc -Wall list.c -o list 1gcc -Wall list2.c -o list2 三、测试样例1、说明（重要）v1.0是基本要求，但是在基础要求上增加了： -？帮助选项 -d 详细模式选项，类似ls命令，可以显示权限，类型，link数，所有者，修改日期，路径…… 选项在路径之前和之后均可分析 不同种类的文件分不同颜色显示：白色为普通磁盘文件，黄色为目录文件，青色为其他文件，红色为ERROR 完备的差错控制，从分析指令到执行指令阶段，均有完善的差错控制。在执行阶段遇到的文件权限等非致命错误不会打断程序的运行，程序会在屏幕上输出错误信息后继续读取下面的文件 v2.0是在v1.0的基础上进行修改的版本，除保留有v1.0的全部功能外，又增加了： 支持输入长选项（具体使用请使用–help或-？查看） 支持长短选项混合 2、测试样例①帮助 1./list -? 1./list2 -? 1./list2 --help ②正常运行 1./list -l 100 -h 5000 /bin /etc 1./list2 -low=100 -high=5000 /bin /etc 1./list -a -r -l 50000 -m 2 也可以混合输入长短选项 1./list2 --all --r --low=50000 -m 2 使用–终止选项分析 1./list -- -l 1./list2 -- -l 1./list * 1./list2 * 增加的-d(–detail)功能 1./list -d -a 1./list2 --detail --recursive ③出错处理两个版本的出错控制基本一致，就不对每一个命令都展示两个版本了 例如输错了选项 1./list -la /home/wxy -h后面没有参数 1./list /home/wxy -h -l后面虽然有参数，但是不是整数 1./list2 --low=abc /home/wxy 长选项格式输入错误 1./list2 -l=12a 长选项格式输入错误 1./list2 --m1abc 路径不存在 1./list /12345 没有权限 1./list2 /root -all -recursive 等等情况，不再一一展示 四、项目地址本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看： 源码仓库 五、附录PS:程序源码均有详细的注释 1、list.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643/* * @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. * @Description: 列表Linux文件，在Ubuntu 18.04上进行的编程 * @Version: 1.0 * @Author: 苇名一心 * @Date: 2020-04-09 17:57:29 * @LastEditors: 苇名一心 * @LastEditTime: 2020-04-13 14:08:50 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;dirent.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#include &lt;pwd.h&gt;#include &lt;grp.h&gt;//颜色#define NONE \"\\e[0m\" //复原#define RED \"\\e[0;31m\" //ERROR#define YELLOW \"\\e[0;33m\" //目录#define CYAN \"\\e[0;36m\" //除普通文件和目录文件外的文件#define OPTION_NUM 7 //选项种类数目（除'--'以外）//****************选项枚举****************enum OPT&#123; _r, //-r 递归方式列出子目录 _a, //-a 列出文件名第一个字符为圆点的普通文件 _d, //-d 展示文件的详细信息（默认只展示文件路径） _l, //-l 后跟一整数，限定文件大小的最小值（字节） _h, //-h 后跟一整数，限定文件大小的最大值（字节） _m, //-m 后跟一整数n，限定文件的最近修改时间必须在n天内 _help, //-? 显示帮助&#125; opt;//-- 显式地终止命令选项分析//**************************************char split[] = \"****************************************\\n\"; //分割线char version[] = \"1.0\"; //版本号char **path; //路径int path_num = 0; //用于记录路径的数目int opts[OPTION_NUM] = &#123;0&#125;; //用来存储选项是否开启，数组的每个位置对应相应选项，值为0表示未开启，为1表示开启long max_size = 0; //最大文件尺寸long min_size = 0; //最小文件尺寸time_t limit_day = 0; //最早修改在几天前time_t current_time = 0; //当前系统时间void free_path(); //释放path分配的空间void help(); //打印帮助信息void analyse_input(int argc, char const *argv[]); //分析输入的命令的函数void show_analyse_result(); //输出命令解析的结果void run(char *path); //对一个路径按照选项运行命令void show_mode(mode_t mode); //输出文件的权限及文件类型（用于-d选项中）void show(struct stat st, char *path); //展示文件信息int main(int argc, char const *argv[])&#123; time(&amp;current_time); //获取指令执行时的时间 analyse_input(argc, argv); //分析用户的输入 //用户加了帮助选项，输出帮助信息后退出 if (opts[_help]) &#123; help(); exit(EXIT_SUCCESS); &#125; //用户没有帮助选项，输出命令解析的结果并运行该命令 else &#123; show_analyse_result(); int i = 0; for (i = 0; i &lt; path_num; i++) &#123; run(path[i]); &#125; &#125; free_path(); return 0;&#125;/** * @name: free_path * @author: 苇名一心 * @msg: 释放path分配的空间 * @param: 无 * @return: 无 */void free_path()&#123; int i = 0; for (i = 0; i &lt; path_num; i++) free(path[i]); free(path);&#125;/** * @name: help * @author: 苇名一心 * @msg: 打印帮助信息 * @param: 无 * @return: 无 */void help()&#123; printf(\"%18sHELP%18s\\n%s\", \"\", \"\", split); printf(\"List %s by 苇名一心 Apr 10 2020\\n\", version); printf(\"Usage: ./list [OPTION]... [PATH]...\\n\"); printf(\"List informaton about the FILEs in these PATHs(the current directory by default)\\nOptions:\\n\"); printf(\"\\t-r\\t\\tList subdirectories recursively\\n\"); printf(\"\\t-a\\t\\tDo not hide entries starting with .\\n\"); printf(\"\\t-d\\t\\tShow detail information of file(only file path by default)\\n\"); printf(\"\\t-l &lt;bytes&gt;\\tMinmum of file size\\n\"); printf(\"\\t-h &lt;bytes&gt;\\tMaxmum of file size\\n\"); printf(\"\\t-m &lt;days&gt;\\tLimit file last changed time\\n\"); printf(\"\\t-?\\t\\tDisplay this help and exit\\n\"); printf(\"Color:\\n\"); printf(\"\\tWHITE: Regular file\\n\"); printf(YELLOW \"\\tYELLOW: Directory file\\n\" NONE); printf(CYAN \"\\tCYAN: Other file\\n\" NONE); printf(RED \"\\tRED: Error\\n\" NONE); printf(\"%s\", split);&#125;/** * @name: analyse_input * @author: 苇名一心 * @msg: 分析输入的命令的函数 * @param: 同main函数 * @return: 无 */void analyse_input(int argc, char const *argv[])&#123; path = (char **)malloc(argc * sizeof(char *)); int i = 1; int flag = 1; //记录选项分析是否终止，终止为0，未终止为1 for (i = 1; i &lt; argc; i++) &#123; //以-开头的是选项 if (flag &amp;&amp; argv[i][0] == '-') &#123; if (strlen(argv[i]) == 1) &#123; printf(RED \"ERROR: Input option wrong, please input the right option\\n\" NONE); printf(\"Here are some tips:\\n\"); help(); free_path(); exit(EXIT_FAILURE); &#125; else if (strlen(argv[i]) == 2) &#123; switch (argv[i][1]) &#123; case 'r': opts[_r] = 1; break; case 'a': opts[_a] = 1; break; case 'd': opts[_d] = 1; break; case 'l': opts[_l] = 1; //判断-l选项后面有没有参数 if (i &lt; argc - 1) &#123; char *stop; long int size = strtol(argv[++i], &amp;stop, 10); //stop长度为0代表进行了有效的转换 if (strlen(stop) == 0) &#123; min_size = size; &#125; else &#123; printf(RED \"ERROR: Input option -l wrong, there is no required min size, please input the right option\\n\" NONE); printf(\"Here are some tips:\\n\"); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; else &#123; printf(RED \"ERROR: Input option -l wrong, there is no required min size, please input the right option\\n\" NONE); printf(\"Here are some tips:\\n\"); help(); free_path(); exit(EXIT_FAILURE); &#125; break; case 'h': opts[_h] = 1; //判断-h选项后面有没有参数 if (i &lt; argc - 1) &#123; char *stop; long int size = strtol(argv[++i], &amp;stop, 10); //stop长度为0代表进行了有效的转换 if (strlen(stop) == 0) &#123; max_size = size; &#125; else &#123; printf(RED \"ERROR: Input option -h wrong, there is no required max size, please input the right option\\n\" NONE); printf(\"Here are some tips:\\n\"); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; else &#123; printf(RED \"ERROR: Input option -h wrong, there is no required max size, please input the right option\\n\" NONE); printf(\"Here are some tips:\\n\"); help(); free_path(); exit(EXIT_FAILURE); &#125; break; case 'm': opts[_m] = 1; //判断-m选项后面有没有参数 if (i &lt; argc - 1) &#123; char *stop; long int day = strtol(argv[++i], &amp;stop, 10); //stop长度为0代表进行了有效的转换 if (strlen(stop) == 0) &#123; limit_day = day; &#125; else &#123; printf(RED \"ERROR: Input option -m wrong, there is no required limit day, please input the right option\\n\" NONE); printf(\"Here are some tips:\\n\"); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; else &#123; printf(RED \"ERROR: Input option -m wrong, there is no required limit day, please input the right option\\n\" NONE); printf(\"Here are some tips:\\n\"); help(); free_path(); exit(EXIT_FAILURE); &#125; break; case '?': opts[_help] = 1; break; case '-': flag = 0; break; default: printf(RED \"ERROR: Input option wrong, please input the right option\\n\" NONE); printf(\"Here are some tips:\\n\"); help(); free_path(); exit(EXIT_FAILURE); break; &#125; &#125; else &#123; printf(RED \"ERROR: Input option wrong, please input the right option\\n\" NONE); printf(\"Here are some tips:\\n\"); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; else &#123; //不是-开头的认为是路径或者--后面的全部认为是路径 path[path_num] = (char *)malloc(strlen(argv[i]) * sizeof(char)); strcpy(path[path_num++], argv[i]); &#125; &#125; if (opts[_l] &amp;&amp; opts[_h]) &#123; if (min_size &gt; max_size) &#123; printf(RED \"ERROR: Min size of file is less than Max size of file, please input the right option\\n\" NONE); printf(\"Here are some tips:\\n\"); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; //没有输入路径，默认为当前工作目录 if (path_num == 0) &#123; path[path_num] = (char *)malloc(sizeof(char) * 255); if (!getcwd(path[path_num++], sizeof(char) * 255)) &#123; printf(RED \"ERROR: Get current work path wrong\\n\" NONE); free_path(); exit(EXIT_FAILURE); &#125; &#125;&#125;/** * @name: show_analyse_result * @author: 苇名一心 * @msg: 输出命令解析的结果 * @param: 无 * @return: 无 */void show_analyse_result()&#123; printf(\"Input Analyse Results are:\\n\"); int i = 0; for (i = 0; i &lt; OPTION_NUM; i++) &#123; switch (i) &#123; case _r: if (opts[i]) &#123; printf(\"-r: True\\n\"); &#125; else &#123; printf(\"-r: False\\n\"); &#125; break; case _a: if (opts[i]) &#123; printf(\"-a: True\\n\"); &#125; else &#123; printf(\"-a: False\\n\"); &#125; break; case _d: if (opts[i]) &#123; printf(\"-d: True\\n\"); &#125; else &#123; printf(\"-d: False\\n\"); &#125; break; case _l: if (opts[i]) &#123; printf(\"-l: True\\tMin Size:%ld\\n\", min_size); &#125; else &#123; printf(\"-l: False\\n\"); &#125; break; case _h: if (opts[i]) &#123; printf(\"-h: True\\tMax Size:%ld\\n\", max_size); &#125; else &#123; printf(\"-h: False\\n\"); &#125; break; case _m: if (opts[i]) &#123; printf(\"-m: True\\tLimit Day:%ld\\n\", limit_day); &#125; else &#123; printf(\"-m: False\\n\"); &#125; break; case _help: if (opts[i]) &#123; printf(\"-?: True\\n\"); &#125; else &#123; printf(\"-?: False\\n\"); &#125; break; default: printf(RED \"ERROR: Unknown error, please consult me\\n\" NONE); break; &#125; &#125; printf(\"%s\", split); printf(\"Path Count is: %d\\nPath:\\n\", path_num); for (i = 0; i &lt; path_num; i++) &#123; printf(\"%s\\n\", path[i]); &#125; printf(\"%s\", split);&#125;/** * @name: run * @msg: 对一个路径按照选项运行命令 * @param： path为这个路径 * @return: 无 */void run(char *path)&#123; struct stat st; //stat结构体 DIR *dir; //目录句柄 struct dirent *entry; //dirent结构体 char current_path[255]; //当前的路径，最长255 //note:一定要用lstat，否则可能会出现有些文件打不开的情况，下面同理 int ret = lstat(path, &amp;st); //取出当前路径的i节点信息 //成功获取stat if (ret == 0) &#123; //如果是目录 if (S_ISDIR(st.st_mode)) &#123; //打开目录 dir = opendir(path); //打开失败 if (dir == NULL) &#123; printf(RED \"ERROR[%d] open dir \\\"%s\\\": %s\\n\" NONE, errno, path, strerror(errno)); &#125; //打开成功 else &#123; entry = readdir(dir); //只要没有读到目录尾就一直读 while (entry != NULL) &#123; //去掉目录中的.和.. if (strcmp(entry-&gt;d_name, \".\") != 0 &amp;&amp; strcmp(entry-&gt;d_name, \"..\") != 0) &#123; //构造当前目录下各文件路径 strcpy(current_path, path); //忽略路径最后一个字符为‘/’ if (current_path[strlen(current_path) - 1] != '/') &#123; strcat(current_path, \"/\"); &#125; strcat(current_path, entry-&gt;d_name); //获取当前目录下面各文件的stat ret = lstat(current_path, &amp;st); //成功获取stat if (ret == 0) &#123; //输出 //是否显示.开头的文件(包括目录文件) if (opts[_a] || entry-&gt;d_name[0] != '.') &#123; show(st, current_path); //如果还是目录并且指定了选项-r，则进行递归 //也就是说current_path一定是目录 if (S_ISDIR(st.st_mode) &amp;&amp; opts[_r]) &#123; run(current_path); &#125; &#125; &#125; //失败输出错误信息 else &#123; printf(RED \"ERROR[%d] read file \\\"%s\\\": %s\\n\" NONE, errno, current_path, strerror(errno)); &#125; &#125; //继续读下一个 entry = readdir(dir); &#125; closedir(dir); &#125; &#125; //如果是文件，直接打印 else &#123; show(st, path); &#125; &#125; //失败输出错误信息 else &#123; printf(RED \"ERROR[%d] read file \\\"%s\\\": %s\\n\" NONE, errno, path, strerror(errno)); &#125;&#125;/** * @name: show_mode * @author: 苇名一心 * @msg: //输出文件的权限及文件类型（用于-d选项中） * @param：mode_t mode，文件的mode * @return: 无 */void show_mode(mode_t mode)&#123; int pos = 0; char str[] = \"----------\"; if (S_ISREG(mode)) str[pos] = '-'; //普通文件 else if (S_ISBLK(mode)) str[pos] = 'b'; //块设备文件 else if (S_ISDIR(mode)) str[pos] = 'd'; //目录文件 else if (S_ISCHR(mode)) str[pos] = 'c'; //字符设备文件 else if (S_ISLNK(mode)) str[pos] = 'l'; //符号连接文件 else if (S_ISFIFO(mode)) str[pos] = 'p'; //命名管道文件 //按位取与，获得文件所有者权限 pos++; if (S_IRUSR &amp; mode) str[pos] = 'r'; pos++; if (S_IWUSR &amp; mode) str[pos] = 'w'; pos++; if (S_IXUSR &amp; mode) str[pos] = 'x'; //按位取与，获得同组用户权限 pos++; if (S_IRGRP &amp; mode) str[pos] = 'r'; pos++; if (S_IWGRP &amp; mode) str[pos] = 'w'; pos++; if (S_IXGRP &amp; mode) str[pos] = 'x'; //按位取与，获得其他用户权限 pos++; if (S_IROTH &amp; mode) str[pos] = 'r'; pos++; if (S_IWOTH &amp; mode) str[pos] = 'w'; pos++; if (S_IXOTH &amp; mode) str[pos] = 'x'; printf(\"%s\", str);&#125;/** * @name: show * @author: 苇名一心 * @msg: 展示文件信息 * @param: st为文件stat结构体，path为文件路径 * @return: 无 */void show(struct stat st, char *path)&#123; //是否对文件大小最小值有要求 //如果opts[_l]为1，说明有要求，!opts[_l]=0 //0||st.st_size &gt; min_size=st.st_size &gt; min_size //因此刚好可以限制文件大小 //如果opts[_l]为0，说明没有要求，!opts[_l]=1 //1||st.st_size &gt; min_size=1 //因此限制无效，直接通过，没有限制文件大小 //以下其他命令同理 if (!opts[_l] || st.st_size &gt;= min_size) &#123; //是否对文件大小最大值有要求 if (!opts[_h] || st.st_size &lt;= max_size) &#123; //是否对文件修改时间有要求 //st_mtime域代表了文件的最近改变时间 //((current_time - st.st_mtime) / (24 * 60 * 60))可以得到天数 if (!opts[_m] || ((current_time - st.st_mtime) / (24 * 60 * 60)) &lt; limit_day) &#123; if (opts[_d]) &#123; show_mode(st.st_mode); struct passwd *user; user = getpwuid(st.st_uid); struct group *group; group = getgrgid(st.st_gid); char *time_str; time_str = ctime(&amp;st.st_ctime); //将日期最后的'\\n'去掉 time_str[strlen(time_str) - 1] = '\\0'; if (S_ISDIR(st.st_mode)) &#123; printf(\"%5lu %-10s%-10s%-15ld%s \" YELLOW \"%s\\n\" NONE, st.st_nlink, user-&gt;pw_name, group-&gt;gr_name, st.st_size, time_str, path); &#125; else if (S_ISREG(st.st_mode)) &#123; printf(\"%5lu %-10s%-10s%-15ld%s %s\\n\", st.st_nlink, user-&gt;pw_name, group-&gt;gr_name, st.st_size, time_str, path); &#125; else &#123; printf(\"%5lu %-10s%-10s%-15ld%s \" CYAN \"%s\\n\" NONE, st.st_nlink, user-&gt;pw_name, group-&gt;gr_name, st.st_size, time_str, path); &#125; &#125; else &#123; if (S_ISDIR(st.st_mode)) &#123; printf(YELLOW \"%s\\n\" NONE, path); &#125; else if (S_ISREG(st.st_mode)) &#123; printf(\"%s\\n\", path); &#125; else &#123; printf(CYAN \"%s\\n\" NONE, path); &#125; &#125; &#125; &#125; &#125;&#125; 2、list2.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770/* * @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. * @Description: 列表Linux文件，在Ubuntu 18.04上进行的编程，较1.0版本增加了长选项分析的功能 * @Version: 2.0 * @Author: 苇名一心 * @Date: 2020-04-09 17:57:29 * @LastEditors: 苇名一心 * @LastEditTime: 2020-04-13 14:10:59 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;dirent.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#include &lt;pwd.h&gt;#include &lt;grp.h&gt;//颜色#define NONE \"\\e[0m\" //复原#define RED \"\\e[0;31m\" //ERROR#define YELLOW \"\\e[0;33m\" //目录#define CYAN \"\\e[0;36m\" //除普通文件和目录文件外的文件#define OPTION_NUM 7 //选项种类数目（除'--'以外）//****************选项枚举****************enum OPT&#123; _r, //-r, --recursive 递归方式列出子目录 _a, //-a, --all 列出文件名第一个字符为圆点的普通文件 _d, //-d, --detail 展示文件的详细信息（默认只展示文件路径） _l, //-l, --low 后跟一整数，限定文件大小的最小值（字节） _h, //-h, --high 后跟一整数，限定文件大小的最大值（字节） _m, //-m, --mdays 后跟一整数n，限定文件的最近修改时间必须在n天内 _help, //-?, --help 显示帮助&#125; opt;//-- 显式地终止命令选项分析//**************************************char split[] = \"****************************************\\n\"; //分割线char version[] = \"2.0\"; //版本号char **path; //路径int path_num = 0; //用于记录路径的数目int opts[OPTION_NUM] = &#123;0&#125;; //用来存储选项是否开启，数组的每个位置对应相应选项，值为0表示未开启，为1表示开启long max_size = 0; //最大文件尺寸long min_size = 0; //最小文件尺寸time_t limit_day = 0; //最早修改在几天前time_t current_time = 0; //当前系统时间void free_path(); //释放path分配的空间void help(); //打印帮助信息void analyse_input(int argc, char const *argv[]); //分析输入的命令的函数void show_analyse_result(); //输出命令解析的结果void run(char *path); //对一个路径按照选项运行命令void show_mode(mode_t mode); //输出文件的权限及文件类型（用于-d选项中）void show(struct stat st, char *path); //展示文件信息int main(int argc, char const *argv[])&#123; time(&amp;current_time); //获取指令执行时的时间 analyse_input(argc, argv); //分析用户的输入 //用户加了帮助选项，输出帮助信息后退出 if (opts[_help]) &#123; help(); exit(EXIT_SUCCESS); &#125; //用户没有帮助选项，输出命令解析的结果并运行该命令 else &#123; show_analyse_result(); int i = 0; for (i = 0; i &lt; path_num; i++) &#123; run(path[i]); &#125; &#125; free_path(); return 0;&#125;/** * @name: free_path * @author: 苇名一心 * @msg: 释放path分配的空间 * @param: 无 * @return: 无 */void free_path()&#123; int i = 0; for (i = 0; i &lt; path_num; i++) free(path[i]); free(path);&#125;/** * @name: help * @author: 苇名一心 * @msg: 打印帮助信息 * @param: 无 * @return: 无 */void help()&#123; printf(\"%18sHELP%18s\\n%s\", \"\", \"\", split); printf(\"List %s by 苇名一心 Apr 13 2020\\n\", version); printf(\"Usage: ./list [OPTION]... [PATH]...\\n\"); printf(\"List informaton about the FILEs in these PATHs(the current directory by default)\\nOptions:\\n\"); printf(\"\\t-r, --recursive\\t\\tList subdirectories recursively\\n\"); printf(\"\\t-a, --all\\t\\tDo not hide entries starting with .\\n\"); printf(\"\\t-d, --detail\\t\\tShow detail information of file(only file path by default)\\n\"); printf(\"\\t-l, --low=&lt;bytes&gt;\\tMinmum of file size\\n\"); printf(\"\\t-h, --high=&lt;bytes&gt;\\tMaxmum of file size\\n\"); printf(\"\\t-m, --mdays=&lt;days&gt;\\tLimit file last changed time\\n\"); printf(\"\\t-?, --help\\t\\tDisplay this help and exit\\n\"); printf(\"Color:\\n\"); printf(\"\\tWHITE: Regular file\\n\"); printf(YELLOW \"\\tYELLOW: Directory file\\n\" NONE); printf(CYAN \"\\tCYAN: Other file\\n\" NONE); printf(RED \"\\tRED: Error\\n\" NONE); printf(\"%s\", split);&#125;/** * @name: analyse_input * @author: 苇名一心 * @msg: 分析输入的命令的函数 * @param: 同main函数 * @return: 无 */void analyse_input(int argc, char const *argv[])&#123; path = (char **)malloc(argc * sizeof(char *)); int i = 1; int flag = 1; //记录选项分析是否终止，终止为0，未终止为1 for (i = 1; i &lt; argc; i++) &#123; //以-开头的是选项 if (flag &amp;&amp; argv[i][0] == '-') &#123; if (strlen(argv[i]) == 1) &#123; printf(RED \"ERROR: Input option wrong, please input the right option\\n\" NONE); printf(\"Here are some tips:\\n\"); help(); free_path(); exit(EXIT_FAILURE); &#125; else if (strlen(argv[i]) == 2) &#123; switch (argv[i][1]) &#123; case 'r': opts[_r] = 1; break; case 'a': opts[_a] = 1; break; case 'd': opts[_d] = 1; break; case 'l': opts[_l] = 1; //判断-l选项后面有没有参数 if (i &lt; argc - 1) &#123; char *stop; long int size = strtol(argv[++i], &amp;stop, 10); //stop长度为0代表进行了有效的转换 if (strlen(stop) == 0) &#123; min_size = size; &#125; else &#123; printf(RED \"ERROR: Input option -l wrong, there is no required min size, please input the right option\\n\" NONE); printf(\"Here are some tips:\\n\"); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; else &#123; printf(RED \"ERROR: Input option -l wrong, there is no required min size, please input the right option\\n\" NONE); printf(\"Here are some tips:\\n\"); help(); free_path(); exit(EXIT_FAILURE); &#125; break; case 'h': opts[_h] = 1; //判断-h选项后面有没有参数 if (i &lt; argc - 1) &#123; char *stop; long int size = strtol(argv[++i], &amp;stop, 10); //stop长度为0代表进行了有效的转换 if (strlen(stop) == 0) &#123; max_size = size; &#125; else &#123; printf(RED \"ERROR: Input option -h wrong, there is no required max size, please input the right option\\n\" NONE); printf(\"Here are some tips:\\n\"); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; else &#123; printf(RED \"ERROR: Input option -h wrong, there is no required max size, please input the right option\\n\" NONE); printf(\"Here are some tips:\\n\"); help(); free_path(); exit(EXIT_FAILURE); &#125; break; case 'm': opts[_m] = 1; //判断-m选项后面有没有参数 if (i &lt; argc - 1) &#123; char *stop; long int day = strtol(argv[++i], &amp;stop, 10); //stop长度为0代表进行了有效的转换 if (strlen(stop) == 0) &#123; limit_day = day; &#125; else &#123; printf(RED \"ERROR: Input option -m wrong, there is no required limit day, please input the right option\\n\" NONE); printf(\"Here are some tips:\\n\"); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; else &#123; printf(RED \"ERROR: Input option -m wrong, there is no required limit day, please input the right option\\n\" NONE); printf(\"Here are some tips:\\n\"); help(); free_path(); exit(EXIT_FAILURE); &#125; break; case '?': opts[_help] = 1; break; case '-': flag = 0; break; default: printf(RED \"ERROR: Input option wrong, please input the right option\\n\" NONE); printf(\"Here are some tips:\\n\"); help(); free_path(); exit(EXIT_FAILURE); break; &#125; &#125; //长度&gt;2的情况，也就是长选项 else &#123; if (strchr(argv[i], '=')) &#123; if (strstr(argv[i], \"--low=\")) &#123; opts[_l] = 1; //判断--low选项后面有没有参数 if (strlen(argv[i]) &gt; 6) &#123; char *stop; long int size = strtol(argv[i] + sizeof(char) * 6, &amp;stop, 10); //stop长度为0代表进行了有效的转换 if (strlen(stop) == 0) &#123; min_size = size; &#125; else &#123; printf(RED \"ERROR: Input option --low wrong, there is no required min size, please input the right option\\n\" NONE); printf(\"Here are some tips:\\n\"); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; else &#123; printf(RED \"ERROR: Input option --low wrong, there is no required min size, please input the right option\\n\" NONE); printf(\"Here are some tips:\\n\"); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; else if (strstr(argv[i], \"--high=\")) &#123; opts[_h] = 1; //判断--high选项后面有没有参数 if (strlen(argv[i]) &gt; 7) &#123; char *stop; long int size = strtol(argv[i] + sizeof(char) * 7, &amp;stop, 10); //stop长度为0代表进行了有效的转换 if (strlen(stop) == 0) &#123; max_size = size; &#125; else &#123; printf(RED \"ERROR: Input option --high wrong, there is no required max size, please input the right option\\n\" NONE); printf(\"Here are some tips:\\n\"); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; else &#123; printf(RED \"ERROR: Input option --high wrong, there is no required max size, please input the right option\\n\" NONE); printf(\"Here are some tips:\\n\"); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; else if (strstr(argv[i], \"--mdays=\")) &#123; opts[_m] = 1; //判断--mdays选项后面有没有参数 if (strlen(argv[i]) &gt; 8) &#123; char *stop; long int day = strtol(argv[i] + sizeof(char) * 8, &amp;stop, 10); //stop长度为0代表进行了有效的转换 if (strlen(stop) == 0) &#123; limit_day = day; &#125; else &#123; printf(RED \"ERROR: Input option --mdays wrong, there is no required limit day, please input the right option\\n\" NONE); printf(\"Here are some tips:\\n\"); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; else &#123; printf(RED \"ERROR: Input option --mdays wrong, there is no required limit day, please input the right option\\n\" NONE); printf(\"Here are some tips:\\n\"); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; else &#123; printf(RED \"ERROR: Input option wrong, please input the right option\\n\" NONE); printf(\"Here are some tips:\\n\"); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; else &#123; if (strcmp(\"--recursive\", argv[i]) == 0) &#123; opts[_r] = 1; &#125; else if (strcmp(\"--all\", argv[i]) == 0) &#123; opts[_a] = 1; &#125; else if (strcmp(\"--detail\", argv[i]) == 0) &#123; opts[_d] = 1; &#125; else if (strcmp(\"--help\", argv[i]) == 0) &#123; opts[_help] = 1; &#125; else &#123; printf(RED \"ERROR: Input option wrong, please input the right option\\n\" NONE); printf(\"Here are some tips:\\n\"); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; &#125; &#125; else &#123; //不是-开头的认为是路径或者--后面的全部认为是路径 path[path_num] = (char *)malloc(strlen(argv[i]) * sizeof(char)); strcpy(path[path_num++], argv[i]); &#125; &#125; if (opts[_l] &amp;&amp; opts[_h]) &#123; if (min_size &gt; max_size) &#123; printf(RED \"ERROR: Min size of file is less than Max size of file, please input the right option\\n\" NONE); printf(\"Here are some tips:\\n\"); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; //没有输入路径，默认为当前工作目录 if (path_num == 0) &#123; path[path_num] = (char *)malloc(sizeof(char) * 255); if (!getcwd(path[path_num++], sizeof(char) * 255)) &#123; printf(RED \"ERROR: Get current work path wrong\\n\" NONE); free_path(); exit(EXIT_FAILURE); &#125; &#125;&#125;/** * @name: show_analyse_result * @author: 苇名一心 * @msg: 输出命令解析的结果 * @param: 无 * @return: 无 */void show_analyse_result()&#123; printf(\"Input Analyse Results are:\\n\"); int i = 0; for (i = 0; i &lt; OPTION_NUM; i++) &#123; switch (i) &#123; case _r: if (opts[i]) &#123; printf(\"-r, --recursive: True\\n\"); &#125; else &#123; printf(\"-r, --recursive: False\\n\"); &#125; break; case _a: if (opts[i]) &#123; printf(\"-a, --all:\\t True\\n\"); &#125; else &#123; printf(\"-a, --all:\\t False\\n\"); &#125; break; case _d: if (opts[i]) &#123; printf(\"-d, --detail:\\t True\\n\"); &#125; else &#123; printf(\"-d, --detail:\\t False\\n\"); &#125; break; case _l: if (opts[i]) &#123; printf(\"-l, --low:\\t True\\tMin Size:%ld\\n\", min_size); &#125; else &#123; printf(\"-l, --low:\\t False\\n\"); &#125; break; case _h: if (opts[i]) &#123; printf(\"-h, --high:\\t True\\tMax Size:%ld\\n\", max_size); &#125; else &#123; printf(\"-h, --high:\\t False\\n\"); &#125; break; case _m: if (opts[i]) &#123; printf(\"-m, --mdays:\\t True\\tLimit Day:%ld\\n\", limit_day); &#125; else &#123; printf(\"-m, --mdays:\\t False\\n\"); &#125; break; case _help: if (opts[i]) &#123; printf(\"-?, --help:\\t True\\n\"); &#125; else &#123; printf(\"-?, --help:\\t False\\n\"); &#125; break; default: printf(RED \"ERROR: Unknown error, please consult me\\n\" NONE); break; &#125; &#125; printf(\"%s\", split); printf(\"Path Count is: %d\\nPath:\\n\", path_num); for (i = 0; i &lt; path_num; i++) &#123; printf(\"%s\\n\", path[i]); &#125; printf(\"%s\", split);&#125;/** * @name: run * @msg: 对一个路径按照选项运行命令 * @param： path为这个路径 * @return: 无 */void run(char *path)&#123; struct stat st; //stat结构体 DIR *dir; //目录句柄 struct dirent *entry; //dirent结构体 char current_path[255]; //当前的路径，最长255 //note:一定要用lstat，否则可能会出现有些文件打不开的情况，下面同理 int ret = lstat(path, &amp;st); //取出当前路径的i节点信息 //成功获取stat if (ret == 0) &#123; //如果是目录 if (S_ISDIR(st.st_mode)) &#123; //打开目录 dir = opendir(path); //打开失败 if (dir == NULL) &#123; printf(RED \"ERROR[%d] open dir \\\"%s\\\": %s\\n\" NONE, errno, path, strerror(errno)); &#125; //打开成功 else &#123; entry = readdir(dir); //只要没有读到目录尾就一直读 while (entry != NULL) &#123; //去掉目录中的.和.. if (strcmp(entry-&gt;d_name, \".\") != 0 &amp;&amp; strcmp(entry-&gt;d_name, \"..\") != 0) &#123; //构造当前目录下各文件路径 strcpy(current_path, path); //忽略路径最后一个字符为‘/’ if (current_path[strlen(current_path) - 1] != '/') &#123; strcat(current_path, \"/\"); &#125; strcat(current_path, entry-&gt;d_name); //获取当前目录下面各文件的stat ret = lstat(current_path, &amp;st); //成功获取stat if (ret == 0) &#123; //输出 //是否显示.开头的文件(包括目录文件) if (opts[_a] || entry-&gt;d_name[0] != '.') &#123; show(st, current_path); //如果还是目录并且指定了选项-r，则进行递归 //也就是说current_path一定是目录 if (S_ISDIR(st.st_mode) &amp;&amp; opts[_r]) &#123; run(current_path); &#125; &#125; &#125; //失败输出错误信息 else &#123; printf(RED \"ERROR[%d] read file \\\"%s\\\": %s\\n\" NONE, errno, current_path, strerror(errno)); &#125; &#125; //继续读下一个 entry = readdir(dir); &#125; closedir(dir); &#125; &#125; //如果是文件，直接打印 else &#123; show(st, path); &#125; &#125; //失败输出错误信息 else &#123; printf(RED \"ERROR[%d] read file \\\"%s\\\": %s\\n\" NONE, errno, path, strerror(errno)); &#125;&#125;/** * @name: show_mode * @author: 苇名一心 * @msg: //输出文件的权限及文件类型（用于-d选项中） * @param：mode_t mode，文件的mode * @return: 无 */void show_mode(mode_t mode)&#123; int pos = 0; char str[] = \"----------\"; if (S_ISREG(mode)) str[pos] = '-'; //普通文件 else if (S_ISBLK(mode)) str[pos] = 'b'; //块设备文件 else if (S_ISDIR(mode)) str[pos] = 'd'; //目录文件 else if (S_ISCHR(mode)) str[pos] = 'c'; //字符设备文件 else if (S_ISLNK(mode)) str[pos] = 'l'; //符号连接文件 else if (S_ISFIFO(mode)) str[pos] = 'p'; //命名管道文件 //按位取与，获得文件所有者权限 pos++; if (S_IRUSR &amp; mode) str[pos] = 'r'; pos++; if (S_IWUSR &amp; mode) str[pos] = 'w'; pos++; if (S_IXUSR &amp; mode) str[pos] = 'x'; //按位取与，获得同组用户权限 pos++; if (S_IRGRP &amp; mode) str[pos] = 'r'; pos++; if (S_IWGRP &amp; mode) str[pos] = 'w'; pos++; if (S_IXGRP &amp; mode) str[pos] = 'x'; //按位取与，获得其他用户权限 pos++; if (S_IROTH &amp; mode) str[pos] = 'r'; pos++; if (S_IWOTH &amp; mode) str[pos] = 'w'; pos++; if (S_IXOTH &amp; mode) str[pos] = 'x'; printf(\"%s\", str);&#125;/** * @name: show * @author: 苇名一心 * @msg: 展示文件信息 * @param: st为文件stat结构体，path为文件路径 * @return: 无 */void show(struct stat st, char *path)&#123; //是否对文件大小最小值有要求 //如果opts[_l]为1，说明有要求，!opts[_l]=0 //0||st.st_size &gt; min_size=st.st_size &gt; min_size //因此刚好可以限制文件大小 //如果opts[_l]为0，说明没有要求，!opts[_l]=1 //1||st.st_size &gt; min_size=1 //因此限制无效，直接通过，没有限制文件大小 //以下其他命令同理 if (!opts[_l] || st.st_size &gt;= min_size) &#123; //是否对文件大小最大值有要求 if (!opts[_h] || st.st_size &lt;= max_size) &#123; //是否对文件修改时间有要求 //st_mtime域代表了文件的最近改变时间 //((current_time - st.st_mtime) / (24 * 60 * 60))可以得到天数 if (!opts[_m] || ((current_time - st.st_mtime) / (24 * 60 * 60)) &lt; limit_day) &#123; if (opts[_d]) &#123; show_mode(st.st_mode); struct passwd *user; user = getpwuid(st.st_uid); struct group *group; group = getgrgid(st.st_gid); char *time_str; time_str = ctime(&amp;st.st_ctime); //将日期最后的'\\n'去掉 time_str[strlen(time_str) - 1] = '\\0'; if (S_ISDIR(st.st_mode)) &#123; printf(\"%5lu %-10s%-10s%-15ld%s \" YELLOW \"%s\\n\" NONE, st.st_nlink, user-&gt;pw_name, group-&gt;gr_name, st.st_size, time_str, path); &#125; else if (S_ISREG(st.st_mode)) &#123; printf(\"%5lu %-10s%-10s%-15ld%s %s\\n\", st.st_nlink, user-&gt;pw_name, group-&gt;gr_name, st.st_size, time_str, path); &#125; else &#123; printf(\"%5lu %-10s%-10s%-15ld%s \" CYAN \"%s\\n\" NONE, st.st_nlink, user-&gt;pw_name, group-&gt;gr_name, st.st_size, time_str, path); &#125; &#125; else &#123; if (S_ISDIR(st.st_mode)) &#123; printf(YELLOW \"%s\\n\" NONE, path); &#125; else if (S_ISREG(st.st_mode)) &#123; printf(\"%s\\n\", path); &#125; else &#123; printf(CYAN \"%s\\n\" NONE, path); &#125; &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/categories/Linux/"},{"name":"上机实战","slug":"Linux/上机实战","permalink":"https://666wxy666.github.io/categories/Linux/%E4%B8%8A%E6%9C%BA%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/tags/Linux/"},{"name":"C","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"实战","slug":"实战","permalink":"https://666wxy666.github.io/tags/%E5%AE%9E%E6%88%98/"},{"name":"ls","slug":"ls","permalink":"https://666wxy666.github.io/tags/ls/"},{"name":"遍历目录","slug":"遍历目录","permalink":"https://666wxy666.github.io/tags/%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95/"}]},{"title":"机器学习 知识拓展 条件熵","slug":"机器学习-知识拓展-条件熵","date":"2020-04-17T16:00:00.000Z","updated":"2020-09-02T02:06:13.861Z","comments":true,"path":"2020/04/18/机器学习-知识拓展-条件熵/","link":"","permalink":"https://666wxy666.github.io/2020/04/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%9F%A5%E8%AF%86%E6%8B%93%E5%B1%95-%E6%9D%A1%E4%BB%B6%E7%86%B5/","excerpt":"本文是关于条件熵的知识拓展。","text":"本文是关于条件熵的知识拓展。 一、问题：假定数据库有𝑁个人，第𝑛个人的先验概率$\\gamma_n$，有𝐾个问题，假定第𝑛个人对第𝑘个问题答案为“是”的概率为$a_{nk}$，请给出给定第𝑘个问题条件下，数据集的条件熵的计算公式。 二、解析原来的条件熵公式为： $$H(Y|X)=\\sum_{x}{P(x)H(Y|X=x)}$$ 因为此题中X的取值只有两个即‘是’和‘否’，因此公式变为： $$H(Y|X)=P(X=是)H(Y|X=是)+P(X=否)H(Y|X=否)$$ 因此先计算对于第k个问题，X=‘是’的样本占总样本的概率P(X=是)和X=‘否’的样本占总样本的概率P(X=否)。 分子为对于第k个问题回答为‘是’的个数即： $$\\sum^{N}_{i=1}{(N\\times\\gamma_i\\times a_{ik})}$$ 分母为总数N，因此P(X=是)： $$P(X=是)=\\frac{\\sum^{N}_{i=1}{(N\\times\\gamma_i\\times a_{ik}})}{N}$$ $$P(X=是)=\\sum^{N}_{i=1}{(\\gamma_i\\times a_{ik})}$$ 同理，P(X=否)： $$P(X=否)=\\frac{\\sum^{N}_{i=1}{[N\\times\\gamma_i\\times (1-a_{ik})}]}{N}$$ $$P(X=否)=\\sum^{N}_{i=1}{[\\gamma_i\\times (1-a_{ik})]}$$ 然后在计算对于第k个问题，X=‘是’的数据集上Y的信息熵和X=‘否’的数据集上Y的信息熵，也就是： $$H(Y|X=是)=-\\sum^{N}_{j=1}{(p(x_j)\\log p(x_j))}$$ $$H(Y|X=否)=-\\sum^{N}_{j=1}{(q(x_j)\\log q(x_j))}$$ 因此要先计算对于第k个问题，X=‘是’的时候，对应每个人‘j’的概率$p(x_j)$。 分子为对于第k个问题，X=‘是’的时候，‘j’这个人的个数： $$N\\times\\gamma_j\\times{a_{jk}}$$ 分母为对于第k个问题所有X=‘是’的个数，也就是上述的P(X=是)的分子： $$\\sum^{N}_{i=1}{(N\\times\\gamma_i\\times a_{ik})}$$ 或者写为： $$P(X=是)\\times{N}$$ 因此$p(x_j)$： $$p(x_j)=\\frac{N\\times\\gamma_j\\times{a_{jk}}}{\\sum^{N}_{i=1}{(N\\times\\gamma_i\\times a_{ik}})}$$ $$p(x_j)=\\frac{\\gamma_j\\times{a_{jk}}}{\\sum^{N}_{i=1}{(\\gamma_i\\times a_{ik})}}$$ 同理X=‘否’的时候，对应每个人‘j’的概率$q(x_j)$： $$q(x_j)=\\frac{N\\times\\gamma_j\\times{(1-a_{jk})}}{\\sum^{N}_{i=1}{[N\\times\\gamma_i\\times (1-a_{jk})}]}$$ $$q(x_j)=\\frac{\\gamma_j\\times{(1-a_{jk})}}{\\sum^{N}_{i=1}{[\\gamma_i\\times (1-a_{jk})]}}$$ 综上所述，可以得出条件熵的最终公式为：","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://666wxy666.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"知识拓展","slug":"机器学习/知识拓展","permalink":"https://666wxy666.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%9F%A5%E8%AF%86%E6%8B%93%E5%B1%95/"}],"tags":[{"name":"拓展","slug":"拓展","permalink":"https://666wxy666.github.io/tags/%E6%8B%93%E5%B1%95/"},{"name":"机器学习","slug":"机器学习","permalink":"https://666wxy666.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"知识","slug":"知识","permalink":"https://666wxy666.github.io/tags/%E7%9F%A5%E8%AF%86/"},{"name":"条件熵","slug":"条件熵","permalink":"https://666wxy666.github.io/tags/%E6%9D%A1%E4%BB%B6%E7%86%B5/"}]},{"title":"现代交换原理 MOOC习题 1~4章","slug":"现代交换原理-MOOC习题-1~4章","date":"2020-04-16T16:00:00.000Z","updated":"2020-09-02T02:07:52.890Z","comments":true,"path":"2020/04/17/现代交换原理-MOOC习题-1~4章/","link":"","permalink":"https://666wxy666.github.io/2020/04/17/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86-MOOC%E4%B9%A0%E9%A2%98-1~4%E7%AB%A0/","excerpt":"自己随便整理了一下在学习“现代交换原理”网课时遇到的一些习题，易错点之类的。","text":"自己随便整理了一下在学习“现代交换原理”网课时遇到的一些习题，易错点之类的。 第一章 交换概论 都是类似的道理，话音业务需要实时、高可靠、恒定速率，因此电路交换适合，异步显然不适合于话音业务。 电路交换是先建立好链路，在进行的交换。路由选择是先进行的，信息转发在建立好的链路上进行。分组交换是上面描述的特点。 通信网三要素是：交换设备、传输设备、终端设备。 交换网络的三要素是：交换单元、不同交换单元间的拓扑连接、控制方式。 第二章 交换网络 交换单元的端口类型有两种：控制端口和状态端口。 T接线器： 话音存储器（SM）：固定每个存储单元8bit存话音，存储单元的数量m就是时隙数m。 控制存储器（CM）：存储单元大小为$\\log_2{m}$，所以时隙数一般都是2的幂次，存储单元的数量m也是时隙数m。 S接线器没有话音存储器，控制存储器（CM），可以把S接线器的所有的控制存储器看成$m\\times{n}$个方格，m为时隙数，n为入（出）线数： S接线器所含CM的数量就是入（出）线数n，也就是一列为一个CM，共有n列。 每个CM所含的存储单元的数量为入（出）线的时隙数m，也就是每个格代表一个存储单元，每个CM有m个存储单元，m行。 每个存储单元的大小为$\\log_2{m}$bit。 $N\\times{N}$的Banyan网络需要$k=\\log_2{N}$级，如果要使用$2\\times{2}$的交换单元构建，那么每层就需要$\\frac{N}{2}$个交换单元，k层共需要$k\\times{\\frac{N}{2}}=\\frac{N}{2}\\times{\\log_2{N}}$，如果是M层的话，则需要$m\\times{\\frac{N}{2}\\times{\\log_2{N}}}$个$2\\times{2}$的交换单元。 因此这个题需要$3\\times{\\frac{8}{2}\\times{\\log_2{8}}}=36$个$2\\times{2}$的交换单元。 第三章 电路交换 常识知识。 示意图： B+C-&gt;A： 这三个题都是基础知识。 直连？应该是可以实现不经过交换设备的语音通信。 用户模块的处理机与区域处理机相连，区域处理机又与其他区域处理机和中央处理机相连。 周期级程序是按一定周期进行的各种扫描和驱动，例如200ms摘挂机扫描。开通业务应该是基本级程序负责。 第四章 分组交换 TCP连接的建立不是路由器基本功能。 ISDN全称是综合业务数字网，不需要支持模拟业务。 ATM 适配层（AAL）主要负责百 ATM 层与高层之间的信元转发过程。从上层收到信息后，AAL 将数据分割成 ATM 信元；从 ATM 层收到信息后，AAL 必须重度新组合数据形成一专个上层能够辨识的格式。上述操作称之为分段与重组（SAR），它是 AAL 的主要任务。此外不同的 AAL 支持属不同的流量或服务类型。 MPLS标记可以任意级，标记栈实现多级标记，Label可以有多个。 A、MPLS和ATM和帧中继都是路由选择和数据转发分开进行，都是面向连接的，但是不需要为每一次通信业务都建立新的连接；而传统IP网是无连接的，路由选择和数据转发同时进行。 B、MPLS和ATM都是虚连接，使用时连接，不需要时可以拆除连接，不是永久连接。 C、MPLS使用的是Label标记方式的逻辑连接，ATM是VPI/VCI方式的逻辑连接，都是逻辑虚连接。 D、MPLS通过LDP等协议，在LSR和LER、LSR和LSR之间完成标记信息的分发，形成与FEC对应的LSP路径。 同上一个题的D选项。 入口LER接收分组，完成第三层功能，判定分组所属的FEC，并给分组加上标记形成MPLS标记分组。 LSR依据分组上的标记以及标记转发表通过交换单元对其进行转发，不再进行任何第三层处理，也就是只处理标记部分，不处理IP分组头。 出口 LER 将分组中的标记去掉后转发至目的地。 MPLS与ATM/FR类似，标记都是本地（逐段）有效的，需要路由器进行标记转换。 所有的习题： 现代交换原理 MOOC习题 1~4章现代交换原理 MOOC习题 5~6章","categories":[{"name":"现代交换原理","slug":"现代交换原理","permalink":"https://666wxy666.github.io/categories/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"},{"name":"习题","slug":"现代交换原理/习题","permalink":"https://666wxy666.github.io/categories/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"习题","slug":"习题","permalink":"https://666wxy666.github.io/tags/%E4%B9%A0%E9%A2%98/"},{"name":"易错点","slug":"易错点","permalink":"https://666wxy666.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"网课","slug":"网课","permalink":"https://666wxy666.github.io/tags/%E7%BD%91%E8%AF%BE/"},{"name":"MOOC","slug":"MOOC","permalink":"https://666wxy666.github.io/tags/MOOC/"},{"name":"现代交换原理","slug":"现代交换原理","permalink":"https://666wxy666.github.io/tags/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"}]},{"title":"计算机系统结构 实验 使用MIPS指令实现冒泡排序法","slug":"计算机系统结构-实验-使用MIPS指令实现冒泡排序法","date":"2020-04-15T16:00:00.000Z","updated":"2020-09-02T02:08:49.323Z","comments":true,"path":"2020/04/16/计算机系统结构-实验-使用MIPS指令实现冒泡排序法/","link":"","permalink":"https://666wxy666.github.io/2020/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AE%9E%E9%AA%8C-%E4%BD%BF%E7%94%A8MIPS%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%B3%95/","excerpt":"本文是关于计算机系统结构实验四，使用MIPS指令实现冒泡排序法。","text":"本文是关于计算机系统结构实验四，使用MIPS指令实现冒泡排序法。 一、实验目的 掌握静态调度方法 增强汇编语言编程能力 学会使用模拟器中的定向功能进行优化 二、实验原理​ 通过编写MIPS汇编程序，实现冒泡排序的功能。在模拟器MIPSsim上执行所写的汇编程序，查看结果，判断所写的汇编程序是否正确。然后观察时钟周期图窗口的执行过程和冲突的指令，查看统计窗口的信息，来判断定向前后和优化前后的执行效率高低。 三、实验步骤及结果分析1、自行编写一个实现冒泡排序的汇编程序，该程序要求可以实现对一维整数数组进行冒泡排序。冒泡排序算法的运作如下： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点， 最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 要求数组长度不得小于10 PS：汇编程序见附录。 2、启动 MIPSsim。 3、载入自己编写的程序，观察流水线输出结果。载入的代码： 执行结果： 内存中的数组 原数组是{5,4,11,3,7,1,10,6,8,9,2}，排序后是{1,2,3,4,5,6,7,8,9,10,11}，结果符合预期，说明编写的汇编程序正确。 部分时钟周期图 可以看到有非常多的停顿，主要是DSUB命令与BGTZ命令的RAW停顿，还有一些控制停顿。 统计 发现RAW停顿有417个周期，停顿次数非常多，可以进行优化。共执行了1076个周期，RAW停顿占周期总数的百分比为38.75465%，所有的停顿为537个周期，占周期总数的百分比为49.90706%，效率很低。$$吞吐率TP_1=\\frac{538}{1076\\Delta{t}}$$ $$加速比S_1=\\frac{538\\times{5\\Delta{t}}}{1076\\Delta{t}}={2.5}$$ 4、使用定向功能再次执行代码，与刚才执行结果进行比较，观察执行效率的不同。 内存中的数组 结果正确。 部分时钟周期图 在使用定向技术后，发现停顿明显减少。 统计 发现RAW停顿有175个周期，停顿周期数比没有定向技术时的417个少了很多； 共执行了834个周期，比没有定向技术时的1076个也少了很多； RAW停顿占周期总数的百分比为20.98321%，较没有定向技术时的38.75465%也减少了很多； 所有的停顿为295个周期，占周期总数的百分比为35.3717%，较没有定向技术时的49.90706%也减少了很多； $$吞吐率TP_2=\\frac{538}{834\\Delta{t}}$$ $$加速比S_2=\\frac{538\\times{5\\Delta{t}}}{834\\Delta{t}}\\approx{3.23}$$吞吐率和加速比是没有定向技术时的$\\frac{1076}{834}\\approx{1.29}$倍。 5、采用静态调度方法重排指令序列，减少相关，优化程序因为主要是DSUB命令与BGTZ命令的RAW停顿，分支指令的操作数需要用到前面的结果，因此将后面pass中执行的ADDIU $r4, $r4, 1和DSUB $r8, $r2, $r4拿到loop2中执行，从而减少RAW停顿。 PS：静态调度后的汇编程序见附录。 载入代码 内存中的数组 结果正确。 部分时钟周期图 在使用静态调度后，发现停顿少了很多。 统计 发现RAW停顿有142个周期，停顿周期数比没有静态调度时的417个少了很多； 共执行了801个周期，比没有静态调度时的1076个也少了很多； RAW停顿占周期总数的百分比为17.72784%，较没有静态调度时的38.75465%也减少了很多； 所有的停顿为262个周期，占周期总数的百分比为32.70911%，较没有静态调度时的49.90706%也减少了很多； $$吞吐率TP_3=\\frac{538}{801\\Delta{t}}$$ $$加速比S_3=\\frac{538\\times{5\\Delta{t}}}{801\\Delta{t}}\\approx{3.36}$$ 吞吐率和加速比是没有静态调度时的$\\frac{1076}{801}\\approx{1.34}$倍。 6、对优化后的程序使用定向功能执行，与刚才执行结果进行比较，观察执行效率的不同。 内存中的数组 结果正确。 部分时钟周期图 在使用静态调度和定向技术后，发现所有的RAW停顿几乎没有了，几乎只剩下了控制停顿。 统计 发现RAW停顿有10个周期，停顿周期数比没有静态调度和定向技术时的417个少了非常多； 共执行了669个周期，比没有静态调度和定向技术时的1076个也少了非常多； RAW停顿占周期总数的百分比为1.494768%，较没有静态调度和定向技术时的38.75465%也减少了非常多； 所有的停顿为130个周期，占周期总数的百分比为19.43199%，较没有静态调度和定向技术时的49.90706%也减少了很多； $$吞吐率TP_4=\\frac{538}{669\\Delta{t}}$$ $$加速比S_4=\\frac{538\\times{5\\Delta{t}}}{669\\Delta{t}}\\approx{4.02}$$ 吞吐率和加速比是没有静态调度和定向技术时的$\\frac{1076}{669}\\approx{1.61}$倍。 四、实验遇到的问题​ 本次实验中遇到了一个问题，如果main到下一个标签（比如loop1）只有一行汇编代码，在载入程序时，loop1的基地址就会和main重合，变为0x00000000，这样就导致loop1被覆盖，使载入的程序与自己编写的汇编程序不符，产生错误或者结果出错。但是如果&gt;=2行汇编代码就不会有问题，我怀疑是MIPSsim程序的bug。 五、附录1、初始的汇编代码12345678910111213141516171819202122232425262728293031.textmain:ADDIU $r1, $r0, 11 # 数组长度n&#x3D;11ADDIU $r2, $r1, -1 # 外循环i&#x3D;n-1&#x3D;10loop1:ADDIU $r3, $r0, array # 数组起始地址ADDIU $r4, $r0, 0 # 内循环j&#x3D;0loop2:LW $r5, 0($r3) # a[j]LW $r6, 4($r3) # a[j+1]DSUB $r7, $r6, $r5 # a[j+1]-a[j]BGTZ $r7, pass # a[j+1]&gt;a[j]，不交换，跳到pass；SW $r6, 0($r3) # a[j+1]&lt;a[j]，交换SW $r5, 4($r3)pass:ADDIU $r4, $r4, 1 # j++ADDIU $r3, $r3, 4 # 取数组的下一个元素DSUB $r8, $r2, $r4 # i-jBGTZ $r8, loop2 # i&gt;j，跳转到loop2，继续内循环ADDIU $r2, $r2, -1 # i--BGTZ $r2, loop1 # i&gt;0，跳转到loop1，继续外循环TEQ $r0, $r0.dataarray: .word 5,4,11,3,7,1,10,6,8,9,2 2、经过静态调度后的汇编代码12345678910111213141516171819202122232425262728293031.textmain:ADDIU $r1, $r0, 11 # 数组长度n&#x3D;11ADDIU $r2, $r1, -1 # 外循环i&#x3D;n-1&#x3D;10loop1:ADDIU $r3, $r0, array # 数组起始地址ADDIU $r4, $r0, 0 # 内循环j&#x3D;0loop2:LW $r5, 0($r3) # a[j]LW $r6, 4($r3) # a[j+1]ADDIU $r4, $r4, 1 # j++DSUB $r7, $r6, $r5 # a[j+1]-a[j]DSUB $r8, $r2, $r4 # i-jBGTZ $r7, pass # a[j+1]&gt;a[j]，不交换，跳到pass；SW $r6, 0($r3) # a[j+1]&lt;a[j]，交换SW $r5, 4($r3)pass:ADDIU $r3, $r3, 4 # 取数组的下一个元素BGTZ $r8, loop2 # i&gt;j，跳转到loop2，继续内循环ADDIU $r2, $r2, -1 # i--BGTZ $r2, loop1 # i&gt;0，跳转到loop1，继续外循环TEQ $r0, $r0.dataarray: .word 5,4,11,3,7,1,10,6,8,9,2","categories":[{"name":"计算机系统结构","slug":"计算机系统结构","permalink":"https://666wxy666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"},{"name":"实验","slug":"计算机系统结构/实验","permalink":"https://666wxy666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"实验","slug":"实验","permalink":"https://666wxy666.github.io/tags/%E5%AE%9E%E9%AA%8C/"},{"name":"计算机系统结构","slug":"计算机系统结构","permalink":"https://666wxy666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"},{"name":"汇编","slug":"汇编","permalink":"https://666wxy666.github.io/tags/%E6%B1%87%E7%BC%96/"},{"name":"MIPS","slug":"MIPS","permalink":"https://666wxy666.github.io/tags/MIPS/"}]},{"title":"Linux 上机实战1 正则表达式","slug":"Linux-上机实战1-正则表达式","date":"2020-03-27T16:00:00.000Z","updated":"2020-09-02T01:59:52.857Z","comments":true,"path":"2020/03/28/Linux-上机实战1-正则表达式/","link":"","permalink":"https://666wxy666.github.io/2020/03/28/Linux-%E4%B8%8A%E6%9C%BA%E5%AE%9E%E6%88%981-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"本文是关于Linux中的文本处理三剑客（grep，sed，awk），以及正则表达式应用的一个样例，获取北京某时刻PM2.5的数据，然后进行处理，输出到csv文件中，并画图表展示。","text":"本文是关于Linux中的文本处理三剑客（grep，sed，awk），以及正则表达式应用的一个样例，获取北京某时刻PM2.5的数据，然后进行处理，输出到csv文件中，并画图表展示。 一、题目要求：​ 从因特网上搜索 Web 页，用 wget 获取网页，处理网页 html 文本数据，从中提取出当前时间点北京各监测站的 PM2.5 浓度，输出如下 CSV 格式数据：2020 03 09 13:00:00, 海淀区万柳 ,732020 03 09 13:00:00, 昌平镇 ,672020 03 09 13:00:00, 奥体中心 ,662020 03 09 13:00:00, 海淀区万柳 ,732020 03 09 13:00:00, 昌平镇 ,732020 03 09 13:00:00, 奥体中心 ,75​ 撰写实验报告，要求：写出对数据的分析和处理思路，列出各个处理步骤并给出解释。 二、详细步骤： 从因特网上搜索 Web 页，找到与含有北京各监测站的 PM2.5 浓度的网站，我找到了**绿色呼吸网**，网站如下： 使用**Xshell**登录到Ubuntu服务器： 使用**wget**命令获取该网页： 1wget http://www.pm25.com/city/beijing.html 使用**cat**命令查看该网页的内容： 1cat beijing.html | more 我们关注的内容： ​ ①数据更新的时间： ​ ②各监测点PM2.5浓度数据： 发现时间的地方有个*“更新时间：”**，监测点名称的地方都有“pjadt_location”*，而PM2.5浓度的地方都有**“pjadt_pm25”。根据这个特性，先使用*awk**命令将需要的行保留下来。下面先进行编写1.awk***： 1vim 1.awk 运行以下命令，对所需行进行过滤： 1cat beijing.html | awk -f 1.awk | more 发现除了我们想要的行还多出了这几行： 经过观察，发现*“PM2.5”**浓度这一行与我们所需的行的区别是，我们所需的行有μg*，而**“PM2.5”浓度这一行没有： 我们重新对*“1.awk”**进行编辑，直接将“监测站点”*这一行排除，并且对**“PM2.5”浓度这一行采用额外的过滤规则: 重新运行以下命令，对所需行进行过滤： 1cat beijing.html | awk -f 1.awk | more 发现已经筛选出了所需要的行。 现在再利用*sed**命令将html标签”&lt;&gt;“*中的内容和**“更新时间：”这个无用的信息删除： 1cat beijing.html | awk -f 1.awk | sed -e 's/&lt;[^&lt;&gt;]*&gt;//g' -e 's/更新时间：//g' | more 发现已经只剩余我们想要的数据。 但是这些数据不在同一行，且没有明显特征，无法进行*awk**命令，因此先使用tr***命令将这些行合并为一行，以空格分隔： 1cat beijing.html | awk -f 1.awk | sed -e 's/&lt;[^&lt;&gt;]*&gt;//g' -e 's/更新时间：//g' | tr '\\n' ' ' | more 最后利用*awk**命令将所需内容规格化输出即可，先编辑“2.awk”***： 1vim 2.awk 利用*for**循环输出，NF*为列数，刚好循环$$(NF-2)/4$$次，第一个**%s为*日期**，第二个%s*为**时间，第三个*%s**为监测点名称*，第四个**%s为*PM2.5浓度**，再运行以下awk***命令，即可得到格式化的输出： 1cat beijing.html | awk -f 1.awk | sed -e 's/&lt;[^&lt;&gt;]*&gt;//g' -e 's/更新时间：//g' | tr '\\n' ' ' | awk -f 2.awk | more 发现输出已经符合题目要求。 将结果重定向到文件**“beijing.csv”**： 12cat beijing.html | awk -f 1.awk | sed -e 's/&lt;[^&lt;&gt;]*&gt;//g' -e 's/更新时间：//g' | tr '\\n' ' ' | awk -f 2.awk &gt; beijing.csvvim beijing.csv 将*beijing.csv**发送到电脑，并将编码转为ANSI***： 由于不同时间的数据有所不同，因此我的过滤语句考虑了不同时间点的情况*（北京一共有12个监测点，有时有的监测点没有数据，因此是只有11个监测点的数据）**，直接运行以下命令就可以直接将数据导出为beijing.csv***，以下为另一时间点的数据情况： 12wget http://www.pm25.com/city/beijing.htmlcat beijing.html | awk -f 1.awk | sed -e 's/&lt;[^&lt;&gt;]*&gt;//g' -e 's/更新时间：//g' | tr '\\n' ' ' | awk -f 2.awk &gt; beijing.csv 三、总结本文以一个样例，详细介绍了Linux中的文本处理三剑客（grep，sed，awk），以及正则表达式的相关知识，希望对你的Linux学习有所帮助。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/categories/Linux/"},{"name":"上机实战","slug":"Linux/上机实战","permalink":"https://666wxy666.github.io/categories/Linux/%E4%B8%8A%E6%9C%BA%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/tags/Linux/"},{"name":"C","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"实战","slug":"实战","permalink":"https://666wxy666.github.io/tags/%E5%AE%9E%E6%88%98/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://666wxy666.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"计算机系统结构 实验 1和2遇到的问题","slug":"计算机系统结构-实验-1和2遇到的问题","date":"2020-03-25T16:00:00.000Z","updated":"2020-09-02T02:08:22.862Z","comments":true,"path":"2020/03/26/计算机系统结构-实验-1和2遇到的问题/","link":"","permalink":"https://666wxy666.github.io/2020/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AE%9E%E9%AA%8C-1%E5%92%8C2%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"本文是关于计算机系统结构实验一（MIPS指令系统和MIPS体系结构）和实验二（流水线及流水线中的冲突），遇到的一些问题。","text":"本文是关于计算机系统结构实验一（MIPS指令系统和MIPS体系结构）和实验二（流水线及流水线中的冲突），遇到的一些问题。 一、关于字B:byte 字节指令 H:half word 半字节指令 W:word 字节指令 二、关于访存按字或半字访存，无论给定地址是字（半字）中的哪一个字节的地址，都会自动转换为该字（半字）的首字节的地址。例如：MIPS中字长4字节，32位（红色框）；半字2字节，16位（蓝色框）。无论你给定的是第一个红框里的7C(0x00000000)/00(0x00000001)/08(0x00000002)/24(0x00000003)的哪一的地址，只要是按字访存，都会自动转换为7C的地址0x00000000，取出的内容都是2408007C，**一定要注意，这里是小端法存储**。 小端法：高内存地址放整数的高位，低内存地址放整数的低位，这种方式叫倒着放，术语叫小端对齐。电脑X86和手机ARM都是小端对齐的。 大端法：高内存地址放整数的低位，低内存地址放整数的高位，这种方式叫正着放，术语叫大端对齐。很多Unix服务器的cpu都是大端对齐的。 大端和小端字节序不是由操作系统决定的，而是由cpu架构决定的。 三、关于返回地址关于这里的**返回地址**，后面的所有其他跳转指令的返回地址均指的是：当前指令的下一条指令的地址，也就是跳转指令如果不跳转（分支失败）的下一条指令的地址。例如：当前的指令的地址是0x00000068，那么返回地址就是0x00000072。还要注意offset要左移两位并进行符号位扩展后才能与PC相加得到转移地址。这里左移两位的目的是，将offset*4，使之成为4的倍数。也就是说PC+offset&lt;&lt;2代表了PC的后offset+1（因为PC+offset&lt;&lt;2的PC已经+1了）条指令为转移指令。 四、关于定向技术在定向技术中，因为其采用的是静态指令调度。非运算类指令必须在 ID段 得到之前指令的定向数据。并不能像运算类执行一样在 EX段 得到定向数据；如图所示： 五、关于STALL“绿色ID后跟绿色ID” 和 “绿色STALL后跟绿色ID”的区别：绿色ID表示该周期ID可以执行，但是存在RAW冲突，因此执行失败，因此紧接着要做绿色ID；绿色STALL表示该周期由于上一条指令的红色STALL，导致该指令此周期停顿，下一周期执行绿色ID。","categories":[{"name":"计算机系统结构","slug":"计算机系统结构","permalink":"https://666wxy666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"},{"name":"实验","slug":"计算机系统结构/实验","permalink":"https://666wxy666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"实验","slug":"实验","permalink":"https://666wxy666.github.io/tags/%E5%AE%9E%E9%AA%8C/"},{"name":"计算机系统结构","slug":"计算机系统结构","permalink":"https://666wxy666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"},{"name":"汇编","slug":"汇编","permalink":"https://666wxy666.github.io/tags/%E6%B1%87%E7%BC%96/"},{"name":"MIPS","slug":"MIPS","permalink":"https://666wxy666.github.io/tags/MIPS/"}]},{"title":"大数据实战 Spark Java单词计数","slug":"大数据实战-Spark-Java单词计数","date":"2020-03-14T16:00:00.000Z","updated":"2020-09-02T02:04:16.588Z","comments":true,"path":"2020/03/15/大数据实战-Spark-Java单词计数/","link":"","permalink":"https://666wxy666.github.io/2020/03/15/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%88%98-Spark-Java%E5%8D%95%E8%AF%8D%E8%AE%A1%E6%95%B0/","excerpt":"本文是关于大数据通过Spark实现Java单词计数。","text":"本文是关于大数据通过Spark实现Java单词计数。 一、实验环境： 虚拟机数量：1 系统版本：Centos 7.5 Spark版本：Apache Spark 2.1.1 JDK版本： jdk-8u131-linux-x64 IDEA版本：ideaIC-2017.2.7 二、实验内容： 创建spark项目 使用Java API 编写wordcount 打印结果 三、实验步骤：3.1新建数据源3.1.1在/home/zkpk目录下创建worddata.txt文件 12cdvim worddata.txt 3.1.2输入以下内容作为JavaWordCount程序的源数据 123456789hello hi hi sparkhello spark hello hi sparksqlhello hi hi sparkstreaminghello hi sparkgraphxhello hello worldhello java c pythonhello scala go htmlhi hi hello spark hdfshello hadoop 3.1.3打开IDEA，创建Java任务 123cdcd idea-IC-172.4574.19/bin/idea.sh &amp; 3.2创建Spark Maven工程，使用Java API 编写wordcount3.2.1点击 Create New Project 3.2.2进入如下图界面，按照图标依次点击，最后点击next 3.2.3依次输入GroupId和ArtifactId和Version的值，随后点击next 3.2.4进入如下界面，设置本地Maven项目的setting.xml文件和warehouse仓库，点击next按钮 3.2.4.1本地setting.xml文件在/home/zkpk/apache-maven-3.5.0/conf目录下 3.2.4.2本地仓库文件夹warehouse在/home/zkpk/apache-maven-3.5.0/warehouse 3.2.5进入如下界面，输入工程名称spark_test，然后点击next，OK 3.2.6工程创建完成后会自动打开一个名为zkpk的xml文件，按照以下修改： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.zkpk.lab&lt;/groupId&gt; &lt;artifactId&gt;zkpk&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;inceptionYear&gt;2008&lt;/inceptionYear&gt; &lt;properties&gt; &lt;scala.version&gt;2.11.11&lt;/scala.version&gt; &lt;spark.version&gt;2.1.1&lt;/spark.version&gt; &lt;/properties&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;scala-tools.org&lt;/id&gt; &lt;name&gt;Scala-Tools Maven2 Repository&lt;/name&gt; &lt;url&gt;http://scala-tools.org/repo-releases&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;scala-tools.org&lt;/id&gt; &lt;name&gt;Scala-Tools Maven2 Repository&lt;/name&gt; &lt;url&gt;http://scala-tools.org/repo-releases&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.scala-lang&lt;/groupId&gt; &lt;artifactId&gt;scala-library&lt;/artifactId&gt; &lt;version&gt;$&#123;scala.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-core_2.11&lt;/artifactId&gt; &lt;version&gt;$&#123;spark.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-sql_2.11&lt;/artifactId&gt; &lt;version&gt;$&#123;spark.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;sourceDirectory&gt;src/main/scala&lt;/sourceDirectory&gt; &lt;testSourceDirectory&gt;src/test/scala&lt;/testSourceDirectory&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.scala-tools&lt;/groupId&gt; &lt;artifactId&gt;maven-scala-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;goal&gt;testCompile&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;scalaVersion&gt;$&#123;scala.version&#125;&lt;/scalaVersion&gt; &lt;args&gt; &lt;arg&gt;-target:jvm-1.5&lt;/arg&gt; &lt;/args&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-eclipse-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;downloadSources&gt;true&lt;/downloadSources&gt; &lt;buildcommands&gt; &lt;buildcommand&gt;ch.epfl.lamp.sdt.core.scalabuilder&lt;/buildcommand&gt; &lt;/buildcommands&gt; &lt;additionalProjectnatures&gt; &lt;projectnature&gt;ch.epfl.lamp.sdt.core.scalanature&lt;/projectnature&gt; &lt;/additionalProjectnatures&gt; &lt;classpathContainers&gt; &lt;classpathContainer&gt;org.eclipse.jdt.launching.JRE_CONTAINER&lt;/classpathContainer&gt; &lt;classpathContainer&gt;ch.epfl.lamp.sdt.launching.SCALA_CONTAINER&lt;/classpathContainer&gt; &lt;/classpathContainers&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;reporting&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.scala-tools&lt;/groupId&gt; &lt;artifactId&gt;maven-scala-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;scalaVersion&gt;$&#123;scala.version&#125;&lt;/scalaVersion&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/reporting&gt;&lt;/project&gt; 3.2.7保存修改的pom.xml文件后，点击工程名，依次选择Maven——&gt;Reimport，即可根据pom.xml文件导入依赖包，出现下图就代表正在导入依赖包 3.2.8设置语言环境language level，点击菜单栏中的file，选择Project Structure，弹出如下对话框，选择Modules，选择Language level为8，然后点击Apply，点击OK 3.2.9设置Java Compiler环境，点击菜单栏中的file，选择Setting，弹出如下对话框，依次选择Build，Execution——&gt;Compiler——&gt;Java Compiler，设置图中的Project bytecode version为1.8，设置图中的Target bytecode version为1.8，然后依次点击Apply和OK 至此，Spark Maven工程创建完毕 3.2.10在main文件夹下新建文件夹，在弹出的对话框中，输入新文件夹名称为java，点击ok 3.2.11右击先创建的java目录，依次选择Mark Directory as—&gt;Sources Root，此时就可以在java目录中创建类了，我们右键点击java目录，依次选择New——&gt;Java——&gt;Class，弹出对话框，输入Java Class的名字：JavaWordCount，然后点击ok 3.2.12编写如下Java代码，实现词频统计，我在原有的参考答案上又新增了可以根据次品的大小，从大到小排序展示的功能，下面是代码截图，具体代码在本文的附录中 3.3运行程序，查看结果选中程序JavaWordCount，在代码界面点击鼠标右键，出现如下提示框，选择并点击Run JavaWordCount.main()，运行程序，并在终端界面查看程序输出结果 四、附录1、JavaWordCount.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import org.apache.spark.api.java.JavaPairRDD;import org.apache.spark.api.java.JavaRDD;import org.apache.spark.sql.SparkSession;import scala.Tuple2;import java.util.Arrays;import java.util.List;import java.util.regex.Pattern;public final class JavaWordCount &#123; private static final Pattern SPACE = Pattern.compile(\" \"); public static void main(String[] args) throws Exception&#123; SparkSession ss = SparkSession .builder() .master(\"local\") .appName(\"JavaWordCount\") .getOrCreate(); JavaRDD&lt;String&gt; lines = ss.read().textFile(\"file:///home/zkpk/worddata.txt\").javaRDD(); JavaRDD&lt;String&gt; words = lines.flatMap(s -&gt; Arrays.asList(SPACE.split(s)).iterator()); JavaPairRDD&lt;String, Integer&gt; wordAndOne = words.mapToPair(s -&gt; new Tuple2&lt;&gt;(s, 1)); JavaPairRDD&lt;String, Integer&gt; wordAndNum = wordAndOne.reduceByKey((i1, i2) -&gt; i1 + i2); //自己额外实现了可以根据词频的大小，从大到小排序展示的功能 List&lt;Tuple2&lt;String, Integer&gt;&gt; result = wordAndNum //先将key和value交换 .mapToPair((row) -&gt; new Tuple2&lt;&gt;(row._2,row._1)) //按照交换后的key也就是词频倒排序 .sortByKey(false) //再将key和value交换回来，回到单词在前，词频在后的状态 .mapToPair((row) -&gt; new Tuple2&lt;&gt;(row._2,row._1)) .collect(); for (Tuple2&lt;?,?&gt; tuple : result)&#123; System.out.println(tuple._1() + \": \" + tuple._2()); &#125; ss.stop(); &#125;&#125; 2、ScalaWordCount.scala1234567891011121314151617181920212223242526272829package org.zkpk.labimport org.apache.spark.rdd.RDDimport org.apache.spark.&#123;SparkConf, SparkContext&#125;class ScalaWordCount &#123;&#125;object ScalaWordCount&#123; def main(args: Array[String]): Unit = &#123; val list = List(\"hello hi hi spark \", \"hello spark hello hi sparksql \", \"hello hi hi sparkstreaming \", \"hello hi sparkgraphx\") val sparkConf = new SparkConf().setAppName(\"word-count\").setMaster(\"local[*]\") val sc = new SparkContext(sparkConf) val lines: RDD[String] = sc.parallelize(list) val words: RDD[String] = lines.flatMap((line: String) =&gt; &#123;line.split(\" \")&#125;) val wordAndOne: RDD[(String, Int)] = words.map((word: String) =&gt; &#123;(word, 1)&#125;) val wordAndNum: RDD[(String, Int)] = wordAndOne.reduceByKey((count1: Int, count2: Int) =&gt; &#123;count1+ count2&#125;) val ret = wordAndNum.sortBy(kv =&gt; kv._2, false) println(ret.collect().mkString(\",\")) ret.saveAsTextFile(args(0)) sc.stop() &#125;&#125;","categories":[{"name":"大数据","slug":"大数据","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"实战","slug":"大数据/实战","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"实战","slug":"实战","permalink":"https://666wxy666.github.io/tags/%E5%AE%9E%E6%88%98/"},{"name":"大数据","slug":"大数据","permalink":"https://666wxy666.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Spark","slug":"Spark","permalink":"https://666wxy666.github.io/tags/Spark/"},{"name":"单词计数","slug":"单词计数","permalink":"https://666wxy666.github.io/tags/%E5%8D%95%E8%AF%8D%E8%AE%A1%E6%95%B0/"},{"name":"Scala","slug":"Scala","permalink":"https://666wxy666.github.io/tags/Scala/"},{"name":"Java","slug":"Java","permalink":"https://666wxy666.github.io/tags/Java/"}]},{"title":"Linux MOOC习题 1~5章","slug":"Linux-MOOC习题-1~5章","date":"2020-03-09T16:00:00.000Z","updated":"2020-09-02T01:56:47.317Z","comments":true,"path":"2020/03/10/Linux-MOOC习题-1~5章/","link":"","permalink":"https://666wxy666.github.io/2020/03/10/Linux-MOOC%E4%B9%A0%E9%A2%98-1~5%E7%AB%A0/","excerpt":"自己随便整理了一下在学习Linux网课时遇到的一些习题，易错点之类的。","text":"自己随便整理了一下在学习Linux网课时遇到的一些习题，易错点之类的。 废话不多说，直接开始： PS：第一章是课程介绍。 二、开始使用Linux和文本文件的处理 第1题其实是很基础的问题，早期的终端一般由键盘、显示器和RS232串行通信接口构成，没有磁盘存储器，其实可以想象成和打字机差不多的东西，他就是直接在显示器上显示了，不需要磁盘存储器。 第2题也比较基础： 行律的作用是： 一行内字符的缓冲、回显和编辑，直到按下回车键； 数据的加工，类似第二题中的将“\\n”替换为“\\r\\n”； 将CTRL-C字符转换为终止进程的信号； 驱动程序其实是串口与行律的接口，负责上行和下行字符流。 这俩题没啥好说的，基础知识。 并不是这样的，CTRL-C确实传送了字符**（Ctrl+字母组合键可以产生ASCII码为1-26的控制字符，字母序号是几，ASCII码就是几，Ctrl+C的ASCII码应为3）**，其实还是行律的作用，他将CTRL-C字符转换为终止进程的信号，从而通知Linux主机，进程终止。 这俩题都是关于uniq命令的。 123uniq -uuniq -duniq 第一个命令，-u代表unique，只打印没有重复的行； 第二个命令，-d代表duplicated，只打印重复的行，注意重复的行只打印一次； 第三个命令，啥也不加就是都打印，但是也是复的行只打印一次； 还有就是关于重复的行，意思其实是连续的紧邻的两行内容相同才被叫做重复的行，因此第10题是错的。 这个题不难，写出来的目的是只要记得 Less is more 就很好想了，less是more的升级版。 这俩题也不多解释了，od不可打印字符也可以显示，tr是用于翻译，把string1出现的字符替换为string2中对应的字符，ASCII字符0也可以翻译。 1tr string1 string2 三、正则表达式 先说一下正则表达式的**元字符**，有6个，分别是： 1. * [ \\ ^ $ 关于他们各自的含义不多说，自行百度，一定要注意的是]不是元字符，很容易搞错。 而关于单字符正则表达式，显而易见，就是匹配一个字符呗，不过有特殊的: \\加一个字符构成的转义字符，看做单字符正则表达式； 1\\. \\* \\[ \\\\ \\^ \\$ []定义的集合也被看做单字符正则表达式; 因为.本来的含义是匹配任意字符，转义后就是单字符.，因此都是单字符正则表达式，而$在尾部时和^在首部时有特殊含义，因此转义之前不是，转义后就是单字符​了。 这个题就比较有意思了，先看一下sed命令的基本用法： 1sed 's/正则表达式/字符串/g' 文件名列表 s选项的意思是替换，将文件中匹配第一个//中的正则表达式的内容替换为第二个//中的字符串。 然后我们在看上题‘’中的正则表达式（也就是第一个//中的内容） 1\\[[^][]*] 可以分为三部分： 因为[是元字符，加\\转义后就变成了真正的[。 1\\[ 中间这一部分是一个集合[]，重复一次或多次[]*，集合里面的^代表排除，排除了]和[，意思就是说除]和[外的字符重复一次或多次。那么这就有一个问题，第一个[为什么不与第一个]匹配，反而去和最后一个]匹配呢？个人觉得，因为如果与第一个]匹配，就有了[^]，这显然是错误的正则表达式，那么就继续向后匹配，因此就匹配到了最后面的]。 1[^][]* 因为]不是元字符，也没有[与它匹配，它就是单纯的一个字符]。 1] 综上所述，这个正则表达式可以匹配“[非]和[的字符任意多个]”，类似[参考文献23]这样的，但是如果[]里面还有]和[，就匹配不到了。再看上面的题，第二个//里面是空的，那么就是把匹配到的内容删除，很好理解。 四、文件比较，文件通配符 vi的基本用法，在命令状态 12345678:q 退出（:quit的缩写）:q! 退出且不保存（:quit!的缩写）:wq 保存并退出:wq! 保存并退出即使文件没有写入权限（强制保存退出）:x 保存并退出（类似:wq，但是只有在有更改的情况下才保存）:exit 保存并退出（和:x相同）:qa 退出所有(:quitall的缩写):cq 退出且不保存（即便有错误） 另外在“正常模式”下输入“ZZ”来保存并退出Vim（和:x相同），或者“ZQ”不保存并退出（和:q!相同）注意此处ZZ大写和小写是完全不同的。 diff一般用于比较文本文件。 五、文件管理和目录管理 在Linux中，Shell会自动帮你进项一些替换，实际运行的命令其实是： 1cp src/x.c src/xx.c src/xxx.c src/x.h src/xx.h src/xxx.h…… 如果有好多.c和.h文件（超过两个），cp就会报错： cp: target xxx is not a directory 但是如果只有两个.c或.h文件，那么就会产生非常严重的后果，实际运行了下面的命令： 1cp src/x.c src/y.c 这是非常危险的，这样y.c的内容会被x.c覆盖，这是我们不愿意看到的。 那么应该用什么命令来实现题目的要求呢？ 1cp src/*.[ch] . 我们显示地指定复制到.（当前目录），就不会出现问题了。 这也是在Linux中很怪的地方，明明你不能写这个文件，但是你却可以删除，如果不加-f，删除只读文件时会有提示，但是加了-f就没有任何提示了。还有一点需要注意的是，如第6题所说，加了-f也不能删除无权限删除的文件。 关于第10题，不像Windows，在Linux中这些后缀都是约定俗成的，只是为了做标记用，好区分而已，没有实际意义。 所有的习题： Linux MOOC习题 1~5章Linux MOOC习题 6~10章Linux MOOC习题 11~15章","categories":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/categories/Linux/"},{"name":"习题","slug":"Linux/习题","permalink":"https://666wxy666.github.io/categories/Linux/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/tags/Linux/"},{"name":"习题","slug":"习题","permalink":"https://666wxy666.github.io/tags/%E4%B9%A0%E9%A2%98/"},{"name":"易错点","slug":"易错点","permalink":"https://666wxy666.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"网课","slug":"网课","permalink":"https://666wxy666.github.io/tags/%E7%BD%91%E8%AF%BE/"},{"name":"MOOC","slug":"MOOC","permalink":"https://666wxy666.github.io/tags/MOOC/"}]},{"title":"Hello Blog","slug":"我的第一篇博客","date":"2020-02-09T16:00:00.000Z","updated":"2020-09-02T01:54:58.521Z","comments":true,"path":"2020/02/10/我的第一篇博客/","link":"","permalink":"https://666wxy666.github.io/2020/02/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"HELLO BLOG 欢迎来到我的博客，这是我的第一篇博客测试文章。","text":"HELLO BLOG 欢迎来到我的博客，这是我的第一篇博客测试文章。 如果有什么问题，欢迎到我的Github提问我。","categories":[{"name":"其他","slug":"其他","permalink":"https://666wxy666.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"first","slug":"first","permalink":"https://666wxy666.github.io/tags/first/"}]}],"categories":[{"name":"C/C++","slug":"C-C","permalink":"https://666wxy666.github.io/categories/C-C/"},{"name":"项目","slug":"C-C/项目","permalink":"https://666wxy666.github.io/categories/C-C/%E9%A1%B9%E7%9B%AE/"},{"name":"杂项","slug":"杂项","permalink":"https://666wxy666.github.io/categories/%E6%9D%82%E9%A1%B9/"},{"name":"机器学习","slug":"机器学习","permalink":"https://666wxy666.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"实验","slug":"机器学习/实验","permalink":"https://666wxy666.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8C/"},{"name":"大数据","slug":"大数据","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"实战","slug":"大数据/实战","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%AE%9E%E6%88%98/"},{"name":"拓展学习","slug":"C-C/拓展学习","permalink":"https://666wxy666.github.io/categories/C-C/%E6%8B%93%E5%B1%95%E5%AD%A6%E4%B9%A0/"},{"name":"Python","slug":"Python","permalink":"https://666wxy666.github.io/categories/Python/"},{"name":"爬虫","slug":"Python/爬虫","permalink":"https://666wxy666.github.io/categories/Python/%E7%88%AC%E8%99%AB/"},{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/categories/Linux/"},{"name":"拓展学习","slug":"Linux/拓展学习","permalink":"https://666wxy666.github.io/categories/Linux/%E6%8B%93%E5%B1%95%E5%AD%A6%E4%B9%A0/"},{"name":"习题","slug":"Linux/习题","permalink":"https://666wxy666.github.io/categories/Linux/%E4%B9%A0%E9%A2%98/"},{"name":"现代交换原理","slug":"现代交换原理","permalink":"https://666wxy666.github.io/categories/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"},{"name":"习题","slug":"现代交换原理/习题","permalink":"https://666wxy666.github.io/categories/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/%E4%B9%A0%E9%A2%98/"},{"name":"习题","slug":"大数据/习题","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E4%B9%A0%E9%A2%98/"},{"name":"上机实战","slug":"Linux/上机实战","permalink":"https://666wxy666.github.io/categories/Linux/%E4%B8%8A%E6%9C%BA%E5%AE%9E%E6%88%98/"},{"name":"计算机系统结构","slug":"计算机系统结构","permalink":"https://666wxy666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"},{"name":"实验","slug":"计算机系统结构/实验","permalink":"https://666wxy666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E5%AE%9E%E9%AA%8C/"},{"name":"知识拓展","slug":"机器学习/知识拓展","permalink":"https://666wxy666.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%9F%A5%E8%AF%86%E6%8B%93%E5%B1%95/"},{"name":"其他","slug":"其他","permalink":"https://666wxy666.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"工程","slug":"工程","permalink":"https://666wxy666.github.io/tags/%E5%B7%A5%E7%A8%8B/"},{"name":"操作系统","slug":"操作系统","permalink":"https://666wxy666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"内存管理","slug":"内存管理","permalink":"https://666wxy666.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"读者写者","slug":"读者写者","permalink":"https://666wxy666.github.io/tags/%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85/"},{"name":"生产者消费者","slug":"生产者消费者","permalink":"https://666wxy666.github.io/tags/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/"},{"name":"进程","slug":"进程","permalink":"https://666wxy666.github.io/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"同步互斥","slug":"同步互斥","permalink":"https://666wxy666.github.io/tags/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/"},{"name":"信号量","slug":"信号量","permalink":"https://666wxy666.github.io/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/tags/Linux/"},{"name":"线程","slug":"线程","permalink":"https://666wxy666.github.io/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"通信","slug":"通信","permalink":"https://666wxy666.github.io/tags/%E9%80%9A%E4%BF%A1/"},{"name":"编译原理","slug":"编译原理","permalink":"https://666wxy666.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"语法分析","slug":"语法分析","permalink":"https://666wxy666.github.io/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"},{"name":"LL1","slug":"LL1","permalink":"https://666wxy666.github.io/tags/LL1/"},{"name":"LR","slug":"LR","permalink":"https://666wxy666.github.io/tags/LR/"},{"name":"词法分析","slug":"词法分析","permalink":"https://666wxy666.github.io/tags/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"},{"name":"C","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://666wxy666.github.io/tags/Python/"},{"name":"项目","slug":"项目","permalink":"https://666wxy666.github.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"机器学习","slug":"机器学习","permalink":"https://666wxy666.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"实验","slug":"实验","permalink":"https://666wxy666.github.io/tags/%E5%AE%9E%E9%AA%8C/"},{"name":"华为云","slug":"华为云","permalink":"https://666wxy666.github.io/tags/%E5%8D%8E%E4%B8%BA%E4%BA%91/"},{"name":"人工智能","slug":"人工智能","permalink":"https://666wxy666.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"AI","slug":"AI","permalink":"https://666wxy666.github.io/tags/AI/"},{"name":"分类","slug":"分类","permalink":"https://666wxy666.github.io/tags/%E5%88%86%E7%B1%BB/"},{"name":"实战","slug":"实战","permalink":"https://666wxy666.github.io/tags/%E5%AE%9E%E6%88%98/"},{"name":"大数据","slug":"大数据","permalink":"https://666wxy666.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Spark","slug":"Spark","permalink":"https://666wxy666.github.io/tags/Spark/"},{"name":"流计算","slug":"流计算","permalink":"https://666wxy666.github.io/tags/%E6%B5%81%E8%AE%A1%E7%AE%97/"},{"name":"单词计数","slug":"单词计数","permalink":"https://666wxy666.github.io/tags/%E5%8D%95%E8%AF%8D%E8%AE%A1%E6%95%B0/"},{"name":"Streaming","slug":"Streaming","permalink":"https://666wxy666.github.io/tags/Streaming/"},{"name":"Scala","slug":"Scala","permalink":"https://666wxy666.github.io/tags/Scala/"},{"name":"Kafka","slug":"Kafka","permalink":"https://666wxy666.github.io/tags/Kafka/"},{"name":"Java","slug":"Java","permalink":"https://666wxy666.github.io/tags/Java/"},{"name":"日志分析","slug":"日志分析","permalink":"https://666wxy666.github.io/tags/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"},{"name":"难点","slug":"难点","permalink":"https://666wxy666.github.io/tags/%E9%9A%BE%E7%82%B9/"},{"name":"C99","slug":"C99","permalink":"https://666wxy666.github.io/tags/C99/"},{"name":"Struct","slug":"Struct","permalink":"https://666wxy666.github.io/tags/Struct/"},{"name":"QT","slug":"QT","permalink":"https://666wxy666.github.io/tags/QT/"},{"name":"小游戏","slug":"小游戏","permalink":"https://666wxy666.github.io/tags/%E5%B0%8F%E6%B8%B8%E6%88%8F/"},{"name":"爬虫","slug":"爬虫","permalink":"https://666wxy666.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"数据处理","slug":"数据处理","permalink":"https://666wxy666.github.io/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"学堂在线","slug":"学堂在线","permalink":"https://666wxy666.github.io/tags/%E5%AD%A6%E5%A0%82%E5%9C%A8%E7%BA%BF/"},{"name":"课程","slug":"课程","permalink":"https://666wxy666.github.io/tags/%E8%AF%BE%E7%A8%8B/"},{"name":"RNN","slug":"RNN","permalink":"https://666wxy666.github.io/tags/RNN/"},{"name":"起名字","slug":"起名字","permalink":"https://666wxy666.github.io/tags/%E8%B5%B7%E5%90%8D%E5%AD%97/"},{"name":"Shell","slug":"Shell","permalink":"https://666wxy666.github.io/tags/Shell/"},{"name":"拓展","slug":"拓展","permalink":"https://666wxy666.github.io/tags/%E6%8B%93%E5%B1%95/"},{"name":"习题","slug":"习题","permalink":"https://666wxy666.github.io/tags/%E4%B9%A0%E9%A2%98/"},{"name":"易错点","slug":"易错点","permalink":"https://666wxy666.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"网课","slug":"网课","permalink":"https://666wxy666.github.io/tags/%E7%BD%91%E8%AF%BE/"},{"name":"MOOC","slug":"MOOC","permalink":"https://666wxy666.github.io/tags/MOOC/"},{"name":"现代交换原理","slug":"现代交换原理","permalink":"https://666wxy666.github.io/tags/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"},{"name":"HDFS","slug":"HDFS","permalink":"https://666wxy666.github.io/tags/HDFS/"},{"name":"MapReduce","slug":"MapReduce","permalink":"https://666wxy666.github.io/tags/MapReduce/"},{"name":"DNN","slug":"DNN","permalink":"https://666wxy666.github.io/tags/DNN/"},{"name":"手写识别","slug":"手写识别","permalink":"https://666wxy666.github.io/tags/%E6%89%8B%E5%86%99%E8%AF%86%E5%88%AB/"},{"name":"可视化","slug":"可视化","permalink":"https://666wxy666.github.io/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"name":"iPython","slug":"iPython","permalink":"https://666wxy666.github.io/tags/iPython/"},{"name":"Matplotlib","slug":"Matplotlib","permalink":"https://666wxy666.github.io/tags/Matplotlib/"},{"name":"K-Means","slug":"K-Means","permalink":"https://666wxy666.github.io/tags/K-Means/"},{"name":"聚类","slug":"聚类","permalink":"https://666wxy666.github.io/tags/%E8%81%9A%E7%B1%BB/"},{"name":"计算机系统结构","slug":"计算机系统结构","permalink":"https://666wxy666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"},{"name":"汇编","slug":"汇编","permalink":"https://666wxy666.github.io/tags/%E6%B1%87%E7%BC%96/"},{"name":"MIPS","slug":"MIPS","permalink":"https://666wxy666.github.io/tags/MIPS/"},{"name":"脚本","slug":"脚本","permalink":"https://666wxy666.github.io/tags/%E8%84%9A%E6%9C%AC/"},{"name":"决策树","slug":"决策树","permalink":"https://666wxy666.github.io/tags/%E5%86%B3%E7%AD%96%E6%A0%91/"},{"name":"ls","slug":"ls","permalink":"https://666wxy666.github.io/tags/ls/"},{"name":"遍历目录","slug":"遍历目录","permalink":"https://666wxy666.github.io/tags/%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95/"},{"name":"知识","slug":"知识","permalink":"https://666wxy666.github.io/tags/%E7%9F%A5%E8%AF%86/"},{"name":"条件熵","slug":"条件熵","permalink":"https://666wxy666.github.io/tags/%E6%9D%A1%E4%BB%B6%E7%86%B5/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://666wxy666.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"first","slug":"first","permalink":"https://666wxy666.github.io/tags/first/"}]}