{"meta":{"title":"Sekiro's Blog","subtitle":null,"description":"经验分享和技术交流","author":"Sekiro","url":"https://666wxy666.github.io","root":"/"},"pages":[{"title":"","date":"2021-05-30T09:07:07.229Z","updated":"2021-05-30T09:07:07.229Z","comments":true,"path":"about/index.html","permalink":"https://666wxy666.github.io/about/index.html","excerpt":"","text":"这里是我的基本信息：我的博客（Github）：Sekiro’s Blog 我的博客（Notion）：Sekiro’s Blog 我的博客（Gitee）：Sekiro’s Blog 我的Notion主页：Sekiro 我的Github主页：Sekiro 我的Gitee主页：Sekiro 我的B站：-Sekiro- 我的知乎：Sekiro 我的网易云：Sekiro 我的微博：-Sekiro- 欢迎关注我，与我联系。"},{"title":"哔哔","date":"2021-05-30T09:07:07.229Z","updated":"2021-05-30T09:07:07.229Z","comments":false,"path":"bb/index.html","permalink":"https://666wxy666.github.io/bb/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2021-05-30T09:07:07.229Z","updated":"2021-05-30T09:07:07.229Z","comments":true,"path":"categories/index.html","permalink":"https://666wxy666.github.io/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2021-05-30T09:07:07.229Z","updated":"2021-05-30T09:07:07.229Z","comments":true,"path":"friends/index.html","permalink":"https://666wxy666.github.io/friends/index.html","excerpt":"这里是我的朋友和一些大佬，感兴趣的就点进去看看吧！","text":"这里是我的朋友和一些大佬，感兴趣的就点进去看看吧！ 想在这里展示或者有什么问题欢迎给我留言。"},{"title":"","date":"2021-05-30T09:07:07.229Z","updated":"2021-05-30T09:07:07.229Z","comments":true,"path":"mylist/index.html","permalink":"https://666wxy666.github.io/mylist/index.html","excerpt":"","text":""},{"title":"说说","date":"2021-05-30T09:07:07.229Z","updated":"2021-05-30T09:07:07.229Z","comments":false,"path":"shuoshuo/index.html","permalink":"https://666wxy666.github.io/shuoshuo/index.html","excerpt":"","text":""},{"title":"标签云","date":"2021-05-30T09:07:07.229Z","updated":"2021-05-30T09:07:07.229Z","comments":true,"path":"tags/index.html","permalink":"https://666wxy666.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android 项目集锦","slug":"Android-项目集锦","date":"2021-01-04T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2021/01/04/Android-项目集锦/","link":"","permalink":"https://666wxy666.github.io/2021/01/04/Android-%E9%A1%B9%E7%9B%AE%E9%9B%86%E9%94%A6/","excerpt":"本文是Android项目工程集锦。","text":"本文是Android项目工程集锦。 这些项目的源码、可执行程序、报告等已经存放于我的Github，欢迎下载查看： 第一次作业-Hello Word 第二次作业 第三次作业 第四次作业-模拟时钟 第五次作业-注册界面 第六次作业-Todo List 第七次作业-Video Player","categories":[{"name":"集锦","slug":"集锦","permalink":"https://666wxy666.github.io/categories/%E9%9B%86%E9%94%A6/"},{"name":"Android","slug":"集锦/Android","permalink":"https://666wxy666.github.io/categories/%E9%9B%86%E9%94%A6/Android/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://666wxy666.github.io/tags/Java/"},{"name":"Android","slug":"Android","permalink":"https://666wxy666.github.io/tags/Android/"},{"name":"集锦","slug":"集锦","permalink":"https://666wxy666.github.io/tags/%E9%9B%86%E9%94%A6/"}]},{"title":"Android项目 类抖音视频播放器","slug":"Android项目-类抖音视频播放器","date":"2021-01-04T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2021/01/04/Android项目-类抖音视频播放器/","link":"","permalink":"https://666wxy666.github.io/2021/01/04/Android%E9%A1%B9%E7%9B%AE-%E7%B1%BB%E6%8A%96%E9%9F%B3%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8/","excerpt":"本文是Android项目“类抖音视频播放器”的实现，具体项目及要求请点击查看。","text":"本文是Android项目“类抖音视频播放器”的实现，具体项目及要求请点击查看。 一、相关技术 Android 编程 Java 语言编程 Android Glide 载入图片 Android ViewPager2 单页列表上下滑动展示 Android SmartRefreshLayout 下拉刷新，上划LoadMore Android VideoView 视频播放 Android LottieAnimation 动画，线性动画，动画集合，插值 Android 自定义Layout，继承RelativeLayout Android 布局 Android 单双击事件 Android 多线程，网络API编程 Android Retrofit JSON 解析 Git和Github的使用 二、系统功能需求开发一个短视频App 视频信息流列表显示（包含封面图） 类似抖音全屏item(即一页就一个)显示视频 使用Glide加载封面图 显示每个视频必要的信息（比如作者等） 视频播放 从视频信息流点击某个视频封面进入播放页面 根据视频信息的url播放视频 单击视频窗口暂停/继续 双击视频窗口弹出点赞爱心图标 额外其他功能 三、系统设计与实现1、总体设计、系统组成 2、模块设计和模块关系 3、关键代码 视频信息JavaBean，用来存储从网络上获取的视频信息 点击查看代码 1234567891011121314151617181920212223242526public class VideoInfo &#123; @SerializedName(&quot;_id&quot;) public String id; @SerializedName(&quot;feedurl&quot;) public String url; @SerializedName(&quot;nickname&quot;) public String nickname; @SerializedName(&quot;description&quot;) public String description; @SerializedName(&quot;likecount&quot;) public String likeCount; @SerializedName(&quot;avatar&quot;) public String avatar; @Override public String toString() &#123; return &quot;VideoInfo&#123;&quot; + &quot;id=&#x27;&quot; + id + &#x27;\\&#x27;&#x27; + &quot;, url=&#x27;&quot; + url + &#x27;\\&#x27;&#x27; + &quot;, nickname=&#x27;&quot; + nickname + &#x27;\\&#x27;&#x27; + &quot;, description=&#x27;&quot; + description + &#x27;\\&#x27;&#x27; + &quot;, likeCount=&#x27;&quot; + likeCount + &#x27;\\&#x27;&#x27; + &quot;, avatar=&#x27;&quot; + avatar + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 贝塞尔动画估值器 点击查看代码 123456789101112131415161718192021222324252627public class Evaluator implements TypeEvaluator&lt;PointF&gt; &#123; //估值器 private PointF p1; private PointF p2; public Evaluator(PointF p1, PointF p2) &#123; super(); this.p1 = p1; this.p2 = p2; &#125; @Override public PointF evaluate(float fraction, PointF p0, PointF p3) &#123; PointF pointf = new PointF(); // 贝塞尔曲线公式: p0*(1-t)^3 + 3p1*t*(1-t)^2 + 3p2*t^2*(1-t) + p3^3 pointf.x = p0.x * (1 - fraction) * (1 - fraction) * (1 - fraction) + 3 * p1.x * fraction * (1 - fraction) * (1 - fraction) + 3 * p2.x * fraction * fraction * (1 - fraction) + p3.x * fraction * fraction * fraction; pointf.y = p0.y * (1 - fraction) * (1 - fraction) * (1 - fraction) + 3 * p1.y * fraction * (1 - fraction) * (1 - fraction) + 3 * p2.y * fraction * fraction * (1 - fraction) + p3.y * fraction * fraction * fraction; return pointf; &#125;&#125;​ 点赞爱心动画 点击查看代码 123456789101112131415161718192021222324252627public void addLoveView(float x, float y) &#123; if (x &lt; 100) &#123; x = 101; &#125; if (y &lt; 100) &#123; y = 101; &#125; // 获取心形图片中心位置 width = (int) (x - 100); height = (int) (y - 100); // 新建心形图片 final ImageView imageView = new ImageView(context); params = new LayoutParams(200, 200); imageView.setLayoutParams(params); imageView.setImageDrawable(icons[new Random().nextInt(4)]); addView(imageView); // 开启动画，动画结束移除图片 AnimatorSet set = getAnimatorSet(imageView); set.start(); set.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; super.onAnimationEnd(animation); removeView(imageView); &#125; &#125;);&#125;​ 下拉刷新和上划LoadMore 点击查看代码 1234567891011121314151617// 下拉刷新refreshLayout.setOnRefreshListener(new OnRefreshListener() &#123; @Override public void onRefresh(@NonNull RefreshLayout refreshLayout) &#123; list.clear(); getData(); refreshLayout.finishRefresh(); &#125;&#125;);// 上划LoadMorerefreshLayout.setOnLoadMoreListener(new OnLoadMoreListener() &#123; @Override public void onLoadMore(@NonNull RefreshLayout refreshLayout) &#123; getData(); refreshLayout.finishLoadMore(); &#125;&#125;);​ 网络请求 点击查看代码 123456789101112131415161718192021222324252627282930private void getData() &#123; Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;https://beiyou.bytedance.com/&quot;) .addConverterFactory(GsonConverterFactory.create()) .build(); ApiService apiService = retrofit.create(ApiService.class); apiService.getVideoInfo().enqueue(new Callback&lt;List&lt;VideoInfo&gt;&gt;() &#123; // 请求成功 @Override public void onResponse(Call&lt;List&lt;VideoInfo&gt;&gt; call, Response&lt;List&lt;VideoInfo&gt;&gt; response) &#123; if (response.body() != null) &#123; List&lt;VideoInfo&gt; videoInfoList = response.body(); Log.d(&quot;wxy&quot;, videoInfoList.toString()); if (videoInfoList.size() != 0) &#123; list.addAll(videoInfoList); myAdapter.setData(list); myAdapter.notifyDataSetChanged(); &#125; &#125; &#125; // 请求失败 @Override public void onFailure(Call&lt;List&lt;VideoInfo&gt;&gt; call, Throwable t) &#123; Log.d(&quot;retrofit&quot;, t.getMessage()); &#125; &#125;);&#125;​ Glide载入图片 点击查看代码 12345 Glide.with(context) .load(list.get(position).avatar) .error(R.mipmap.load_error) .transition(withCrossFade()).into(holder.imageView); 四、系统可能的扩展在本系统的基础上还具有很高的拓展性。 在查看老师给的视频API时，发现这个API过于老旧，并且视频与视频信息对应不上，导致APP的最终显示效果并不是那么理想。在本系统的基础上，如果能提供新视频API，在每次发出GET请求时，返回的视频列表都是不同的，并且数据也是随时间更新的，这样就可以真正地实现抖音的效果，无限上划刷新或者下拉刷新，每次的视频都不一样。 还可以在本系统的基础上修改界面，这个界面只是基础的显示视频信息的界面，并不是像抖音那样的更为美观的界面，可以进一步美化界面，增加各种动画。 也可以增加注册登录系统，使用数据库等记录不同用户点赞的数据，个性化推荐视频。 还可以实现视频拍摄录制，上传到服务器，这样就能在本地获取到自己上传的视频。 …… 五、总结体会本系统是一个类似抖音的网络短视频APP，基于Android和Java开发。在开发的过程中，我和我的另一个伙伴（两人一组合作开发）经过上网查找资料，Debug反复调试，克服了重重困难，终于成功的完成了这个APP。移动互联网是PC和互联网发展的必然产物，他将移动通信和互联网二者结合起来，成为一体。随着现在5G技术的快速发展，6G甚至都已经开始研究，这样移动网络APP开发必然是一种趋势。无论是短视频APP，例如抖音、快手，还是视频弹幕APP，例如BiliBili、爱奇艺等，还有即时通讯APP，例如QQ、微信、飞书，甚至是游戏APP，例如王者荣耀等，都离不开移动互联网，由此也可以看出移动互联网的重要性。以后移动互联网的发展将会比现在更快，在他基础上萌发出的新型产业也将层出不穷，基于移动互联网的高新科技也一定会迅速兴起，包括AI、智能家庭等等。移动互联网总是各个领域都扮演着不可或缺的角色，总之移动互联网这门课让我学到了很多新知识，收获很多。 六、项目地址本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看：","categories":[{"name":"Java","slug":"Java","permalink":"https://666wxy666.github.io/categories/Java/"},{"name":"Android项目","slug":"Java/Android项目","permalink":"https://666wxy666.github.io/categories/Java/Android%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://666wxy666.github.io/tags/Java/"},{"name":"Android","slug":"Android","permalink":"https://666wxy666.github.io/tags/Android/"}]},{"title":"C++工程项目 travel","slug":"C++工程项目-travel","date":"2021-01-04T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2021/01/04/C++工程项目-travel/","link":"","permalink":"https://666wxy666.github.io/2021/01/04/C++%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE-travel/","excerpt":"本文是数据结构课程设计项目，实现类似“携程”旅行模拟，具体项目及要求请点击查看。","text":"本文是数据结构课程设计项目，实现类似“携程”旅行模拟，具体项目及要求请点击查看。 一、设计任务的描述本软件旨在根据旅客的要求设计出行路线并输出，同时系统能模拟旅所在的地点和状态，目标是为旅客提供能完美出行的计划。处于对不同目的的旅客对交通工具有不同的要求。例如，因公出差的旅客希望在旅途中的时间尽可能短，出门旅游的游客则希望旅费尽可能省。编制一个全国城市间的交通咨询程序，为旅客提供最优决策的交通咨询。 二、功能需求说明及分析设计最省钱和最少时间的算法及其需要信息的存储：最省钱和最少的算法利用迪杰斯塔拉算法； 信息先是存储在一个文本文件中，程序可以从中读取并且存放在一个类中。 该程序所做的工作是模拟旅游交通查询，为旅客提供最有决策的交通查询。 规定： 输入城市名称时，直接输入城市的名称（汉字） 输入时间时，需要输入一个整型数据，选择功能时在界面上直接选择。 程序的输出信息主要是： 最快需要多少时间才能到达，或者最少需要多少费用才能到达，以及在旅程途中临时改变目的地时方案也相对发生变化和在规定时间内的最省钱方案。 模拟旅游交通查询系统，能实现现实生活中旅客的各种需求做出相应的程序，能实现选择功能。 城市总数不少于10个，即不能过于简单 建立汽车，火车，飞机的航班表，包含沿途到站、票价信息，并且要求两个城市之间不能只有一班车次 旅客的需求包含：起点、中点、途经城市、在某个城市的停留时间、旅行策略（旅客可以中途改变旅行方案） 旅行策略包含： 最少费用：不考虑时间，只需费用最少 最少时间：不考虑费用，只需时间最短 限时最少费用：在规定的时间内，让费用最少 旅行查询系统以10s ：1h的速度推进时间轴（非查询状态不计时） 不考虑城市内换乘交通工具所需时间 系统的时间精确到小时 建立日志文件，对旅客状态变化和键入等信息进行记录 旅客在旅途中可更改旅行计划，系统做出相应的操作 用图形绘制地图，并在地图上反映出旅客的旅行过程 三、开发环境 版本库：Qt 5.12.2 IDE：Qt Creator 4.8.2 编译器：MinGW 64-bit 系统：Windows 10 四、项目地址本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看：","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://666wxy666.github.io/categories/C-C/"},{"name":"项目","slug":"C-C/项目","permalink":"https://666wxy666.github.io/categories/C-C/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"QT","slug":"QT","permalink":"https://666wxy666.github.io/tags/QT/"}]},{"title":"算法设计 分治 最接近点对","slug":"算法设计-分治-最接近点对","date":"2021-01-04T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2021/01/04/算法设计-分治-最接近点对/","link":"","permalink":"https://666wxy666.github.io/2021/01/04/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1-%E5%88%86%E6%B2%BB-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%82%B9%E5%AF%B9/","excerpt":"本文是算法设计基于分治算法的问题“最接近点对”的实现。","text":"本文是算法设计基于分治算法的问题“最接近点对”的实现。 一、问题给定n个点(xi,yi) 1&lt;=i&lt;=n，找出其中距离最近的两个点，并简单讨论到3维情形下的推广。 二、环境电脑硬件配置： 处理器：Intel i7 7700HQ 显卡：NVIDIA GeForce GTX 1050 Ti 内存：16GB 软件： 编程语言：C++ IDE：Microsoft Visual Studio 2019 Windows SDK版本：10.0 平台工具集：Visual Studio 2019（v142） 三、项目地址本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看：","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://666wxy666.github.io/categories/C-C/"},{"name":"算法设计","slug":"C-C/算法设计","permalink":"https://666wxy666.github.io/categories/C-C/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"算法设计","slug":"算法设计","permalink":"https://666wxy666.github.io/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"},{"name":"分治","slug":"分治","permalink":"https://666wxy666.github.io/tags/%E5%88%86%E6%B2%BB/"}]},{"title":"算法设计 动态规划 最优二叉搜索树","slug":"算法设计-动态规划-最优二叉搜索树","date":"2021-01-04T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2021/01/04/算法设计-动态规划-最优二叉搜索树/","link":"","permalink":"https://666wxy666.github.io/2021/01/04/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"本文是算法设计基于动规算法的问题“最优二叉搜索树”的实现。","text":"本文是算法设计基于动规算法的问题“最优二叉搜索树”的实现。 一、问题最优二叉搜索树问题： 给定一个n个不同关键字已排序的序列 ： K=&lt;k1,k2,…,kn&gt; (k1&lt;k2&lt;…&lt;kn)， 我们希望用这些关键字构造一棵二叉搜索树。对每个关键字ki，都有一个概率bi表示其搜索频率。有些要搜索的值可能不在K中，因此我们还有n+1个“伪关键字”d0,d1,d2…dn表示不在K中的值。d0表示所有小于k1的值， dn 表示所有大于kn的值，对i=1,2,…,n−1，伪关键字di表示所有在ki和ki+1之间的值。对每个伪关键字di，也都有一个概率ai表示对应的搜索频率。 二、环境电脑硬件配置： 处理器：Intel i7 7700HQ 显卡：NVIDIA GeForce GTX 1050 Ti 内存：16GB 软件： 编程语言：C++ IDE：Microsoft Visual Studio 2019 Windows SDK版本：10.0 平台工具集：Visual Studio 2019（v142） 三、项目地址本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看：","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://666wxy666.github.io/categories/C-C/"},{"name":"算法设计","slug":"C-C/算法设计","permalink":"https://666wxy666.github.io/categories/C-C/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"算法设计","slug":"算法设计","permalink":"https://666wxy666.github.io/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"},{"name":"动态规划","slug":"动态规划","permalink":"https://666wxy666.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"软件工程 自助计费温控系统 动态模型","slug":"软件工程-自助计费温控系统-动态模型","date":"2021-01-04T00:00:00.000Z","updated":"2021-05-30T09:07:07.229Z","comments":true,"path":"2021/01/04/软件工程-自助计费温控系统-动态模型/","link":"","permalink":"https://666wxy666.github.io/2021/01/04/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E8%87%AA%E5%8A%A9%E8%AE%A1%E8%B4%B9%E6%B8%A9%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9E%8B/","excerpt":"本文是软件工程项目“自助计费温控系统”的动态模型。","text":"本文是软件工程项目“自助计费温控系统”的动态模型。 编写人员 小组名：软件工程-307d组 软件架构（Architecture）本系统采用客户端+服务器端的基础架构 服务器端的架构图（与课本样例基本一致，稍微修改了一下）： 系统顺序图（Sequence Diagram,SD）一、客户-使用空调1、RequestOn(RoomId,CurrentRoomTemp) 点击查看 1.1、RequestNumber&gt;ServiceNumber（请求数&gt;3的情况，也就是有关调度的交互过程） 点击查看 2、ChangeTargetTemp(RoomId,TargetTemp) 点击查看 3、ChangeFanSpeed(RoomId,FanSpeed) 点击查看 4、RequestOff(RoomId) 点击查看 5、RequestFee(RoomId) 点击查看 二、前台-出具详单1、CreateRDR(RoomId,date_in,date_out) 点击查看 2、PrintRDR(RoomId,list_RDR) 点击查看 三、前台-出具账单1、CreateInvoice(RoomId,date_in,date_out) 点击查看 2、PrintInvoice(RoomId,date_out,Toal_fee) 点击查看 四、空调管理员-运行空调1、PowerON() 点击查看 2、setPara(Mode,…,FeeRate_L） 点击查看 3、StartUp() 点击查看 五、空调管理员-监视空调1、CheckRoomState(list_Room) 点击查看 六、酒店经理-查看报表1、QueryReport(list_RoomId,type_Report,date) 点击查看 2、PrintReport(Report,date) 点击查看 项目地址整个项目的源代码，可执行文件，测试用例，结果均在下面的仓库中，欢迎查看：","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://666wxy666.github.io/categories/C-C/"},{"name":"软件工程","slug":"C-C/软件工程","permalink":"https://666wxy666.github.io/categories/C-C/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"QT","slug":"QT","permalink":"https://666wxy666.github.io/tags/QT/"},{"name":"软件工程","slug":"软件工程","permalink":"https://666wxy666.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}]},{"title":"软件工程 自助计费温控系统 静态模型","slug":"软件工程-自助计费温控系统-静态模型","date":"2021-01-04T00:00:00.000Z","updated":"2021-05-30T09:07:07.229Z","comments":true,"path":"2021/01/04/软件工程-自助计费温控系统-静态模型/","link":"","permalink":"https://666wxy666.github.io/2021/01/04/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E8%87%AA%E5%8A%A9%E8%AE%A1%E8%B4%B9%E6%B8%A9%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E9%9D%99%E6%80%81%E6%A8%A1%E5%9E%8B/","excerpt":"本文是软件工程项目“自助计费温控系统”的静态模型。","text":"本文是软件工程项目“自助计费温控系统”的静态模型。 编写人员 小组名：软件工程-307d组 一、用例级的静态结构1、客户-使用空调 点击查看 2、前台-出具详单 点击查看 3、前台-出具账单 点击查看 4、空调管理员-运行空调 点击查看 5、空调管理员-监视空调 点击查看 6、酒店经理-查看报表 点击查看 二、系统级的静态结构 点击查看 三、项目地址整个项目的源代码，可执行文件，测试用例，结果均在下面的仓库中，欢迎查看：","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://666wxy666.github.io/categories/C-C/"},{"name":"软件工程","slug":"C-C/软件工程","permalink":"https://666wxy666.github.io/categories/C-C/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"QT","slug":"QT","permalink":"https://666wxy666.github.io/tags/QT/"},{"name":"软件工程","slug":"软件工程","permalink":"https://666wxy666.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}]},{"title":"软件工程 自助计费温控系统 用例模型","slug":"软件工程-自助计费温控系统-用例模型","date":"2021-01-04T00:00:00.000Z","updated":"2021-05-30T09:07:07.229Z","comments":true,"path":"2021/01/04/软件工程-自助计费温控系统-用例模型/","link":"","permalink":"https://666wxy666.github.io/2021/01/04/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E8%87%AA%E5%8A%A9%E8%AE%A1%E8%B4%B9%E6%B8%A9%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E7%94%A8%E4%BE%8B%E6%A8%A1%E5%9E%8B/","excerpt":"本文是软件工程项目“自助计费温控系统”的用例模型。","text":"本文是软件工程项目“自助计费温控系统”的用例模型。 编写人员 小组名：软件工程-307d组 一、角色根据《用户需求说明书》中的要求，经过分析后得出，分布式温控计费系统的角色有： 住户（Guest）：即入住客户； 空调管理员（Administrator）：即在服务器端控制和监控各房间的空调的人员，相当于是系统的Administrator； 前台（Reception）：即酒店前台，在住户退房时出具空调使用的详单和账单； 酒店经理（Manager）：或称酒店管理人员，在需要时通过系统查看不同时间范围内的格式化统计报表。 二、用例图1、住户（Guest） 点击查看 2、空调管理员（Administrator） 点击查看 3、前台（Reception） 点击查看 4、 酒店经理（Manager） 点击查看 三、顺序图（SSD）1、住户（Guest）①使用空调 点击查看 ②查询信息 点击查看 2、空调管理员（Administrator）①总控空调 点击查看 ②监控空调 点击查看 3、前台（Reception）①打印账单 点击查看 ②打印详单 点击查看 4、 酒店经理（Manager）①打印统计报表 点击查看 5、其他①登录系统 点击查看 ②获取状态信息 点击查看 四、操作契约1、住户（Guest）①使用空调1:OpenAC(room_id) 系统事件 OpenAC(room_id) 开空调 交叉引用 使用空调 前置条件 已经登录系统，用户按动开机键 后置条件 （1）空调开机，空调开关状态被修改（2）计费状态被修改；（3）服务记录被更新； 3:SetACMode(room_id,mode) 系统事件 SetACMode(room_id,mode) 修改空调模式 交叉引用 使用空调 前置条件 空调开启并运行 后置条件 （1）空调模式被修改； （2）返回当前设置状态； 5:SetACTemp(room_id,temp) 系统事件 SetACTemp(room_id,temp) 设定温度 交叉引用 使用空调 前置条件 空调开启并运行 后置条件 （1）空调温度被修改； （2）返回当前设置温度； 7:SetACWindLevel(room_id,level) 系统事件 SetACWindLevel(room_id,level) 设定风速 交叉引用 使用空调 前置条件 空调开启并运行 后置条件 （1）空调风速被修改； （2）返回当前设置风速； 9:SetACTimer(room_id,time) 系统事件 SetACTimer(room_id,time) 设定定时 交叉引用 使用空调 前置条件 空调开启并运行 后置条件 （1）设定计时器，计时器开关状态被修改； （2）返回剩余时间； 11:MakeNewInfoCollection(guest_id,room_id,date_time) 系统事件 MakeNewInfoCollection(guest_id,room_id,date_time) 创建新的信息集合 交叉引用 使用空调 前置条件 修改空调状态完成，开始显示信息 后置条件 （1）新概念类信息集合被创建；（2）信息集合与住户、房间、时间建立关联；（3）信息集合初始化 13:AddInfoItem(info_item) 系统事件 AddInfoItem(info_item) 添加信息项 交叉引用 使用空调 前置条件 获取信息完成 后置条件 （1）新概念类信息项被创建；（2）信息项与信息集合建立关联； 15:ListInfoCollection(collection_id) 系统事件 ListInfoCollection(collection_id) 列出信息集合 交叉引用 使用空调 前置条件 信息集合建立完成 后置条件 （1）信息集合属性isComplete被修改 17:Show(collection_id) 系统事件 Show(collection_id) 展示空调信息 交叉引用 使用空调 前置条件 信息集合建立完成 后置条件 （1）信息集合属性isShow被修改 19:ShutDownAC(room_id) 系统事件 shutdownAC(RoomID) 关空调 交叉引用 使用空调 前置条件 用户按动关机按钮 后置条件 （1）空调开关状态被修改（2）结束本次服务记录 21:EndUseAC() 系统事件 EndUseAC() 使用空调结束 交叉引用 使用空调 前置条件 空调已关机 后置条件 （1）空调状态被修改：ReadyToStart； （2）结算 ②查询信息1:MakeNewInfoCollection(guest_id,room_id,date_time) 系统事件 MakeNewInfoCollection(guest_id,room_id,date_time) 创建新的信息集合 交叉引用 查询信息 前置条件 已经登录系统，开始显示信息 后置条件 （1）新概念类信息集合被创建；（2）信息集合与住户、房间、时间建立关联；（3）信息集合初始化 3:AddInfoItem(info_item) 系统事件 AddInfoItem(info_item) 添加信息项 交叉引用 查询信息 前置条件 获取信息完成 后置条件 （1）新概念类信息项被创建；（2）信息项与信息集合建立关联； 5:ListInfoCollection(collection_id) 系统事件 ListInfoCollection(collection_id) 列出信息集合 交叉引用 查询信息 前置条件 信息集合建立完成 后置条件 （1）信息集合属性isComplete被修改 7:Show(collection_id) 系统事件 Show(collection_id) 展示空调信息 交叉引用 查询信息 前置条件 信息集合建立完成 后置条件 （1）信息集合属性isShow被修改 9:EndQuery() 系统事件 EndQuery() 查询信息结束 交叉引用 查询信息 前置条件 信息集合已经被展示 后置条件 （1）查询状态被修改： isEnd 2、空调管理员（Administrator）①总控空调1:OnOffAC(room_id) 系统事件 OnOffAC(room_id) 开关空调 交叉引用 总控空调 前置条件 已经登录系统，管理员想要开关某房间的空调 后置条件 （1）空调开机/关机状态被修改；（2）服务记录被更新； 3:SetACMode(room_id,mode) 系统事件 SetACMode(room_id,mode) 修改空调模式 交叉引用 总控空调 前置条件 已经登录系统，管理员想要修改某房间的空调模式 后置条件 （1）空调模式被修改； （2）返回当前设置状态； 5:SetACTemp(room_id,temp) 系统事件 SetACTemp(room_id,temp) 设定温度 交叉引用 总控空调 前置条件 已经登录系统，管理员想要修改某房间的空调温度 后置条件 （1）空调温度被修改； （2）返回当前设置温度； 7:SetACWindLevel(room_id,level) 系统事件 SetACWindLevel(room_id,level) 设定风速 交叉引用 总控空调 前置条件 已经登录系统，管理员想要修改某房间的空调风速 后置条件 （1）空调风速被修改； （2）返回当前设置风速； 9:SetACTimer(room_id,time) 系统事件 SetACTimer(room_id,time) 设定定时 交叉引用 总控空调 前置条件 已经登录系统，管理员想要修改某房间的空调定时 后置条件 （1）设定计时器，计时器开关状态被修改； （2）返回剩余时间； 11:MakeNewInfoCollection(admin_id,room_id,date_time) 系统事件 MakeNewInfoCollection(admin_id,room_id,date_time) 创建新的信息集合 交叉引用 总控空调 前置条件 修改空调状态完成，开始显示信息 后置条件 （1）新概念类信息集合被创建；（2）信息集合与管理员、房间、时间建立关联；（3）信息集合初始化 13:AddInfoItem(info_item) 系统事件 AddInfoItem(info_item) 添加信息项 交叉引用 总控空调 前置条件 获取信息完成 后置条件 （1）新概念类信息项被创建；（2）信息项与信息集合建立关联； 15:ListInfoCollection(collection_id) 系统事件 ListInfoCollection(collection_id) 列出信息集合 交叉引用 总控空调 前置条件 信息集合建立完成 后置条件 （1）信息集合属性isComplete被修改 17:Show(collection_id) 系统事件 Show(collection_id) 展示空调信息 交叉引用 总控空调 前置条件 信息集合建立完成 后置条件 （1）信息集合属性isShow被修改 19:EndControl() 系统事件 EndControl() 总控空调结束 交叉引用 总控空调 前置条件 信息集合展示完成 后置条件 （1）总控任务状态被修改：isEnd； ②监控空调1:MakeNewInfoCollection(admin_id,room_id,date_time) 系统事件 MakeNewInfoCollection(admin_id,room_id,date_time) 创建新的信息集合 交叉引用 监控空调 前置条件 已经登录系统，开始显示信息 后置条件 （1）新概念类信息集合被创建；（2）信息集合与管理员、房间、时间建立关联；（3）信息集合初始化 3:AddInfoItem(info_item) 系统事件 AddInfoItem(info_item) 添加信息项 交叉引用 监控空调 前置条件 获取信息完成 后置条件 （1）新概念类信息项被创建；（2）信息项与信息集合建立关联； 5:ListInfoCollection(collection_id) 系统事件 ListInfoCollection(collection_id) 列出信息集合 交叉引用 监控空调 前置条件 信息集合建立完成 后置条件 （1）信息集合属性isComplete被修改 7:Show(collection_id) 系统事件 Show(collection_id) 展示空调信息 交叉引用 监控空调 前置条件 信息集合建立完成 后置条件 （1）信息集合属性isShow被修改 9:EndMonitor() 系统事件 EndMonitor() 监控空调结束 交叉引用 监控空调 前置条件 信息集合已经被展示 后置条件 （1）监控空调状态被修改： isEnd 3、前台（Reception）①打印账单1:MakeNewBill(room_id,reception_id) 系统事件 MakeNewBill(room_id,reception_id) 生成新账单 交叉引用 打印账单 前置条件 前台身份验证通过，开始账单处理 后置条件 （1）一个新的帐单创建 （2）账单与房间建立“关联” （3）账单与前台建立“关联” （4）账单的属性初始化：金额 3:GetRoomBill(room_id) 系统事件 GetRoomBill(room_id) 获取房间账单 交叉引用 打印账单 前置条件 前台正在处理账单 后置条件 （1）账单的属性被修改:isComplete （2）账单与房间建立“关联” 5:Print(bill) 系统事件 Print(bill) 打印账单 交叉引用 打印账单 前置条件 前台完成处理账单 后置条件 帐单属性被修改：isPrinted 7:EndPrintBill() 系统事件 EndPrintBill() 打印账单结束 交叉引用 打印账单 前置条件 前台完成打印账单 后置条件 (1）账单属性被修改：isReadytoSend (2）账单与报表数据库建立“关联” ②打印详单1:MakeNewSpecifications(room_id,reception_id) 系统事件 MakeNewSpecifications(room_id,reception_id) 生成新详单 交叉引用 打印详单 前置条件 前台身份验证通过，开始详单处理 后置条件 （1）一个新的详单创建 （2）详单与房间建立“关联” （3）详单与前台建立“关联” （4）详单的属性初始化：空调使用时间、空调状态变化、每个阶段对应金额 3:GetRoomDailySpecifications(room_id,date) 系统事件 GetRoomDailySpecifications(room_id,date) 获取房间每日详单 交叉引用 打印详单 前置条件 前台正在处理详单 后置条件 （1） 具体日期的详单获取成功 （2） 详单与日期建立“关联” 5:AddRoomDailySpecifications(room_daily_specifications) 系统事件 AddRoomDailySpecifications(room_daily_specifications) 添加房间每日详单 交叉引用 打印详单 前置条件 已经获取了具体日期的详单 后置条件 （1）合并详单获取成功 （2）详单属性被修改：isComplete 7:Print(specifications) 系统事件 Print(specifications) 打印详单 交叉引用 打印详单 前置条件 前台完成处理详单 后置条件 详单属性被修改：isPrinted 9:EndPrintSpecifications() 系统事件 EndPrintSpecifications() 结束打印详单 交叉引用 打印详单 前置条件 前台完成打印详单 后置条件 (1）详单属性被修改：isReadytoSend (2）详单与报表数据库建立“关联” 4、 酒店经理（Manager）①打印统计报表1:MakeNewReport(manager_id,date_time) 系统事件 MakeNewReport(manager_id,date_time) 创建新的总统计报表 交叉引用 打印统计报表 前置条件 已经登录系统 后置条件 （1）新概念类统计报表被创建；（2）统计报表与经理、日期时间建立关联；（3）统计报表初始化 3:GetRoomReport(room_id) 系统事件 GetRoomReport(room_id) 获取房间的统计报表 交叉引用 打印统计报表 前置条件 统计报表已经初始化 后置条件 （1）新概念类房间的统计报表被创建；（2）房间的统计报表与房间建立关联；（3）获得房间的统计报表 5:AddReportItem(report_item) 系统事件 AddReportItem(report_item) 向总统计报表中添加每个房间的统计报表 交叉引用 打印统计报表 前置条件 已经获得房间的统计报表 后置条件 （1）新概念类统计报表项被创建；（2）房间的统计报表与统计报表项建立关联； 7:ListRoomReport(report_id) 系统事件 ListRoomReport(report_id) 列出总统计报表每一项 交叉引用 打印统计报表 前置条件 统计报表建立完成 后置条件 （1）统计报表属性isComplete被修改 9:Summary(report) 系统事件 Summary(report) 总结整合统计报表信息 交叉引用 打印统计报表 前置条件 统计报表建立完成 后置条件 （1）统计报表属性isSummary被修改 （2）获得统计信息 11:Print(Report,Summary) 系统事件 Print(Report,Summary) 打印报表和统计信息 交叉引用 打印统计报表 前置条件 统计报表建立完成，已经获得统计信息 后置条件 （1）统计报表属性isPrint被修改 13:EndPrintReport() 系统事件 EndPrintReport() 打印统计报表结束 交叉引用 打印统计报表 前置条件 报表和统计信息已经被打印 后置条件 （1）打印统计报表任务状态被修改： isEnd 5、其他①登录系统1:RequestLogin(user_id) 系统事件 RequestLogin(user_id) 请求登录 交叉引用 登陆系统 前置条件 用户准备进行登录 后置条件 （1）用户与系统建立“关联” （2）用户的属性初始化：账号、密码 3:CheckUserInfo(user_id) 系统事件 CheckUserInfo(user_id) 检查登录信息 交叉引用 登陆系统 前置条件 用户输入账号密码 后置条件 （1）用户帐号状态被修改:ischecked 5:EndLogin() 系统事件 EndLogin() 结束登录 交叉引用 登陆系统 前置条件 系统账号检查完毕 后置条件 登陆结束，进入系统（或者返回登陆页面） ②获取状态信息1：GetUserInfo(user_id) 系统事件 GetUserInfo(user_id) 获取用户信息 交叉引用 获取状态信息 前置条件 用户登陆完成 后置条件 （1）用户与数据库建立“关联” （2）用户成功获取住户信息 （3）返回当前状态 3:GetRoomInfo(room_id) 系统事件 GetRoomInfo(room_id) 获取房间信息 交叉引用 获取状态信息 前置条件 用户登陆完成 后置条件 （1）用户与数据库建立“关联” （2）用户成功获取房间信息 （3）返回当前状态 5:GetACInfo(room_id) 系统事件 GetACInfo(room_id) 获取空调信息 交叉引用 获取状态信息 前置条件 用户登陆完成 后置条件 （1）用户与数据库建立“关联” （2）用户成功获取房间空调信息 （3）返回当前状态 7:GetConsumeInfo(room_id) 系统事件 GetConsumeInfo(room_id) 获取消费信息 交叉引用 获取状态信息 前置条件 用户登陆完成 后置条件 （1）用户与数据库建立“关联” （2）用户成功获取房间消费信息 （3）返回当前状态 9:EndGetInfo() 系统事件 EndGetInfo() 获取信息结束 交叉引用 获取状态信息 前置条件 获取信息完成 后置条件 用户获取状态信息结束 五、项目地址整个项目的源代码，可执行文件，测试用例，结果均在下面的仓库中，欢迎查看：","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://666wxy666.github.io/categories/C-C/"},{"name":"软件工程","slug":"C-C/软件工程","permalink":"https://666wxy666.github.io/categories/C-C/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"QT","slug":"QT","permalink":"https://666wxy666.github.io/tags/QT/"},{"name":"软件工程","slug":"软件工程","permalink":"https://666wxy666.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}]},{"title":"软件工程 自助计费温控系统 用户需求说明书","slug":"软件工程-自助计费温控系统-用户需求说明书","date":"2021-01-04T00:00:00.000Z","updated":"2021-05-30T09:07:07.229Z","comments":true,"path":"2021/01/04/软件工程-自助计费温控系统-用户需求说明书/","link":"","permalink":"https://666wxy666.github.io/2021/01/04/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E8%87%AA%E5%8A%A9%E8%AE%A1%E8%B4%B9%E6%B8%A9%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E7%94%A8%E6%88%B7%E9%9C%80%E6%B1%82%E8%AF%B4%E6%98%8E%E4%B9%A6/","excerpt":"本文是软件工程项目“自助计费温控系统”的用户需求说明书。","text":"本文是软件工程项目“自助计费温控系统”的用户需求说明书。 编写人员 小组名：软件工程-307d组 0. 文档介绍0.1 文档目的​ 根据与用户（客户和最终用户）调查和收集的相关信息，对来源于用户的各项系统需求信息进行分析，归纳与总结共性的用户需求。与用户确认，邀请行业专家评审，从而消除错误，确保准确无误、规范地表达用户对系统的真实意愿，为项目的合作方提供主要的参考依据。 0.2 文档范围​ 本文档包括产品背景及业务介绍、产品的受众描述、产品应当遵守的标准或规范、产品的功能性和非功能性等需求，以及相关的附件信息。 0.3 读者对象 用户——确认本文档是否已经准确表达并涵盖了所有需求； 开发人员——开发人员根据本文档分析所有需求的可行性，然后以本文档为参考对象，进行项目下一步的设计与开发； 第三方评审——包括行业专家、律师等，确保本产品需求应当合乎行业规范及标准，不违反相关规定； 0.4 参考文档 文档名称 《系统解决方案》 《需求调查问题表》 《中国旅游饭店行业规范》 《旅店业卫生标准》 《全球旅游消费报告2019》 0.5 术语与缩写解释 名称 说明 本系统 分布式温控计费系统 本产品 分布式温控计费系统产品 前台 设置在酒店大堂为客人提供登记、问讯、结账等服务的区域 总机 最基本的工作就是电话的转接和信息的传达，以及做留言、叫醒等服务工作。总机可能还要分担前台的问询、预订部的订房、餐饮部的订餐、客房中心的信息服务等 详单 由空调运行状态信息和使用信息组成的报表信息 规范 文档中所提及的规范、标准，都指的是参考文档中提及的相关文档 吞吐量 单位时间内成功地传送数据的数量 时延 从一种状态到另一种状态所需的时间 数据缺失率 在计算机网络相关行业可以近似看做丢包率，丢失的数据数量占所发送总数据的比率 科学的方法模型 在软件工程方面主要包括软件生命周期模型，领域模型，用例模型等各种相关模型 …… …… 1. 系统或产品介绍1.1 产品介绍​ 本产品是一套快捷酒店自助计费式中央温控系统，以节能环保为理念，通过本软件系统的自助计费、自动控制、实时监控、及时断电等功能，实现对于酒店管理人员和客户更为便利的服务。由酒店住客决定空调的运行计划，并将计划所需资金实时显示，自助式的模式也能够帮助客人节约资金。同时酒店管理部门可以使用监管系统来监管各个房间空调的使用情况，在必要时控制各房间空调的状态，帮助酒店节约管理与维护费用。 1.2 开发背景​ 在新世纪新阶段，党中央、国务院把扩大内需、促进消费确立为促进国民经济发展的长期战略方针和基本立足点，国家扩大内需的经济发展方略和加快推动服务业的发展，将为旅游业进一步发展创造新 的机遇。而酒店作为旅游业务三大支柱之一住宿业的重要组成部分，数量增长快速，种类更加丰富。快捷酒店是相对于传统的全面服务酒店而存在的一种酒店业态。快捷酒店房价便宜，深受一般商务人士、 工薪阶层、普通自费旅游者和学生等人群的欢迎，但同样竞争激烈。在绿色发展的前提下，提升服务品质、降低服务成本，无疑将进一步增大酒店竞争力。​ 快捷酒店自助计费式中央温控系统只需要在传统人工空调管理体系基础上加入少量的硬件支持，就能通过软件系统自助计费、自动控制、实时监控、及时断电，达到降低人工调节和检查的成本，及时断电、精准控制也比人为干预更加节能环保。 1.3业务背景​ 传统廉价酒店对于房间使用情况的统计，尤其是与本系统息息相关的核心空调服务，较为简陋，以人工为主，甚至有的酒店部分房间不提供自主控制的空调服务。 ​ 住户要么通过房间内的遥控器对空调进行控制，要么向前台打电话通过前台的总控控制中央空调，极为不方便。并且最为关键的是廉价酒店不具备自动化的计费系统，空调的计费功能只能通过时间计时或者固定收费，且时间计时方式收费只能是在住户退房时，服务员亲自到房间查看，手动记录，耗时耗力且极有可能出现计录不准确的情况，与廉价酒店的核心目标“经济实用”严重不符。 ​ 除空调服务之外，其他计费合同及记录等也只能通过登记住户信息、记录开房退房时间等相关操作，记录入住时间和其他额外消费以计算得出账单费用。耗时耗力，服务成本较高，服务品质和速度也难以达标。且无法实现对于报表的一键式查询，需要人工多次进行统计和修改，难以保证数据一致和安全。 ​ 酒店前台的主要职责是在住户订房、消费、退房时需要将相关信息如房间信息、住户信息、额外消费情况等记录在册，整理每日的已定房间及金额统计，作为每日的交班记录。客房部服务员在住户订餐或需要增加毛巾、枕套等其他物品时提供服务，在住户退房时进行查房，退房后对于房间进行清洁工作。 1.4业务流程1.4.1 预订房间​ 住户在可以在入住前先对房间进行预订，可以通过电话、网络或者亲自到前台等方式，与预订员取得联系。首先登记自己的姓名、身份证等基本信息，选择要预订的房型。预订员将预订ID标识、预订信息（包括姓名、对应房型等）以及预订时间、想要入住的时间等信息进行记录，形成预订单。预订员将预订单发送给住户和前台进行确认。住户确认预订单后，缴纳预订押金，同时前台录入相关信息和收取押金，预定结束。 点击查看 1.4.2 办理入住​ 住户在办理入住时首先在前台登记自己的姓名、身份证等信息，并交付押金获得相应房间的房卡。同时前台将入住信息（包括姓名、对应房间号等）以及入住时间等信息进行记录形成收费单。住户就可以入住了。 点击查看 1.4.3 服务1.4.3.1 基本服务​ 住户在进入房间后，插入房卡便可获得房间使用权限，对于光照情况进行调整，使用影音娱乐设施等以使其获得更好的住房体验。如果相关设备出现故障可向服务员请求维修服务。 点击查看 1.4.3.2 请求服务​ 住户可通过电话等方式呼叫前台或者亲自到前台进行订餐等请求其他相关的服务。 点击查看 1.4.3.3 核心空调服务​ 住户进入房间后，可以选择开启空调，可对于空调的温度、风速、制冷制热模式等进行选择，当空调达到住户所给的要求后，若住户未关闭空调或者未到定时时间，则空调维持在设定温度不变，空调不会自动关闭，直到住户用遥控器关闭空调（比较耗电）。如果关闭整个房间的电器开关，空调设备也同时关闭。关于空调的计费，要么在入住时选择开启或关闭空调服务，如果开启空调服务，会需要事先缴纳固定费用（无论是否使用空调），第二种形式是酒店工作人员手工纪录开启空调到关闭空调的时间，按时间收费（无法按温度等更为细化收费），第三种是直接把空调的花费记入房间的电费中，由服务员查看电表来统计收费（与其他电器的电费混合，无法额外精确计费，也不便于统计空调使用情况）。如果相关设备出现故障可向服务员请求维修服务。 点击查看 1.4.3.4 安保服务 点击查看 1.4.4 办理退房​ 当住户退房时，前台确定退房房号后由客房部服务员前往查房，确定是否还有遗留物品，以及酒店物品是否有损坏，检查完毕后，将相应电器开关关掉。前台根据查房情况可退还遗留物品或者要求赔偿，再加上应付房费和其他额外消费（如水电、餐饮、行李寄存、停车费等）付清之后，并交还房间钥匙。前台退回押金即可办理完成退房手续。 点击查看 2. 产品面向的用户群体2.0 关于经济型酒店的市场调查（市场背景资料）​ 近年来，伴随中国经济的飞速发展，同时带动了我国包括商业领域、交通领域等诸多领域的快速发展。并且随着人们开始逐渐转变生活态度，旅游出行成为越来越多人的选择。在当前的时代潮流中，旅游业的前景持续向好，市场广大。 ​ 在**《全球旅游消费报告2019》**中，我国国内旅游人数达到55.39亿人次，全年全国旅游业占GDP总量高达11.04%。下面我们关注这几个方面： 人年均出游次数高达4次： 意味着中国进入大众旅游时代，人们旅行趋于日常化，并且出现“说走就走，短期多地”的旅行现象； 旅游者平均年龄日趋下降，例如初次出境游平均年龄已经降至18岁： 大学生、年轻人已经成为了旅游中的不可忽视的一部分。由于经济因素、旅游行为取向等因素，经济型廉价酒店在酒店订单中占比高达三成以上，并且仍有上升的趋势； 文化旅游、体验旅游成为新常态： 伴随很多地区打出文化度假旅游招牌，人们对旅途中的酒店的要求体现为“高舒适度、高性价比、有特色”； ​ 但随着豪华型酒店、独间高档民宿等诸多住宿方式的热度不断上升，市场占有率不断上升，经济型廉价酒店的市场不断被挤压，竞争也继续扩大并且变愈发激烈。因此，经济型廉价酒店面临的转型升级变得尤为重要。 2.1 关于本产品的面向用户及特征​ 本产品面向的是想要同时兼顾成本并且良好住宿体验的经济型廉价酒店（廉价连锁酒店、廉价便捷酒店、多房间型民宿，如：和心旅馆、汉庭酒店、速8酒店、锦江之星、橘子酒店等）。 酒店特征： 以客房为主要经营项目，客房价低； 客源流动性高，住宿时长长短差异大； 希望自己的客房设置标准化，突出舒适、卫生、方便； 希望降低运营成本（人力、电费等）； 希望控制成本的同时向住客提供高品质的空调通风服务； 酒店工作人员特征： 大部分工作人员有一定计算机操作基础； 少数对计算机相关领域了解较少或完全不了解； 管理员较少，大部分都是服务人员; 酒店住户特征： 重点关注于省钱，经济，廉价，对高端、华丽等并不着重关心，也就是更关注于“性价比”； 关注舒适、快捷、方便； 对在酒店的支出有严格的要求，不能出现差错； 2.2 关于本产品特点与优势 整套系统完全依照绿色环保的理念设计，可以监控房间状态，提供舒适环境的同时为酒店大幅度节约电力成本； 本系统安装方便，可靠性、安全性强，自助计费的管理方式较传统温控系统更加人性化、便捷； 致力于为酒店管理人员打造“简单的全面性”：本系统对酒店相关的管理人员拥有简单、友好的界面；致力于简单化相关人员培训过程，简单化使用方式，可以大幅度降低人力成本； 无论住客流动性有多高，本系统都可以让对每个房间的管理变得极其容易； 致力于为住客打造“亲切的科技感”：较传统的空调遥控器方式或者复杂的壁式控制系统，本系统对单独客房的用户同样拥有良好的界面，致力于优化用户体验感，体现整洁、卫生以及亲切的科技感；亲切科技感可以吸引各种年龄段的顾客，并且提供宾至如归的体验； ​ 我们团队坚信一贯秉持的“简单而全面，科技又亲民”理念会让让用户以更低的成本，为住客提供更优的服务，获得更高的利益，树立更好的口碑。配合以酒店自身特色与规划，这相辅相成的合作会让渴望转型的经济型廉价酒店完美华丽变身，让渴望打造自己特色的经济型廉价酒店大展宏图。 ​ 综上所述，本系统将会给廉价酒店带来前所未有的改变和无与伦比的好处，因此各大廉价酒店会有非常大概率（保守估计90%以上）选择本产品。 3. 产品应当遵循的标准或规范略 4. 产品的功能性需求4.1 客户服务功能 类别 功能名称，标识符 描述 控制 设置温度功能 可以通过该功能设置空调温度与制冷、制热模式 控制 设置时间功能 可以通过该功能设置空调开启时间与关闭时间，达到节省电力与费用的效果 控制 开、关机 控制空调的开关 控制 风速设置 控制空调的风速（Low、Mid、High三档） 控制 制冷制热 选择空调工作模式 计费 自动计费功能 将计算当前计划预计产生的费用，以及到目前为止的总费用 显示 显示功能 显示当前的温度，风速，模式以及当次费用，总费用 4.2 管理员主控功能 类别 功能名称，标识符 描述 控制 控制功能 可以通过该功能修改任意房间的空调状态（开关，模式，温度，风速等） 显示 查看功能 可以通过该功能查看任意房间的空调状态（开关，模式，温度，风速等） 显示 拉取信息功能 可以拉取任意房间的账单、详单等信息 通讯 数据接收功能 接收各个房间发来的数据 通讯 命令发送功能 将控制面板生成的命令发送给对应的房间空调 存取 存储功能 存储将接收的数据以方便将来生成详单 存取 读取功能 在生成时间更长的详单时，需要更多的房间空调的信息，将读取已经存储的空调运行信息并生成详单或者实现数据统计信息 5. 产品的非功能性需求5.1 用户界面需求 需求类别 需求名称、标识符 描述 用户界面需求 高效实用 因为本系统是应用于廉价酒店，所以必须把入住用户的体验放在第一位，但是酒店管理人员的体验也同样重要。因此要求本系统提供友好、简洁、清晰、漂亮的中文人机交互界面，操作简便、灵活、易学易用，便于管理和维护。在操作处理上有高效实用的特点，能够满足分布式温控系统的要求。 用户界面需求 技术先进 整个系统的软件设计应符合现代的潮流，操作界面、存储、传输等关键技术均应处于领先的技术水平。在满足现期功能的前提下，系统设计具有前瞻性，在今后较长时间内保持一定的技术先进性。 用户界面需求 廉价美观 界面设计应廉价但又不失高端奢华，一切以用户的体验至上，让用户使用该系统后既能在廉价酒店体验高档酒店的舒适，又能实现省钱的目的，从而符合廉价酒店省钱的原则。 5.2 软硬件需求 需求类别 需求名称、标识符 描述 软硬件需求 数据一致 由于本系统的主要功能是计费，因此要求服务器端和客户端的数据要一致，不能初现导致计费错误的情况。 软硬件需求 计费准确 由于本系统的主要功能是计费，因此要求空调的计费结果不能出现失误，精度要足够精确，防止酒店和客人出现不必要的损失。 软硬件需求 可扩展性强 本系统设计时，应充分考虑后期系统功能的扩充等方面的需求，软件的设计应留有升级的空间，方便系统平滑升级。 软硬件需求 标准规范 应以科学的方法模型设计软件，使之有良好的结构和完备的文档，便于查阅维护。 软硬件需求 低成本、低维护量 因为本系统的运行环境是廉价酒店，因此在满足系统功能及性能要求的前提下，应当尽量降低系统建设成本，本着经济实用的原则，充分利用现资源，综合考虑系统的后期维护费用。 5.3 质量需求 需求类别 需求名称、标识符 描述 质量需求 性能 要求该系统：1. 吞吐量高，以保证多房间的用户正常使用；2. 时延低，以保证房间用户和系统管理员及时得到反馈信息；3. 数据缺失率少，以保证数据完整安全。 质量需求 可靠 客户端尽量不要卡顿，不能崩溃。如果客户端或服务器端发生了卡顿和崩溃，要保证数据不会丢失，有及时快速的应急方案和崩溃恢复系统。系统应当支持关键数据的备份功能，有较强的容错和系统恢复能力，确保系统长期正常运行。 质量需求 安全 系统应当保证用户隐私信息不泄露等多方面的安全要求。对登录系统的用户，进行严格的鉴权认证，以保证整个系统的安全性。 6. 其它需求 需求名称、标识符 描述 标准需求 本系统中采用的相关技术和标准等均应该符合国家标准、行业标准和公安部颁布的技术规范且具有良好的兼容性和互联互通性。 合法性需求 本系统中采用的一切相关事物均应当符合国家相关法律法规和政策，保证项目的合法性 7. 附录用户需求调查报告略 8. 项目地址整个项目的源代码，可执行文件，测试用例，结果均在下面的仓库中，欢迎查看：","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://666wxy666.github.io/categories/C-C/"},{"name":"软件工程","slug":"C-C/软件工程","permalink":"https://666wxy666.github.io/categories/C-C/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"QT","slug":"QT","permalink":"https://666wxy666.github.io/tags/QT/"},{"name":"软件工程","slug":"软件工程","permalink":"https://666wxy666.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}]},{"title":"软件工程 自助计费温控系统 系统解决方案","slug":"软件工程-自助计费温控系统-系统解决方案","date":"2021-01-04T00:00:00.000Z","updated":"2021-05-30T09:07:07.229Z","comments":true,"path":"2021/01/04/软件工程-自助计费温控系统-系统解决方案/","link":"","permalink":"https://666wxy666.github.io/2021/01/04/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E8%87%AA%E5%8A%A9%E8%AE%A1%E8%B4%B9%E6%B8%A9%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"本文是软件工程项目“自助计费温控系统”的系统解决方案。","text":"本文是软件工程项目“自助计费温控系统”的系统解决方案。 编写人员 小组名：软件工程-307d组 一、关于本方案（About This）​ 某快捷廉价酒店响应节能绿色环保理念，推行自助计费式中央温控系统，因此，编写本系统解决方案。本方案论述了快捷酒店自助计费式中央温控系统需求分析、总体分析及详细分析，并基于各个需求间内在联系，以节能环保、安全为理念，通过我们已经掌握的软件设计的技术和理论，设计一个尽可能完善的自助计费式中央温控系统。 二、概述（Summary）1. 背景（Background）​ 在新世纪新阶段，党中央、国务院把扩大内需、促进消费确立为促进国民经济发展的长期战略方针和基本立足点，国家扩大内需的经济发展方略和加快推动服务业的发展，将为旅游业进一步发展创造新的机遇。而酒店作为旅游业务三大支柱之一住宿业的重要组成部分，数量增长快速，种类更加丰富。快捷酒店是相对于传统的全面服务酒店而存在的一种酒店业态。快捷酒店房价便宜，深受一般商务人士、工薪阶层、普通自费旅游者和学生等人群的欢迎，但同样竞争激烈。在绿色发展的前提下，提升服务品质、降低服务成本，无疑将进一步增大酒店竞争力。 ​ 快捷酒店自助计费式中央温控系统只需要在传统人工空调管理体系基础上加入少量的硬件支持，就能通过软件系统自助计费、自动控制、实时监控、及时断电，达到降低人工调节和检查的成本，及时断电、精准控制也比人为干预更加节能环保。 2. 目标（Target）​ 对快捷酒店推行的自助计费式中央温控系统进行系统地分析，并在此基础上，提供一个较为完善的软件系统设计和解决方案，以满足快捷酒店对此系统的所有需求。 3. 原则（Principle）​ 系统安全性，操作方便性，易于维护性，节能环保，节省费用。 4. 依据（Foundation）​ 本方案主要依据**《软件工程模型与方法（第2版）》**提供的模型与方法，以C++为开发语言进行设计与开发。 三、需求分析（Requirements Analysis）1. 概述​ 要求开发出一整套的空调控制系统，该系统将大规模应用于廉价酒店中。为了响应国家节能环保的组织号召，同时也符合廉价酒店的原则，帮助客人节约资金，帮助酒店节约管理与维护费用，该系统将采用自主计费的方式，由酒店住客决定空调的运行计划并且把该计划所需要的资金实时的显示出来。同时，酒店的管理部门可以使用监管系统来监视各个房间空调的使用情况，并在必要时控制这些空调的状态。 2. 需求描述①接口需求： 接口名称 服务器端到客户端的数据接受接口 接口描述 接受客户端发来的信息，并把该信息整理并存储。 接收参数 空调的状态；改变温度的范围；账单；房间号 返回参数 成功；失败显示失败原因 接口名称 服务器向空调发出的控制指令 接口描述 用于服务器控制空调的状态，一般用于关闭该空调 推送参数 房间号；想要使空调达到的状态 返回参数 成功；失败则再次发送 接口名称 空调接收服务器指令的接口 接口描述 用于接收服务器的指令改变自身的状态 接受参数 房间号；想要使空调达到的状态 返回参数 成功；失败 接口名称 服务器向数据库的数据发送接口 接口描述 用于向数据库传送日志文件以便生成报表 推送参数 空调状态；温度范围；房间号；账单 返回参数 成功；失败则再次发送 接口名称 服务器向数据库的命令发送接口 接口描述 用于获取数据库内容 推送参数 房间号；时间段 返回参数 成功；失败则再次发送 接口名称 数据库接收服务器命令的接口 接口描述 用于获取命令 接收参数 房间号；时间段 返回参数 成功；失败 接口名称 数据库向服务器发送数据的接口 接口描述 用于返回服务器想要获取的数据 发送参数 数据包 返回参数 成功；失败则再次发送 ② 性能需求：​ 要求该系统发送数据的时延要低，丢包率要少，尽量做到实时的监控每个房间的数据。同时要求服务器端和客户端的数据要一致，不能初现导致计费错误的情况。客户端尽量不要卡顿，不能崩溃。 ③ 安全需求：​ 如果客户端或服务器端发生了卡顿和崩溃，要保证数据不会丢失，而且空调的计费结果不会出现失误，防止酒店和客人出现不合理的损失。 3. 系统涉众分析：① 市场分析：​ 近年来，伴随着中国经济全球化、国际化的步伐继续加快，我国包括商业领域、交通领域、旅游业在内的诸多领域都在飞速发展。其中，旅游业前景持续向好，市场广大。随着豪华型酒店、民宿等诸多住宿方式的热度不断上升，市场占有率不断上升，经济型酒店、廉价便捷酒店的市场不断被挤压，竞争也继续扩大并且变愈发激烈。因此，经济型酒店、廉价便捷酒店的“节能绿色环保”转型升级变得尤为重要。一方面提升经济型酒店、廉价便捷酒店的住宿环境、用户体验感；另一方面也可以帮助酒店有效地节约各方面成本（电费、管理）。 ② 涉众分析：​ 本系统涉众即为众多上述经济型酒店、廉价便捷酒店。空调系统作为酒店系统中最重要地一环，关系住客体验、酒店运营成本、酒店口碑等诸多方面。通过部署本系统，可以轻松地管理、优化整个酒店地空调通风系统。一体式监控管理可以大幅度简化管理流程，可以大幅度压缩电费、管理等运营成本，极具性价比。 4.功能需求分析① 终端功能：a) 清晰的信息显示界面：帮助住客轻松获取空间空调系统的信息。 显示信息 说明 1、当前室内温度 实时显示 2、当前空调设定温度 由用户通过控制面板进行设置 3、当前空调设置风速 Low、Mid、High、Auto四档 4、当前空调运行模式 Cool、Warm两档 5、欠费提醒 是否需要由预缴费机制？ b) 交互友好的控制面板：帮助用户调节自己空间的空调系统。 住客（人工）控制部分 说明 1、开、关机 先插卡、再开机。拔卡自动关机。 2、温度设置 设置范围区间待定。精度待定 3、风速设置 Low、Mid、High、Auto四档 4、制冷、制热选择 Cool、Warm两档 c) 自动控制部分： 自动控制部分 说明 1、温控 到达温度后自动休眠/关机/其他机制。 2、室温监控（模拟） 室温变化公式。 3、计费 单价待定。计费方式待定。 4、空调使用情况日志记录 记录空调从当前用户入住到退房期间内的所用空调使用信息。信息单元内容待定。 d) 与服务器端交互： 交互部分 说明 1、向服务器端（监控端）反馈： 当前信息、住户操作 可以直接在服务器端显示或日志存储，便于后期查看 2、无条件执行服务器端（监控端）的指令 ②服务器端功能：a) 信息与监控显示系统（Info Displaying System）： 说明：所有房屋信息都将记录并显示，下述为单一房屋单元将要显示的内容。 显示部分 说明 1、住户信息 住户ID 入住时间 2、空调运行状况 开机/关机 设定温度 设置风速 运行模式（Cool/Warm） 3、当前室内状况 室内温度 4、计费信息 消费金额。计费公式待定。 b) 控制终端（Terminal Controlling System）： 说明：所有房屋均可以被控制，下述为单一房屋单元的内容。 显示部分 说明 1、强制开关机 2、控制各种空调操作 设定温度 设置风速 运行模式（Cool/Warm） c) 计费/缴费（Billing System）： 按照计费公式进行计费。 d) 信息记录系统（Logs Recording System）： 组成部分 说明 1、记录所有信息 查询界面。查询权限问题？ 2、打印详单 打印信息 ③其他附加功能需求待定 5. 技术框架要求​ 由于一对多的服务框架，本系统拟采用“服务器+终端”模式，通过Socket套接字进行网络通信。用户通过终端控制室内空调系统，终端在本地记录操作信息并上载道服务器进行存储。所有数据存储来专用数据库中，并且只有服务器端有权限进行相应访问。前台控制端可以及逆行监控，以及全局控制。 四、总体设计(Overall Design)1. 总体设计目标​ 搭建一个服务于酒店管理人员与住户的空调管理系统，利用“服务器+终端”的模式，通过“socket套接字”进行连接，使得住户能够控制改变房间内（终端）的空调状态，并将空调信息实时传送给服务器，便于管理人员数据统计和处理。 2. 总体设计原则​ 空调管理系统需要建立终端与服务器之间的连接，并对于住户的空调使用信息和费用进行准确的统计、计算与存储。 3. 总体逻辑架构设计 逻辑架构 4. 网络设计​ 讨论后准备采用Socket+UDP方式，但因为验收组的最终具体协议还未确定，后期可能会有所变化。 5. 硬件相关设计​ 由于本系统规模较小，暂时不需要大型服务器、云存储设备等大型设备，仅使用几台基本的电脑即可实现。 电脑的推荐配置： Windows 10 操作系统（64位）； 2.8 GHz 或更高级别的处理器； 8 GB 内存； 40 GB 可用硬盘空间； 6. 软件平台选择 版本管理工具： Tortoise Git+Github 开发平台以及开发语言： Microsoft Visual Studio 2019/C++ 数据库平台： Microsoft SQL Server 2019 图形界面实现： QT 5.14 7. 基本技术路线 技术路线 PS：大概路线，仅供参考，可能有所变动。 五、详细设计（Detail Design）1. 引言（Introduction）编写目的 在前期阶段（*《概要设计》**）中，已解决了本系统的开发环境及技术路线和总体设计框架。建立了分布式温控系统***各模块之间的设计问题，包括用户如何进行控制本系统和查询等。以及管理员的登陆，用户信息管理（新用户添加，删除和状态修改）及系统的控制和查询。 ​ 在以下的详细设计中将对在本阶段中对系统所做的详细设计进行说明。在本阶段中，确定应该如何具体地实现所要求的**分布式温控系统**，从而在编码阶段可以把这个描述直接翻译成用具体的程序语言书写的程序。 ​ 主要的工作有：根据在*《需求分析》**中所描述的数据、功能、运行、安全、性能等需求，并依照《概要设计》***所确定的技术路线、处理流程、总体结构和模块外部设计，设计系统的结构、逐个模块的程序描述（包括各模块的功能、性能、输入、输出、算法技术等等），解决如何： 接受：用户信息和管理员修改后的信息； 输出：供用户查询的文字等信息； 进行数据库的查询、修改工作； 接受并判断系统错误，输出相应的出错消息； …… PS: 《用户操作手册》将与本阶段的工作紧密结合，努力作到让用户易懂易学。*《测试报告》、《维护报告》**也将参考本部分，检验本系统的各项性能指标，及时发现纰漏及时修补，一定要把功能强大、稳定可靠、便于维护的分布式温控系统***交到用户手中。 2. 软件架构设计（Software Architecture）关于软件的架构模型有众多： 分层架构（Layered Architecture） ​ 最常见的软件架构，也是标准架构，但此架构部署比较麻烦，且扩展性差，代码调整或增加功能时，通常比较麻烦和费时。且由于小组人数较少，本系统较为简单，不适用于此架构。 客户端-服务器架构（Client-Server Architecture） ①单体式： ​ 典型的三级架构，比较容易部署、测试，适合于较小型的系统，但由于存在可靠性差、扩展能力有限等缺点，经讨论后放弃。 ②分布式： ​ 单体式架构的拓展，应用多个数据库和多个服务器，从而提高了可靠性和安全性，经讨论，初步采用本架构部署和实施本系统。 微内核架构（Micro-kernel Architecture） ​ 本架构可定制性高，但是因为涉及到插件与内核的通信，以及内部的插件登记机制等问题，开发难度太高，故放弃本架构。 微服务架构（Micro-services Architecture） 云架构（cloud architecture） 微服务架构和云架构的实现依靠资金等支持，成本太高，不适用于本系统廉价的需求，均放弃。 3. 软件生命周期模型（Software Life Cycle Model）关于软件的生命周期模型有众多： 名称 对本系统的适用程度及分析 瀑布模型 实现简单，但风险控制能力较弱，缺乏灵活性，不能很好适应甲方需求的变化 演化模型 Do-Twice的开发模式虽然灵活且开发风险较低，但由于开发人员较为不足，两次的开发可能会导致不能在规定的时间内完成，且可能会导致软件系统的结构性较差 增量模型 本模型结合了瀑布模型和演化模型的优点，对系统的基本核心功能优先实现，保证了系统的稳定性和可维护性，较为适合本系统 喷泉模型 该模型虽然高效，但由于管理过于复杂，不适用于该系统 V模型和W模型 该模型较为高效，但由于本系统的测试主要集中在后期，因此不适用于该系统 螺旋模型 该模型主要针对大型软件项目的开发，由于本系统较为简单，并不适合该模型 构件组装模型 该模型主要适用于大公司使用，本项目较为简单且开发人员较少，并不适合该模型 …… …… 经讨论，最终决定采用增量模型作为本系统的生命周期模型。 4. 系统设计原则（System Design Principles）​ 总体上以技术先进、系统实用、结构合理、安全可靠、高效简便、低成本、低维护量作为基本设计原则，规划系统的整体构架。 先进性在本系统的设计上，整个系统的软件设计符合现代的潮流，操作界面、存储、传输等关键技术均处于领先的技术水平。在满足甲方现期功能的前提下，系统设计具有前瞻性，在今后较长时间内保持一定的技术先进性。 实用性和高效性 本系统提供友好、简洁、清晰、漂亮的中文人机交互界面，操作简便、灵活、易学易用，便于管理和维护。在操作处理上有高效实用的特点，能够满足分布式温控系统的要求。 安全性和可靠性本系统能够保证用户隐私信息不泄露、误操作提醒保护等多方面的安全要求。对登录系统的用户，进行严格的鉴权认证，以保证整个系统的安全性。系统支持对关键数据采取备份措施，有较强的容错和系统恢复能力，确保系统长期正常运行。并且本系统也能及时应对突发事件，保证了可靠性。 合理性和经济性 本系统设计时，充分考虑系统功能的扩充等方面的需求，方便系统平滑升级。并且在满足系统功能及性能要求的前提下，尽量降低系统建设成本，本着经济实用的原则，充分利用现资源，综合考虑系统的后期维护费用。 可扩展性本系统以科学的方法模型设计软件，使之有良好的结构和完备的文档，便于查阅维护，且软件的设计留有升级的空间，便于后期升级。 标准化和规范性本系统中采用的传输协议、文件格式等均符合国家标准、行业标准和公安部颁布的技术规范且具有良好的兼容性和互联互通性。 5. 功能设计（Functional Design）​ 该系统的主要模块划分已在概要设计中介绍，本部分将对每个模块的基本组成、具体功能、模块性能、输入、输出、主要算法和技术等方面进行展开描述： 1. 系统整体性能：①响应时间和延迟时间 ​ 用户对UI界面做出操作后，系统的处理响应时间不高于100 ms，网络传输数据延迟不高于500 ms，数据库读写操作时间不高于500 ms,从用户操作开始到用户得到相应的数据信息的总时间不超过800 ms（本项可能受到网络或者硬件本身性能等的影响，导致最终的延迟有所变化，受限于实际情况，最终解释权归乙方所有）。 ②吞吐量 ​ 本系统的吞吐量受限于响应延迟时间以及用户个数，在不同的时间段吞吐量可能不尽相同，但平均吞吐量一定满足甲方需求，最高吞吐量支持突发情况，最低吞吐量满足最低需求，保证系统稳定性。 ③并发用户数 ​ 因为本系统是应用于酒店，要求本系统能同时处理每个房间的不同用户的各种请求，每个客户端处于一个房间，客户端理论上只需单用户即可，不需要并发用户，并发用户还可能导致资源浪费，因此客户端并发用户数为 1，但是服务器需具有并发处理多个客户端的请求，目前设定并发用户数为10个（已经满足甲方验收组要求），可能保留有扩展空间，后期需要时也可继续增加。 2.模块详解：①客户端/终端模块 组成 模块名称 说明 文件存取模块 用于读取和写入本地文件 网络传输模块 与服务器进行通信，实现与服务器端的信息交互 用户界面模块 外部UI界面，实现与用户的交互 底层控制模块 实现各种控制功能，包括但不限于设定温度、风速、模式 日志模块 运行状态、账单详单等日志处理 额外功能模块 实现一些其他的新增功能，便于升级增加新功能 …… …… 功能 Ⅰ. 显示功能部分: 具体功能 说明 显示当前房间住户信息 包括住户ID、姓名等信息（隐私相关信息不予展示） 显示当前房间基本信息 包括房间当前温度等 显示当前房间的温控系统状态 包括温控系统开、关、休眠等状态 显示当前房间的温控系统基本信息 包括温控系统已使用时间、已改变温度、已花费金额等 显示当前房间的温控系统所处模式 包括制冷、制热、送风、自动运行（AUTO） 显示当前房间的温控系统所设风速 手动高、中、低（目前先设置为三挡），以及自动风速（AUTO） 警报功能（Beta） 如果用户设置的温度过高或过低超过阈值，或者用户打开该系统时间过长，则会提醒用户，发出警报 账单、详单功能 打印当前房间本系统使用的账单、详单等日志信息。该部分涉及到用户隐私问题，将考虑采用密码等方式进行，以保护用户隐私 Ⅱ. 控制功能部分： 具体功能 说明 开关功能 控制本温控系统的开关 改变模式 修改当前系统所处模式 修改风速 修改当前系统风速 定时功能（Beta） 定时开关本系统 Ⅲ. 其他功能部分： 具体功能 说明 登录功能 用户登录到该系统以查看关乎用户隐私的敏感信息（账单、详单等） 修改密码 修改用户的密码 被控功能 接受主控制台的控制信息，远程对本房间的温控系统进行强制控制，由本温控系统的Administrator负责 信息传送功能 定时或接收主控制台的请求，向主控制台发送本房间的温控系统的相关状态等信息 召唤人工服务 用户通过此功能召唤前台 输入 用户的按键等操作；主控制台由服务器传送的控制信息 输出 用户、房间信息；日志信息 算法和技术 网络访问socket技术；图形化界面QT设计 ②服务器模块A、主控服务器部分 组成 模块名称 说明 网络传输模块 与各房间的客户端进行通信，实现信息交互 数据库互联模块 连接数据库，实现数据的存取 用户界面模块 外部UI界面，实现与Administrator的交互 底层控制模块 实现对每个房间的各种总控功能，包括但不限于设定温度、风速、模式 日志模块 系统运行状态等日志处理 统计和数据处理模块 处理和统计所有客户端的数据 额外功能模块 实现一些其他的新增功能，便于升级增加新功能 …… …… 功能 Ⅰ. 监控功能部分: 具体功能 说明 显示所有房间住户信息 包括每个住户ID、姓名等信息 显示每个房间基本信息 包括每个房间当前温度等 显示每个房间温控系统信息 包括系统运行状态、所处模式等 账单、详单功能 打印一定时间段的某个或某些房间的账单、详单日志信息，或者打印所有房间的统计信息便于统计分析 Ⅱ. 总控功能部分： 具体功能 说明 总控功能 控制每个房间的温控系统的一切行为，包括开关、模式等，可以远程对房间的温控系统进行操控 Ⅲ. 其他功能部分： 具体功能 说明 登录及账户控制功能 Administrator登录到主控系统，从而进行一系列操作，包括对Administrator和普通账户的操作 日志等信息持久化 将一段时间内的各房间及其温控系统的日志持久化到数据库中保存 输入 每个房间发送的信息及日志；Administrator的按键等操作；本地SQL数据库的表数据 输出 对每个房间的控制信息；每个房间的账单、详单等统计信息；日志信息 算法和技术 网络访问socket技术；图形化界面QT设计；数据库SQL语句；ODBC等数据库连接相关技术 B、数据库部分 组成 ​ 拟采用微软Microsoft SQL Server 2019 Developer版本数据库对服务器数据进行管理，借助于其强大的数据存储和处理功能，保证系统数据安全性和可靠性，借助其便捷度事务处理机制，便于应对各种突发事件，保证系统稳定性。 功能 接收来自主控模块的日志等信息，持久化到磁盘中，供查询等使用 输入 主控模块的日志 输出 各种数据表 算法和技术 关系型数据库的设计方法；与数据库设计相关的SQL语句；E-R图等数据库设计模型方法 4. 安全设计(Security Design)​ 为确保本系统的安全性要求，进行如下的安全设计，以防止用户隐私泄露、主控被不良控制等对用户造成的不良影响： 信息安全：对用户和Administrator使用严格的密码管理，对其权限进行严格规定，确保身份鉴别安全。 数据库安全：配置用户帐号与口令安全策略，提高数据库系统帐户与口令安全。 网络安全：socket传输网络安全问题（防火墙？待定）。 系统交互安全：系统各模块之间接口明确，图形化界面与后台区分明确，尽量减少图形界面按钮出错等问题。 数据安全及备份：使用磁盘作为数据备份介质，对部分重要数据进行备份。 PS：具体实现仍需讨论，部分较难实现。 5. 用户界面设计（User Interface Design） 界面设计原则 ​ 本系统由于面向快捷廉价酒店，因此界面设计本着简洁高效的原则，用料廉价但又不失高端奢华，一切以用户的体验至上，让用户使用该系统后既能在廉价酒店体验高档酒店的舒适，又能实现省钱的目的。 界面原型设计 后期将进行详细设计说明 6. 数据库设计（Database Design）后期将进行详细设计说明 六、项目实施方案（Project Implementation Plan）（一）项目管理：1. 管理计划：​ 以五人小组为单位进行开发，将开发过程严格细分，以明确分工，再由组长负责监督、检查和评价，确保在规定的时间内完成并提交以下软件系统开发内容。 名称 时间 系统解决方案 2020-03-13 需求定义及领域模型 2020-03-27 用例模型 2020-04-10 设计模型-动态结构设计 2020-05-08 设计模型-静态结构设计 2020-05-15 系统验收 2020-06-05 2. 分工及评价：在项目开始后，根据各部分的难易程度和数量大小，明确分工给各个组员，下表用以统计组员工作情况和评价。 编号-姓名 具体分工内容 完成情况 评价 其他说明 待填写 （二）软件测试方案1. 测试目标：测试本软件系统在规定原则范围内，满足用户所提需求（请参考本方案第三部分）。 2. 测试流程：1.将整个软件系统进行安装和布置； 2.检测是否能正常运行； 3.根据提供的多个样本信息，逐一进行测试，并记录测试过程中各项与客户需求有关的数据信息； 4.分析运行结果和有关的数据信息，逐一确认是否达到客户需求标准； 5.对软件系统进行评价，客户接收确认； 客户需求及需求标准 软件运行数据信息 是否达标（可说明） 七、总结及问题说明（Summary and Problem Description）开发过程中遇到的问题及解决方案说明: 时间 问题描述 是否解决以及解决方案 八、附录（Appendix）1. 项目规范①编程规范：​ 严格遵循C++编码规范，有详细的注释说明，包括源文件头注释及函数头注释等，统一变量、函数等命名规范，确保代码易读性和规范性。 PS:后期有详细的编码、注释规范，此处略。 ②文档规范： 正文 采用宋体作为基本字体，辅以其他字体作为备用，强调部分用斜体或粗体提示。 标题 一级标题序号 如：一、二、三、 标题四号黑体，加粗，顶格。 二级标题序号 如：(一)(二)(三) 标题小四号宋体，不加粗，顶格。 三级标题序号 如：1.2.3. 标题小四号宋体，不加粗，缩进二个字。 四级标题序号 如：(1)(2)(3) 标题小四号宋体，不加粗，缩进二个字。 五级标题序号 如：①②③ 标题小四号宋体，不加粗，缩进二个字。 PS:标题可能因为markdown语法限制和书签目录等情况适当进行调整，但一定保证整齐易读。 表格 ​ 每个表格应有自己的表题，表格允许下页接续写，表题可省略，表头应重复写，并在右上方写“续表××”。 插图 ​ 每幅图应该配有必要的图题，图题应放在图位下方居中处。图应在描图纸或在洁白纸上用墨线绘成，也可以用计算机绘图，保证清晰可见。 其他 ​ 论文中的图、表、公式、算式等，需要时可用阿拉伯数字分别依序连编编排序号。序号分章依序编码，其标注形式应便于互相区别，例如：图2.1、表3.2、公式(3.5)等。 PS:本规范仅作为基本要求，必要时可做修改。 2. 相关术语解释 名称 说明 本系统 分布式温控计费系统 …… …… 说明： ​ 软件系统的最终版本可能与本系统解决方案的描述有所差异，最终的实行也可能与本方案有所偏差，本方案的最终解释权归乙方所有。 六、项目地址整个项目的源代码，可执行文件，测试用例，结果均在下面的仓库中，欢迎查看：","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://666wxy666.github.io/categories/C-C/"},{"name":"软件工程","slug":"C-C/软件工程","permalink":"https://666wxy666.github.io/categories/C-C/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"QT","slug":"QT","permalink":"https://666wxy666.github.io/tags/QT/"},{"name":"软件工程","slug":"软件工程","permalink":"https://666wxy666.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}]},{"title":"现代交换原理 实验3 MPLS编程实验","slug":"交换原理-实验3-MPLS编程实验","date":"2020-10-09T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/10/09/交换原理-实验3-MPLS编程实验/","link":"","permalink":"https://666wxy666.github.io/2020/10/09/%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86-%E5%AE%9E%E9%AA%8C3-MPLS%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/","excerpt":"本文是关于交换原理实验三——MPLS编程实验报告记录。","text":"本文是关于交换原理实验三——MPLS编程实验报告记录。 一、实验目的安排的三个编程实验主要用于加强学生对MPLS交换中标记请求、标记分配与分发、标记分组转发的理解。 二、实验内容和实验步骤1、实验原理及设计多协议标记交换MPLS（Multiple Protocol Labeled Switching）技术是将第二层交换和第三层路由结合起来的一种L2/L3集成数据传输技术。MPLS是一项面向连接的交换技术，因此有建立连接的过程。各个MPLS设备运行 路由协议，在标记分发协议LDP的控制下根据计算得到的路由在相邻的路由器进行标记分配和分发，从而通过标记的拼接建立起从网络入口到出口的标记交换路径LSP。 在数据转发过程中，入口标记路由器LER根据数据流的属性比如网络层目的地址等将分组映射到某一转发等价类FEC，并为分组绑定标记。核心标记交换路由器LSR只需根据分组中所携带的标记进行转发即可。出口标记路由器LER弹出标记，根据分组的网络层目的地址将分组转发到下一跳。MPLS节点（MPLS标记交换路由器LSR或MPLS边缘路由器LER）均要创建和维护传统的路由表和标记信息库LIB。 路由表记录记录路由信息，用于转发网络层分组和标记分发从而建立标记交换路径。LIB记录了本地节点分配的标记与从邻接MPLS节点收到的标记之间的映射关系，用于标记分组的转发。 MPLS技术的核心实质在于： 网络中分组基于标记的转发； LDP协议控制下的进行标记分发从而建立标记交换路径LSP； 2、实验主要数据结构所需要的头文件：”mplsconstant.h” 其中的主要数据结构为： 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//发送的请求信息包数据结构struct ReqType&#123; int iFirstNode; //请求信息包的源节点 int iEndNode; //请求信息包的目的节点 double ipaddress; //请求信息包包含的网络层目的IP地址前缀（例如197.42）&#125;;//路由表表项的数据结构struct routertype&#123; double ipaddress; //网络层目的地址前缀 int nexthop; //下一跳节点 int lasthop; //上一跳节点 int inpoint; //入端口号 int outpoint; //出端口号&#125;;//标记信息表表项的数据结构struct libtype&#123; double ipaddress; //网络层目的地址前缀 int inpoint; //入端口号 int outpoint; //出端口号 int inlabel; //入标记值 int outlabel; //出标记值&#125;;//发送的标记信息包数据结构struct LabelPack&#123; int iFirstNode; //源节点号 int iEndNode; //目的节点号 int labelvalue; //标签值&#125;;struct funcusedtype&#123; struct libtype libinfo; //包含的标记信息表项 struct LabelPack labelinfo; //包含的标记信息包数据结构&#125;;//发送的标记分组信息包类型struct LabelledDataPack&#123; int iFirstNode; //源节点号 int iEndNode; //目的节点号 struct MessageType DataInfo; //包含的标记分组类型信息&#125;;//标记分组类型struct MessageType&#123; double ipaddress; //网络层目的地址前缀 int labelvalue; //输出标签值&#125;; ①标记请求实验：12345extern &quot;C&quot; _declspec(dllexport) struct ReqType req_process(int idnow,struct routertype routenow)&#123; struct ReqType reqtemp; return reqtemp;&#125; 参数意义： int idnow：当前的节点号； struct routertype routenow：当前所指的路由表的表项； 函数要求： 根据提供的当前节点号和路由表表项值产生标记请求包； 过程描述： 标记请求包的源节点号由当前节点号提供，目的节点号和ip地址前缀由当前所指的路由表表项的下一跳节点和ip地址前缀提供； ②标记分配与分发实验：12345extern &quot;C&quot; _declspec(dllexport) struct funcusedtype label_process(struct routertype routenow,int labelout,int idnow)&#123; struct funcusedtype tempstruct; return tempstruct;&#125; 参数意义： struct routertype routenow：当前所指的路由表表项； int labelout：分配的输出标签号； int idnow：当前的节点号； 函数要求： 该函数要求根据提供的路由表当前表项、分配的输出标签号和当前节点号，构造一funcusedtype信息包。注：各节点的输入标签可以自由选定，但必须是1-9的整数； 过程描述： 该funcusedtype信息包的libinfo部分可由当前的路由表表项、当前分配的标签号的有关部分构成；labelinfo部分由当前节点号和当前的路由表表项的有关部分构成； ③标记分组转发实验12345extern &quot;C&quot; _declspec(dllexport) struct LabelledDataPack pack_process(struct routertype routenow,struct libtype libnow,int idnow)&#123; struct LabelledDataPack packtemp; return packtemp;&#125; 参数意义： struct routertype routenow：当前所指的路由表表项； struct libtype libnow：当前的标签信息表表项； int idnow：当前的节点号； 函数要求: 该函数要求根据提供的路由表表项、标签信息表表项和当前节点号，构造出一个标签数据信息包。 过程描述： 该标签信息包的源节点、目的节点、IP地址前缀和标签值均可由当前节点号、路由表表项和标签信息表表项构成； 3、实验效果检验建立连接阶段、数据传输阶段、拆除阶段，三阶段均可正常进行。 4、实验步骤 熟悉实验平台和测试环境； 编写C程序实现所要求的功能； 运行测试程序； 完成实验报告。 三、源代码①标记请求实验： 点击查看代码 12345678910#include &quot;mplsconstant.h&quot;extern &quot;C&quot; _declspec(dllexport) struct ReqType req_process(int idnow, struct routertype routenow)&#123; struct ReqType reqtemp; reqtemp.iFirstNode = idnow; //源节点号由当前节点号提供 reqtemp.iEndNode = routenow.nexthop; //目的节点号由当前路由表表项的下一跳节点提供 reqtemp.ipaddress = routenow.ipaddress; //IP地址前缀由当前路由表表项的IP地址前缀提供 return reqtemp;&#125; ②标记分配与分发实验： 点击查看代码 1234567891011121314151617#include &quot;mplsconstant.h&quot;extern &quot;C&quot; _declspec(dllexport) struct funcusedtype label_process(struct routertype routenow, int labelout, int idnow)&#123; struct funcusedtype tempstruct; //包含的标记信息表项 tempstruct.libinfo.ipaddress = routenow.ipaddress; //网络层目的地址前缀 tempstruct.libinfo.inpoint = routenow.inpoint; //入端口号 tempstruct.libinfo.outpoint = routenow.outpoint; //出端口号 tempstruct.libinfo.inlabel = 1; //入标记值 tempstruct.libinfo.outlabel = labelout; //出标记值 //包含的标记信息包数据结构 tempstruct.labelinfo.iFirstNode = idnow; //当前节点号 tempstruct.labelinfo.iEndNode = routenow.lasthop; //当前的路由表表项的上一跳节点 tempstruct.labelinfo.labelvalue = 1; //与tempstruct.libinfo.inlabel保持一致 return tempstruct;&#125; ③标记分组转发实验 点击查看代码 123456789101112#include &quot;mplsconstant.h&quot;extern &quot;C&quot; _declspec(dllexport) struct LabelledDataPack pack_process(struct routertype routenow, struct libtype libnow, int idnow)&#123; struct LabelledDataPack packtemp; packtemp.iFirstNode = idnow; //源节点号 packtemp.iEndNode = routenow.nexthop; //目的节点号 //包含的标记分组类型信息 packtemp.DataInfo.ipaddress = routenow.ipaddress; //网络层目的地址前缀 packtemp.DataInfo.labelvalue = libnow.outlabel; //输出标签值 return packtemp;&#125; 四、实验结果运行程序后，建立连接阶段、数据传输阶段、拆除阶段，三阶段均可正常进行，实验成功。 五、实验心得这次实验要编写三个程序，但是基本框架都已经规定好了，对照指导书上结构体和函数的说明，只需要简单的创建结构体和赋值操作就能很轻松地完成。加强了我对MPLS的原理和标记请求、标记分配与分发、标记分组转发过程的理解和认识。实验虽然简单，但是很有意义，收获很多。","categories":[{"name":"现代交换原理","slug":"现代交换原理","permalink":"https://666wxy666.github.io/categories/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"},{"name":"实验","slug":"现代交换原理/实验","permalink":"https://666wxy666.github.io/categories/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"现代交换原理","slug":"现代交换原理","permalink":"https://666wxy666.github.io/tags/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"},{"name":"MPLS","slug":"MPLS","permalink":"https://666wxy666.github.io/tags/MPLS/"}]},{"title":"现代交换原理 实验1 时间表调度实验","slug":"现代交换原理-实验1-时间表调度实验","date":"2020-10-09T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/10/09/现代交换原理-实验1-时间表调度实验/","link":"","permalink":"https://666wxy666.github.io/2020/10/09/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86-%E5%AE%9E%E9%AA%8C1-%E6%97%B6%E9%97%B4%E8%A1%A8%E8%B0%83%E5%BA%A6%E5%AE%9E%E9%AA%8C/","excerpt":"本文是关于交换原理实验一——时间表调度实验报告记录。","text":"本文是关于交换原理实验一——时间表调度实验报告记录。 一、实验目的驱动交换网络实验用来考查学生对时间表调度原理的掌握情况。 二、实验内容和实验步骤1、实验原理及设计在程控数字交换的体系结构中，周期级程序（例如摘挂机检测程序、脉冲识别程序、位间隔识别程序）是由时间表调度实现的。所谓时间表调度，是指每经过交换系统的最短有效时间（这通常是指各周期性程序周期的最大公约数），都会检查调度表的调度要求，如果某个程序在这时需要执行，则调度程序开始执行它。 在我们设计的时间表调度实验中，这个调度表的调度是静态的。所谓静态，是指我们的调度表是在系统初始化的时候就建立起来的，在系统运行的情况下不再改动。 实验要求的就是这个调度表的初始化。这个调度表如下： 时间（10ms) \\任务 0：摘挂机检测任务 1：脉冲检测任务 2：位间隔检测任务 0 0/1 0/1 0/1 1 0/1 0/1 0/1 …… …… …… …… …… …… …… …… …… …… …… …… 18 0/1 0/1 0/1 19 0/1 0/1 0/1 我们这个交换系统提供了三个周期性调度程度（摘挂机检测程序、脉冲识别程序和位间隔识别程序），它们的调用周期分别为 200ms、10ms 和 100ms，所以我们系统的最小调度时间为 10ms。如图所示，每隔 10ms,我们就会检查这个表的一行，如果该行上某一列为 1，我们就执列所对应的任务，如果为 0，就什么都不做。每当执行到这个表的最后一行，调度任务会返回第一行循环执行。而你所要做的就是按照你的理解来填写这个调度表。 2、实验主要数据结构函数功能：完成调度表的初始化； 函数原型： 1initSchTable(int ScheduleTable[SchTabLen][SchTabWdh])； 其中 SchTalLen 和 SchTabWdh 为在 bconstant.h 中的宏定义： 12#define SchTabLen 20 //代表这个调度表为 20 行（相邻行之间的时间间隔为 10ms); #define SchTabWdh 3 //代表三个周期性调度任务——0：摘挂机检测任务；1：脉冲检测任务；2：位间隔检测任务； 3、实验效果检验当调度表初始化正确时，能够进行正常的通话；如果初始化不正确，可能会造成周期性程序的不正常调用，例如位间隔调度的延迟会造成识别位间隔的延误甚至丢失。 4、实验步骤 熟悉实验平台和测试环境； 编写C程序实现所要求的功能； 运行测试程序； 完成实验报告。 三、源代码 点击查看代码 12345678910111213141516171819202122232425262728293031323334#include &quot;bconstant.h&quot;extern &quot;C&quot; _declspec(dllexport) void initSchTable(intScheduleTable[SchTabLen][SchTabWdh])&#123; int i; for (i = 0; i != SchTabLen; i++) &#123; //最小时间间隔为10ms //对摘挂机状态进行初始化 if (i % 20 == 0) //因为调度周期为200ms，也就是每隔20个最小间隔执行一次 &#123; ScheduleTable[i][0] = 1; &#125; else &#123; ScheduleTable[i][0] = 0; &#125; //对脉冲识别进行初始化 ScheduleTable[i][1] = 1; //因为调度周期为10ms，也就是每个最小间隔都执行一次 //对为间隔识别进行初始化 if (i % 10 == 0) //因为调度周期为100ms，也就是每隔10个最小间隔执行一次 &#123; ScheduleTable[i][2] = 1; &#125; else &#123; ScheduleTable[i][2] = 0; &#125; &#125; return;&#125; 四、实验结果运行程序后，调度表初始化正确，周期性程序正常调用，能够进行正常的通话。 五、实验心得这是第一个交换原理的实验，是较为基础的实验，只是对数组的静态初始化，为以后的实验打下基础。我观察了模拟环境下的电路接通情形，让我对时间调度有了一个形象生动的认识，加深了这部分知识记忆和理解。","categories":[{"name":"现代交换原理","slug":"现代交换原理","permalink":"https://666wxy666.github.io/categories/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"},{"name":"实验","slug":"现代交换原理/实验","permalink":"https://666wxy666.github.io/categories/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"现代交换原理","slug":"现代交换原理","permalink":"https://666wxy666.github.io/tags/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"}]},{"title":"现代交换原理 实验2 摘挂机检测实验","slug":"现代交换原理-实验2-摘挂机检测实验","date":"2020-10-09T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/10/09/现代交换原理-实验2-摘挂机检测实验/","link":"","permalink":"https://666wxy666.github.io/2020/10/09/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86-%E5%AE%9E%E9%AA%8C2-%E6%91%98%E6%8C%82%E6%9C%BA%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/","excerpt":"本文是关于交换原理实验二——摘挂机检测实验报告记录。","text":"本文是关于交换原理实验二——摘挂机检测实验报告记录。 一、实验目的摘挂机检测实验用来考查学生对摘挂机检测原理的掌握情况。 二、实验内容和实验步骤1、实验原理及设计设用户在挂机状态时扫描输出为“0”，用户在摘机状态时扫描输出为“1”，摘挂机扫描程序的执行周期为200ms，那么摘机识别，就是在200ms的周期性扫描中找到从“0”到“1”的变化点，挂机识别就是在200ms的周期性扫描中找到从“1”到“0”的变化点。 在我们的实验中，我们把前200ms的线路状态保存以备这次可以读取，同时读出这次的线路状态，把前200ms的线路状态取反与这次的线路状态相与，如果为1，就说明检测到摘机消息了。同理，我们把这次的线路状态取反再与前200ms的线路状态相与，如果为1就说明检测到挂机消息了，然后把摘挂机信号作为事件放入摘挂机队列中。 2、实验主要数据结构函数功能为：检测到摘、挂机事件，并把该事件放入到摘挂机事件队列中。 函数原型： 1void scanfor200(int linestate200[LINEMAX],int linestate[LINEMAX],UpOnnode * head1, UpOnnode* end1); 其中LINEMAX为线路总数，是定义在”bconstant.h”中的一个宏,linestate200[LINEMAX]为已保存的200ms前线路状态，linestate[LINEMAX]为当前的线路状态，head1,end1为摘挂机队列的首尾指针，该队列已经在主程序中进行了初始化。我们所要做的就是把检测到的摘挂机事件以摘挂机队列节点的形式插入到摘挂机事件队列中。 数据结构说明： 点击查看代码 1234567891011121314&quot;bconstant.h&quot; //以下的数据结构都已在该文件中定义 LINEMAX //最大线路数； int linestate200[LINEMAX],linestate[LINEMAX] //线路从0开始编号；状态：1：有电流，0无电流； enum UporOn &#123;ehandup,ehandon&#125; //为摘挂机区别符：ehandup表示摘机，ehandon表示挂机； struct UpOnnode //摘挂机队列节点结构 &#123; UporOn phonestate; //摘挂机区别符； int linenum; //线路号（从0开始）； struct UpOnnode* next; //指向下一节点的指针；&#125;; 注意事项： 我们编写的模块是基础实验部分预加载的本局交换系统的一个模块而已，在系统中head1头指针和end1尾指针已经完成初始化。为方便起见，我们的摘挂机事件队列是一个包含头节点的单向链表，并且头指针指向该头节点，尾指针在初始化时也指向了该节点。所以在我们的函数编写中应保证头指针始终指向该头节点上、尾指针指向摘挂机事件队列的最末一个节点。 注意把这次扫描的线路状态值保存在前200ms扫描线路状态数组中,以便主程周期调用。 3、实验效果检验当调度表初始化正确时，能够进行正常的通话；如果初始化不正确，可能会造成周期性程序的不正常调用，例如位间隔调度的延迟会造成识别位间隔的延误甚至丢失。 4、实验步骤 熟悉实验平台和测试环境； 编写C程序实现所要求的功能； 运行测试程序； 完成实验报告。 三、源代码 点击查看代码 123456789101112131415161718192021222324252627282930#include &quot;bconstant.h&quot;extern &quot;C&quot; _declspec(dllexport) void scanfor200(int linestate200[LINEMAX], int linestate[LINEMAX], UpOnnode *head1, UpOnnode *end1)&#123; int i; for (i = 0; i &lt;= LINEMAX; i++) &#123; struct UpOnnode *newNode = new struct UpOnnode; if (!linestate200[i] &amp;&amp; linestate[i]) &#123; newNode-&gt;phonestate = ehandup; &#125; if (!linestate[i] &amp;&amp; linestate200[i]) &#123; newNode-&gt;phonestate = ehandon; &#125; newNode-&gt;linenum = i; newNode-&gt;next = 0; end1-&gt;next = newNode; end1 = newNode; linestate200[i] = linestate[i]; &#125; return;&#125;// 此函数不需修改extern &quot;C&quot; _declspec(dllexport) void freenode(UpOnnode *node)&#123; delete node;&#125; 四、实验结果运行程序后，能正确检测摘挂机动作并且能进行通话，与预期结果相符，成功。 五、实验心得这次实验也比较简单，主要用来考察对摘挂机检测的原理的掌握情况。在实验中遇到的比较困难的就是新节点添加到链表中指针如何分配，因为大一学过的知识时间比较久了，记得不是很清晰，于是就先复习了链表相关的知识，最终也成功实现了要求的功能。通过这次实验， 我加深了对摘挂机检测原理的掌握（检测到摘挂机事件，都将该事件添加到队列中），深入了解了摘挂机的详细过程，增强了对实验平台的熟悉和对软件的了解，收获很大。","categories":[{"name":"现代交换原理","slug":"现代交换原理","permalink":"https://666wxy666.github.io/categories/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"},{"name":"实验","slug":"现代交换原理/实验","permalink":"https://666wxy666.github.io/categories/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"现代交换原理","slug":"现代交换原理","permalink":"https://666wxy666.github.io/tags/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"}]},{"title":"交换原理 实验4 拨打SIP电话","slug":"现代交换原理-实验4-拨打SIP电话","date":"2020-10-09T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/10/09/现代交换原理-实验4-拨打SIP电话/","link":"","permalink":"https://666wxy666.github.io/2020/10/09/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86-%E5%AE%9E%E9%AA%8C4-%E6%8B%A8%E6%89%93SIP%E7%94%B5%E8%AF%9D/","excerpt":"本文是关于交换原理实验四——拨打SIP电话及抓包分析实验报告记录。","text":"本文是关于交换原理实验四——拨打SIP电话及抓包分析实验报告记录。 这些项目的源码、可执行程序、报告等已经存放于我的Github，欢迎下载查看：","categories":[{"name":"现代交换原理","slug":"现代交换原理","permalink":"https://666wxy666.github.io/categories/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"},{"name":"实验","slug":"现代交换原理/实验","permalink":"https://666wxy666.github.io/categories/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"现代交换原理","slug":"现代交换原理","permalink":"https://666wxy666.github.io/tags/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"},{"name":"SIP","slug":"SIP","permalink":"https://666wxy666.github.io/tags/SIP/"}]},{"title":"C++工程项目 JobShop","slug":"C++工程项目-JobShop","date":"2020-09-30T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/09/30/C++工程项目-JobShop/","link":"","permalink":"https://666wxy666.github.io/2020/09/30/C++%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE-JobShop/","excerpt":"本文是计算机导论的程序设计实战项目，实现单词消除游戏，具体项目及要求请点击查看。","text":"本文是计算机导论的程序设计实战项目，实现单词消除游戏，具体项目及要求请点击查看。 一、任务概述 完成这一任务必须满足以下约束条件： 约束1：程序启动后首先接受产品加工请求输入，确认当天的需求后不再接受新的订单。对每个产品需满足加工工序约束，即只有其前一个工序加工完毕，才能加工其后一个工序。每个工序的加工时间已知，且所需机器固定(每台机器都不能被其他机器替代)，均作为程序的输入。 表1. 要输入的参数 产品1 产品2 产品3 … 操作1 （7，M1） （10，M2） （7，M1） … 操作2 （12，M2） （17，M1） （22，M2） … 操作3 （15，M3） … … … 约束2：每台机器同一时间只能加工一个操作，一旦开始加工一个操作就要加工完成，期间不允许中断。 二、运行环境电脑硬件配置： 处理器：Intel i7 7700HQ 显卡：NVIDIA GeForce GTX 1050 Ti 内存：16GB 编程语言：C++ 三、程序输入输入参数如下： 产品的数目n； 所用机器数目m； 表1所示的各工序的加工时间，所用机器约束。 要求开发两个版本：命令行版本和动画版本。 具体说明如下： 命令行版本，要求实现文件输入和键盘输入，文件和命令行同时输出。 动画版本，要求实现图形界面输入，文件和动画同时输出。 1、文件输入文件名为input.txt，文本文件格式为： 首行输入产品数和机器数，格式为： 1&lt;产品数目&gt; &lt;空格&gt;&lt;机器数目&gt;&lt;\\n&gt; 之后每一行代表一个产品的加工订单，‘-1’表示结束。 每行的订单输入格式规定如下： 1&lt;产品序号&gt;&lt;空格&gt;&lt;(&gt;&lt;按顺序的工序所花时间&gt;&lt;,&gt;&lt;工序指定机器号&gt;&lt;)&gt;&lt;空格&gt;...&lt;\\n&gt; 例如上面表1的加工三个产品的订单，输入文件内容为： 3 3 1 (7,1) (3,2) (15,3) 2 (10,2) (17,1) 3 (7,1) (22,2) -1 在软件系统开发期间，老师会提供几组测试数据（输入文件和参照方案）给同学们，便于大家测试。最后验收的时候，老师会现场给定新的测试数据，来验证各组程序的算法优劣。 2、从键盘输入命令行方式下，首先输入产品数和机器数，格式为： 1&lt;产品数目&gt; &lt;空格&gt;&lt;机器数目&gt;&lt;\\n&gt; 之后每一行代表一个产品的加工订单，输入‘-1’表示结束输入。 每行的订单输入格式规定如下： 1&lt;产品序号&gt;&lt;空格&gt;&lt;(&gt;&lt;按顺序的工序所花时间&gt;&lt;,&gt;&lt;工序指定机器号&gt;&lt;)&gt;&lt;空格&gt;...&lt;ENTER&gt; 例如上面表1的加工三个产品的订单输入，可以用键盘输入为： 3 3 1 (7,1) (3,2) (15,3) 2 (10,2) (17,1) 3 (7,1) (22,2) -1 在输出过程中，随机增加故障 3、图形界面输入图形窗口中设计总产品数目和机器数目的输入框，工序所花时间的输入框、工序指定机器号的输入框，工序确认的按钮，下一产品的按钮，以及订单收齐确认按钮。界面元素大致如图1所示。 初始输入时，首先输入产品总数和机器总数，然后是产品1的加工要求，用户输入工序时间和机器号后，按工序确认可以产生一个工序操作，顺序产生多道工序后可以按“下一产品”按钮进入下一个产品的工序输入。依次操作直到所有产品的加工要求输入完成，按“订单确认”按钮启动程序计算。 三、程序输出在满足以上约束条件的前提下，安排所输入订单的n个产品在m台机器上的加工，要求给出产品的各操作在机器上的加工顺序，以及各操作的起始加工时间。 要求开发两个版本：命令行版本和动画版本。具体说明如下： 命令行版本，要求实现文件输入和键盘输入，文件和命令行同时输出。 动画版本，要求实现图形界面输入，文件和动画同时输出。 1、文件输出文件名为output.txt，文本文件格式为： 一行代表一个机器的加工序列，最后一行输出‘End &lt;最终结束时间&gt;’表示方案的最终完成时间。 每行的机器加工序列输出格式规定如下： 1&lt;M&gt;&lt;机器号&gt;&lt;空格&gt;&lt;(&gt;&lt;起始时间,产品号-工序号,终止时间&gt;&lt;)&gt;&lt;空格&gt;...&lt;\\n&gt; 例如上面表1的加工三个产品的方案输出，文件内容为： M1 (0,1-1,7) (7,3-1,14) (29,2-2,46) M2 (7,1-2,19) (19,2-1,29) (29,3-2,51) M3 (19,1-3,34) End 51 通过时间轴，动态的打印出各个计划 2、命令行输出命令行方式下，一行代表一个机器的加工序列，最后一行输出‘End &lt;最终结束时间&gt;’表示方案的最终完成时间。 每行的机器加工序列输出格式规定如下： &lt;机器号&gt;&lt;空格&gt;&lt;(&gt;&lt;起始时间,产品号-工序号,终止时间&gt;&lt;)&gt;&lt;空格&gt;…&lt;\\n&gt; 例如上面表1的加工三个产品的方案输出，命令行显示为： M1 (0,1-1,7) (7,3-1,14) (29,2-2,46) M2 (7,1-2,19) (19,2-1,29) (29,3-2,51) M3 (19,1-3,34) End 51 3、图形界面输出要求在图形窗口中用绘制的甘特图来表示操作在机器上的安排。 例如，图2所示的甘特图给出了上文提及的3个产品在3台机器上加工的一个安排，其中给出了每台机器上的操作的加工排序以及每个操作的开始加工时间。图2所示的加工安排满足产品加工约束和表1所示的机器加工约束。例如，产品1的第1个操作加工完毕再加工第2个操作，第2个操作加工完毕再加工第3个操作。产品1的第1、2、3个操作分别在机器1、2、3上加工，加工时间分别是7、12、15，满足表1中的约束。 4、动画输出四、核心调度算法n个产品在m台机器上加工，满足约束条件的加工安排有很多。我们设定最优解为所有产品加工完成所需时间最短，则需要找到一个加工安排，使得所有产品最快完成加工。 要想获得所有产品加工完成时间更短的方案，我们需要借助调度算法。以下是可选的调度算法。 （1）调度规则算法当一台机器加工完毕一个操作而变为空闲状态后，通常有多个操作请求在该机器上加工，此时，需要决定该机器下一步加工哪个操作。用调度规则可做出这一决策。调度规则在每次迭代中按照优先规则调度一个操作，直至生成一个完整调度。如果要用调度规则生成一个较好的安排，需要借助Giffler &amp; Thompson算法。 （2）邻域搜索算法采用析取图为问题建模，然后基于析取图模型构造解的邻域。邻域搜索的基本思想为：在每次迭代中，选取当前解的邻域中的最好解作为下一个解，只要目标函数值减少，该过程就不断继续，直到找到局部最优点。典型的邻域搜索算法包括模拟退火、禁忌搜索算法。 （3）演化算法需要将问题的解表示为一个编码，用一个群体来表示一组解。群体经过若干世代的进化，最终产生的最优个体即为问题的最优解。 第1种算法相对较简单，对于小规模问题效果较好，但对较大规模问题效果不够理想；第2、3种算法较复杂，需要了解一些背景知识，对大规模问题的性能也较好。 建议同学们用关键词“车间调度”、“Job shop调度”“Job shop scheduling”在学校图书馆电子数据库中查找并阅读相关文献，然后选择一种算法实现。 最终，所有参与此游戏开发的小组会将结果：程序运行时间、最优解方案加工时间两个时间值按一定权重进行评比，形成一个排行榜。所以选择算法时，要综合考虑最短的算法运行时间和解决方案最优，两者平衡。 五、实现要求 以小组为单位完成上述任务要求，只要能完成输入订单的方案输出，满足约束规则，就可通过。 必须完成两个版本：命令行版本和动画版本的开发，按时参加验收。为了保证验收，要求各小组的程序运行时间不能超过10分钟。 必须在指定时间内提交概要设计文档和程序代码。 六、评价规则所有参与此游戏开发的小组会将结果：程序运行时间、最优解方案加工时间两个时间值按一定权重进行评比，形成一个排行榜。 大作业成绩会基于这个排行榜得分。另外再综合软件的扩展功能、程序代码结构、小组协作度等附加项，形成最终分数。 五、项目地址本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看：","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://666wxy666.github.io/categories/C-C/"},{"name":"项目","slug":"C-C/项目","permalink":"https://666wxy666.github.io/categories/C-C/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"JobShop","slug":"JobShop","permalink":"https://666wxy666.github.io/tags/JobShop/"}]},{"title":"计算机组成原理 FPGA编程实验","slug":"计算机组成原理-FPGA编程实验","date":"2020-09-13T00:00:00.000Z","updated":"2021-05-30T09:07:07.229Z","comments":true,"path":"2020/09/13/计算机组成原理-FPGA编程实验/","link":"","permalink":"https://666wxy666.github.io/2020/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-FPGA%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/","excerpt":"本文是计算机机组成原理在MiniSYS系统上的FPGA编程实验项目。","text":"本文是计算机机组成原理在MiniSYS系统上的FPGA编程实验项目。 这些项目的源码、可执行程序、报告等已经存放于我的Github，欢迎下载查看：","categories":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://666wxy666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"实验","slug":"计算机组成原理/实验","permalink":"https://666wxy666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"Verilog","slug":"Verilog","permalink":"https://666wxy666.github.io/tags/Verilog/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://666wxy666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"FPGA","slug":"FPGA","permalink":"https://666wxy666.github.io/tags/FPGA/"},{"name":"MiniSYS","slug":"MiniSYS","permalink":"https://666wxy666.github.io/tags/MiniSYS/"}]},{"title":"计算机网络 实验集锦","slug":"计算机网络-实验集锦","date":"2020-09-10T00:00:00.000Z","updated":"2021-05-30T09:07:07.229Z","comments":true,"path":"2020/09/10/计算机网络-实验集锦/","link":"","permalink":"https://666wxy666.github.io/2020/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%AE%9E%E9%AA%8C%E9%9B%86%E9%94%A6/","excerpt":"本文是计算机网络相关实验项目工程集锦。","text":"本文是计算机网络相关实验项目工程集锦。 这些项目的源码、可执行程序、报告等已经存放于我的Github，欢迎下载查看： 网络层数据分组的捕获和分析 数据链路层滑动窗口协议的设计与实现 DNS中继服务器的简单实现","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://666wxy666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"实验","slug":"计算机网络/实验","permalink":"https://666wxy666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"集锦","slug":"集锦","permalink":"https://666wxy666.github.io/tags/%E9%9B%86%E9%94%A6/"},{"name":"C++","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"C","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://666wxy666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"DNS","slug":"DNS","permalink":"https://666wxy666.github.io/tags/DNS/"}]},{"title":"CSAPP 实验集锦","slug":"CSAPP-实验集锦","date":"2020-09-04T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/09/04/CSAPP-实验集锦/","link":"","permalink":"https://666wxy666.github.io/2020/09/04/CSAPP-%E5%AE%9E%E9%AA%8C%E9%9B%86%E9%94%A6/","excerpt":"本文是CSAPP（深入理解计算机系统）项目工程集锦。","text":"本文是CSAPP（深入理解计算机系统）项目工程集锦。 这些项目的源码、可执行程序、报告等已经存放于我的Github，欢迎下载查看： LINUX环境和GCC工具链 缓冲区溢出 键盘驱动程序的分析与修改","categories":[{"name":"集锦","slug":"集锦","permalink":"https://666wxy666.github.io/categories/%E9%9B%86%E9%94%A6/"},{"name":"CSAPP","slug":"集锦/CSAPP","permalink":"https://666wxy666.github.io/categories/%E9%9B%86%E9%94%A6/CSAPP/"}],"tags":[{"name":"集锦","slug":"集锦","permalink":"https://666wxy666.github.io/tags/%E9%9B%86%E9%94%A6/"},{"name":"C","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/tags/Linux/"},{"name":"CSAPP","slug":"CSAPP","permalink":"https://666wxy666.github.io/tags/CSAPP/"}]},{"title":"操作系统 内存管理","slug":"操作系统-内存管理","date":"2020-09-03T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/09/03/操作系统-内存管理/","link":"","permalink":"https://666wxy666.github.io/2020/09/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","excerpt":"本文是操作系统内存管理的基本实验。","text":"本文是操作系统内存管理的基本实验。 一、实验目的在本次实验中，需要从不同的侧面了解Windows 的虚拟内存机制。在Windows操作系统中，可以通过一些API 操纵虚拟内存。主要需要了解以下几方面： Windows 虚拟存储系统的组织 如何控制虚拟内存空间 如何编写内存追踪和显示工具 详细了解与内存相关的API 函数的使用 二、实验需求编写一个包含两个线程的进程，一个线程用于模拟内存分配活动，一个线程用于跟踪第一个线程的内存行为。模拟内存活动的线程可以从一个文件中读出要进行的内存操作，每个内存操作包含如下内容： 时间：开始执行的时间 块数：分配内存的粒度 操作：包括保留一个区域、提交一个区域、释放一个区域、回收一个区域以及锁与解锁一个区域；可以将这些操作编号，存放于文件中 大小：指块的大小 访问权限：共五种PAGE_READONLY、PAGE_READWRITE、PAGE_EXCUTE、PAGE_EXECUTE_READ 和PAGE_EXECUTE_READWRITE。可以将这些权限编号，存放于文件中。跟踪线程将页面大小、已使用的地址范围、物理内存总量以及虚拟内存总量等信息显示出来。 三、运行环境电脑硬件配置： 处理器：Intel i7 7700HQ 显卡：NVIDIA GeForce GTX 1050 Ti 内存：16GB 软件： 编程语言：C++ IDE：Microsoft Visual Studio 2019 Windows SDK版本：10.0 平台工具集：Visual Studio 2019（v142） 四、实验原理内存管理是Windows执行体的一部分，位于Ntoskrnl.exe 文件中，是整个操作系统的重要组成部分。物理内存是固定的，内存条的容量多大，物理内存就有多大。但是如果程序运行很多或者程序本身很大的话，就会导致大量的物理内存占用，甚至导致物理内存消耗殆尽。 虚拟内存就是在硬盘上划分一块页面文件，充当内存。当程序在运行时，有一部分资源还没有用上或者同时打开几个程序却只操作其中一个程序时，系统没必要将程序所有的资源都放在物理内存中。于是，系统将这些暂时不用的资源放在虚拟内存上，等到需要时在调出来用。这也是虚拟内存的优点：需要的时候才真正分配内存。 默认情况下，32位Windows上每个用户进程可以占有2GB的私有地址空间，操作系统占有剩下的2GB。Windows在x86体系结构上利用二级页表结构来实现虚拟地址向物理地址的变换。一个32位虚拟地址被解释为三个独立的分量——页目录索引、页表索引和字节索引——它们用于找出描述页面映射结构的索引。页面大小及页表项的宽度决定了页目录和页表索引的宽度。比如，在x86 系统中，因为一页包含4096字节，于是字节索引被确定为12位宽（2^12=4096）。 应用程序有三种使用内存方法： 以页为单位的虚拟内存分配方法，适合于大型对象或结构数组 内存映射文件方法，适合于大型数据流文件以及多个进程之间的数据共享 内存堆方法，适合于大量的小型内存申请 本次实验主要是针对第一种使用方式。应用程序通过API函数 VirtualAlloc和VirtualAllocEx等实现以页为单位的虚拟内存分配方法。首先保留地址空间，然后向此地址空间提交物理页面，也可以同时实现保留和提交。保留地址空间是为线程将来使用保留一块虚拟地址。在已保留的区域中，提交页面必须指出将物理存储器提交到何处以及提交多少。提交页面在访问时会转变为物理内存中的有效页面。 五、实验步骤1、编译运行makefile.cpp，生成opfile文件。opfile里记录了几个不同的内存操作，包括时间、块数、操作、大小、访问权限。生成了包括5个权限和6个操作任意组合共30个操作。 2、将生成的opfile复制到memory-op的工程目录下 3、编译运行memory-op.cpp，产生两个线程，一个从opfile文件里读取内存操作，模拟内存活动，另一个跟踪第一个的内存行为，将结果输出，并保存在out.txt文件中。 4、输出结果 六、相关的API 函数 点击查看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243//可以通过GetSystemInfo，GlobalMemoryStatus 和VirtualQuery 来查询进程虚空间的状态。主要的信息来源如下：VOID GetSystemInfo （ LPSYSTEM_INFO lpSystemInfo ）;//结构SYSTEMINFO 定义如下：typedef struct _SYSTEM_INFO &#123;DWORD dwOemld;DWORD dwPageSize;LPVOID lpMinimumApplicationAddress;LPVOID lpMaximumApplicationAddress;DWORD dwActiveProcessorMask;DWORD dwNumberOfProcessors;DWORD dwProcessorType;DWORD dwAllocationGranularity;DWORD dwReserved;&#125; SYSTEM_INFO, *LPSYSTEM_INFO;//函数VOID GlobalMemoryStatus （LPMEMORYSTATUS lpBuffer）;//数据结构MEMORYSTATUS 定义如下：typedef struct _ MEMORYSTATUS &#123;DWORD dwLength;DWORD dwMemoryLoad;DWORD dwTotalPhys;DWORD dwAvailPhys;DWORD dwTotalPageFile;DWORD dwAvailPageFile;DWORD dwTotalVirtual;DWORD dwAvailVirtual;&#125; MEMORYSTATUS, * LPMEMORYSTATUS;DWORD VirtualQuery （ LPCVOLD lpAddress,PMEMORY_BASIC_INFORMATION lpBuffer, DWORD dwLength）;//主要数据结构MEMORY_BASIC_INFORMATION 定义如下：typedef struct _ MEMORY_BASIC_INFORMATION &#123;PVOID BaseAddress;PVOID AllocationBase;DWORD AllocationProtect;DWORD RegionSize;DWORD State;DWORD Protect;DWORD Type;&#125; MEMORY_BASIC_INFORMATION;typedef MEMORY_BASIC_INFORMATION * PMEMORY_BASIC_INFORMATION;//还有一些函数，例如VirtualAlloc，VirtualAllocEx，VirtualFree 和VirtualFreeEx 等，用于虚拟内存的管理，详情请见Microsoft 的Win32 API Reference Manual。 七、项目地址本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看：","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://666wxy666.github.io/categories/C-C/"},{"name":"操作系统","slug":"C-C/操作系统","permalink":"https://666wxy666.github.io/categories/C-C/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"操作系统","slug":"操作系统","permalink":"https://666wxy666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统 读者写者(生产者消费者)","slug":"操作系统-读者写者(生产者消费者)","date":"2020-09-03T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/09/03/操作系统-读者写者(生产者消费者)/","link":"","permalink":"https://666wxy666.github.io/2020/09/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85(%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85)/","excerpt":"本文是操作系统进程同步互斥关于读者写者(生产者消费者)的基本实验。","text":"本文是操作系统进程同步互斥关于读者写者(生产者消费者)的基本实验。 一、需求本课程实验内容引自《Windows 内核实验教程》(陈向群、林斌等编著，机械工业出版社，2002.9)。 在Windows 环境下，创建一个包含n 个线程的控制进程。用这n 个线程来表示n个读者或写者。每个线程按相应测试数据文件的要求，进行读写操作。请用信号量机制分别实现读者优先和写者优先的读者-写者问题。 读者-写者问题的读写操作限制： 写-写互斥 读-写互斥 读-读允许 读者优先的附加限制：如果一个读者申请进行读操作时已有另一读者正在进行读操作，则该读者可直接开始读操作。 写者优先的附加限制：如果一个读者申请进行读操作时已有另一写者在等待访问共享资源，则该读者必须等到没有写者处于等待状态后才能开始读操作。 运行结果显示要求：要求在每个线程创建、发出读写操作申请、开始读写操作和结束读写操作时分别显示一行提示信息，以确信所有处理都遵守相应的读写操作限制。 二、运行环境电脑硬件配置： 处理器：Intel i7 7700HQ 显卡：NVIDIA GeForce GTX 1050 Ti 内存：16GB 软件： 编程语言：C++ IDE：Microsoft Visual Studio 2019 Windows SDK版本：10.0 平台工具集：Visual Studio 2019（v142） 三、核心算法读者优先： 点击查看代码 12345678910111213141516171819//信号量：mutex=1;//对read_count的互斥操作RP_Write=1;//保证读者优先，读者与写者互斥//读者：wait(mutex);read_count++;if(read_count==1) wait(&amp;RP_Write);signal(mutex);读临界区……wait(mutex);read_count--;if(read_count==0) signal(&amp;RP_Write);signal(mutex);//写者：wait(&amp;RP_Write);写临界区……signal(&amp;RP_Write); 写者优先： 点击查看代码 123456789101112131415161718192021222324252627282930313233343536//信号量：mutex1=1;//保证每个读者按顺序依次进入临界区mutex2=1;//对read_count的互斥操作mutex3=1;//对write_count的互斥操作cs_Read =1;//保证写者优先，读者与写者互斥cs_Write=1;//保证如果有读者正在读，写者等待当前读者读完后再写//读者：wait(mutex1);wait(&amp;cs_Read);wait(mutex2);read_count++;if(read_count==1) wait(&amp;cs_Write);signal(mutex2);signal(&amp;cs_Read);signal(mutex1);读临界区……wait(mutex2);read_count--;if(read_count==0) signal(&amp;cs_Write);signal(mutex2);//写者：wait(mutex3);write_count++;if(write_count==1) wait(&amp;cs_Read);signal(mutex3);wait(&amp;cs_Write);写临界区……signal(&amp;cs_Write);wait(mutex3);write_count--;if(write_count==0) signal(&amp;cs_Read);signal(mutex3); 输入： 屏幕输入： 1：选择读者优先，调用ReaderPriority(“thread.dat”)函数； 2：选择写者优先，调用WriterPriority(“thread.dat”)函数； 3：退出。 从thread.dat文件读入读者写者线程信息。输出：屏幕输出各读者写者线程信息。 五、测试样例： 输入1 可以看出，写者进程4、2、6虽然都请求了写操作，但是却是等待所有的读者1、3、5读完了再按顺序进行的写入操作，符合读者优先的要求。 输入2 可以看出，除了第一个读者进程1在读文件外，虽然读者3、5都请求了读操作，但由于写者进程4、2、6请求了写操作，因为写者优先，所以读者3、5都要等待写者4、2、6写入完成才能读，而写者4、2、6必须等待读者进程1读操作完成后才能写。读者1读操作完成后，写者4、2、6按顺序写入文件，写入完成后，读者3、5同时读文件，符合写者优先的要求。 输入3 释放线程，程序退出。 六、项目地址本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看：","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://666wxy666.github.io/categories/C-C/"},{"name":"操作系统","slug":"C-C/操作系统","permalink":"https://666wxy666.github.io/categories/C-C/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"操作系统","slug":"操作系统","permalink":"https://666wxy666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"进程","slug":"进程","permalink":"https://666wxy666.github.io/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"线程","slug":"线程","permalink":"https://666wxy666.github.io/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"同步互斥","slug":"同步互斥","permalink":"https://666wxy666.github.io/tags/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/"},{"name":"读者写者","slug":"读者写者","permalink":"https://666wxy666.github.io/tags/%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85/"},{"name":"生产者消费者","slug":"生产者消费者","permalink":"https://666wxy666.github.io/tags/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/"}]},{"title":"操作系统 进程线程管理通信与同步互斥","slug":"操作系统-进程线程管理通信与同步互斥","date":"2020-09-03T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/09/03/操作系统-进程线程管理通信与同步互斥/","link":"","permalink":"https://666wxy666.github.io/2020/09/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86%E9%80%9A%E4%BF%A1%E4%B8%8E%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/","excerpt":"本文是操作系统课程设计关于进程线程管理通信与同步互斥的综合实验（长文警告）。","text":"本文是操作系统课程设计关于进程线程管理通信与同步互斥的综合实验（长文警告）。 一、实验目的 以OpenEuler等Linux操作系统为实验对象，加深对Linux进程、线程概念的理解，掌握利用Linux系统调用创建、管理进程的方法，掌握利用POSIX线程（Pthread）库创建管理线程的方法，认识进程、线程并发执行的实质； 深入理解Linux内核提供的消息队列、共享内存、管道、软中断四种进程间通信机制，掌握利用系统调用实现进程间通信； 了解Pthread线程库提供的线程间通信机制，掌握使用Pthread API实现线程间通信的方法； 深入理解Linux系统提供的多种进程同步互斥机制，掌握使用信号量实现进程间的同步互斥的方法； 了解Pthread提供的线程同步互斥机制，掌握使用互斥变量和条件变量实现多线程间的同步互斥的方法 二、实验环境硬件： Intel i7 7700HQ，内存16GB 软件： 虚拟机：VMware Workstation Pro 15.5.6 Linux系统：华为openEuler-20.03-LTS-x86_64 Pthread线程库，POSIX接口 gcc编译 C语言 三、实验内容在Linux环境下，采用C/C++/Java（或其它语言）编程，完成以下实验内容。 1、第一组 进程的创建与管理 阅读Linux内核源码，分析Linux进程的组成，观察进PCB/task_struc等进程管理数据结构； 利用Linux内核提供的fork()、exec()、wait()等系统调用，创建管理多个进程，观察父子进程的结构和并发行为，掌握睡眠、撤销等进程控制方法； 掌握ps、top、pstree –h、vmstat、strace、ltrace、sleep x、kill、jobs等命令的功能和使用方式； 2、第二组 线程的创建与管理 了解POSIX 线程标准库（Pthread线程库）定义的线程结构和提供的线程管理API； 利用Pthread线程库API，创建管理多个线程，观察线程的结构和并发执行行为； 3、第三/四组 进程/线程通信 了解Linux提供的消息队列、共享内存、管道、软中断Signal等四种通信机制，编程实现进程间通信； 线程通信 了解Linux所支持的线程机制，在一个进程内创建多个主从线程，采用参数传递机制，实现线程间通信； 4、第五组 进程/线程同步互斥要求：参照2019-2020学年操作系统期末考试信号量题目，设计实现三个进程/线程A、B、C，分别模拟题目所描述的生产产品A、B、C的三个worker，观察并记录进程/线程的创建和同步互斥行为。重点分析信号量设计方案是否合理、符合预期，避免设计方案导致死锁或不符合题目要求。 期末考试试题如下： An assembly line is to produce a product C with four part As, and three part Bs. The worker of machining(加工) A and worker of machining B will produce two part As and one part B independently each time. Then the two part As or one part B will be moved to the station(工作台), which can hold at most 12 of part As and part Bs altogether. Two part As must be put onto the station simultaneously. The workers must exclusively put a part on the station or get it from the station. In addition, the worker to make C must get all part of As and Bs for one product once. Using semaphores to coordinate the three workers who are machining part A, part B and the product C to manufacture the product without deadlock. It is required that (1) definition and initial value of each semaphore, and (2) the algorithm to coordinate the production process for the three workers should be given. 进程同步互斥 创建3个Linux进程，分别模拟生产产品A、B、C的三个worker的行为，利用Linux内核信号量，实现三者间正确的同步互斥； 线程同步互斥 利用Pthread API，创建3个Linux线程，分别模拟生产产品A、B、C的三个worker的行为，采用Pthread提供的信号量/管程机制，现三者间正确的同步互斥； 四、实验步骤0、实验环境配置0-1. Linux 操作系统安装 选择OpenEuler等Linux发行版本，观察所采用的内核版本，采用硬盘分区模式安装Linux系统； 也可以先在本机操作系统上安装VitualBox、VMware、Virtual PC等虚拟机软件，在虚拟机之上安装Linux系统。 注意安装操作系统所需的软硬件环境和硬件配置要求。 0-2. Pthread 线程库安装观察确认所安装的Linux发行版本带有Pthread线程库，注意： 某些版本Ubuntu Linux默认不带Pthread线程库，即使在编译的度时候 加上-lpthread也不行，man不到相关Pthread函知数。此时，需要在/usr/lib/…下导入动态库libpthread.a，具体方法可以查阅网上相关资料。 后续编程时导入头文件：#include &lt;pthread.h&gt; 因为我电脑早已经安装了VMware虚拟机，就不重新安装了，直接下载安装OpenEuler。 1、下载OpenEuler 进入OpenEuler下载页面，下载openEuler-20.03-LTS-x86_64-dvd.iso镜像。 等待下载完成。 2、创建虚拟机 打开VMware Workstation Pro，选择“创建新的虚拟机”。 选择“自定义”。 设置虚拟机的硬件兼容性限制，按照默认选择。 选择下载好的openEuler-20.03-LTS-x86_64-dvd.iso镜像。 选择Linux 操作系统。 配置虚拟机的名称，位置，处理器，内存，网络连接、控制器、磁盘等。 创建完成。 3、安装OpenEuler 启动虚拟机。 选择第一项安装OpenEuler。 等待check完毕。 选择安装过程中所使用的语言。 选择分区和软件模块，点击“开始安装”后，开始安装系统，在安装期间可以设置Root密码以及创建用户。 安装完成。 重启后登录OpenEuler系统。 创建的wxy用户以及root用户均可以成功登录，安装OpenEuler完成。 1、第一组 进程的创建与管理实验1-1. 进程观察查阅相关资料，阅读Linux内核源码，分析Linux进程的组成，了解进程状态，观察进PCB/task_struc等进程管理数据结构； 实验1-2. 进程创建与管理参照**“【实验指导】1. 进程创建及管理示例”**中的程序，结合所查阅的参考资料，利用Linux内核提供的fork()、exec()、wait()、exit()、kill()等系统调用，创建管理多个进程，观察父子进程的结构和并发行为，掌握睡眠、撤销等进程控制方法； 要求：本组实验至少用到fork()、exec()、wait()、exit()、kill()、getpid()五个系统调用。 1-2-1 fork() 点击查看代码 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char **argv)&#123; __pid_t pid; if ((pid = fork()) &gt; 0) &#123; printf(&quot;I am the parent process.\\n&quot;); /*父进程处理过程*/ &#125; else if (pid == 0) &#123; printf(&quot;I am the child process.\\n&quot;); /*子进程处理过程*/ &#125; else &#123; printf(&quot;fork error\\n&quot;); exit(0); &#125;&#125; fork的返回值如果是&gt;0，那么就是父进程，这个&gt;0的返回值就是创建的子进程的PID； fork的返回值如果是=0，那么就是子进程； fork的返回值如果是&lt;0，那么就是fork失败； 1-2-2 exec() 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char **argv)&#123; char *envp[] = &#123;&quot;PATH=/tmp&quot;, &quot;USER = 1ei&quot;, &quot;STATUS = testing&quot;, NULL&#125;; char *argv_execv[] = &#123;&quot;echo&quot;, &quot;excuted by execv&quot;, NULL&#125;; char *argv_execvp[] = &#123;&quot;echo&quot;, &quot;excuted by execvp&quot;, NULL&#125;; char *argv_execve[] = &#123;&quot;env&quot;, NULL&#125;; if (fork() == 0) &#123; if (execl(&quot;/bin/echo&quot;, &quot;echo&quot;, &quot;executed by execl&quot;, NULL) &lt; 0) perror(&quot;Err on execl&quot;); &#125; if (fork() == 0) &#123; if (execlp(&quot;echo&quot;, &quot;echo&quot;, &quot;executed by execlp&quot;, NULL) &lt; 0) perror(&quot;Err on execlp&quot;); &#125; if (fork() == 0) &#123; if (execle(&quot;/usr/bin/env&quot;, &quot;env&quot;, NULL, envp) &lt; 0) perror(&quot;Err on execle&quot;); &#125; if (fork() == 0) &#123; if (execv(&quot;/bin/echo&quot;, argv_execv) &lt; 0) perror(&quot;Err on execv&quot;); &#125; if (fork() == 0) &#123; if (execvp(&quot;echo&quot;, argv_execvp) &lt; 0) perror(&quot;Err on execvp&quot;); &#125; if (fork() == 0) &#123; if (execve(&quot;/usr/bin/env&quot;, argv_execve, envp) &lt; 0) perror(&quot;Err on execve&quot;); &#125;&#125; exec用一个指定的程序文件,重新初始化一个进程。 可指定新的命令行参数和环境参数(初始化堆栈底部)。 exec不创建新进程,只是将当前进程重新初始化了指令段和用户数据段,堆栈段以及CPU的PC指针。 6种格式exec系统调用，exec前缀,后跟以下字母： l—list，v—vector l与v:指定命令行参数的两种方式，l以表的形式，v要事先组织成一个指针数组。 e—env 需要指定envp来初始化进程。 p—path 使用环境变量PATH查找可执行文件。 1-2-3 wait() 点击查看代码 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char **argv)&#123; __pid_t pid; if ((pid = fork()) &gt; 0) &#123; int status, wait_pid; printf(&quot;I am the parent process.\\n&quot;); wait_pid = wait(&amp;status); printf(&quot;pid=%d,wait_pid=%d\\n&quot;, pid, wait_pid); printf(&quot;status=%#X,WTERMSIG=%d,WEXITSTATUS=%d\\n&quot;, status, WTERMSIG(status), WEXITSTATUS(status)); /*父进程处理过程*/ &#125; else if (pid == 0) &#123; int i; for (i = 0; i &lt; 3; i++) &#123; printf(&quot;I am the child process.\\n&quot;); sleep(1); &#125; /*子进程处理过程*/ exit(5); &#125; else &#123; printf(&quot;fork error\\n&quot;); exit(0); &#125;&#125; 函数返回值为已终止的子进程PID。 status中含有子进程终止的原因。 TERMSIG(status)为被杀信号。 EXITSTATUS(status)为退出码。 子进程正常退出，且退出码为5，因此wait的status退出码刚好是5。 1-2-4 kill() 点击查看代码 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char **argv)&#123; __pid_t pid; if ((pid = fork()) &gt; 0) &#123; int status; printf(&quot;I am the parent process.\\n&quot;); sleep(3); kill(pid, 5); wait(&amp;status); printf(&quot;%#X,%d,%d\\n&quot;, status, WTERMSIG(status), WEXITSTATUS(status)); /*父进程处理过程*/ &#125; else if (pid == 0) &#123; while (1) &#123; printf(&quot;I am the child process.\\n&quot;); sleep(1); &#125; /*子进程处理过程*/ exit(0); &#125; else &#123; printf(&quot;fork error\\n&quot;); exit(0); &#125;&#125; 可以发现子进程被父进程杀掉了，且终止码为5，刚好wait的终止码也是5。 1-2-5 getpid() 点击查看代码 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char **argv)&#123; __pid_t pid; if ((pid = fork()) &gt; 0) &#123; printf(&quot;I am the parent process.\\tpid=%d,child_pid=%d\\n&quot;, getpid(), pid); /*父进程处理过程*/ &#125; else if (pid == 0) &#123; printf(&quot;I am the child process.\\t\\tpid=%d,ppid=%d\\n&quot;, getpid(), getppid()); /*子进程处理过程*/ exit(0); &#125; else &#123; printf(&quot;fork error\\n&quot;); exit(0); &#125;&#125; 可以发现，父进程打印的子进程pid和子进程的pid相等，子进程打印的父进程的pid也和父进程的pid相等。 实验1-3. 进程管理命令了解ps、top、pstree –h、vmstat、strace、ltrace、sleep x、kill、jobs等命令的功能，使用这些命令观察进程结构和行为； 1-3-1 ps查看正在运行的进程。 1-3-2 toptop查看进程相关信息。 1-3-3 pstree –hpstree查看进程树。 1-3-4 vmstatvmstat可以查看系统相关信息。 1-3-5 strace先运行这个程序（ltrace、kill、jobs也是一样）： 点击查看代码 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char **argv)&#123; __pid_t pid; if ((pid = fork()) &gt; 0) &#123; while (1) &#123; printf(&quot;I am the parent process.\\tpid=%d,child_pid=%d\\n&quot;, getpid(), pid); sleep(3); &#125; /*父进程处理过程*/ &#125; else if (pid == 0) &#123; while (1) &#123; printf(&quot;I am the child process.\\t\\tpid=%d,ppid=%d\\n&quot;, getpid(), getppid()); sleep(3); &#125; /*子进程处理过程*/ exit(0); &#125; else &#123; printf(&quot;fork error\\n&quot;); exit(0); &#125;&#125; 屏幕输出： strace就相当于是调试信息： 1-3-6 ltraceltrace也是同理。 1-3-7 sleep x睡眠了3s后继续输出。 1-3-8 kill 运行kill后只有父进程输出，子进程被杀掉了。 1-3-9 jobs jobs查看已挂载的程序,不用携带任何参数，这里查看了正在后台运行的1-2-5程序。 2、第二组 线程的创建与管理实验2-1. Pthread线程库背景知识了解POSIX 线程标准库（Pthread线程库）相关知识，分析Pthread线程结构，掌握所提供的线程管理API，如pthread_create(), pthread_join(), pthread_self(), pthread_detach(), pthread_exit()； 实验2-2. 线程创建与管理参照**“【实验指导】 2. 线程创建及管理程序示例”**，查阅参考资料，利用Pthread API，创建和管理线程，观察线程的结构和并发执行行为； 要求：本组实验至少用到pthread_create(), pthread_exit(),pthread_join(), pthread_self()等四个API。 2-2-1 pthread_create()函数原型： 12#include&lt;pthread.h&gt;int pthread_create(pthread_t *thread，pthread_attr_t*attr，void*(*start_routine)(void *), void *arg) 函数说明：创建线程。 参数和返回值： 参数 说明 thread 该参数是指向线程标识符的指针，当线程创建成功时，用来返回创建的线程ID attr 该参数用于指定线程的属性，NULL表示使用默认属性 start_routine 该参数为一个函数指针，指向线程创建后要调用的函数，是一个以指向void的指针作为参数和返回值的函数指针，这个被线程调用的函数也被称为线程函数 arg 指向传递给线程函数的参数，NULL代表不传参数 返回值 成功：0出错：返回错误码 点击查看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;void *mythread1(void *arg)&#123; int i; for (i = 0; i &lt; 5; i++) &#123; printf(&quot;I am thread 1\\n&quot;); sleep(2); &#125;&#125;void *mythread2(void *arg)&#123; int i; for (i = 0; i &lt; 5; i++) &#123; printf(&quot;I am thread 2\\n&quot;); sleep(2); &#125;&#125;int main(int argc, char const *argv[])&#123; pthread_t id1, id2; int res; res = pthread_create(&amp;id1, NULL, mythread1, NULL); if (res) &#123; printf(&quot;Create pthread error!\\n&quot;); return -1; &#125; res = pthread_create(&amp;id2, NULL, mythread2, NULL); if (res) &#123; printf(&quot;Create pthread error!\\n&quot;); return -2; &#125; pthread_join(id1, NULL); pthread_join(id2, NULL); return 0;&#125; 可以发现，创建了两个线程：thread1和thread2。两个线程分别打印自己的信息，等带2s后继续打印。 2-2-2 pthread_exit()函数原型： 12#include&lt;pthread.h&gt;void pthread_exit(void *retval) 函数说明：线程退出。 参数和返回值： 参数 说明 Rretval 线程结束时的返回值,可由其它函数如pthread_join0来获取 返回值 void 点击查看代码 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;void *create(void *arg)&#123; printf(&quot;New thread is create...\\n&quot;); pthread_exit((void *)6);&#125;int main(int argc, char const *argv[])&#123; pthread_t tid; int res; void *temp; res = pthread_create(&amp;tid, NULL, create, NULL); printf(&quot;I am the main thread!\\n&quot;); if (res) &#123; printf(&quot;thread id not create...\\n&quot;); return -1; &#125; res = pthread_join(tid, &amp;temp); if (res) &#123; printf(&quot;thread is not exit...\\n&quot;); return -2; &#125; printf(&quot;Thread is exit code %ld \\n&quot;, (long)temp); return 0;&#125; 可以发现，子线程退出，主线程接收到了子线程的退出码6。 2-2-3 pthread_join()函数原型： 12#include&lt;pthread.h&gt;int pthread_join(pthread_t thread，void **thread_return) 函数说明：线程等待。 参数和返回值： 参数 说明 thread 等待退出的线程ID thread_return 用于定义的指针，用来存储被等待线程结束时的返回值(不为NULL时) 返回值 成功：0出错：返回错误码 点击查看代码 1234567891011121314151617181920212223242526272829#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;void *thread(void *str)&#123; int i; for (i = 0; i &lt; 4; ++i) &#123; sleep(2); printf(&quot;This is the thread:%d\\n&quot;, i); &#125; return NULL;&#125;int main(int argc, char const *argv[])&#123; pthread_t pth; long i; int ret = pthread_create(&amp;pth, NULL, thread, (void *)(i)); pthread_join(pth, NULL); printf(&quot;123\\n&quot;); for (i = 0; i &lt; 3; ++i) &#123; sleep(1); printf(&quot;This is the main:%ld\\n&quot;, i); &#125; return 0;&#125; 可以发现主线程在调用pthread_join后等待子线程输出完毕结束后再进行的输出，相当于是主线程被阻塞。 2-2-4 pthread_self()函数原型： 12#include&lt;pthread.h&gt;Pthread_t pthread_self(void) 函数说明：获取调用线程的标识ID。 参数和返回值： 参数 说明 void 无 返回值 返回调用该函数的线程的标识ID 点击查看代码 123456789101112131415161718192021222324252627#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;void *create(void *arg)&#123; printf(&quot;New thread...\\n&quot;); printf(&quot;This thread&#x27;s id is %u \\n&quot;, (unsigned int)pthread_self()); printf(&quot;This thread process pid is %d\\n&quot;, getpid()); return NULL;&#125;int main(int argc, char const *argv[])&#123; pthread_t tid; int res; printf(&quot;Main thread is starting...\\n&quot;); res = pthread_create(&amp;tid, NULL, create, NULL); if (res) &#123; printf(&quot;thread id not create...\\n&quot;); return -1; &#125; printf(&quot;The main process pid is %d\\n&quot;, getpid()); sleep(1); return 0;&#125; 可以发现，子线程成功打印了自己的线程id，并且子线程的进程pid和主线程的进场pid相等，这也说明这两个线程属于同一个进程。 2-2-5 pthread_cleanup_push()，pthread_cleanup_pop()1、函数原型： 12#include&lt;pthread.h&gt;void pthread_cleanup_push(void (*rtn)(void *), void *arg) 函数说明：将清除函数压入清除栈 参数和返回值： 参数 说明 rtn 清除函数 arg 清除函数的参数 返回值 void 2、函数原型： 12#include&lt;pthread.h&gt;void pthread_cleanup_pop(int execute) 函数说明：将清除函数弹出清除栈 参数和返回值： 参数 说明 execute 执行到pthread_cleanup_pop()时是否在弹出清理函数的同时执行该函数。非0：执行；0：不执行 返回值 void 点击查看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;void *clean(void *arg)&#123; printf(&quot;Cleanup %s\\n&quot;, (char *)arg); return (void *)0;&#125;void *thr_fn1(void *arg)&#123; printf(&quot;Thread1 start\\n&quot;); pthread_cleanup_push((void *)clean, &quot;Thread1 first handler&quot;); pthread_cleanup_push((void *)clean, &quot;Thread1 second handler&quot;); printf(&quot;Thread1 push complete\\n&quot;); if (arg) &#123; return ((void *)1); &#125; pthread_cleanup_pop(1); pthread_cleanup_pop(1); return (void *)2;&#125;void *thr_fn2(void *arg)&#123; printf(&quot;Thread2 start\\n&quot;); pthread_cleanup_push((void *)clean, &quot;Thread2 first handler&quot;); pthread_cleanup_push((void *)clean, &quot;Thread2 second handler&quot;); printf(&quot;Thread2 push complete\\n&quot;); if (arg) &#123; return ((void *)3); &#125; pthread_cleanup_pop(0); pthread_cleanup_pop(1); return (void *)4;&#125;int main(int argc, char const *argv[])&#123; int res; pthread_t tid1, tid2; void *tret; res = pthread_create(&amp;tid1, NULL, thr_fn1, (void *)1); if (res != 0) &#123; printf(&quot;Create theate error...\\n&quot;); return -1; &#125; res = pthread_create(&amp;tid2, NULL, thr_fn2, (void *)0); if (res != 0) &#123; printf(&quot;Create theate error...\\n&quot;); return -1; &#125; res = pthread_join(tid1, &amp;tret); if (res != 0) &#123; printf(&quot;Thread_join error...\\n&quot;); return -1; &#125; printf(&quot;Thread1 exit code %ld\\n&quot;, (long)tret); res = pthread_join(tid2, &amp;tret); if (res != 0) &#123; printf(&quot;Thread_join error...\\n&quot;); return -1; &#125; printf(&quot;Thread2 exit code %ld\\n&quot;, (long)tret); return 0;&#125; 对于Thread1，传入的参数是1，因此函数thr_fn1只执行了两个pthread_cleanup_push，在pthread_cleanup_pop之前就return 1了，因此Thread1没有Cleanup输出，且返回码是1。 对于Thread2，传入的参数是0，因此函数thr_fn2在执行了两个pthread_cleanup_push后又执行了两个pthread_cleanup_pop，但是第一个pthread_cleanup_pop传的参数是0，第二个pthread_cleanup_pop传的参数是1，而且这个是栈的结构，第一个出栈的“Thread2 second handler”，参数为0，不清理；第二个出栈的“Thread2 first handler”，参数为1，清理。因此Thread2只有一个Cleanup输出（Thread2 first handler），且返回码是4。 2-2-6 综合 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#define THREAD_NUMBER 3 //线程数#define REPEAT_NUMBER 5 //每个线程中的小任务数#define DELAY_TIME_LEVELS 10.0 //小任务之间的最大时间间隔void *thrd_func(void *arg)&#123; long thrd_num = (long)arg; int delay_time = 0; int count = 0; printf(&quot;Thread %ld is starting\\n&quot;, thrd_num); for (count = 0; count &lt; REPEAT_NUMBER; count++) &#123; delay_time = (int)(rand() * DELAY_TIME_LEVELS / (RAND_MAX)) + 1; sleep(delay_time); printf(&quot;\\tThread %ld:job %d delay=%d\\n&quot;, thrd_num, count, delay_time); &#125; printf(&quot;Thread %ld finished\\n&quot;, thrd_num); pthread_exit(NULL);&#125;int main(int argc, char const *argv[])&#123; pthread_t thread[THREAD_NUMBER]; long no, res; void *thrd_ret; srand(time(NULL)); for (no = 0; no &lt; THREAD_NUMBER; no++) &#123; res = pthread_create(&amp;thread[no], NULL, thrd_func, (void *)no); if (res != 0) &#123; printf(&quot;Create thread %d failed\\n&quot;, no); exit(res); &#125; &#125; printf(&quot;Creating threads success\\nWaiting for thread to finish...\\n&quot;); for (no = 0; no &lt; THREAD_NUMBER; no++) &#123; res = pthread_join(thread[no], &amp;thrd_ret); if (!res) &#123; printf(&quot;Thread %d joined\\n&quot;, no); &#125; else &#123; printf(&quot;Thread %d joined failed\\n&quot;, no); &#125; &#125; return 0;&#125; 这个综合案例就是创建了3个线程，让3个线程共用同一个执行函数。每个线程都有5次循环（可以看成5个小任务，也就是5个job），每次循环之间会随机等待1～10s的时间，意义在于模拟每个任务的到达时间是随机的，并没有任何特定的规律。最后就是三个线程相继完成了各自的任务，都成功join，最后主线程结束。 3、第三组 进程间通信了解Linux提供的消息队列（消息传递）、共享内存、管道/命名管道、信号(signal)/软中断四种进程间通信机制的实现原理和方法； 消息队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。具有一定权限的进程通过向消息队列中写入组织成消息的数据、从队列中读取数据，实现相互间通信。消息队列克服了信号signal承载信息量少，管道pipe只能承载无格式字节流以及缓冲区大小受限等缺点； 共享内存：多个进程通过访问同一块内存空间，实现快速的进程间通信是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥； 管道（Pipe）及命名管道（named pipe）：用于具有亲缘关系进程间的通信，命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还支持无亲缘关系进程间的通信； 信号（Signal：也称为软中断，是一种基于事件的通信机制，用于通知接受进程有某种事件发生。除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction； 参照**“【实验指导】 6.3 进程间通信示例”**，查阅参考资料，选择上述四种通信方式中的一种，编程实现进程间通信，观察进程间通信过程。 我选择的是消息队列（消息传递）方式。 消息结构体： 12345struct my_message&#123; long int message_type; /* The data you wish to transfer*/&#125;; 相关函数： 函数原型 说明 int msgget(key_t key, int msgflg); 创建和访问一个消息队列 int msgsend(int msgid, const void *msg_ptr, size_t msg_sz, int msgflg); 将消息添加到消息队列，即消息发送 int msgrcv(int msgid, void *msg_ptr, size_t msg_st, long int msgtype, int msgflg); 从一个消息队列获取消息，即消息接收 int msgctl(int msgid, int command, struct msgid_ds *buf); 控制消息队列 代码： 信息发送方：msgsend.c 点击查看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;sys/msg.h&gt;#include &lt;errno.h&gt;#define MAX_TEXT 512struct msg_st&#123; long int msg_type; char text[MAX_TEXT];&#125;;int main()&#123; int running = 1; struct msg_st data; char buffer[BUFSIZ]; int msgid = -1; //建立消息队列 msgid = msgget((key_t)1234, 0666 | IPC_CREAT); if (msgid == -1) &#123; fprintf(stderr, &quot;msgget failed with error: %d\\n&quot;, errno); exit(EXIT_FAILURE); &#125; //向消息队列中写消息，直到写入end while (running) &#123; //输入数据 printf(&quot;Enter some text: &quot;); fgets(buffer, BUFSIZ, stdin); data.msg_type = 1; //注意2 strcpy(data.text, buffer); //向队列发送数据 if (msgsnd(msgid, (void *)&amp;data, MAX_TEXT, 0) == -1) &#123; fprintf(stderr, &quot;msgsnd failed\\n&quot;); exit(EXIT_FAILURE); &#125; //输入end结束输入 if (strncmp(buffer, &quot;end&quot;, 3) == 0) running = 0; sleep(1); &#125; exit(EXIT_SUCCESS);&#125; 消息接受方：msgreceive.c 点击查看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;sys/msg.h&gt;struct msg_st&#123; long int msg_type; char text[BUFSIZ];&#125;;int main()&#123; int running = 1; int msgid = -1; struct msg_st data; long int msgtype = 0; //注意1 //建立消息队列 msgid = msgget((key_t)1234, 0666 | IPC_CREAT); if (msgid == -1) &#123; fprintf(stderr, &quot;msgget failed with error: %d\\n&quot;, errno); exit(EXIT_FAILURE); &#125; //从队列中获取消息，直到遇到end消息为止 while (running) &#123; if (msgrcv(msgid, (void *)&amp;data, BUFSIZ, msgtype, 0) == -1) &#123; fprintf(stderr, &quot;msgrcv failed with errno: %d\\n&quot;, errno); exit(EXIT_FAILURE); &#125; printf(&quot;You wrote: %s\\n&quot;, data.text); //遇到end结束 if (strncmp(data.text, &quot;end&quot;, 3) == 0) running = 0; &#125; //删除消息队列 if (msgctl(msgid, IPC_RMID, 0) == -1) &#123; fprintf(stderr, &quot;msgctl(IPC_RMID) failed\\n&quot;); exit(EXIT_FAILURE); &#125; exit(EXIT_SUCCESS);&#125; 在第一个终端中编译运行msgsend.c： 新开一个终端编译运行msgreceive.c： 在第一个终端的发送进程中输入，能在第二个终端的接收进程中显示： 在发送进程中输入end，接收进程接收到了end信号，就会删除消息队列，退出进程；发送进程也会在退出。 在同一个终端，发送进程后台运行也是同样的道理。但是如果开两个接收进程，一个发送进程，那么就会出现接收进程争抢使用消息队列的情况，并且每个消息只会被使用一次，不会出现被重复消费的情况。因此最后的end消息因为只会被一个接收方拿到，且将消息队列删除，发送方和接收方1正常退出，但是导致另一个接收方2找不到消息队列，出错退出。 msgsend： msgreceive1： msgreceive2： 4、第四组 线程间通信了解Linux中的线程概念、线程通信机制、线程间同步互斥模式，以及多线程编程方式； 参照*“【实验指导】 6.2.7 Linux c/c++线程间参数传递”**中的【示例2-3-3】～【示例2-3-5】***，编程实现线程间参数传递。 示例2-3-3 向新建的线程传递字符串代码： 点击查看代码 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;void *create(void *arg)&#123; char *str; str = (char *)arg; printf(&quot;The parameter passed from main is %s\\n&quot;, str); return (void *)0;&#125;int main()&#123; int error; pthread_t id1; char *str1 = &quot;Hello!&quot;; char *attr = str1; error = pthread_create(&amp;id1, NULL, create, (void *)attr); if (error != 0) &#123; printf(&quot;This pthread is not created!\\n&quot;); return -1; &#125; sleep(1); printf(&quot;pthread is created..\\n&quot;); return 0;&#125; 运行结果： 可以发现Hello字符串已经传到了子线程，并在子线程打印输出。 示例2-3-4 向新建的线程传递字符串代码： 点击查看代码 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;struct member&#123; int a; char *s;&#125;;void *create(void *arg)&#123; struct member *temp; temp = (struct member *)arg; printf(&quot;member-&gt;a = %d\\n&quot;, temp-&gt;a); printf(&quot;member-&gt;s = %s\\n&quot;, temp-&gt;s); return (void *)0;&#125;int main(int argc, char const *argv[])&#123; int error; pthread_t id1; struct member *p; p = (struct member *)malloc(sizeof(struct member)); p-&gt;a = 1; p-&gt;s = &quot;Robben!&quot;; error = pthread_create(&amp;id1, NULL, create, (void *)p); if (error) &#123; printf(&quot;pthread is not created!\\n&quot;); return -1; &#125; sleep(1); printf(&quot;pthread is created!\\n&quot;); free(p); p = NULL; return 0;&#125; 运行结果： 可以发现，结构体member传递到了子线程中，member中的int型a和char*型s，在子线程中被输出。 示例2-3-5 验证新建立的线程可以共享进程中的数据代码： 点击查看代码 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;static int a = 5;void *create(void *arg)&#123; printf(&quot;New pthread...\\n&quot;); printf(&quot;a = %d\\n&quot;, a); a = -1; return (void *)0;&#125;int main(int argc, const char *argv[])&#123; int error; pthread_t id1; a = 10; error = pthread_create(&amp;id1, NULL, create, NULL); if (error != 0) &#123; printf(&quot;new thread is not created!\\n&quot;); return -1; &#125; sleep(1); printf(&quot;a = %d\\n&quot;, a); printf(&quot;New thread is created...\\n&quot;); return 0;&#125; 运行结果： 可以发现，定义了一个静态变量a=5，在主线程创建子线程之前a被赋值为10，然后主线程创建子线程，子线程读取a，读取到的是重新赋值后的a（10）,因此子线程中输出a = 10。然后子线程中将a修改为-1，因为主线程等待（sleep）了1s，因此主线程拿到的a是子线程修改后的a（-1），因此主线程中输出a = -1。这也证明了新建立的线程可以共享进程中的数据，同一进程中的主线程和子线程可以共享进程中的静态数据。 5、第五组 进程/线程间同步与互斥（二选一） 针对2019-2020学年操作系统期末考试信号量题目，定义合理的锁和信号量，设计生产产品A、B、C的三个worker三个进程/线程A、B、C的业务流程和同步互斥机制。 要求：给出具体的设计方案，并单独提交设计方案，类似期末考试答题形式； 参照**“【实验指导】 6.5 进程间同步互斥示例”**，根据上一步的设计方案，利用semget、semctl、semop等信号量原语，以进程方式编程实现该设计方案； 观察分析程序运行结果，重点分析信号量设计方案是否合理、程序运行是否符合预期，应避免设计方案导致死锁或不符合题目要求。 参照**“【实验指导】 6.6 线程间同步互斥示例”**，根据第一步的设计方案，利用Pthread提供的pthread_mutex_init()、pthread_mutex_lock()、pthread_mutex_unlock()等线程同步互斥API，以线程方式编程实现该设计方案； 观察分析程序运行结果。重点分析信号量设计方案是否合理、程序运行是否符合预期，应避免设计方案导致死锁或不符合题目要求。 要求： 基于进程和基于线程的同步互斥实现方案二选一，完成其中一个即可； 不论采用进程方式、还是线程方式，模拟A、B、C三个worker的三个进程/线程A、B、C应当多次循环反复执行，便于观察同步互斥效应； 根据设计方案，给出程序代码，程序运行结果，结果分析。 我选择的是基于进程的同步互斥实现方案。 1、设计方案方案1（采用二元互斥信号量+整形变量，效率比方案2高）：整型变量123int count_A=0; // 当前工作台中已有的A的数量int count_B=0; // 当前工作台中已有的B的数量int empty=12; // 工作台中空位数量，empty=12-(count_A+count_B) 信号量经分析题目，发现共需要4个信号量，分别为： 1234semaphore MUTEX_STATION = 0 // 二元信号量，控制对工作台和count_A、count_B、empty的互斥访问（取/放零件）semaphore SUSPEND_A = 1 // 控制台无足够空位时，挂起worker Asemaphore SUSPEND_B = 2 // 控制台无足够空位时，挂起worker Bsemaphore SUSPEND_C = 3 // 控制台无足够零件时，挂起worker C WorkerA 点击查看代码 1234567891011121314151617181920212223WorkerA()&#123; while (1) &#123; // 生产2个A P(MUTEX_STATION, -1); // 申请对count_A、empty和控制台的访问权 if (count_A &lt;= 7 &amp;&amp; empty &gt;= 2) &#123; // 同时放入工作台2个A count_A += 2; //修改count_A empty -= 2; //修改empty V(MUTEX_STATION, 1); //释放对控制台、count_A和empty的访问权 V(SUSPEND_C, 1); //控制台放入新零件，解挂/唤醒worker C &#125; else &#123; V(sem_id, MUTEX_STATION, 1); //释放对控制台和count_A、empty的访问权 P(sem_id, SUSPEND_A, -1); //控制台无足够空位，或不允许再放入A，转入waiting态，挂起自身 &#125; &#125;&#125; WorkerB 点击查看代码 1234567891011121314151617181920212223WorkerB()&#123; while (1) &#123; // 生产1个B P(MUTEX_STATION, -1); // 申请对count_B、empty和控制台的访问权 if (count_B &lt;= 7 &amp;&amp; empty &gt;= 1) &#123; // 放入工作台1个B count_B += 1; //修改count_B empty -= 1; //修改empty V(MUTEX_STATION, 1); //释放对控制台、count_B和empty的访问权 V(SUSPEND_C, 1); //控制台放入新零件，解挂/唤醒worker C &#125; else &#123; V(MUTEX_STATION, 1); //释放对控制台和count_B、empty的访问权 P(SUSPEND_B, -1); //控制台无足够空位，或不允许再放入B，转入waiting态，挂起自身 &#125; &#125;&#125; WorkerC 点击查看代码 123456789101112131415161718192021222324252627WorkerC()&#123; while (1) &#123; P(MUTEX_STATION, -1); // 申请对count_A、count_B和控制台的访问权 // 有足够多的A、B用于装配 if (count_A &gt;= 4 &amp;&amp; count_B &gt;= 3) &#123; // 同时从工作台取出4个A、3个B count_A -= 4; //修改count_A count_B -= 3; //修改count_B empty += 7; //修改empty V(MUTEX_STATION, 1); //释放对控制台、count_A、count_B的控制权 V(SUSPEND_A, 1); //控制台新增空位，解挂A V(SUSPEND_B, 1); //控制台新增空位，解挂B // 生产1个C &#125; else &#123; V(MUTEX_STATION, 1); //释放对控制台、count_A、count_B的控制权 P(SUSPEND_C, -1); //控制台无足够零件，转入waiting态，挂起自身 &#125; &#125;&#125; 编程实现 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;signal.h&gt;#include &lt;time.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;#include &lt;sys/shm.h&gt;#define NUM_SEMAPHORE 4 // 信号量个数// 信号量ID#define MUTEX_STATION 0 // 二元信号量，控制对工作台和count_A、count_B、empty的互斥访问（取/放零件）#define SUSPEND_A 1 // 控制台无足够空位时，挂起worker A#define SUSPEND_B 2 // 控制台无足够空位时，挂起worker B#define SUSPEND_C 3 // 控制台无足够零件时，挂起worker C#define SEM_KEY 0x11223344 // 信号量组的KEY#define SHM_KEY1 0x11223355 // 共享内存的KEY1#define SHM_KEY2 0x11223366 // 共享内存的KEY2// 颜色#define NONE &quot;\\e[0m&quot; // 复原#define RED &quot;\\e[0;31m&quot; // ERROR#define YELLOW &quot;\\e[1;33m&quot; // WorkerA#define PINK &quot;\\e[1;35m&quot; // WorkerB#define GREEN &quot;\\e[1;32m&quot; // WorkerC#define CYAN &quot;\\e[0;36m&quot; // Share Memory#define BUF_SIZE 12char *buf;int *info; // 用于记录信息的3个整形变量int i, sv, sem_id, shm_id, info_shm_id, C_num = 0;union semun&#123; int val; // SETVAL使用的值 struct semid_ds *buf; // IPC_STAT、IPC_SET 使用缓存区 unsigned short *array; // GETALL,、SETALL 使用的数组 struct seminfo *__buf; // IPC_INFO(Linux特有) 使用缓存区&#125;;// 对信号量做减1操作，即P（wait）void P(int sem_id, int sem_num, int op)&#123; if (op &lt; 0) &#123; struct sembuf sem_buf; sem_buf.sem_num = sem_num; sem_buf.sem_op = op; //P() sem_buf.sem_flg = SEM_UNDO; if (semop(sem_id, &amp;sem_buf, 1) == -1) &#123; perror(RED &quot;Semaphore P&quot; NONE); exit(2); &#125; &#125; else &#123; perror(RED &quot;Semaphore P&quot; NONE); exit(3); &#125; return;&#125;// 对信号量做减1操作，即V（signal）void V(int sem_id, int sem_num, int op)&#123; if (op &gt; 0) &#123; struct sembuf sem_buf; sem_buf.sem_num = sem_num; sem_buf.sem_op = op; //V() sem_buf.sem_flg = SEM_UNDO; if (semop(sem_id, &amp;sem_buf, 1) == -1) &#123; perror(RED &quot;Semaphore V&quot; NONE); exit(2); &#125; &#125; else &#123; perror(RED &quot;Semaphore V&quot; NONE); exit(3); &#125; return;&#125;// 展示共享内存void show_shm()&#123; printf(CYAN &quot;[&quot;); for (i = 0; i &lt; BUF_SIZE - 1; i++) &#123; printf(&quot;%c,&quot;, buf[i]); &#125; printf(&quot;%c]\\n\\n&quot; NONE, buf[BUF_SIZE - 1]);&#125;// 创建并初始化信号量和共享内存void create_ipc()&#123; union semun arg[NUM_SEMAPHORE]; arg[MUTEX_STATION].val = 1; arg[SUSPEND_A].val = 0; arg[SUSPEND_B].val = 0; arg[SUSPEND_C].val = 0; // 创建信号量 if ((sem_id = semget(SEM_KEY, NUM_SEMAPHORE, IPC_CREAT | IPC_EXCL | 0666)) == -1) &#123; perror(RED &quot;Create Semaphores&quot; NONE); exit(1); &#125; printf(&quot;Create Semaphores: OK\\n&quot;); printf(&quot;Sem_id = %d\\n&quot;, sem_id); // 初始化信号量 for (i = 0; i &lt; NUM_SEMAPHORE; i++) &#123; semctl(sem_id, i, SETVAL, arg[i]); &#125; for (i = 0; i &lt; NUM_SEMAPHORE; i++) &#123; printf(&quot;The Sem[%d] = %d\\n&quot;, i, semctl(sem_id, i, GETVAL, NULL)); &#125; printf(&quot;\\n&quot;); // 创建Info共享内存，用于记录信息 info_shm_id = shmget(SHM_KEY2, 3 * sizeof(int), IPC_CREAT | IPC_EXCL | 0666); if (info_shm_id == -1) &#123; perror(RED &quot;Create Info Share Memory&quot; NONE); exit(1); &#125; printf(&quot;Create Info Share Memory: OK\\n&quot;); // 初始化Info共享内存 info = (int *)shmat(info_shm_id, 0, 0); // 获取指向共享内存段的指针 if (info == (int *)-1) &#123; perror(RED &quot;Attach Info Share Memory&quot; NONE); exit(1); &#125; info[0] = 0; // 当前工作台中已有的A的数量（count_A） info[1] = 0; // 当前工作台中已有的B的数量（count_B） info[2] = 12; // 工作台中空位数量（empty=12-(count_A+count_B)） printf(&quot;Attach Info Share Memory: OK\\n&quot;); // 展示info共享内存 printf(&quot;count_A=%d, count_B=%d, empty=%d\\n\\n&quot;, info[0], info[1], info[2]); // 创建Buffer共享内存 shm_id = shmget(SHM_KEY1, BUF_SIZE * sizeof(char), IPC_CREAT | IPC_EXCL | 0666); if (shm_id == -1) &#123; perror(RED &quot;Create Buffer Share Memory&quot; NONE); exit(1); &#125; printf(&quot;Create Buffer Share Memory: OK\\n&quot;); // 初始化Buffer共享内存 buf = (char *)shmat(shm_id, 0, 0); // 获取指向共享内存段的指针 if (buf == (char *)-1) &#123; perror(RED &quot;Attach Buffer Share Memory&quot; NONE); exit(1); &#125; for (i = 0; i &lt; BUF_SIZE; i++) &#123; buf[i] = &#x27; &#x27;; &#125; printf(&quot;Initialize QUEUE: OK\\n&quot;); show_shm();&#125;// 删除信号量和共享内存void remove_ipc()&#123; // 删除信号量 if (semctl(sem_id, 0, IPC_RMID, 0) == -1) perror(RED &quot;Remove Semaphores&quot; NONE); else printf(&quot;Remove Semaphores: OK\\n&quot;); // 删除共享内存 if (shmctl(shm_id, IPC_RMID, 0) == -1) perror(RED &quot;Remove Buffer Share Memory&quot; NONE); else printf(&quot;Remove Buffer Share Memory: OK\\n&quot;); if (shmctl(info_shm_id, IPC_RMID, 0) == -1) perror(RED &quot;Remove Info Share Memory&quot; NONE); else printf(&quot;Remove Info Share Memory: OK\\n&quot;);&#125;// CTRL-C回调函数void sig_handler(int sig)&#123; printf(&quot;\\n&quot;); remove_ipc(); printf(&quot;EXIT: OK\\n&quot;);&#125;int main(int argc, char const *argv[])&#123; srand(time(NULL)); // 创建并初始化信号量和共享内存 create_ipc(); // WorkerA if (fork() == 0) &#123; while (1) &#123; sleep(1 + random() % 10); // 生产2个A P(sem_id, MUTEX_STATION, -1); // 申请对count_A、empty和控制台的访问权 // 还能再生产放置2个A，最多可放7+2=9个A，以便至少给B留下12-9=3个空位，防止工作台中没有足够多的B，导致worker C无法同时取出3个B if (info[0] &lt;= 7 &amp;&amp; info[2] &gt;= 2) &#123; // 同时放入工作台2个A for (i = 0; i &lt; 2; i++) &#123; char *c; c = strchr(buf, &#x27; &#x27;); *c = &#x27;A&#x27;; &#125; printf(YELLOW &quot;Worker A puts 2 As to the station\\n&quot; NONE); show_shm(); info[0] += 2; //修改count_A info[2] -= 2; //修改empty // 展示info共享内存 printf(&quot;count_A=%d, count_B=%d, empty=%d\\n\\n&quot;, info[0], info[1], info[2]); V(sem_id, MUTEX_STATION, 1); //释放对控制台、count_A和empty的访问权 V(sem_id, SUSPEND_C, 1); //控制台放入新零件，解挂/唤醒worker C &#125; else &#123; V(sem_id, MUTEX_STATION, 1); //释放对控制台和count_A、empty的访问权 printf(&quot;Worker A suspended\\n\\n&quot;); P(sem_id, SUSPEND_A, -1); //控制台无足够空位，或不允许再放入A，转入waiting态，挂起自身 &#125; &#125; &#125; // WorkerB else if (fork() == 0) &#123; while (1) &#123; sleep(1 + random() % 10); // 生产1个B P(sem_id, MUTEX_STATION, -1); // 申请对count_B、empty和控制台的访问权 // 还能再生产并放置1个B，最多可放7+1=8个B，以便至少给A留下12-8=4个空位，防止工作台中没有足够多的A，导致worker C无法同时取出4个A if (info[1] &lt;= 7 &amp;&amp; info[2] &gt;= 1) &#123; // 放入工作台1个B char *c; c = strchr(buf, &#x27; &#x27;); *c = &#x27;B&#x27;; printf(PINK &quot;Worker B puts 1 B to the station\\n&quot; NONE); show_shm(); info[1] += 1; //修改count_B info[2] -= 1; //修改empty // 展示info共享内存 printf(&quot;count_A=%d, count_B=%d, empty=%d\\n\\n&quot;, info[0], info[1], info[2]); V(sem_id, MUTEX_STATION, 1); //释放对控制台、count_B和empty的访问权 V(sem_id, SUSPEND_C, 1); //控制台放入新零件，解挂/唤醒worker C &#125; else &#123; V(sem_id, MUTEX_STATION, 1); //释放对控制台和count_B、empty的访问权 printf(&quot;Worker B suspended\\n\\n&quot;); P(sem_id, SUSPEND_B, -1); //控制台无足够空位，或不允许再放入B，转入waiting态，挂起自身 &#125; &#125; &#125; // WorkerC else if (fork() == 0) &#123; while (1) &#123; P(sem_id, MUTEX_STATION, -1); // 申请对count_A、count_B和控制台的访问权 // 有足够多的A、B用于装配 if (info[0] &gt;= 4 &amp;&amp; info[1] &gt;= 3) &#123; // 同时从工作台取出4个A、3个B for (i = 0; i &lt; 4; i++) &#123; char *c; c = strchr(buf, &#x27;A&#x27;); *c = &#x27; &#x27;; &#125; for (i = 0; i &lt; 3; i++) &#123; char *c; c = strchr(buf, &#x27;B&#x27;); *c = &#x27; &#x27;; &#125; printf(GREEN &quot;Worker C gets 4 As and 3 Bs from the station\\n&quot; NONE); show_shm(); info[0] -= 4; //修改count_A info[1] -= 3; //修改count_B info[2] += 7; //修改empty // 展示info共享内存 printf(&quot;count_A=%d, count_B=%d, empty=%d\\n\\n&quot;, info[0], info[1], info[2]); V(sem_id, MUTEX_STATION, 1); //释放对控制台、count_A、count_B的控制权 V(sem_id, SUSPEND_A, 1); //控制台新增空位，解挂A V(sem_id, SUSPEND_B, 1); //控制台新增空位，解挂B // 生产1个C printf(GREEN &quot;Worker C is producing C-%d......\\n\\n&quot; NONE, ++C_num); sleep(1 + random() % 10); printf(GREEN &quot;C-%d is produced\\n\\n&quot; NONE, C_num); &#125; else &#123; V(sem_id, MUTEX_STATION, 1); //释放对控制台、count_A、count_B的控制权 printf(&quot;Worker C suspended\\n\\n&quot;); P(sem_id, SUSPEND_C, -1); //控制台无足够零件，转入waiting态，挂起自身 &#125; &#125; &#125; // Main else &#123; // CTRL-C信号自行处理 signal(SIGINT, sig_handler); wait(&amp;sv); wait(&amp;sv); wait(&amp;sv); printf(&quot;THANKS\\n&quot;); return 0; &#125;&#125; 方案2（采用多元信号量，效率不如方案1高）：信号量经分析题目，发现共需要6个信号量，分别为： 123456semaphore MUTEX = 1; // 用于WorkerA、WorkerB和WorkerC对Station的互斥访问semaphore A_FULL = 0; // 用于限制WorkerC取Asemaphore A_EMPTY = 9; // 用于限制WorkerA生产A的数量semaphore B_FULL = 0; // 用于限制WorkerC取Bsemaphore B_EMPTY = 8; // 用于限制WorkerB生产B的数量semaphore ALL_EMPTY = 12; // 用于限制整个Station的生产数量 分析： WorkerA最多生产9个A，如果生产A的个数大于9，则B的个数就会小于3，导致C永远从Station中拿不到4个A和3个B，产生死锁。但是由于WorkerA一次生产2个A，则WorkerA最多生产8（2×4）个A，因此使用信号量A_EMPTY来控制。A_EMPTY初始值可以设置为8，但是A_EMPTY初始值也可以设置为9，都是可以的。 同理，WorkerB最多生产8个B，如果生产B的个数大于8，则A的个数就会小于4，导致C永远从Station中拿不到4个A和3个B，产生死锁。因此使用信号量B_EMPTY来控制。 WorkerA和WorkerB一起最多生产12个A和B，因此使用信号量B_EMPTY来控制。 需要一个互斥量MUTEX，用于WorkerA、WorkerB和WorkerC对Station的互斥访问。 WorkerA 点击查看代码 12345678910111213WorkerA()&#123; while (1) &#123; // 生产2个A P(A_EMPTY,-2); P(ALL_EMPTY,-2); P(MUTEX,-1); // 同时放入工作台2个A V(MUTEX,1); V(A_FULL,2); &#125;&#125; WorkerB 点击查看代码 12345678910111213WorkerB()&#123; while (1) &#123; // 生产1个B P(B_EMPTY,-1); P(ALL_EMPTY,-1); P(MUTEX,-1); // 放入工作台1个B V(MUTEX,1); V(B_FULL,1); &#125;&#125; WorkerC 点击查看代码 123456789101112131415WorkerC()&#123; while (1) &#123; P(A_FULL,-4); P(B_FULL,-3); P(MUTEX,-1); // 同时从工作台取出4个A、3个B V(MUTEX,1); V(ALL_EMPTY,7); V(B_EMPTY,3); V(A_EMPTY,4); // 生产1个C &#125;&#125; 编程实现 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;signal.h&gt;#include &lt;time.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;#include &lt;sys/shm.h&gt;#define NUM_SEMAPHORE 6 // 信号量个数// 信号量ID#define MUTEX 0 // 用于WorkerA、WorkerB和WorkerC对Station的互斥访问#define A_FULL 1 // 用于限制WorkerC取A#define A_EMPTY 2 // 用于限制WorkerA生产A的数量#define B_FULL 3 // 用于限制WorkerC取B#define B_EMPTY 4 // 用于限制WorkerB生产B的数量#define ALL_EMPTY 5 // 用于限制整个Station的生产数量#define SEM_KEY 0x11223344 // 信号量组的KEY#define SHM_KEY 0x11223355 // 共享内存的KEY// 颜色#define NONE &quot;\\e[0m&quot; // 复原#define RED &quot;\\e[0;31m&quot; // ERROR#define YELLOW &quot;\\e[1;33m&quot; // WorkerA#define PINK &quot;\\e[1;35m&quot; // WorkerB#define GREEN &quot;\\e[1;32m&quot; // WorkerC#define CYAN &quot;\\e[0;36m&quot; // Share Memory#define BUF_SIZE 12 // 工作台大小char *buf;int i, sv, sem_id, shm_id, C_num = 0;union semun&#123; int val; // SETVAL使用的值 struct semid_ds *buf; // IPC_STAT、IPC_SET 使用缓存区 unsigned short *array; // GETALL,、SETALL 使用的数组 struct seminfo *__buf; // IPC_INFO(Linux特有) 使用缓存区&#125;;// 对信号量做减1操作，即P（wait）void P(int sem_id, int sem_num, int op)&#123; struct sembuf sem_buf; sem_buf.sem_num = sem_num; sem_buf.sem_op = op; //P() sem_buf.sem_flg = SEM_UNDO; if (semop(sem_id, &amp;sem_buf, 1) == -1) &#123; perror(RED &quot;Semaphore P&quot; NONE); exit(2); &#125; return;&#125;// 对信号量做减1操作，即V（signal）void V(int sem_id, int sem_num, int op)&#123; struct sembuf sem_buf; sem_buf.sem_num = sem_num; sem_buf.sem_op = op; //V() sem_buf.sem_flg = SEM_UNDO; if (semop(sem_id, &amp;sem_buf, 1) == -1) &#123; perror(RED &quot;Semaphore V&quot; NONE); exit(2); &#125; return;&#125;// 展示共享内存void show_shm()&#123; printf(CYAN &quot;[&quot;); for (i = 0; i &lt; BUF_SIZE - 1; i++) &#123; printf(&quot;%c,&quot;, buf[i]); &#125; printf(&quot;%c]\\n\\n&quot; NONE, buf[BUF_SIZE - 1]);&#125;// 创建并初始化信号量和共享内存void create_ipc()&#123; union semun arg[NUM_SEMAPHORE]; arg[MUTEX].val = 1; arg[A_FULL].val = 0; arg[A_EMPTY].val = 9; arg[B_FULL].val = 0; arg[B_EMPTY].val = 8; arg[ALL_EMPTY].val = 12; // 创建信号量 if ((sem_id = semget(SEM_KEY, NUM_SEMAPHORE, IPC_CREAT | IPC_EXCL | 0666)) == -1) &#123; perror(RED &quot;Create Semaphores&quot; NONE); exit(1); &#125; printf(&quot;Create Semaphores: OK\\n&quot;); printf(&quot;Sem_id = %d\\n&quot;, sem_id); // 初始化信号量 for (i = 0; i &lt; NUM_SEMAPHORE; i++) &#123; semctl(sem_id, i, SETVAL, arg[i]); &#125; for (i = 0; i &lt; NUM_SEMAPHORE; i++) &#123; printf(&quot;The Sem[%d] = %d\\n&quot;, i, semctl(sem_id, i, GETVAL, NULL)); &#125; // 创建共享内存 shm_id = shmget(SHM_KEY, BUF_SIZE * sizeof(char), IPC_CREAT | IPC_EXCL | 0666); if (shm_id == -1) &#123; perror(RED &quot;Create Share Memory&quot; NONE); exit(1); &#125; printf(&quot;Create Share Memory: OK\\n&quot;); // 初始化共享内存 buf = (char *)shmat(shm_id, 0, 0); // 获取指向共享内存段的指针 if (buf == (char *)-1) &#123; perror(RED &quot;Attach Share Memory&quot; NONE); exit(1); &#125; for (i = 0; i &lt; BUF_SIZE; i++) &#123; buf[i] = &#x27; &#x27;; &#125; printf(&quot;Initialize QUEUE: OK\\n&quot;); show_shm();&#125;// 删除信号量和共享内存void remove_ipc()&#123; // 删除信号量 if (semctl(sem_id, 0, IPC_RMID, 0) == -1) perror(RED &quot;Remove Semaphores&quot; NONE); else printf(&quot;Remove Semaphores: OK\\n&quot;); // 删除共享内存 if (shmctl(shm_id, IPC_RMID, 0) == -1) perror(RED &quot;Remove Share Memory&quot; NONE); else printf(&quot;Remove Share Memory: OK\\n&quot;);&#125;// CTRL-C回调函数void sig_handler(int sig)&#123; printf(&quot;\\n&quot;); remove_ipc(); printf(&quot;EXIT: OK\\n&quot;);&#125;int main(int argc, char const *argv[])&#123; srand(time(NULL)); // 创建并初始化信号量和共享内存 create_ipc(); // WorkerA if (fork() == 0) &#123; while (1) &#123; sleep(1 + random() % 10); // 生产2个A P(sem_id, A_EMPTY, -2); P(sem_id, ALL_EMPTY, -2); P(sem_id, MUTEX, -1); // 同时放入工作台2个A for (i = 0; i &lt; 2; i++) &#123; char *c; c = strchr(buf, &#x27; &#x27;); *c = &#x27;A&#x27;; &#125; printf(YELLOW &quot;Worker A puts 2 As to the station\\n&quot; NONE); show_shm(); V(sem_id, MUTEX, 1); V(sem_id, A_FULL, 2); &#125; &#125; // WorkerB else if (fork() == 0) &#123; while (1) &#123; sleep(1 + random() % 10); // 生产1个B P(sem_id, B_EMPTY, -1); P(sem_id, ALL_EMPTY, -1); P(sem_id, MUTEX, -1); // 放入工作台1个B char *c; c = strchr(buf, &#x27; &#x27;); *c = &#x27;B&#x27;; printf(PINK &quot;Worker B puts 1 B to the station\\n&quot; NONE); show_shm(); V(sem_id, MUTEX, 1); V(sem_id, B_FULL, 1); &#125; &#125; // WorkerC else if (fork() == 0) &#123; while (1) &#123; P(sem_id, A_FULL, -4); P(sem_id, B_FULL, -3); P(sem_id, MUTEX, -1); // 同时从工作台取出4个A、3个B for (i = 0; i &lt; 4; i++) &#123; char *c; c = strchr(buf, &#x27;A&#x27;); *c = &#x27; &#x27;; &#125; for (i = 0; i &lt; 3; i++) &#123; char *c; c = strchr(buf, &#x27;B&#x27;); *c = &#x27; &#x27;; &#125; printf(GREEN &quot;Worker C gets 4 As and 3 Bs from the station\\n&quot; NONE); show_shm(); V(sem_id, MUTEX, 1); V(sem_id, ALL_EMPTY, 7); V(sem_id, B_EMPTY, 3); V(sem_id, A_EMPTY, 4); // 生产1个C printf(GREEN &quot;Worker C is producing C-%d......\\n\\n&quot; NONE, ++C_num); sleep(1 + random() % 10); printf(GREEN &quot;C-%d is produced\\n\\n&quot; NONE, C_num); &#125; &#125; // Main else &#123; // CTRL-C信号自行处理 signal(SIGINT, sig_handler); wait(&amp;sv); wait(&amp;sv); wait(&amp;sv); printf(&quot;THANKS\\n&quot;); return 0; &#125;&#125; 2、运行结果及分析两种方案的运行情况只选择了其中一种方案的运行结果，如果工作时间一致的话，两种方案的运行情况基本一致，但是因为使用了随机工作时间，每次运行的结果可能不一样，因此只选择了其中的一次运行结果。 1、编译 2、运行方案一： 方案二： 3、分析从运行结果来看，完全没有死锁现象，程序完全正常运行，输出结果也正常，创建和初始化信号量和共享内存，释放和删除信号量和共享内存都正常结束。 方案一的输出中有count_A、count_B、和empty的值，以及Worker A、Worker B和Worker C在进入阻塞状态时的输出，整个过程比较清晰。 方案二的基本过程在输出中，共享内存的状态也很清晰： 2A-B-2A-B-2A-B-C-2A-B-2A-B-2A-B-C-2A-B-2A-B-B-C-2A-B-2A-B-B-C-2A…… 方案一和方案二多次运行都没有产生死锁，并且因为设置了随机等待时间模拟生产，每次的结果都有所不同，但都符合预期。但是经过分析，方案二可能会导致Worker A和Worker B都等待Worker C，但是此时工作台却还有一个空位的情况，但是并没有产生死锁，只是效率相较于方案一会低一些。 五、实验总结这次操作系统课程设计的5组实验，虽然难度可能不是那么高，但是结合了操作系统理论课所学的知识，很有实践意义。经过这5组实验，我首先认识了华为最新的OpenEuler开源Linux操作系统，学习了Linux操作系统的安装、基本操作和使用。这次实验还加深了我对操作系统进程、线程概念和消息队列、共享内存、管道、软中断四种进程间通信机制的理解，掌握了利用Linux系统调用创建、管理进程的方法、利用POSIX线程（Pthread）库创建管理线程的方法和实现进程间通信和线程间通信的方法，深刻地认识了进程、线程并发执行的实质，并掌握了编程使用互斥变量和条件变量实现多线程间的同步互斥。 在实验的过程中，也遇到了各种各样的小问题，比如Linux的命令报错啊，编程gcc编译不通过等等，但经过上网查找资料和与同学讨论交流，都完美解决了问题，总体上看实验过程比较顺利。经过这次的课程设计，明显加深了对操作系统理论课知识的理解，并拓展了很多新的知识和内容，让我受益匪浅。 六、项目源码本项目的源码已经存放于我的Github，欢迎下载查看：","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://666wxy666.github.io/categories/C-C/"},{"name":"操作系统","slug":"C-C/操作系统","permalink":"https://666wxy666.github.io/categories/C-C/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/tags/Linux/"},{"name":"操作系统","slug":"操作系统","permalink":"https://666wxy666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"进程","slug":"进程","permalink":"https://666wxy666.github.io/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"线程","slug":"线程","permalink":"https://666wxy666.github.io/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"同步互斥","slug":"同步互斥","permalink":"https://666wxy666.github.io/tags/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/"}]},{"title":"编译原理 语法分析 LL1","slug":"编译原理-语法分析-LL1","date":"2020-09-02T00:00:00.000Z","updated":"2021-05-30T09:07:07.229Z","comments":true,"path":"2020/09/02/编译原理-语法分析-LL1/","link":"","permalink":"https://666wxy666.github.io/2020/09/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-LL1/","excerpt":"本文是编译原理C语言LL1语法分析器的简单实现项目。","text":"本文是编译原理C语言LL1语法分析器的简单实现项目。 一、需求 拓展需求：还能自动够造LL1文法的first集和follow集，为LL1文法自动构造预测分析表。 二、运行环境电脑硬件配置： 处理器：Intel i7 7700HQ 显卡：NVIDIA GeForce GTX 1050 Ti 内存：16GB 软件： 编程语言：C++ IDE：Microsoft Visual Studio 2019 Windows SDK版本：10.0 平台工具集：Visual Studio 2019（v142） 三、核心算法1、整个程序的模型如图所示 分析栈、分析表的数据结构详见【变量和函数】。 2、first集的构造使用深度优先遍历递归的方法，当遍历完所有的非终结符的产生式右部，first集构造完成。详见注释。 点击查看代码 3、follow集的构造不能采用深度优先遍历的方法，否则求给出的测试样例【其它文法1】会无限循环，因为非终结符之间的follow集是互相依赖的，因而采用了另一种方法解决了这个问题。就是无限循环求所有非终结符的follow集，直到所有的follow集都不再增大为止，跳出循环。详见注释。 点击查看代码 4、预测分析表的构造算法利用课本上的算法4.2 5、预测分析控制程序算法利用课本上的算法 但是该算法有点小瑕疵，就是最后while循环的出口判断条件有问题，不应该是只是【栈顶文法符号X不为‘$’】，而应为【栈顶文法符号X不为‘$’&amp;&amp;所指向的输入符号a不为‘$’】。 6、输入形式：先输入文法的产生式个数，然后输入产生式，该文法必须为LL1文法（消除左递归和左公因子），然后输入1或0，决定是否要进行分析，然后再输入要分析的字符串，该字符串需要用i代表数字，以‘$’结尾。输入的文法默认第一个输入的产生式的左部为起始符，非终结符仅为一个大写字母，终结符仅为一个小写字母和各种符号，且用~代替epsilon,且输入的文法必须满足LL1文法的条件。输入的要分析的字符串需要用i代表数字，以‘$’结尾。我认为没有必要把i也就是题目中的num细化为数字，因为这些操作已经在词法分析中完成了，语法分析只需完成分析类似于这种字符串的输入是否被接受就可以了。 7、输出形式：先输出该文法的first集和follow集，再输出该文法的LL1预测分析表，最后输出用户输入的待分析字符串的分析过程 四、变量和函数1、类 点击查看代码 1234567891011121314class PF//Production formula,产生式的类&#123;public: string left;//产生式的左部 set&lt;string&gt; right;//产生式的右部 PF(char s[])//构造函数，确定产生式左部 &#123; left = s; &#125; void insert(char s[])//插入产生式右部的函数 &#123; right.insert(s); &#125;&#125;; 2、全局变量 点击查看代码 123456789101112vector&lt;PF&gt; PF_vector;//产生式使用一个vector数组，每个元素为PF类的对象，来存放输入的产生式。map&lt;string, set&lt;char&gt; &gt; first;//first集map&lt;string, set&lt;char&gt; &gt; follow;//follow集使用了map哈希key的类型为string，存放产生式的左部，value的类型为char的set,用来存放对应key的first集和follow集。vector&lt;map&lt;char, string&gt;&gt; predict_table;//LL1分析表//使用一个vector数组，每个元素为一个map，该vector的每一个map分别对应PF_vector中每个产生式的左部的非终结符所在的预测分析表的行，map的key为终结符，value为对应表项中的产生式的右部vector&lt;char&gt; A;//分析栈vector&lt;char&gt; B;//剩余串map&lt;string, int&gt; PF_map;//存储每个非终结符对应的编号，key为非终结符，value为编号vector&lt;char&gt; letter;//所有的终结符,在构造预测分析表的时候创建完毕int B_point = 0, input_len = 0;//B_point为输入串指针，input_len为输入串长度 3、函数 点击查看代码 1234567891011121314151617181920//first集的构造：void first_construction() //构造并输出first集void DFS(int x)//为构造first集深度优先遍历PF，递归调用//follow集的构造：void follow_construction()//构造并输出follow集void add_follow(const string&amp; str1, const string&amp; str2)//将str1的follow集加入到str2的follow集中//预测分析表的构造：void predict_table_construction()//构造并输出LL1分析表bool check_first(const string&amp; str, char ch)//检查ch是否属于str的FIRST集合bool check_follow(const string&amp; str, char ch)//检查ch是否属于str的FOLLOW集合//预测分析控制程序：void analyse()//预测分析控制程序void print_A()//输出分析栈void print_B()//输出剩余串//主函数：int main() PS：关于每个函数内部详细实现详见main.cpp中写好了详细的注释，我几乎对每一步操作的目的和函数的目的都写了详细的注释。 五、测试样例：这个语法分析程序普适性较高，不仅对课本上的算数运算文法能实现求first集和follow集，自动生成预测分析表，以及对字符串进行分析，还对几乎所有的LL1文法都可以实现，只要输入的文法按照【核心算法】中的【输入形式】的要求即可。 在这里我以课本上的算数运算文法为例。其它文法1为follow集循环依赖文法（求follow集不可以用递归求，否则该文法会无限循环），其它文法2为起始符可推空文法（如果不按严格算法4.2构造分析表，也就是作业中把A-&gt;~产生式加入到A的follow集所对应的终结符的表项中的做法其实是不准确的，而应把A可以推空的产生式加入到A的follow集所对应的终结符的表项中，否则就会导致无法识别某些字符串的错误，例如其它文法2就是无法识别空串的错误，但该文法确实可以识别空串）。 六、项目地址本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看：","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://666wxy666.github.io/categories/C-C/"},{"name":"编译原理","slug":"C-C/编译原理","permalink":"https://666wxy666.github.io/categories/C-C/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"编译原理","slug":"编译原理","permalink":"https://666wxy666.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"语法分析","slug":"语法分析","permalink":"https://666wxy666.github.io/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"}]},{"title":"编译原理 语法分析 LR","slug":"编译原理-语法分析-LR","date":"2020-09-02T00:00:00.000Z","updated":"2021-05-30T09:07:07.229Z","comments":true,"path":"2020/09/02/编译原理-语法分析-LR/","link":"","permalink":"https://666wxy666.github.io/2020/09/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-LR/","excerpt":"本文是编译原理C语言LR语法分析器的简单实现项目。","text":"本文是编译原理C语言LR语法分析器的简单实现项目。 一、需求 拓展需求：除题目的基础要求外，还额外实现了对任意SLR1文法，自动生成拓广文法，且求该文法的first集和follow集，并且自动生成LR0项目集规范簇和识别该文法所有活前缀的DFA，然后根据该DFA自动生成SLR1分析表。 二、运行环境电脑硬件配置： 处理器：Intel i7 7700HQ 显卡：NVIDIA GeForce GTX 1050 Ti 内存：16GB 软件： 编程语言：C++ IDE：Microsoft Visual Studio 2019 Windows SDK版本：10.0 平台工具集：Visual Studio 2019（v142） 三、核心算法1、整个程序的模型如图所示手动分析： 首先对文法进行拓广，求first集和follow集，发现该文法是一个SLR1文法。 构造LR0项目集规范簇及识别该文法所有活前缀的DFA 构造识别该文法的SLR0分析表 整个程序的模型如图所示 预测分析控制程序算法 6、输入形式：文件输入，格式为： 产生式个数n { …… 第i(1&lt;=i&lt;=n)个产生式（例如A-&gt;a，按照输入顺序分别从1到n编号，拓广产生式为0号，规定终结符和非终结符都是一个字符且非终结符都为大写字母） …… } 要分析的字符串个数n { …… 第i(1&lt;=i&lt;=n)个要分析的字符串（要求以$结尾） …… } 7、输出形式：先输出该文法的拓广文法，再输出该拓广文法的first集和follow集，再输出SLR0分析表，然后输出用户输入的待分析字符串的分析过程。 四、变量和函数1、类和枚举： 点击查看代码 12345678910111213141516171819202122232425262728293031323334353637enum RS//动作的枚举&#123; shift,//移进 reduce,//规约 accept//接受&#125;;//假定非终结符仅为一个大写字母，终结符仅为一个小写字母和各种符号，且用~代替epsilonclass PF//Production formula,产生式的类&#123;public: char left;//产生式的左部 string right;//产生式的右部 PF(char l, string r)//构造函数 &#123; left = l; right = r; &#125;&#125;;class ITEM//项目集&#123;public: ITEM();//默认构造函数 ITEM(int NO);//构造函数 int NO;//项目集编号 set&lt;pair&lt;int, int&gt;&gt; production;//项目，第一个int代表产生式编号，第二个int代表.的位置 set&lt;pair&lt;char, int&gt;&gt; go_to;//该项目集指向的项目集，第一个char代表箭头上的字符，第二个int代表指向的项目集编号 bool operator&lt;(const ITEM&amp; item)const;//重载&lt;操作符，以便使用set&#125;;class action//动作类&#123;public: action(RS rs,int num);//重写构造函数 string ret_action();//返回该动作 action();//初始 RS rs;//动作 int num;//移进到哪个状态，或者用哪个产生式规约&#125;; 2、全局变量 点击查看代码 123456789101112vector&lt;PF&gt; PF_vector;//产生式map&lt;char, set&lt;char&gt; &gt; first;//first集map&lt;char, set&lt;char&gt; &gt; follow;//follow集set&lt;ITEM&gt; DFA;//DFA项目集规范簇vector&lt;map&lt;char, action&gt;&gt; predict_table_action;//SLR1分析表actionvector&lt;map&lt;char, int&gt;&gt; predict_table_goto;//SLR1分析表gotovector&lt;char&gt; A_1;//符号栈vector&lt;int&gt; A_2;//状态栈vector&lt;char&gt; B;//剩余串set&lt;char&gt; terminal;//所有的终结符+&#x27;$&#x27;set&lt;char&gt; non_terminal;//所有的非终结符int B_point = 0, input_len = 0;//B_point为输入串指针，input_len为输入串长度 3、函数 点击查看代码 123456789101112131415ITEM::ITEM()//默认构造函数ITEM::ITEM(int NO)//构造函数bool ITEM::operator&lt;(const ITEM&amp; item)const//重载&lt;操作符，以便使用setaction::action(RS rs, int num) //构造函数action::action()//默认构造函数string action::ret_action()//返回该动作void first_construction()//构造并输出first集void add_follow(const char&amp; ch1, const char&amp; ch2)//将ch1的follow集加入到ch2的follow集中void follow_construction()//构造并输出follow集void DFA_construction()//构造DFAvoid predict_table_construction()//构造并输出SLR1预测分析表void print_A()//输出分析栈void print_B()//输出剩余串void analyse()//预测分析控制程序int main() PS：关于每个函数内部详细实现详见main.cpp中写好了详细的注释，我几乎对每一步操作的目的和函数的目的都写了详细的注释。 五、测试样例： 六、项目地址本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看：","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://666wxy666.github.io/categories/C-C/"},{"name":"编译原理","slug":"C-C/编译原理","permalink":"https://666wxy666.github.io/categories/C-C/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"编译原理","slug":"编译原理","permalink":"https://666wxy666.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"语法分析","slug":"语法分析","permalink":"https://666wxy666.github.io/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"}]},{"title":"编译原理 词法分析","slug":"编译原理-词法分析","date":"2020-09-01T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/09/01/编译原理-词法分析/","link":"","permalink":"https://666wxy666.github.io/2020/09/01/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/","excerpt":"本文是编译原理C语言词法分析器的简单实现项目。","text":"本文是编译原理C语言词法分析器的简单实现项目。 一、需求词法分析程序的设计和实现。 设计并实现C语言的词法分析程序，要求如下： 可以识别出用C语言编写的源程序中的每个单词符号，并以记号的形式输出每个单词符号。 可以识别并读取源程序中的注释。 可以统计源程序汇总的语句行数、各类单词的个数、以及字符个数，并输出统计结果。 检查源程序中存在的词法错误，并报告错误所在的位置。 对源程序中存在的错误进行适当的恢复，使词法分析可以继续进行，对源程序进行一次扫描即可检查并报告源程序中存在的所有词法错误。 二、运行环境电脑硬件配置： 处理器：Intel i7 7700HQ 显卡：NVIDIA GeForce GTX 1050 Ti 内存：16GB 软件： 编程语言：C++ IDE：Microsoft Visual Studio 2019 Windows SDK版本：10.0 平台工具集：Visual Studio 2019（v142） 三、核心算法读入源程序，将源程序拆分为单词，同时去除空格和空行并存入vector中，一个字符一个字符的读入自动机，文件输出单词和类型，并在最后输出统计结果，在屏幕输出错误。 PS:不支持中文字符 源程序的记号和表达式： 标识符：字母或“_”开头，后跟字母或数字或“_”组成的符号串 关键字：标识符集合的子集。C语言有32个关键字，分别为： 123&quot;do&quot;,&quot;double&quot;,&quot;auto&quot;,&quot;break&quot;,&quot;case&quot;,&quot;char&quot;,&quot;const&quot;,&quot;continue&quot;,&quot;default&quot;,&quot;else&quot;,&quot;enum&quot;,&quot;extern&quot;,&quot;float&quot;,&quot;for&quot;,&quot;goto&quot;,&quot;if&quot;,&quot;int&quot;,&quot;long&quot;,&quot;register&quot;,&quot;return&quot;,&quot;struct&quot;,&quot;switch&quot;,&quot;typedef&quot;,&quot;short&quot;,&quot;signed&quot;,&quot;sizeof&quot;,&quot;static&quot;,&quot;union&quot;,&quot;unsigned&quot;,&quot;void&quot;,&quot;volatile&quot;,&quot;while&quot; 数字：由整数部分、可选小数部分和可选整数部分构成 运算符： 1. ( ) ~ &amp; ^ % &lt;= &lt;&lt; &lt; &gt;= &gt;&gt; &gt; = == / != ! &amp;&amp; &amp; || | -&gt; - : ? 分隔符： 1; # ’ ” [ ] &#123; &#125; , 转义符：\\ 状态转换图： 输入形式：文件输入。 输出形式：分两部分：文件输出和屏幕输出。文件输出分析内容，分四部分：按文件顺序输出类型和表达式，每种表达式数量统计，每种类型数量统计，行数、单词数、字符数统计；屏幕输出错误。详见输出样例部分。 四、变量和函数 点击查看代码 12345678910111213141516171819202122232425262728293031323334int start = 0, over = 0, first = 0;//指针int letters = 0, lines = 0, words = 0;//统计单词数，行数和字符数的变量int state;//状态变量class str//单词类&#123;public: int linenum;//行号 string Str;//单词 &#125;;//输出文件名string file_name;//返回单词或符号,从位置i开始查找，引用参数j返回这个单词最后一个字符在str的位置。string GetWord(string str, int i, int&amp; j);//除去字符串中连续的空格和换行。第一个参数为目标字符串，第二个参数为开始位置。返回值为第一个有效字符在字符串的位置int get_nbc(string str, int i);//文件输出函数，成功输出返回true，失败返回falsebool Output(vector&lt;pair&lt;string, string&gt; &gt; v);//词法分析主要算法函数，返回一个pair型数组vector&lt;pair&lt;string, string&gt; &gt; analyse(vector&lt;str&gt;&amp; vec);//此函数判断str是否为关键字，是的话，返回真，反之返回假bool IsKey(string str);//此函数判断C是否为字母，是的话，返回真，反之返回假bool letter(char C);//此函数判断C是否为数字，是的话，返回真，反之返回假bool digit(char C); 详细代码见文末github项目。 五、测试样例： 六、项目地址本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看：","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://666wxy666.github.io/categories/C-C/"},{"name":"编译原理","slug":"C-C/编译原理","permalink":"https://666wxy666.github.io/categories/C-C/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"编译原理","slug":"编译原理","permalink":"https://666wxy666.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"词法分析","slug":"词法分析","permalink":"https://666wxy666.github.io/tags/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"}]},{"title":"Python 项目集锦","slug":"Python-项目集锦","date":"2020-08-15T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/08/15/Python-项目集锦/","link":"","permalink":"https://666wxy666.github.io/2020/08/15/Python-%E9%A1%B9%E7%9B%AE%E9%9B%86%E9%94%A6/","excerpt":"本文是一些我曾经写过的Python项目工程集锦。","text":"本文是一些我曾经写过的Python项目工程集锦。 这些项目的源码、可执行程序、报告等已经存放于我的Github，欢迎下载查看： Python爬虫、数据处理、数据分析、数据可视化 学校和房价爬虫小项目 数据预处理小项目 房价数据分析小项目 数据可视化小项目 京东淘宝手机爬虫分析项目","categories":[{"name":"集锦","slug":"集锦","permalink":"https://666wxy666.github.io/categories/%E9%9B%86%E9%94%A6/"},{"name":"Python","slug":"集锦/Python","permalink":"https://666wxy666.github.io/categories/%E9%9B%86%E9%94%A6/Python/"}],"tags":[{"name":"集锦","slug":"集锦","permalink":"https://666wxy666.github.io/tags/%E9%9B%86%E9%94%A6/"},{"name":"Python","slug":"Python","permalink":"https://666wxy666.github.io/tags/Python/"}]},{"title":"机器学习 花卉识别","slug":"机器学习-实验-花卉识别","date":"2020-08-10T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/08/10/机器学习-实验-花卉识别/","link":"","permalink":"https://666wxy666.github.io/2020/08/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%AE%9E%E9%AA%8C-%E8%8A%B1%E5%8D%89%E8%AF%86%E5%88%AB/","excerpt":"本文是机器学习人工智能实验，利用华为云ModelArts平台实现花卉分类识别。","text":"本文是机器学习人工智能实验，利用华为云ModelArts平台实现花卉分类识别。 一、实验目的通过该实验，实现以下目标 熟悉ModelArts平台，能够调用平台的简单物体识别算法进行物体检测； 熟悉ModelArts平台特征提取方法，提取数据集的视觉特征； 熟悉ModelArts的神经网络架构，改进架构算法，进行目标检测算法的设计与实现。 学会评价检测算法的基本方法，对所设计的算法进行评估。 二、实验环境ModelArts平台 三、实验内容 四、实验步骤由于时间久远，详细内容请前往Github项目查看实验报告。 五、项目地址本项目的实验报告已经存放于我的Github，欢迎下载查看： 源码仓库","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://666wxy666.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"实验","slug":"机器学习/实验","permalink":"https://666wxy666.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://666wxy666.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"华为云","slug":"华为云","permalink":"https://666wxy666.github.io/tags/%E5%8D%8E%E4%B8%BA%E4%BA%91/"},{"name":"分类","slug":"分类","permalink":"https://666wxy666.github.io/tags/%E5%88%86%E7%B1%BB/"}]},{"title":"大数据实战 Spark 自选日志分析","slug":"大数据实战-Spark-自选日志分析","date":"2020-07-21T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/07/21/大数据实战-Spark-自选日志分析/","link":"","permalink":"https://666wxy666.github.io/2020/07/21/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%88%98-Spark-%E8%87%AA%E9%80%89%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/","excerpt":"本文是关于大数据通过Java进行Spark编程实现自选日志处理分析。","text":"本文是关于大数据通过Java进行Spark编程实现自选日志处理分析。 一、实验环境： 虚拟机数量：1 系统版本：Centos 7.5 Spark版本：Apache Spark 2.1.1 Eclipse版本：Neno.3 （4.6.3） 二、实验内容： 收集一组自选日志，构造mydata.log数据集，上传到实验环境中，重新完成对自选日志分析。 三、主要步骤： 获取自选数据集 自选数据集计算的需求分析 编程设计实现 运行程序 四、实验步骤：4.1获取自选数据集以及数据字段格式解释说明我受到平台的第一个实验和uber日志文件的启发，想到了自己用python生成uber日志文件，首先是日志的格式： 字段 数据类型 说明信息 dispatching_base_number String 区域编号 date String 日期 active_vehicles int 使用的机动车数量 trips int 旅游次数 定义好了日志的格式，只要编写python程序，让他自己按照这个格式生产日志即可，具体代码见附录，下面是部分代码截图和运行结果： 4.2自选数据集计算的需求分析因为是汽车和旅游日志信息，并且有不同日期，不同地区的信息，主要需求就是选取从开始时间到截止时间使用的机动车数量和旅游次数最多的前10个地区，以及他们的机动车总数量和旅游总次数。 主要步骤就是（与实验一大体相同，又有所区别）： 按照 Serrializable 接口实现自定义排序的 Key； 将要进行二次排序的文件加载进来生成 key-value 类型的 RDD 使用 sortByKey 基于自定义的 Key 进行二次排序 去除掉排序的 key，只保留排序结果 排序规则如下： 以区域编号dispatching_base_number为基准，分别按照active_vehicles，trips，date进行降序排序。即先按照active_vehicles排序，如果active_vehicles相同，再比较trips，如果trips相同，再比较date，最后选择前10条记录输出。 4.3编程设计实现4.3.1创建工程4.3.1.1打开Eclipse IDE 12cd eclipse/./eclipse &amp; 4.3.1.2点击 File -&gt; New -&gt;Other 4.3.1.3搜索 maven -&gt; 点击 Maven Project -&gt; Next-&gt;Next 4.3.1.4选中maven-archetype-quickstart -&gt;Next 4.3.1.5输入Group Id 为 org.zkpk；Artifact Id 为 spark ；Package为org.zkpk.spark；-&gt;Finish 4.3.1.6升级maven工程 升级完成： 4.3.1.7更改JRE，右键JRE System Library-&gt; Properties 4.3.1.8选中jdk1.8.0_131-&gt; OK 4.3.1.9点击spark项目-&gt;修改pom.xml-&gt; 保存会自动下载jar包 4.3.1.10下载Jar包： 4.3.1.11最终 pom.xml 如下： 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.zkpk&lt;/groupId&gt; &lt;artifactId&gt;spark&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;spark&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-core_2.10&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-sql_2.10&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-hive_2.10&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-streaming_2.10&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-streaming-kafka_2.10&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-streaming-flume_2.10&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.3.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpcore&lt;/artifactId&gt; &lt;version&gt;4.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;sourceDirectory&gt;src/main/java&lt;/sourceDirectory&gt; &lt;testSourceDirectory&gt;src/main/test&lt;/testSourceDirectory&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;archive&gt; &lt;manifest&gt; &lt;mainClass&gt;&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-assembly&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;exec&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;executable&gt;java&lt;/executable&gt; &lt;includeProjectDependencies&gt;true&lt;/includeProjectDependencies&gt; &lt;includePluginDependencies&gt;false&lt;/includePluginDependencies&gt; &lt;classpathScope&gt;compile&lt;/classpathScope&gt; &lt;mainClass&gt;cn.com.syl.spark.App&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.6&lt;/source&gt; &lt;target&gt;1.6&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 4.3.1.12删除工程生成的App.java和AppTest.java 利用实验一的实验环境编写java程序，同样是SecondarySortKey.java和SecondarySortDemo.java两个java文件。其中SecondarySortKey.java中有两个类，一个是serDemo类，用于存储未排序的数据，一个是SecondarySortKey类，里面重写了一系列排序函数，用于按照自己的规则排序；SecondarySortDemo.java有一个类SecondarySortDemo，里面有主函数和创建Spark RDD，求和，sortByKey等函数，是主要的逻辑运行的地方。 4.3.2这里只挑出关键的代码进行解释注释和说明，详细的带注释的代码见附录：这是排序的数据存放的类，有三个字段，全参构造函数，getter和setter，以及toString，hashCode和equal方法。 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class SecondarySortKey implements Ordered&lt;SecondarySortKey&gt;, Serializable &#123; private static final long serialVersionUID = 3702442700882342403L; //日期 private String date; //使用的机动车数量 private int activeVehicles; //旅游次数 private int trips; public SecondarySortKey() &#123; super(); &#125; public SecondarySortKey(String date, int activeVehicles, int trips) &#123; super(); this.date = date; this.activeVehicles = activeVehicles; this.trips = trips; &#125; ...... @Override public boolean equals(Object o) &#123; if (this == o) &#123; return true; &#125; if (o == null || getClass() != o.getClass()) &#123; return false; &#125; SecondarySortKey that = (SecondarySortKey) o; return activeVehicles == that.activeVehicles &amp;&amp; trips == that.trips &amp;&amp; Objects.equals(date, that.date); &#125; @Override public int hashCode() &#123; return Objects.hash(date, activeVehicles, trips); &#125; @Override public String toString() &#123; return &quot;SortResult&#123;&quot; + &quot;截止日期：&quot; + date + &quot;, 使用的机动车总数量：&quot; + activeVehicles + &quot;, 旅游总次数：&quot; + trips + &#x27;&#125;&#x27;; &#125;&#125; 最主要的是$greater，$less等一系列比较函数和compare和compareTo函数用于RDD的sortByKey。 点击查看代码 12345678910111213141516171819202122232425262728293031323334...... public boolean $greater(SecondarySortKey other) &#123; if (activeVehicles &gt; other.activeVehicles) &#123; return true; &#125; else if (activeVehicles == other.activeVehicles &amp;&amp; trips &gt; other.trips) &#123; return true; &#125; else if (activeVehicles == other.activeVehicles &amp;&amp; trips == other.trips &amp;&amp; date.compareTo(other.date) &gt; 0) &#123; return true; &#125; return false; &#125;...... public int compare(SecondarySortKey other) &#123; if (activeVehicles - other.activeVehicles != 0) &#123; return activeVehicles - other.activeVehicles; &#125; else if (trips - other.trips != 0) &#123; return trips - other.trips; &#125; return 0; &#125; public int compareTo(SecondarySortKey other) &#123; if (activeVehicles - other.activeVehicles != 0) &#123; return activeVehicles - other.activeVehicles; &#125; else if (trips - other.trips != 0) &#123; return trips - other.trips; &#125; return 0; &#125; 下面的类是主方法所在的类，也是主要的对数据进行处理计算的类： 他有四个函数（算上主函数），分别为： main： 用于打开文件，创建SparkConf和SparkContext对象，调用函数对RDD进行操作，并输出结果。 点击查看代码 12345678910111213141516public static void main(String[] args) throws Exception &#123; SparkConf conf = new SparkConf().setAppName(&quot;SecondarySortDemo&quot;).setMaster(&quot;local&quot;); JavaSparkContext jsc = new JavaSparkContext(conf); jsc.setLogLevel(&quot;WARN&quot;); JavaRDD&lt;String&gt; textfile = jsc.textFile(&quot;/home/zkpk/experiment/mydata.log&quot;); JavaPairRDD&lt;String, serDemo&gt; pairRdd = mapTfRDD2Pair(textfile); JavaPairRDD&lt;String, serDemo&gt; getlines = aggregateByDeviceID(pairRdd); JavaPairRDD&lt;SecondarySortKey, String&gt; telval = mapRDDKey2SortKey(getlines); JavaPairRDD&lt;SecondarySortKey, String&gt; sortedRdd = telval.sortByKey(false); List&lt;Tuple2&lt;SecondarySortKey, String&gt;&gt; getTop = sortedRdd.take(10); System.out.println(&quot;============ result ============&quot;); for (Tuple2&lt;SecondarySortKey, String&gt; dt : getTop) &#123; System.out.println(&quot;区域编号：&quot; + dt._2 + &quot;, &quot; + dt._1); &#125; jsc.close(); &#125; mapTfRDD2Pair： 用于从文件中读取数据，并将其转化为JavaPairRDD，key为区域编号dispatchingBaseNumber，value为以文件每一行生成的serDemo对象。 点击查看代码 123456789101112131415private static JavaPairRDD&lt;String, serDemo&gt; mapTfRDD2Pair(JavaRDD&lt;String&gt; accessLogRDD) &#123; return accessLogRDD.mapToPair(new PairFunction&lt;String, String, serDemo&gt;() &#123; private static final long serialVersionUID = 1L; public Tuple2&lt;String, serDemo&gt; call(String lines) throws Exception &#123; String[] split = lines.split(&quot;,&quot;); String dispatchingBaseNumber = split[0]; String date = split[1]; int activeVehicles = Integer.valueOf(split[2]); int trips = Integer.valueOf(split[3]); serDemo dataInfo = new serDemo(date, activeVehicles, trips); return new Tuple2&lt;String, serDemo&gt;(dispatchingBaseNumber, dataInfo); &#125; &#125;); &#125; aggregateByRegionID： 用于将mapTfRDD2Pair生成好的JavaPairRDD按照key对使用的机动车数量activeVehicles和旅游次数trips求和，获得JavaPairRDD，key为区域编号dispatchingBaseNumber，value为已经求和聚集完成的serDemo对象。 点击查看代码 12345678910111213141516private static JavaPairRDD&lt;String, serDemo&gt; aggregateByDeviceID(JavaPairRDD&lt;String, serDemo&gt; accessLogPairRDD) &#123; return accessLogPairRDD.reduceByKey(new Function2&lt;serDemo, serDemo, serDemo&gt;() &#123; private static final long serialVersionUID = 1L; public serDemo call(serDemo d1, serDemo d2) throws Exception &#123; String date = d1.getDate().compareTo(d2.getDate()) &gt; 0 ? d1.getDate() : d2.getDate(); int activeVehicles = d1.getActiveVehicles() + d2.getActiveVehicles(); int trips = d1.getTrips() + d2.getTrips(); serDemo accessLogInfo = new serDemo(); accessLogInfo.setDate(date); accessLogInfo.setActiveVehicles(activeVehicles); accessLogInfo.setTrips(trips); return accessLogInfo; &#125; &#125;);&#125; mapRDDKey2SortKey： 用于将aggregateByRegionID生成好的JavaPairRDD按照上面定义好的规则进行排序，获得排好序的JavaPairRDD，用于输出。 点击查看代码 123456789101112131415 private static JavaPairRDD&lt;SecondarySortKey, String&gt; mapRDDKey2SortKey( JavaPairRDD&lt;String, serDemo&gt; aggrAccessLogPairRDD) &#123; return aggrAccessLogPairRDD.mapToPair( new PairFunction&lt;Tuple2&lt;String, serDemo&gt;, SecondarySortKey, String&gt;() &#123; private static final long serialVersionUID = 1L; public Tuple2&lt;SecondarySortKey, String&gt; call(Tuple2&lt;String, serDemo&gt; tuple) throws Exception &#123; String dispatchingBaseNumber = tuple._1; serDemo accessLogInfo = tuple._2; SecondarySortKey accessLogSortKey = new SecondarySortKey(accessLogInfo.getDate(), accessLogInfo.getActiveVehicles(), accessLogInfo.getTrips()); return new Tuple2&lt;SecondarySortKey, String&gt;(accessLogSortKey, dispatchingBaseNumber); &#125; &#125;);&#125; 4.4运行程序4.4.1将生成好的mydata.log发送到平台。 4.4.2运行程序，查看结果。可以发现，程序正常运行得出了结果，并且已经求和和排序，成功！ 五、附录1、SecondarySortKey.java 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200package org.zkpk.spark;import scala.math.Ordered;import java.io.Serializable;import java.util.Objects;class serDemo implements Serializable &#123; private static final long serialVersionUID = 5749943279909593929L; //日期 private String date; //使用的机动车数量 private int activeVehicles; //旅游次数 private int trips; public serDemo() &#123; super(); &#125; public serDemo(String date, int activeVehicles, int trips) &#123; super(); this.date = date; this.activeVehicles = activeVehicles; this.trips = trips; &#125; public static long getSerialVersionUID() &#123; return serialVersionUID; &#125; public String getDate() &#123; return date; &#125; public void setDate(String date) &#123; this.date = date; &#125; public int getActiveVehicles() &#123; return activeVehicles; &#125; public void setActiveVehicles(int activeVehicles) &#123; this.activeVehicles = activeVehicles; &#125; public int getTrips() &#123; return trips; &#125; public void setTrips(int trips) &#123; this.trips = trips; &#125;&#125;public class SecondarySortKey implements Ordered&lt;SecondarySortKey&gt;, Serializable &#123; private static final long serialVersionUID = 3702442700882342403L; //日期 private String date; //使用的机动车数量 private int activeVehicles; //旅游次数 private int trips; public SecondarySortKey() &#123; super(); &#125; public SecondarySortKey(String date, int activeVehicles, int trips) &#123; super(); this.date = date; this.activeVehicles = activeVehicles; this.trips = trips; &#125; public static long getSerialVersionUID() &#123; return serialVersionUID; &#125; public String getDate() &#123; return date; &#125; public void setDate(String date) &#123; this.date = date; &#125; public int getActiveVehicles() &#123; return activeVehicles; &#125; public void setActiveVehicles(int activeVehicles) &#123; this.activeVehicles = activeVehicles; &#125; public int getTrips() &#123; return trips; &#125; public void setTrips(int trips) &#123; this.trips = trips; &#125; public boolean $greater(SecondarySortKey other) &#123; if (activeVehicles &gt; other.activeVehicles) &#123; return true; &#125; else if (activeVehicles == other.activeVehicles &amp;&amp; trips &gt; other.trips) &#123; return true; &#125; else if (activeVehicles == other.activeVehicles &amp;&amp; trips == other.trips &amp;&amp; date.compareTo(other.date) &gt; 0) &#123; return true; &#125; return false; &#125; public boolean $greater$eq(SecondarySortKey other) &#123; if ($greater(other)) &#123; return true; &#125; else if (activeVehicles == other.activeVehicles &amp;&amp; trips == other.trips &amp;&amp; date.compareTo(other.date) == 0) &#123; return true; &#125; return false; &#125; public boolean $less(SecondarySortKey other) &#123; if (activeVehicles &lt; other.activeVehicles) &#123; return true; &#125; else if (activeVehicles == other.activeVehicles &amp;&amp; trips &lt; other.trips) &#123; return true; &#125; else if (activeVehicles == other.activeVehicles &amp;&amp; trips == other.trips &amp;&amp; date.compareTo(other.date) &lt; 0) &#123; return true; &#125; return false; &#125; public boolean $less$eq(SecondarySortKey other) &#123; if ($less(other)) &#123; return true; &#125; else if (activeVehicles == other.activeVehicles &amp;&amp; trips == other.trips &amp;&amp; date.compareTo(other.date) == 0) &#123; return true; &#125; return false; &#125; public int compare(SecondarySortKey other) &#123; if (activeVehicles - other.activeVehicles != 0) &#123; return activeVehicles - other.activeVehicles; &#125; else if (trips - other.trips != 0) &#123; return trips - other.trips; &#125; return 0; &#125; public int compareTo(SecondarySortKey other) &#123; if (activeVehicles - other.activeVehicles != 0) &#123; return activeVehicles - other.activeVehicles; &#125; else if (trips - other.trips != 0) &#123; return trips - other.trips; &#125; return 0; &#125; @Override public boolean equals(Object o) &#123; if (this == o) &#123; return true; &#125; if (o == null || getClass() != o.getClass()) &#123; return false; &#125; SecondarySortKey that = (SecondarySortKey) o; return activeVehicles == that.activeVehicles &amp;&amp; trips == that.trips &amp;&amp; Objects.equals(date, that.date); &#125; @Override public int hashCode() &#123; return Objects.hash(date, activeVehicles, trips); &#125; @Override public String toString() &#123; return &quot;SortResult&#123;&quot; + &quot;截止日期：&quot; + date + &quot;, 使用的机动车总数量：&quot; + activeVehicles + &quot;, 旅游总次数：&quot; + trips + &#x27;&#125;&#x27;; &#125;&#125; 2、SecondarySortDemo.java 点击查看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package org.zkpk.spark;import org.apache.spark.SparkConf;import org.apache.spark.api.java.JavaPairRDD;import org.apache.spark.api.java.JavaRDD;import org.apache.spark.api.java.JavaSparkContext;import org.apache.spark.api.java.function.Function2;import org.apache.spark.api.java.function.PairFunction;import scala.Tuple2;import java.util.List;public class SecondarySortDemo &#123; public static void main(String[] args) throws Exception &#123; SparkConf conf = new SparkConf().setAppName(&quot;SecondarySortDemo&quot;).setMaster(&quot;local&quot;); JavaSparkContext jsc = new JavaSparkContext(conf); jsc.setLogLevel(&quot;WARN&quot;); JavaRDD&lt;String&gt; textfile = jsc.textFile(&quot;/home/zkpk/experiment/mydata.log&quot;); JavaPairRDD&lt;String, serDemo&gt; pairRdd = mapTfRDD2Pair(textfile); JavaPairRDD&lt;String, serDemo&gt; getlines = aggregateByRegionID(pairRdd); JavaPairRDD&lt;SecondarySortKey, String&gt; telval = mapRDDKey2SortKey(getlines); JavaPairRDD&lt;SecondarySortKey, String&gt; sortedRdd = telval.sortByKey(false); List&lt;Tuple2&lt;SecondarySortKey, String&gt;&gt; getTop = sortedRdd.take(10); System.out.println(&quot;============ result ============&quot;); for (Tuple2&lt;SecondarySortKey, String&gt; dt : getTop) &#123; System.out.println(&quot;区域编号：&quot; + dt._2 + &quot;, &quot; + dt._1); &#125; jsc.close(); &#125; //从文件读取生成PairRDD private static JavaPairRDD&lt;String, serDemo&gt; mapTfRDD2Pair(JavaRDD&lt;String&gt; accessLogRDD) &#123; return accessLogRDD.mapToPair(new PairFunction&lt;String, String, serDemo&gt;() &#123; private static final long serialVersionUID = 1L; public Tuple2&lt;String, serDemo&gt; call(String lines) throws Exception &#123; String[] split = lines.split(&quot;,&quot;); String dispatchingBaseNumber = split[0]; String date = split[1]; int activeVehicles = Integer.valueOf(split[2]); int trips = Integer.valueOf(split[3]); serDemo dataInfo = new serDemo(date, activeVehicles, trips); return new Tuple2&lt;String, serDemo&gt;(dispatchingBaseNumber, dataInfo); &#125; &#125;); &#125; //对PairRDD进行reduceByKey聚集操作求和 private static JavaPairRDD&lt;String, serDemo&gt; aggregateByRegionID(JavaPairRDD&lt;String, serDemo&gt; accessLogPairRDD) &#123; return accessLogPairRDD.reduceByKey(new Function2&lt;serDemo, serDemo, serDemo&gt;() &#123; private static final long serialVersionUID = 1L; public serDemo call(serDemo d1, serDemo d2) throws Exception &#123; String date = d1.getDate().compareTo(d2.getDate()) &gt; 0 ? d1.getDate() : d2.getDate(); int activeVehicles = d1.getActiveVehicles() + d2.getActiveVehicles(); int trips = d1.getTrips() + d2.getTrips(); serDemo accessLogInfo = new serDemo(); accessLogInfo.setDate(date); accessLogInfo.setActiveVehicles(activeVehicles); accessLogInfo.setTrips(trips); return accessLogInfo; &#125; &#125;); &#125; //对PairRDD进行排序，用于最后输出 private static JavaPairRDD&lt;SecondarySortKey, String&gt; mapRDDKey2SortKey( JavaPairRDD&lt;String, serDemo&gt; aggrAccessLogPairRDD) &#123; return aggrAccessLogPairRDD.mapToPair( new PairFunction&lt;Tuple2&lt;String, serDemo&gt;, SecondarySortKey, String&gt;() &#123; private static final long serialVersionUID = 1L; public Tuple2&lt;SecondarySortKey, String&gt; call(Tuple2&lt;String, serDemo&gt; tuple) throws Exception &#123; String dispatchingBaseNumber = tuple._1; serDemo accessLogInfo = tuple._2; SecondarySortKey accessLogSortKey = new SecondarySortKey(accessLogInfo.getDate(), accessLogInfo.getActiveVehicles(), accessLogInfo.getTrips()); return new Tuple2&lt;SecondarySortKey, String&gt;(accessLogSortKey, dispatchingBaseNumber); &#125; &#125;); &#125;&#125; 3、log_generate.py 点击查看代码 123456789101112131415161718192021222324252627282930# -*- coding: UTF-8 -*-import randomimport stringimport timefile = open(&quot;mydata.log&quot;, mode=&#x27;a&#x27;)ch = string.ascii_uppercasedispatching_base_number_list = []for j in range(20): dispatching_base_number_list.append(random.choice(ch) + str(random.randint(1, 9)))for i in range(100): for dispatching_base_number in dispatching_base_number_list: file.write(dispatching_base_number + &quot;,&quot; + time.strftime(&quot;%Y-%m-%d&quot;, time.gmtime( time.mktime( time.strptime(&quot;2020-01-02&quot;, &quot;%Y-%m-%d&quot;)) + 86400 * i)) + &quot;,&quot; + str(random.randint(100, 10000)) + &quot;,&quot; + str(random.randint(1000, 100000)) + &quot;\\n&quot;) if i == 99 and dispatching_base_number == dispatching_base_number_list[len(dispatching_base_number_list) - 1]: file.write(dispatching_base_number + &quot;,&quot; + time.strftime(&quot;%Y-%m-%d&quot;, time.gmtime( time.mktime( time.strptime(&quot;2020-01-02&quot;, &quot;%Y-%m-%d&quot;)) + 86400 * i)) + &quot;,&quot; + str(random.randint(100, 10000)) + &quot;,&quot; + str(random.randint(1000, 100000)))file.close()","categories":[{"name":"大数据","slug":"大数据","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"实战","slug":"大数据/实战","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://666wxy666.github.io/tags/Java/"},{"name":"大数据","slug":"大数据","permalink":"https://666wxy666.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Spark","slug":"Spark","permalink":"https://666wxy666.github.io/tags/Spark/"},{"name":"Scala","slug":"Scala","permalink":"https://666wxy666.github.io/tags/Scala/"},{"name":"Streaming","slug":"Streaming","permalink":"https://666wxy666.github.io/tags/Streaming/"},{"name":"Kafka","slug":"Kafka","permalink":"https://666wxy666.github.io/tags/Kafka/"}]},{"title":"大数据实战 Spark 分析流量日志","slug":"大数据实战-Spark-分析流量日志","date":"2020-07-20T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/07/20/大数据实战-Spark-分析流量日志/","link":"","permalink":"https://666wxy666.github.io/2020/07/20/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%88%98-Spark-%E5%88%86%E6%9E%90%E6%B5%81%E9%87%8F%E6%97%A5%E5%BF%97/","excerpt":"本文是关于大数据通过Java进行Spark编程实现日志处理分析。","text":"本文是关于大数据通过Java进行Spark编程实现日志处理分析。 一、实验环境： 虚拟机数量：1 系统版本：Centos 7.5 Spark版本：Apache Spark 2.1.1 Eclipse版本：Neno.3 （4.6.3） 二、实验目的：掌握 Spark原理 Hadoop原理 Shell Spark Streaming 二次排序 序列化 Spark RDD 三、实验结果： 以下是分析后的流量日志结果： 四、实验内容： 使用SparkStreaming构建实时数据处理系统，来分析手机流量日志。 五、主要步骤： 日志分析 代码实现 运行程序 六、实验步骤：6.1数据日志介绍6.1.1数据字段 6.1.1.1reportTime（报告时间戳） 6.1.1.2telNum（手机号） 6.1.1.3upwardflow（上行总流量） 6.1.1.4downwardflow（下行总流量） 6.2需求分析6.2.1对文本中数据记录进行排序，排序规则如下： 以telNum为基准，分别按照 upwardflow，downwardflow，reportTime进行降序排序，即先按照upwardflow排序，如果upwardflow相同，再比较downwardflow，如果downwardflow相同，再比较reportTime，最后选择前10条记录输出。 6.2.2具体实现步骤： 6.2.2.1按照 Serrializable 接口实现自定义排序的 Key 6.2.2.2将要进行二次排序的文件加载进来生成 key-value 类型的 RDD 6.2.2.3使用 sortByKey 基于自定义的 Key 进行二次排序 6.2.2.4去除掉排序的 key，只保留排序结果 6.3代码实现：6.3.1创建maven项目6.3.1.1打开Eclipse IDE 12cd eclipse/./eclipse &amp; 6.3.1.2点击 File -&gt; New -&gt;Other 6.3.1.3搜索 maven -&gt; 点击 Maven Project -&gt; Next-&gt;Next 6.3.1.4选中maven-archetype-quickstart -&gt;Next 6.3.1.5输入Group Id 为 org.zkpk；Artifact Id 为 spark ；Package为org.zkpk.spark；-&gt;Finish 6.3.1.6升级maven工程 升级完成： 6.3.1.7更改JRE，右键JRE System Library-&gt; Properties 6.3.1.8选中jdk1.8.0_131-&gt; OK 6.3.1.9点击spark项目-&gt;修改pom.xml-&gt; 保存会自动下载jar包 6.3.1.10下载Jar包： 6.3.1.11最终 pom.xml 如下： 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.zkpk&lt;/groupId&gt; &lt;artifactId&gt;spark&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;spark&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-core_2.10&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-sql_2.10&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-hive_2.10&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-streaming_2.10&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-streaming-kafka_2.10&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-streaming-flume_2.10&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.3.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpcore&lt;/artifactId&gt; &lt;version&gt;4.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;sourceDirectory&gt;src/main/java&lt;/sourceDirectory&gt; &lt;testSourceDirectory&gt;src/main/test&lt;/testSourceDirectory&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;archive&gt; &lt;manifest&gt; &lt;mainClass&gt;&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-assembly&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;exec&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;executable&gt;java&lt;/executable&gt; &lt;includeProjectDependencies&gt;true&lt;/includeProjectDependencies&gt; &lt;includePluginDependencies&gt;false&lt;/includePluginDependencies&gt; &lt;classpathScope&gt;compile&lt;/classpathScope&gt; &lt;mainClass&gt;cn.com.syl.spark.App&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.6&lt;/source&gt; &lt;target&gt;1.6&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 6.3.1.12删除工程生成的App.java和AppTest.java 6.3.2编写代码6.3.2.1在src/main/java中创建类，并命名为SecondarySortKey.java，然后按Finish 6.3.2.1.1创建SecondarySortKey.java，代码见附录 6.3.2.1.2在src/main/java中创建类，并命名为SecondarySortDemo，然后按Finish 6.3.2.1.3创建SecondarySortDemo.java代码见附录 6.3.2.1.4运行SecondarySortDemo，观察控制台输出 6.3.2.1.5右键SecondarySortDemo.java -&gt; Run As -&gt; Java Application 最终结果： 七、附录1、SecondarySortKey.java 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174package org.zkpk.spark;import java.io.Serializable;import scala.math.Ordered;class serDemo implements Serializable &#123; private static final long serialVersionUID = 5749943279909593929L; private long reportTime; // 时间戳 private long upwardflow; // 上行总流量 private long downwardflow; // 下行总流量 public serDemo() &#123; super(); // TODO Auto-generated constructor stub &#125; public serDemo(long reportTime, long upwardflow, long downwardflow) &#123; super(); this.reportTime = reportTime; this.upwardflow = upwardflow; this.downwardflow = downwardflow; &#125; public long getReportTime() &#123; return reportTime; &#125; public void setReportTime(long reportTime) &#123; this.reportTime = reportTime; &#125; public long getUpwardflow() &#123; return upwardflow; &#125; public void setUpwardflow(long upwardflow) &#123; this.upwardflow = upwardflow; &#125; public long getDownwardflow() &#123; return downwardflow; &#125; public void setDownwardflow(long downwardflow) &#123; this.downwardflow = downwardflow; &#125; public static long getSerialversionuid() &#123; return serialVersionUID; &#125;&#125;public class SecondarySortKey implements Ordered&lt;SecondarySortKey&gt;, Serializable &#123; private static final long serialVersionUID = 3702442700882342403L; private long upwardflow; private long downwardflow; private long reportTime; public SecondarySortKey() &#123; super(); // TODO Auto-generated constructor stub &#125; public SecondarySortKey(long upwardflow, long downwardflow, long reportTime) &#123; super(); this.upwardflow = upwardflow; this.downwardflow = downwardflow; this.reportTime = reportTime; &#125; public long getUpwardflow() &#123; return upwardflow; &#125; public void setUpwardflow(long upwardflow) &#123; this.upwardflow = upwardflow; &#125; public long getDownwardflow() &#123; return downwardflow; &#125; public void setDownwardflow(long downwardflow) &#123; this.downwardflow = downwardflow; &#125; public long getReportTime() &#123; return reportTime; &#125; public void setReportTime(long reportTime) &#123; this.reportTime = reportTime; &#125; public static long getSerialversionuid() &#123; return serialVersionUID; &#125; public boolean $greater(SecondarySortKey other) &#123; if(upwardflow &gt; other.upwardflow) &#123; return true; &#125; else if(upwardflow == other.upwardflow &amp;&amp; downwardflow &gt; other.downwardflow) &#123; return true; &#125; else if(upwardflow == other.upwardflow &amp;&amp; downwardflow == other.downwardflow &amp;&amp; reportTime &gt; other.reportTime) &#123; return true; &#125; return false; &#125; public boolean $greater$eq(SecondarySortKey other) &#123; if($greater(other)) &#123; return true; &#125; else if(upwardflow == other.upwardflow &amp;&amp; downwardflow == other.downwardflow &amp;&amp; reportTime == other.reportTime) &#123; return true; &#125; return false; &#125; public boolean $less(SecondarySortKey other) &#123; if(upwardflow &lt; other.upwardflow) &#123; return true; &#125; else if(upwardflow == other.upwardflow &amp;&amp; downwardflow &lt; other.downwardflow) &#123; return true; &#125; else if(upwardflow == other.upwardflow &amp;&amp; downwardflow == other.downwardflow &amp;&amp; reportTime &lt; other.reportTime) &#123; return true; &#125; return false; &#125; public boolean $less$eq(SecondarySortKey other) &#123; if($less(other)) &#123; return true; &#125; else if(upwardflow == other.upwardflow &amp;&amp; downwardflow == other.downwardflow &amp;&amp; reportTime == other.reportTime) &#123; return true; &#125; return false; &#125; public int compare(SecondarySortKey other) &#123; if(upwardflow - other.upwardflow != 0) &#123; return (int) (upwardflow - other.upwardflow); &#125; else if(downwardflow - other.downwardflow != 0) &#123; return (int) (downwardflow - other.downwardflow); &#125; else if(reportTime - other.reportTime != 0) &#123; return (int) (reportTime - other.reportTime); &#125; return 0; &#125; public int compareTo(SecondarySortKey other) &#123; if(upwardflow - other.upwardflow != 0) &#123; return (int) (upwardflow - other.upwardflow); &#125; else if(downwardflow - other.downwardflow != 0) &#123; return (int) (downwardflow - other.downwardflow); &#125; else if(reportTime - other.reportTime != 0) &#123; return (int) (reportTime - other.reportTime); &#125; return 0; &#125; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + (int) (downwardflow ); result = prime * result + (int) (reportTime ); result = prime * result + (int) (upwardflow ); return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; SecondarySortKey other = (SecondarySortKey) obj; if (downwardflow != other.downwardflow) return false; if (reportTime != other.reportTime) return false; if (upwardflow != other.upwardflow) return false; return true; &#125; @Override public String toString() &#123; return &quot;SortResult： [上行总流量： &quot; + upwardflow + &quot;, 下行总流量： &quot; + downwardflow + &quot;, 时间戳：&quot; + reportTime + &quot;]&quot;; &#125;&#125; 2、SecondarySortDemo.java 点击查看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package org.zkpk.spark;import java.util.List;import org.apache.spark.SparkConf;import org.apache.spark.api.java.JavaPairRDD;import org.apache.spark.api.java.JavaRDD;import org.apache.spark.api.java.JavaSparkContext;import org.apache.spark.api.java.function.Function2;import org.apache.spark.api.java.function.PairFunction;import scala.Tuple2;public class SecondarySortDemo &#123; public static void main(String[] args) throws Exception &#123; // 创建sparkcontext对象，sparkcontext是程序的唯一入口 SparkConf conf = new SparkConf().setAppName(&quot;SecondarySortDemo&quot;).setMaster(&quot;local&quot;); JavaSparkContext jsc = new JavaSparkContext(conf); // 去掉WARN类的输出信息 jsc.setLogLevel(&quot;WARN&quot;); // 调用textFile()方法，读取日志文件，这里指定本地磁盘文件 JavaRDD&lt;String&gt; textfile = jsc.textFile(&quot;/home/zkpk/experiment/data.log&quot;); // 调用mapTfRDD2Pair方法 将tf映射为键值对 JavaPairRDD&lt;String, serDemo&gt; pairRdd = mapTfRDD2Pair(textfile); // 获取每个手机号的总上行流量、总下行流量、最早报告时间戳 JavaPairRDD&lt;String, serDemo&gt; getlines = aggregateByDeviceID(pairRdd); // 聚合，封装的RDD作为key,手机号作为值 JavaPairRDD&lt;SecondarySortKey, String&gt; telval = mapRDDKey2SortKey(getlines); // 依次按照上行流量、下行流量以及时间戳倒序排序 JavaPairRDD&lt;SecondarySortKey, String&gt; sortedRdd = telval.sortByKey(false); // 根据您的需要获得输出，这里仅显示前10行 List&lt;Tuple2&lt;SecondarySortKey, String&gt;&gt; getTop = sortedRdd.take(10); System.out.println(&quot;============ result ============&quot;); for (Tuple2&lt;SecondarySortKey, String&gt; dt : getTop) &#123; System.out.println(&quot;telNum: &quot; + dt._2 + &quot;, &quot; + dt._1); &#125; // 执行结束关闭资源 jsc.close(); &#125; // mapTfRDD2Pair方法，封装键值对 private static JavaPairRDD&lt;String, serDemo&gt; mapTfRDD2Pair(JavaRDD&lt;String&gt; accessLogRDD) &#123; return accessLogRDD.mapToPair(new PairFunction&lt;String, String, serDemo&gt;() &#123; private static final long serialVersionUID = 1L; @Override public Tuple2&lt;String, serDemo&gt; call(String lines) throws Exception &#123; // 根据数据格式进行切分 String[] split = lines.split(&quot;\\t&quot;); // 获取切分的字段 long reportTime = Long.valueOf(split[0]); String telNum = split[1]; long upwardflow = Long.valueOf(split[2]); long downwardflow = Long.valueOf(split[3]); // 创建cmbInfo对象，有参构造 ，将上行流量、下行流量，报告时间戳封装为自定义的可序列化对象 serDemo dataInfo = new serDemo(reportTime, upwardflow, downwardflow); return new Tuple2&lt;String, serDemo&gt;(telNum, dataInfo); &#125; &#125;); &#125; // 根据手机号进行聚合，依次按照上行流量、下行流量以及报告时间戳倒序排序 private static JavaPairRDD&lt;String, serDemo&gt; aggregateByDeviceID(JavaPairRDD&lt;String, serDemo&gt; accessLogPairRDD) &#123; return accessLogPairRDD.reduceByKey(new Function2&lt;serDemo, serDemo, serDemo&gt;() &#123; private static final long serialVersionUID = 1L; @Override public serDemo call(serDemo d1, serDemo d2) throws Exception &#123; long reportTime = d1.getReportTime() &lt; d2.getReportTime() ? d1.getReportTime() : d2.getReportTime(); long upwardflow = d1.getUpwardflow() + d2.getUpwardflow(); long downwardflow = d1.getDownwardflow() + d2.getDownwardflow(); serDemo accessLogInfo = new serDemo(); accessLogInfo.setReportTime(reportTime); accessLogInfo.setUpwardflow(upwardflow); accessLogInfo.setDownwardflow(downwardflow); return accessLogInfo; &#125; &#125;); &#125; // 二次排序，手机号作为值 private static JavaPairRDD&lt;SecondarySortKey, String&gt; mapRDDKey2SortKey( JavaPairRDD&lt;String, serDemo&gt; aggrAccessLogPairRDD) &#123; return aggrAccessLogPairRDD.mapToPair( new PairFunction&lt;Tuple2&lt;String, serDemo&gt;, SecondarySortKey, String&gt;() &#123; private static final long serialVersionUID = 1L; @Override public Tuple2&lt;SecondarySortKey, String&gt; call(Tuple2&lt;String, serDemo&gt; tuple) throws Exception &#123; // 获取元祖里的数据 String telNum = tuple._1; serDemo accessLogInfo = tuple._2; // 封装为二次排序key SecondarySortKey accessLogSortKey = new SecondarySortKey(accessLogInfo.getUpwardflow(), accessLogInfo.getDownwardflow(), accessLogInfo.getReportTime()); // 返回新的Tuple return new Tuple2&lt;SecondarySortKey, String&gt;(accessLogSortKey, telNum); &#125; &#125;); &#125;&#125;","categories":[{"name":"大数据","slug":"大数据","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"实战","slug":"大数据/实战","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://666wxy666.github.io/tags/Java/"},{"name":"大数据","slug":"大数据","permalink":"https://666wxy666.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Spark","slug":"Spark","permalink":"https://666wxy666.github.io/tags/Spark/"},{"name":"流计算","slug":"流计算","permalink":"https://666wxy666.github.io/tags/%E6%B5%81%E8%AE%A1%E7%AE%97/"},{"name":"Streaming","slug":"Streaming","permalink":"https://666wxy666.github.io/tags/Streaming/"},{"name":"日志","slug":"日志","permalink":"https://666wxy666.github.io/tags/%E6%97%A5%E5%BF%97/"}]},{"title":"C和C++的struct使用总结","slug":"C和C++的struct使用总结","date":"2020-07-15T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/07/15/C和C++的struct使用总结/","link":"","permalink":"https://666wxy666.github.io/2020/07/15/C%E5%92%8CC++%E7%9A%84struct%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/","excerpt":"简单的写了一下关于C语言和C++中的Struct结构体的定义的疑惑点和C99新增的柔性数组的使用和理解。","text":"简单的写了一下关于C语言和C++中的Struct结构体的定义的疑惑点和C99新增的柔性数组的使用和理解。 一、关于C语言和C++中的Struct结构体的定义1、C语言对于C语言，结构体的定义可以是以下的标准定义法： 点击查看代码 1234567891011121314#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct TEST&#123; int a;&#125;;int main(int argc, char const *argv[])&#123; struct TEST test; test.a = 1; printf(&quot;%d\\n&quot;, test.a); return 0;&#125; 像这样就定义了一个结构体TEST，在声明新结构体变量时，需要使用“struct TEST test”，“struct”必须有，不写会报错，“struct TEST”就相当于是“int”。 直接在结构体里赋初值是不允许的，例如： 点击查看代码 12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct TEST&#123; int a = 1;&#125;;int main(int argc, char const *argv[])&#123; struct TEST test; printf(&quot;%d\\n&quot;, test.a); return 0;&#125; 会产生如下错误： 另外，除了标准定义法，C语言还支持直接在定义结构体的时候声明变量，以及给结构体重命名： 点击查看代码 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct TEST1&#123; int a;&#125; test1;typedef struct TEST2&#123; int a;&#125; TEST2;int main(int argc, char const *argv[])&#123; struct TEST1 test11; TEST2 test2; struct TEST2 test22; test1.a = 1; test2.a = 2; test11.a = 11; test22.a = 22; printf(&quot;%d,%d,%d,%d\\n&quot;, test1.a, test2.a, test11.a, test22.a); return 0;&#125; 可以看出，TEST1是直接在定义结构体时就声明了一个变量test1，在下面可以直接使用test1访问结构体成员a，另外你仍然可以在后面使用标准方法定义新的TEST1结构体。 而对于TEST2，则是使用“typedef”将“struct TEST2”起了个别名叫“TEST2”，因此后面既可以使用struct TEST2”也可以使用“TEST2”声明TEST2结构体变量。 在定义结构体的时候，你也可以省略TEST1或者TEST2不写，但是这样对于没有起别名的TEST1就只能在定义结构体的时候声明结构体变量，在后面不能定义（因为没有名字，很好理解），相当于是一次性的结构体。但是对于起了别名的TEST2，在后面就只能使用TEST2来声明结构体变量，而不能再使用标准的“struct TEST2”。 点击查看代码 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct&#123; int a;&#125; test1;typedef struct&#123; int a;&#125; TEST2;int main(int argc, char const *argv[])&#123; TEST2 test2; test1.a = 1; test2.a = 2; printf(&quot;%d,%d\\n&quot;, test1.a, test2.a); return 0;&#125; 2、C++对于C++，因为C++是面向对象的程序设计语言，结构体struct就相当于是C++的类class，只是默认继承访问权限不同，class默认的是private，strcut默认的是public。你甚至可以在结构体定义函数，这是在C语言里不允许的，并且C++也允许声明结构体变量时省略“struct”，这个在C语言里也不允许，除非使用typedef起别名。 点击查看代码 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;struct TEST&#123; int a = 1; void hello() &#123; cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; &#125;;&#125;;int main(int argc, char const *argv[])&#123; struct TEST test1; TEST test2; cout &lt;&lt; test1.a &lt;&lt; endl; test2.hello(); return 0;&#125; 当然，C++也允许对类或者结构体起别名： 点击查看代码 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;typedef struct TEST&#123; int a = 1; void hello() &#123; cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; &#125;;&#125; T;int main(int argc, char const *argv[])&#123; struct TEST test1; TEST test2; T test3; cout &lt;&lt; test1.a &lt;&lt; endl; test2.hello(); test3.hello(); return 0;&#125; 直接在定义结构体的时候声明变量也可以： 点击查看代码 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;struct TEST&#123; int a = 1; void hello() &#123; cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; &#125;;&#125; test3;int main(int argc, char const *argv[])&#123; struct TEST test1; TEST test2; cout &lt;&lt; test1.a &lt;&lt; endl; test2.hello(); test3.hello(); return 0;&#125; 二、关于C99新增的柔性数组在C99中，结构中的最后一个元素允许是未知大小的数组，这就叫做柔性数组成员，但结构中的柔性数组成员前面必须至少一个其他成员。柔性数组成员允许结构中包含一个大小可变的数组。sizeof返回的这种结构大小不包括柔性数组的内存。包含柔性数组成员的结构用malloc函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。 例如： 点击查看代码 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct TEST&#123; int a; char b[];&#125; T;int main(int argc, char const *argv[])&#123; T test; T *test_ptr; test.a = 1; printf(&quot;%d,%d,%d,%d\\n&quot;, test.a, sizeof(T), sizeof(test), sizeof(*test_ptr)); return 0;&#125; 我们可以发现，结构体的大小确实等于一个整型的大小4字节，也就是a的大小，b数组是没有占空间的。对于编译器来说，此时长度为0的数组并不占用空间，因为数组名本身不占空间，它只是一个偏移量，数组名这个符号本身代表了一个不可修改的地址常量 ，但对于这个数组的大小，我们可以进行动态分配。当我们对结构体指针test_ptr进行malloc分配内存空间，分配的空间减去sizeof(T)就是柔性数组b的空间，我们就可以对b操作了。其实，b就是柔性数组，或者叫动态数组。这个操作常用于缓冲区或者网络通信中构造不定长数据包。 例如： 点击查看代码 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct TEST&#123; int a; char b[];&#125; T;int main(int argc, char const* argv[])&#123; T* test_ptr; test_ptr = (T*)malloc(sizeof(T) + 10 * sizeof(char)); test_ptr-&gt;a = 10; strcpy(test_ptr-&gt;b, &quot;aaaaaaaaa&quot;); printf(&quot;%d,%d,%s\\n&quot;, sizeof(*test_ptr), test_ptr-&gt;a, test_ptr-&gt;b); free(test_ptr); return 0;&#125; 可以发现T的大小依然是4字节，因此b明确来说不算是结构体成员。但是我们却可以使用长度为10的数组b。但为什么我只能复制9个a到数组b呢，其实9个a的字符串长度就是10，因为常量字符串最后一个字符是‘\\0’，用于标志字符串而结束，因此实际上b[9]是‘\\0’。那如果我们此时强制访问越界会怎么样呢？ 点击查看代码 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct TEST&#123; int a; char b[];&#125; T;int main(int argc, char const* argv[])&#123; T* test_ptr; test_ptr = (T*)malloc(sizeof(T) + 10 * sizeof(char)); test_ptr-&gt;a = 10; strcpy(test_ptr-&gt;b, &quot;aaaaaaaaabbbbbbbbbb&quot;); printf(&quot;%d,%d,%s\\n&quot;, sizeof(*test_ptr), test_ptr-&gt;a, test_ptr-&gt;b); free(test_ptr); return 0;&#125; 可以发现产生了异常，但是后面的b却被成功打印了出来。经过调试，发现是free语句产生的异常，如果我们把free语句注释掉，就能正常跑了，但是显然不应该这么做，原因是什么呢？ 点击查看代码 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct TEST&#123; int a; char b[];&#125; T;int main(int argc, char const* argv[])&#123; T* test_ptr; test_ptr = (T*)malloc(sizeof(T) + 10 * sizeof(char)); test_ptr-&gt;a = 10; strcpy(test_ptr-&gt;b, &quot;aaaaaaaaabbbbbbbbbb&quot;); printf(&quot;%d,%d,%s\\n&quot;, sizeof(*test_ptr), test_ptr-&gt;a, test_ptr-&gt;b); // free(test_ptr); return 0;&#125; 其实，在动态分配的时候，会在数组界限外加一个用来标识数组范围的标志，例如b数组，就会在b[-1]和b[10]有两个标志，如果我们在这两个位置赋值，赋值和调用时并不会出错，而是在freed掉b申请的内存时出错，错误的名称就是“before Normal block”或“after Normal block”，一般是后者居多。 那么这个柔性数组相比与在结构体里的动态数组有什么优势呢？从上面的代码也能看出，如果使用普通的动态数组，需要分配两块内存，即动态数组的内存和结构体的内存，在释放时也要先释放b的内存，再释放test_ptr的内存，比较麻烦。但是柔性数组就完全不需要，直接申请结构体的内存即可，释放时也只需要释放结构体申请的内存，非常方便。 还有一点要说明的是：在C99之前是不支持灵活数组成员（Fleible Array Member，int a[]）的，C99把它作为一种特例加入了标准。但是，C99所支持的是Incomplete Type（int a[]），而不是Zero Array（int a[0]）。也就是说类似“int a[0];”这种形式是非法的，只不过有些编译器把“int a[0];”作为非标准扩展来支持，而且在C99发布之前已经有了这种非标准扩展了，C99发布之后，有些编译器把两者合而为一了而已。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://666wxy666.github.io/categories/C-C/"},{"name":"拓展学习","slug":"C-C/拓展学习","permalink":"https://666wxy666.github.io/categories/C-C/%E6%8B%93%E5%B1%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"C","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"难点","slug":"难点","permalink":"https://666wxy666.github.io/tags/%E9%9A%BE%E7%82%B9/"}]},{"title":"C++工程项目 单词消除游戏","slug":"C++工程项目-单词消除游戏","date":"2020-07-12T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/07/12/C++工程项目-单词消除游戏/","link":"","permalink":"https://666wxy666.github.io/2020/07/12/C++%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE-%E5%8D%95%E8%AF%8D%E6%B6%88%E9%99%A4%E6%B8%B8%E6%88%8F/","excerpt":"本文是C++面向对象的程序设计实战项目，实现单词消除游戏，具体项目及要求请点击查看。","text":"本文是C++面向对象的程序设计实战项目，实现单词消除游戏，具体项目及要求请点击查看。 一、单词消除游戏总体要求单词消除游戏由两类参与者组成：闯关者（即游戏玩家），出题者（为游戏增加游戏中使用单词）。游戏规则为，游戏每一轮，程序会根据该关卡难度，显示一个单词，一定时间后单词消失。闯关者需要在相应地方输入刚刚显示并消失的单词，如果闯关者输入正确（即闯关者输入的单词与刚刚显示的单词完全一致，包含大小写）则为通过。一关可以由一轮或者多轮组成。 二、单词消除游戏具体要求 Version1 实现闯关者，出题者本地的注册、登录。 程序支持多人注册，同一时间只有一人可以登录。 实现游戏规则：出题者增加游戏中使用单词。游戏每一关，程序会根据该关卡难度，显示一个单词，一定时间后单词消失。闯关者需要在相应地方输入刚刚显示并消失的单词，如果闯关者输入正确则为通过。 任何角色均可查询所有闯关者、出题者，按照属性查找相应闯关者、出题者。 采用面向对象的方式，使用类设计。 在设计类时请注意类的继承关系，关注闯关者、出题者的关联（闯关者与出题者有共同的基类）。 使用文件或者数据库作为存储对象，自行设计文件格式，或者数据库表结构。 Version2 在Version1的基础上增加： 可以根据闯关者闯过关卡数、经验、等级等对闯关者排名，根据出题者出题数目、等级对出题者排名。 请根据要求设计每一关的出题方式，注意随着关卡数增加，题目难度增加 计闯关者经验值，等级增加策略。设计出题者等级升级策略。 Version3 在Version2的基础上增加： 使用socket进行通信，实现局域网通信游玩。 需要完成服务器端程序，以及客户端程序。客户端可以启动多个同时与服务器交互，要求服务器具有并发处理能力。 在题目的要求下自行扩展功能，功能扩展适当者酌情加分。 三、运行环境电脑硬件配置： 处理器：Intel i7 7700HQ 显卡：NVIDIA GeForce GTX 1050 Ti 内存：16GB 编程语言：C++ QT：Qt Creator 4.11.1 Based on Qt 5.14.1 (MSVC 2017, 32 bit) 编译器：Desktop Qt 5.14.2 MinGW 7.3.0 64-bit 数据库：mysql Ver 8.0.20 for Win64 on x86_64 (MySQL Community Server - GPL) 其它说明： 关于QT数据库驱动 libmysql.dll和libqsqlmysql.a放入【…\\Qt5.14.2\\5.14.2\\mingw73_64\\bin】下。 qsqlmysql.dll和qsqlmysql.dll.debug放入【…\\Qt5.14.2\\5.14.2\\mingw73_64\\plugins\\sqldrivers】下。 数据库信息： 需要修改请自行修改代码，以下是默认用户名和密码。 用户名：wxy 密码：123456 由于QT的限制，编译构建时路径不允许有中文。 服务器默认IP地址是本地127.0.0.1，有需要请自行修改代码。 四、模块设计1、游戏客户端模块清单 编号 模块名称 模块标识 模块功能 1 主界面模块 Widget 主界面，包括登录等 2 用户类模块 User 闯关者，出题人类 3 注册模块 Register 注册用户 4 用户信息模块 Info 展示用户信息，包括等级、经验等 5 游戏模块 Game 单词消除游戏游玩界面 6 出题模块 Create 出题人出题界面 7 查询模块 Check 查询用户，排名界面 用户界面1、主界面 2、注册界面 3、用户信息界面（出题人与闯关者文字略有不同） 4、游戏界面 5、出题界面 Version2： Version3： 6、查询界面 函数具体功能1、Widget 点击查看代码 1234567891011121314void init_UI();//初始化图形界面void connect_event();//信号，槽函数链接void user_registe_show();//显示闯关者注册界面void creater_registe_show();//显示出题人注册界面void check_user_show(); //显示查询闯关者界面void check_creater_show();//显示查询出题人界面void info_show();//显示用户信息界面void check_close();//关闭查询界面void registe_close();//关闭注册界面void info_close();//关闭用户信息界面void showEvent(QShowEvent *);//显示界面void close_Widget();//关闭界面void type_changed();//闯关者，出题人切换void init_database();//初始化数据库 2、userplayer和creater继承于user类，升级函数采用虚函数，分别在各自类中实现。 3、register 点击查看代码 12345void init_UI();//初始化图形界面void connect_event();//信号，槽函数链接void showEvent(QShowEvent *);//显示界面void close_Widget();//关闭界面void send_change_signal();//改变界面信号 4、info 点击查看代码 123456789void init_UI();//初始化图形界面void connect_event();//信号，槽函数链接void showEvent(QShowEvent *);//显示界面void close_Widget();//关闭界面void send_change_signal();//改变界面信号void game_show();//游戏界面显示void game_close();//游戏界面关闭void create_show();//出题界面显示 void create_close();//出题界面关闭 5、game 点击查看代码 123456789void init_UI();//初始化图形界面void connect_event();//信号，槽函数链接void showEvent(QShowEvent *);//显示界面void close_Widget();//关闭界面void send_change_signal();//改变界面信void init_timer();//计时器初始化void init_ms_timer();//计时器初始化void timeup();//超时void ms_timeup();//超时 6、create 点击查看代码 12345void init_UI();//初始化图形界面void connect_event();//信号，槽函数链接void showEvent(QShowEvent *);//显示界面void close_Widget();//关闭界面void send_change_signal();//改变界面信号 6、check 点击查看代码 123456void init_UI();//初始化图形界面void connect_event();//信号，槽函数链接void showEvent(QShowEvent *);//显示界面void close_Widget();//关闭界面void send_change_signal();//改变界面信号void search();//搜索信息 2、服务器端模块清单 编号 模块名称 模块标识 模块功能 1 主界面模块 Widget 主界面 2 线程模块 My_thread 实现多线程 用户界面 函数具体功能1、Widget 点击查看代码 1234void init_UI();//初始化图形界面void tcpserver_connect();//tcpserver连接void tcpsocket_connect();//tcpsocket连接void showEvent(QShowEvent *);//界面显示 2、My_thread当收到客户端的请求后，根据客户端发送的字符串判断是什么请求，在屏幕上输出，同时新建线程，在线程中处理这些请求，从而实现并发处理。 1void init_database();//初始化数据库 五、项目地址本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看：","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://666wxy666.github.io/categories/C-C/"},{"name":"项目","slug":"C-C/项目","permalink":"https://666wxy666.github.io/categories/C-C/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"QT","slug":"QT","permalink":"https://666wxy666.github.io/tags/QT/"},{"name":"小游戏","slug":"小游戏","permalink":"https://666wxy666.github.io/tags/%E5%B0%8F%E6%B8%B8%E6%88%8F/"}]},{"title":"Python 爬虫小Demo 学堂在线课程","slug":"Python-爬虫小Demo-学堂在线课程","date":"2020-07-05T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/07/05/Python-爬虫小Demo-学堂在线课程/","link":"","permalink":"https://666wxy666.github.io/2020/07/05/Python-%E7%88%AC%E8%99%AB%E5%B0%8FDemo-%E5%AD%A6%E5%A0%82%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/","excerpt":"本文是关于Python中的Spider的小Demo，通过Python的scrapy爬取学堂在线课程的相关数据。","text":"本文是关于Python中的Spider的小Demo，通过Python的scrapy爬取学堂在线课程的相关数据。 一、编译环境： 点击查看 123456789101112131415161718192021222324252627PyCharm 2019.3.4 (Professional Edition)Build #PY-193.6911.25, built on March 18, 2020Runtime version: 11.0.6+8-b520.43 amd64VM: OpenJDK 64-Bit Server VM by JetBrains s.r.oWindows 10 10.0GC: ParNew, ConcurrentMarkSweepMemory: 725MCores: 8Registry: ide.balloon.shadow.size&#x3D;0Non-Bundled Plugins: GrepConsole,Statistic,cn.yiiguxing.plugin.translate,com.chrisrm.idea.MaterialThemeUI,com.notime.intellijPlugin.backgroundImagePlus,com.wakatime.intellij.plugin,izhangzhihao.rainbow.brackets,mobi.hsz.idea.gitignore, net.vektah.codeglance, org.intellij.giteePython Version：3.7（Anaconda3）Package：scrapy&#x3D;&#x3D;2.0.1 二、详细步骤①准备工作 在Pycharm中新建一个Pure Python项目（记得要按照一中的要求配好Python环境）。 打开Pycharm的下方的终端（Terminal），当然这些也可以在系统终端里操作，不过可能需要的步骤多一些，还是直接在Pycharm里方便一些。 在终端里输入 1scrapy startproject myScrapy 本来是可以在我们刚刚创建的项目里新建一个名为“myScrapy”的scrapy项目的，但是不知道为什么竟然报错了： 这是什么奇奇怪怪的错误，我都没有“d:\\bld\\scrapy_1584555997548_h_env\\python.exe”这个目录，经过查找相关问题的资料，问题可能是出在Python环境上，因为我上一次新建项目时并没有报错，这一次我直接用的上一个项目的环境，网上还有一种说法是Scrapy的bug，详见 Fatal error launching scrapy&gt;1.6.0 from Anaconda Prompt Issue with conda-forge scrapy&gt;1.6.0 on Windows 目前找到了两种解决方案： 把python环境复制到报错的那个目录（d:\\bld\\scrapy_1584555997548_h_env\\python.exe），然后在创建scrapy项目，但这个解决方法有点愚蠢，就没有采用。 在scrapy命令前面添加“python -m”选项： 1python -m scrapy startproject myScrapy 就可以正常创建了。 关于Python的-m选项，官方给出的解释是“run library module as a script”，简单来说就是将库中的Python模块当作脚本去运行。 特别感谢简书的大佬ccw1078提供的解释，很清晰明了，有兴趣的可以去瞅一下，因为和本文的主题爬虫没啥关系，在这里就不赘述了。 出现这些提示就代表创建成功了。 然后在spiders文件里新建一个spider.py文件，用于写爬虫。 我们来看一下目前scrapy项目的目录结构。 __init__.py：pycharm生成的文件，简化导入语句用的，可以忽略，没啥用，建议删了，留着可能会出问题。 spiders：存放你Spider爬虫源文件 ​ spider.py：代码主要在这里写。 items.py：数据容器。 middlewares.py：Downloader Middlewares(下载器中间件)和Spider Middlewares(蜘蛛中间件)实现的地方。 pipelines.py：项目管道文件，相当于数据中转站。实现数据的清洗，储存，验证。 settings.py：scrapy的全局配置。 scrapy.cfg：配置文件。 scrapy已经帮我们把大体框架写好了，我们主要要修改的文件是spider.py，items.py，pipelines.py，settings.py。 这是爬虫spider的基本工作方式，想要深入了解的可以去网上查找资料。 ②开始写代码1、先来写items.py。 点击查看代码 12345678import scrapyclass MyscrapyItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() school = scrapy.Field() num = scrapy.Field() pass 2、再来搞settings.py，这个只需要找到这个注释掉的语句，把#去掉就OK了，就像这样： 3、pipelines.py就很好写了，基本可以当模板来用。 点击查看代码 123456789101112131415161718import jsonclass MyscrapyPipeline(object): def open_spider(self, spider): try: # 这个就是爬虫生成的文件，可以支持好多种格式，这里使用的是json文件 self.file = open(&#x27;MyData.json&#x27;, &#x27;w&#x27;, encoding=&quot;utf-8&quot;) except Exception as err: print(err) def process_item(self, item, spider): dict_item = dict(item) json_str = json.dumps(dict_item, ensure_ascii=False) + &quot;\\n&quot; self.file.write(json_str) return item def close_spider(self, spider): self.file.close() 4、spider.py是我们主要写的核心部分。这里需要一些html的xpath相关知识来对项进行定位，可以自行查找相关资料。 点击查看代码 1234567891011121314151617181920212223242526272829303132import scrapyimport refrom myScrapy.myScrapy.items import MyscrapyItemclass mySpider(scrapy.spiders.Spider): # spider的名字 name = &quot;xuetang&quot; # 限制spider爬取的域名 allowed_domains = [&quot;www.xuetangx.com/&quot;] # 爬虫要爬取的网页，是一个列表，按顺序爬取 start_urls = [&quot;http://www.xuetangx.com/partners&quot;] # 这是一种方式，可以爬取网页中所有的项 # def parse(self, response): # item = MyscrapyItem() # for each in response.xpath(&quot;/html/body/article[1]/section/ul/*&quot;): # item[&#x27;school&#x27;] = each.xpath(&quot;a/div[2]/h3/text()&quot;).extract() # item[&#x27;num&#x27;] = each.xpath(&quot;a/div[2]/p[1]/text()&quot;).extract() # if item[&#x27;num&#x27;]: # item[&#x27;num&#x27;] = re.findall(r&#x27;\\d+&#x27;, item[&#x27;num&#x27;][0]) # if item[&#x27;school&#x27;] and item[&#x27;num&#x27;]: # yield (item) # 这是第二种方式，使用for循环，制定爬取项的数目 def parse(self, response): item = MyscrapyItem() for i in range(1, 144): item[&#x27;school&#x27;] = response.xpath \\ (&quot;/html/body/article[1]/section/ul/li[&#123;&#125;]/a/div[2]/h3/text()&quot;.format(i)).extract() item[&#x27;num&#x27;] = response.xpath \\ (&quot;/html/body/article[1]/section/ul/li[&#123;&#125;]/a/div[2]/p[1]/text()&quot;.format(i)).extract() # 判断爬取的项目是否为空，把非空的项目提交 if item[&#x27;school&#x27;] and item[&#x27;num&#x27;]: yield (item) ③可以开始运行啦1、在运行前要先在项目根目录下建立一个begin.py文件来控制scrapy爬虫的运行。 点击查看代码 123from scrapy import cmdline# &quot;xuetang&quot;是我们上面spider.py中定义的爬虫名cmdline.execute(&quot;scrapy crawl xuetang&quot;.split()) 2、最终的项目结构（__init__.py没啥用，删了）： 3、运行begin.py就可以开始爬虫了。 出现这些提示就表示成功了，运行完毕后会发现项目根目录出现了我们在pipelines.py中设置好的MyData.json。 4、打开MyData.json看一下，Perfect！ 有了这个json文件，我们就可以利用Python的pandas、numpy等工具进行各种处理，然后用matplotlib等模块进行画图了。 三、总结本文只是对Python的scrapy爬虫进行了简单的介绍和用一个小Demo讲述了如何使用scrapy爬取网页数据，希望对你有所帮助。 四、项目地址本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看：","categories":[{"name":"Python","slug":"Python","permalink":"https://666wxy666.github.io/categories/Python/"},{"name":"爬虫","slug":"Python/爬虫","permalink":"https://666wxy666.github.io/categories/Python/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://666wxy666.github.io/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://666wxy666.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"机器学习 实验 RNN 为baby起名字","slug":"机器学习-实验-RNN-为baby起名字","date":"2020-07-03T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/07/03/机器学习-实验-RNN-为baby起名字/","link":"","permalink":"https://666wxy666.github.io/2020/07/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%AE%9E%E9%AA%8C-RNN-%E4%B8%BAbaby%E8%B5%B7%E5%90%8D%E5%AD%97/","excerpt":"本文是关于经典RNN的应用为baby起名字的代码实现。","text":"本文是关于经典RNN的应用为baby起名字的代码实现。 一、任务定义采用 RNN 为小 Baby 起个英文名字吧 神经网络语言模型，即通过神经网络，计算一项自然语言（例如一条句子）的出现概率，或者根据上文中的词推断句子中某个词的出现概率。例如，下图采用了一个具有一个输入层、一个隐藏层和一个输出层的 MLP 网络，建模三元文法模型： 本作业提供了8000多个英文名字，试训练一个环神经网络语言模型，进而给定若干个开始字母，由语言模型自动生成后续的字母，直到生成一个名字的结束符。从模型生成的名字中，挑选你最喜欢的一个，并采用一种可视化技术，绘制出模型为每个时刻预测的前5个最可能的候选字母。 事实上，你也可以给定结尾的若干个字母，或者随意给出中间的若干个字母，让 RNN 补全其它字母，从而得到一个完整的名字。因此，你也可以尝试设计并实现一个这样的 RNN 模型，从模型生成的名字中，挑选你最喜欢的一个，并采用可视化技术，绘制出模型为每个时刻预测的前5个最可能的候选字母。 二、输入输出1、输入 male和female数据集作为训练集。 【PS】注意，两个数据集的格式必须是一行一个英文名字，不能有其他文字说明，在使用前请先将male.txt和female.txt中的文字说明删除，例如： 超参数总迭代次数，打印精度（每隔多少次迭代打印一次损失日志），绘图精度（每隔多少次迭代求和取平均作为一个数据点）。 （类别，姓名的起始字母）对。 2、输出 RNN神经网络模型。 该模型的损失等日志信息。 该模型的损失-(迭代次数/画图精度)函数图像。 根据这个神经网络模型和输入的（类别，姓名的起始字母）对生成的姓名。 三、实验环境硬件： 处理器：Intel i7 7700HQ 显卡：NVIDIA GeForce GTX 1050 Ti 内存：16GB 软件： 编程语言： Python 3.7（Anaconda3） 模块： pytorch 1.5 numpy 1.18.1 matplotlib 3.1.3 编译器： PyCharm 2020.1.1 (Professional Edition)Build #PY-201.7223.92, built on April 30, 2020For educational use only.Runtime version: 11.0.6+8-b765.40 amd64VM: OpenJDK 64-Bit Server VM by JetBrains s.r.oWindows 10 10.0GC: ParNew, ConcurrentMarkSweepMemory: 725MCores: 8Registry: ide.balloon.shadow.size=0Non-Bundled Plugins: com.dubreuia, GrepConsole, Statistic, com.chrisrm.idea.MaterialThemeUI, org.intellij.gitee, com.mallowigi, com.wakatime.intellij.plugin, mobi.hsz.idea.gitignore, net.vektah.codeglance, tanvd.grazi, com.jetbrains.intellij.datalore, izhangzhihao.rainbow.brackets, cn.yiiguxing.plugin.translate, org.nik.presentation-assistant 四、方法描述1、数据集处理对老师的male.txt和female.txt数据集进行处理，保证每行只能由一个姓名，不得出现其他类似下图的说明信息。 我们将行分割成数组, 并把 Unicode 转换成 ASCII 编码, 最后放进一个字典里 &#123;language: [names ...]&#125; 2、创建网络输出设定为下一个字母的概率，采样测试的时候，概率最大的输出字母被当做下一个输入。 输出层采用softmax函数，为了让网络更加有效工作，添加了第二个线性层o2o（在合并了隐藏层和输出层的后面）。还有一个 Dropout 层，使输入的部分值以给定的概率值随机的变成 0（这里概率取0.1）, 为了模糊输入以防止过拟合，在网络的最末端使用它，从而故意添加一些混乱和增加采样的多样化。 3、训练前的准备首先读取文件，产生随机的（类别，文件行[也就是姓名]）对。对每一个时间点（也就是说在训练集中词的每个字母）网络的输入是（类别，当前字母，隐藏层状态），输出是（下一个字母，下一个隐藏层状态）。 因为在每一步，我们从当前的字母预测下一个字母，这样的字母对是在原有行中连续字母的集合，例如： 类别张量是一个大小为$1\\times{categories}$的one-hot tensor张量，在训练的每一个时间点把它提供给网络。 4、开始训练使用自动求导（autograd）辅助计算损失。循环调用train，每隔一段时间打印损失等Log，直到到达规定输入的迭代次数。在训练完成后绘制损失-(迭代次数/画图精度)函数图像折线图，用于性能评估分析。 5、测试采样输入（类别，姓名起始字母）对，返回生成的姓名。 五、结果分析与性能评价PS: []中的为每一次迭代的最可能的字母前五，如果为空，就是已经到达迭代终点。 下面是100000次迭代的测试采样结果，可以发现生成的姓名非常好，完全符合日常的姓名样式，RNN神经网络性能很好。 100次的因为迭代次数太少，网络非常不好，完全不能生成所需的姓名： 1000次还算可以接受： 如果是10000次迭代，基本能满足生成姓名的要求: 观察并对比不同迭代次数的损失-(迭代次数/画图精度)函数折线图可以看出迭代次数越多损失越小，性能越好，且一开始损失下降较快，当迭代次数大到一定程度后，损失下降较慢。 查看并对比不同迭代次数的损失日志输出，很明显能发现最大的区别就是训练时间。可以看出迭代次数越多花费时间越多，所需的电脑性能显然也需要更高，100次和1000次由于网络不好，可以先排除在外。100000次迭代的所需时间是10min左右，而10000次迭代所需的时间为1min左右，相差10倍，如果迭代次数更多，可能相差更多，因此选择合适的迭代次数很重要，避免不必要的性能时间浪费。 六、项目地址本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看： 七、附录 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241from __future__ import unicode_literals, print_function, divisionimport globimport mathimport osimport randomimport stringimport timefrom io import openimport matplotlib.pyplot as pltimport torchimport torch.nn as nnimport unicodedata################################################## 全局参数#################################################all_letters = string.ascii_letters + &quot; .,;&#x27;-&quot;n_letters = len(all_letters) + 1criterion = nn.NLLLoss()learning_rate = 0.0005 # 学习率max_length = 20path = &quot;data/names/*.txt&quot;################################################## 数据集操作################################################## 将Unicode转为ASCII# https://stackoverflow.com/a/518232/2809427def Unicode_to_ASCII(s): return &#x27;&#x27;.join( c for c in unicodedata.normalize(&#x27;NFD&#x27;, s) if unicodedata.category(c) != &#x27;Mn&#x27; and c in all_letters )# 将行分割成数组, 并把 Unicode 转换成 ASCII 编码, 最后放进一个字典里 &#123;category: [names ...]&#125;category_lines = &#123;&#125;all_categories = []for file_name in glob.glob(path): category = os.path.splitext(os.path.basename(file_name))[0] all_categories.append(category) line_list = open(file_name, encoding=&#x27;utf-8&#x27;).read().strip().split(&#x27;\\n&#x27;) lines = [Unicode_to_ASCII(line) for line in line_list] category_lines[category] = linescategory_num = len(all_categories)if category_num == 0: raise RuntimeError(&quot;未找到数据集！&quot;)print(&quot;数据集类别：&quot;, category_num, all_categories)################################################## 构建RNN网络#################################################class RNN(nn.Module): def __init__(self, input_size, hidden_size, output_size): super(RNN, self).__init__() self.hidden_size = hidden_size self.i2h = nn.Linear(category_num + input_size + hidden_size, hidden_size) self.i2o = nn.Linear(category_num + input_size + hidden_size, output_size) self.o2o = nn.Linear(hidden_size + output_size, output_size) self.dropout = nn.Dropout(0.1) self.softmax = nn.LogSoftmax(dim=1) def forward(self, category, input, hidden): input_combined = torch.cat((category, input, hidden), 1) hidden = self.i2h(input_combined) output = self.i2o(input_combined) output_combined = torch.cat((hidden, output), 1) output = self.o2o(output_combined) output = self.dropout(output) output = self.softmax(output) return output, hidden def init_hidden(self): return torch.zeros(1, self.hidden_size)################################################## 训练前的准备################################################## 输入串从第一个字母到最后一个字母（不包括 EOS ）的 one-hot 矩阵def generate_input_tensor(letters): tensor = torch.zeros(len(letters), 1, n_letters) for i in range(len(letters)): letter = letters[i] tensor[i][0][all_letters.find(letter)] = 1 return tensor# 目标的第k个字母到结尾（EOS）的 LongTensordef generate_target_Tensor(letters): letter_indexes = [all_letters.find(letters[i]) for i in range(1, len(letters))] letter_indexes.append(n_letters - 1) # EOS return torch.LongTensor(letter_indexes)# 类别的One-hot向量def generate_category_tensor(category): i = all_categories.index(category) tensor = torch.zeros(1, category_num) tensor[0][i] = 1 return tensor# 利用辅助函数从数据集中获取随机的category和linedef random_pair(): category = all_categories[random.randint(0, len(all_categories) - 1)] line = category_lines[category][random.randint(0, len(category_lines[category]) - 1)] return category, line# 从随机的（category, line）对中生成 category, input, 和 target Tensordef randomTrainingExample(): category, line = random_pair() category_tensor = generate_category_tensor(category) input_tensor = generate_input_tensor(line) target_tensor = generate_target_Tensor(line) return category_tensor, input_tensor, target_tensor################################################## 训练RNN网络#################################################def train(category_tensor, input_tensor, target_tensor): target_tensor.unsqueeze_(-1) hidden = rnn.init_hidden() rnn.zero_grad() loss = 0 for i in range(input_tensor.size(0)): output, hidden = rnn(category_tensor, input_tensor[i], hidden) l = criterion(output, target_tensor[i]) loss += l loss.backward() for p in rnn.parameters(): p.data.add_(p.grad.data, alpha=-learning_rate) return output, loss.item() / input_tensor.size(0)# 秒转时间戳def time_format(since): now = time.time() s = now - since m = math.floor(s / 60) s -= m * 60 return &#x27;%dm %ds&#x27; % (m, s)# 从一个类中获取一个以start_letters开头的名字def sample(category, start_letters=&#x27;Al&#x27;): with torch.no_grad(): category_tensor = generate_category_tensor(category) input = generate_input_tensor(start_letters) hidden = rnn.init_hidden() output_name = start_letters for i in range(max_length): output, hidden = rnn(category_tensor, input[0], hidden) topv, topi_temp = output.topk(5) topi = topi_temp[0][0].item() if topi == n_letters - 1: break else: print(&quot;[&quot;, end=&quot;&quot;) for j in range(5): if j != 4: if topi_temp[0][j].item() &gt;= n_letters - 1: print(&quot; &quot;, end=&quot;,&quot;) else: print(all_letters[topi_temp[0][j].item()], end=&quot;,&quot;) else: if topi_temp[0][j].item() &gt;= n_letters - 1: print(&quot; &quot;, end=&quot;]\\n&quot;) else: print(all_letters[topi_temp[0][j].item()], end=&quot;]\\n&quot;) letter = all_letters[topi] output_name += letter input = generate_input_tensor(letter) print(output_name)################################################## 开始运行#################################################rnn = RNN(n_letters, 128, n_letters)all_losses = []total_loss = 0# 超参数参考值# n_its = 100000# print_every = 5000# plot_every = 500print(&quot;请分别输入总迭代次数,打印精度,绘图精度(按空格分隔): &quot;, end=&quot;&quot;)n_its, print_every, plot_every = map(int, input().split())print(&quot;开始训练......&quot;)start = time.time()print(&quot;[时间戳]\\t\\t百分比\\t\\t已迭代数\\t\\t损失&quot;)for it in range(1, n_its + 1): output, loss = train(*randomTrainingExample()) total_loss += loss if it % print_every == 0: print(&quot;[%10s] &lt;%3d%%&gt; %10d %.4f&quot; % (time_format(start), it / n_its * 100, it, loss)) if it % plot_every == 0: all_losses.append(total_loss / plot_every) total_loss = 0print(&quot;训练完成！&quot;)# 画出损失图像print(&quot;绘制损失图像......&quot;)plt.figure()plt.plot(all_losses)plt.show()# 生成测试print(&quot;请输入是否要进行网络采样测试(1,是;0,否): &quot;, end=&quot;&quot;)flag = int(input())while flag: print(&quot;请输入类别和姓名首字母(按空格分割,例: female Al): &quot;, end=&quot;&quot;) cat, letters = input().split() sample(cat, letters) print(&quot;要继续吗(1,继续;0,停止)？&quot;, end=&quot;&quot;) flag = int(input())","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://666wxy666.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"实验","slug":"机器学习/实验","permalink":"https://666wxy666.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://666wxy666.github.io/tags/Python/"},{"name":"机器学习","slug":"机器学习","permalink":"https://666wxy666.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"RNN","slug":"RNN","permalink":"https://666wxy666.github.io/tags/RNN/"}]},{"title":"Linux 拓展学习","slug":"Linux-拓展学习","date":"2020-06-24T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/06/24/Linux-拓展学习/","link":"","permalink":"https://666wxy666.github.io/2020/06/24/Linux-%E6%8B%93%E5%B1%95%E5%AD%A6%E4%B9%A0/","excerpt":"简单的写了一些Linux的课外拓展学习的相关知识和问题。","text":"简单的写了一些Linux的课外拓展学习的相关知识和问题。 一、命令的参数编写一个小程序，可以显示命令的选项和参数 点击查看代码 1234567891011#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int i; for (i = 0; i &lt; argc; i++) &#123; printf(&quot;%d:%p [%s]\\n&quot;, i, argv[i], argv[i]); &#125; return 0;&#125; 效果： 二、关于控制printf输出的颜色编写程序hello.c，编译和运行程序，得到类似以下结果： 可以通过 1\\033[ 来控制printf输出的颜色，格式为： 1printf(&quot;\\033[字背景颜色;字体颜色m 字符串 \\033[0m&quot; ); 注意，一定要在printf最后使用 1\\033[0m 来消除前面的作用，否则前面的设置对后面的printf都有效果。 ANSI控制码 效果 \\033[0m 关闭所有属性 \\033[1m 设置高亮度 \\033[4m 下划线 \\033[5m 闪烁 \\033[7m 反显 \\033[8m 消隐 \\033[30m —\\033[37m 设置前景色 \\033[40m—\\033[47m 设置背景色 \\033[nA 光标上移n行 \\03[nB 光标下移n行 \\033[nC 光标右移n行 \\033[nD 光标左移n行 字背景颜色范围: 40–49 字颜色范围: 30—39 字背景颜色代号 字背景颜色 字颜色代号 字颜色 40 黑 30 黑 41 红 31 红 42 绿 32 绿 43 黄 33 黄 44 蓝 34 蓝 45 紫 35 紫 46 青 36 青 47 白 37 白 小程序具体代码： 点击查看代码 12345678910#define NONE &quot;\\e[0m&quot;#define RED &quot;\\e[0;31m&quot;#define CYAN &quot;\\e[0;36m&quot;#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; printf(RED &quot;Hello &quot; CYAN &quot;World!\\n&quot; NONE); printf(&quot;\\e[0;31mHello \\e[0;36mWorld!\\n\\e[0m&quot;); return 0;&#125; 在这里\\e和\\033是一个意思，e的八进制代码就是033，这两个print其实效果是一样的，前面那个printf中多个连续的“xxx”字符串会被自动整合为一个字符串，其实最终执行的就是第二个printf。 效果： 三、关于Linux中bash的变量、替换和元字符要求只列出所有bash进程的状态，使用命令 1ps -ef | grep bash 但grep进程自身也被输出了： 使用以下的命令： 12345ps -ef | grep [b]ashps -ef | grep \\\\bashps -ef | grep b\\\\ashps -ef | grep b\\ashps -ef | grep ba\\\\sh 可以 上面这5个命令的核心目的其实是改变grep在 1ps -ef 命令中的显示形式，例如这一个，我们使用三通（tee）命令将在grep命令过滤之前的输出定向到一个文件中。 先将原命令试一下： 12ps -ef | tee 1.txt | grep bashcat 1.txt 与1这个命令进行一下对比： 12ps -ef | tee 1.txt | grep [b]ashcat 1.txt 我们可以很明显的看到，grep命令确实改变了，因为正则表达式 1[b]ash 是可以匹配bash的，但是却不能匹配[b]ash，因此第一行的-bash这一行被取了出来，而最后grep这一行，由于不匹配[b]ash，就取不出来了，刚好实现了我们只列出所有bash进程的状态的目的，下面的几个命令大同小异。 不可以 12ps -ef | tee 1.txt | grep \\\\bashcat 1.txt 首先，\\是Shell的元字符，先被\\转义为真正的单个字符\\，因此传给grep的正则表达式其实是\\bash，而在正则表达式中，\\b有特殊含义，是单词边界，因此就连bash和\\bash全部都没有匹配到。 可以 12ps -ef | tee 1.txt | grep b\\\\ashcat 1.txt 和2一样，传给grep的正则表达式为b\\ash，在正则表达式中\\a是没有意义的，因此\\被丢弃，正则表达式其实就是bash，所以第一行的-bash这一行被取了出来，而最后grep这一行，由于不匹配b\\ash，就取不出来了。 不可以 12ps -ef | tee 1.txt | grep b\\ashcat 1.txt 首先，\\a先经过Shell的替换，因\\a是没有特殊含义的，因此\\被直接丢掉，传给grep的正则表达式为bash，这就和使用这个命令是一样的： 1ps -ef | grep bash 显然是不能实现目的。 不可以 12ps -ef | tee 1.txt | grep ba\\\\shcat 1.txt 这个和2基本是一样的，和3唯一的区别就是，第3个中\\a对正则表达式而言是没有特殊含义的，但是\\s对正则表达式而言是有特殊含义的，\\s代表空白字符（可能是空格、制表符、其他空白），也就是说，grep匹配到的应该是类似于： 1ba h 这种的字符串，显然-bash和ba\\sh都不符合，因此就什么都没取到。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/categories/Linux/"},{"name":"拓展学习","slug":"Linux/拓展学习","permalink":"https://666wxy666.github.io/categories/Linux/%E6%8B%93%E5%B1%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/tags/Linux/"},{"name":"难点","slug":"难点","permalink":"https://666wxy666.github.io/tags/%E9%9A%BE%E7%82%B9/"},{"name":"Shell","slug":"Shell","permalink":"https://666wxy666.github.io/tags/Shell/"}]},{"title":"现代交换原理 MOOC习题 5~6章","slug":"现代交换原理-MOOC习题-5~6章","date":"2020-06-20T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/06/20/现代交换原理-MOOC习题-5~6章/","link":"","permalink":"https://666wxy666.github.io/2020/06/20/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86-MOOC%E4%B9%A0%E9%A2%98-5~6%E7%AB%A0/","excerpt":"自己随便整理了一下在学习“现代交换原理”网课时遇到的一些习题，易错点之类的。接上一部分现代交换原理 MOOC习题 1~4章。","text":"自己随便整理了一下在学习“现代交换原理”网课时遇到的一些习题，易错点之类的。接上一部分现代交换原理 MOOC习题 1~4章。 第五章 信令与协议 通话所需的媒体资源可以理解为控制呼叫的接续和拆线和通信网管理和维护的信息资源。 通信网中为用户建立连接和拆除连接，需要网中各个相关设备协调工作，为此在各个设备间传输的控制信号和规约称为信令。 路由标记供MTP3级进行消息寻址和路由，而MTP3的路由标记是由信令点编码实现的。 电信网（现代通信网）的三大支撑网络：同步网，管理网，信令网。 SIP与普通电话用户进行通话时要进行协议转换，SIP-&gt;七号信令。SIP协议中SDP的媒体端口号由网关（中继网关）保存。中继网关是分组网和电路网边界设备，实现不同媒体协议的转换。 注意中继网关（Trunk Gateway）跟代理服务器（Proxy Server）不是一个东西。 中继网关也叫落地设备，简称TG。用于VOIP网络电话系统或呼叫中心、软交换等，将模拟信号与数字信号相互转换。是voip解决方案的重要组成部分，它位于NGN网络的边缘接入层，连接PSTN和voip网络，实现IP包转TDM的功能。 承载着IP域与电路域的语音汇接任务。 常识问题。 显然错误，MTP1的通路也要经过TST交换网络。 错误，不多解释。 模拟用户信令：主要包括用户向交换机发送的监视信令和选择信令，交换机向用户发送的铃流和忙音等音信号。**用于PSTN**。 状态信令：用户线的忙闲状态，如主、被叫的摘、挂机状态； 地址信令：主叫所拨的被叫号码，直流脉冲或双音频； 铃流和信号音：交换机向用户发送的信号。振铃信号、信号音、来电显示的FSK信号； 数字用户信令：通过消息的形式传送以上信息，**用于ISDN用户**。例如：DSS1 30B+D 在用户线上传输的信令叫用户线信令，No.7信令是专为电话局之间交互控制信息而设计的，所以是局间信令，也就是在中继线上交互的信令，以数字信号方式传送。它跟能否携带电话号码没关系。 第六章 移动交换 MSC是移动交换中心，主要功能有： 信道的管理和分配； 呼叫的处理和控制； 用户位置信息的登记与管理； 越区切换和漫游的控制； 号码的登记和管理； 服务类型的鉴权； 用户的鉴权； 提供链路接口； 相关签约信息及4G位置信息不是存在MME中，而是HSS。 所有的习题： 现代交换原理 MOOC习题 1~4章现代交换原理 MOOC习题 5~6章","categories":[{"name":"现代交换原理","slug":"现代交换原理","permalink":"https://666wxy666.github.io/categories/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"},{"name":"习题","slug":"现代交换原理/习题","permalink":"https://666wxy666.github.io/categories/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"习题","slug":"习题","permalink":"https://666wxy666.github.io/tags/%E4%B9%A0%E9%A2%98/"},{"name":"易错点","slug":"易错点","permalink":"https://666wxy666.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"MOOC","slug":"MOOC","permalink":"https://666wxy666.github.io/tags/MOOC/"},{"name":"现代交换原理","slug":"现代交换原理","permalink":"https://666wxy666.github.io/tags/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"}]},{"title":"Linux MOOC习题 11~15章","slug":"Linux-MOOC习题-11~15章","date":"2020-06-20T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/06/20/Linux-MOOC习题-11~15章/","link":"","permalink":"https://666wxy666.github.io/2020/06/20/Linux-MOOC%E4%B9%A0%E9%A2%98-11~15%E7%AB%A0/","excerpt":"自己随便整理了一下在学习Linux网课时遇到的一些习题，易错点之类的，接上文Linux MOOC习题 6~10章。","text":"自己随便整理了一下在学习Linux网课时遇到的一些习题，易错点之类的，接上文Linux MOOC习题 6~10章。 十一、进程的基本概念 int a[N] = { 2 };的意思是把a[N]第一个元素赋值为2，其他的赋值为0，也就是说，所有的元素都被赋值了，因此占空间很大。 int a[N];的a[N]没有赋初值，只需记录a的长度即可，占用空间很小。 从图中（test是第一种赋值的，test2是第二种不赋值的）也可以看出，差别巨大： 忙等待主要是占用CPU，和内存没啥关系。 十二、进程的创建和重定向 注意，这个程序是持续不间断运行的，也就是说，不能停止后再重启，但是重定向是只能在程序运行的时候进行的操作，程序一旦开始运行就没办法重定向了，因此不能实现。并且重定向是“当前进程”做的，不是父进程做的。但是如果foo可以终止后重启，确实可以用shell脚本等程序实现上述功能。修改foo程序也可以实现上述功能。 执行的大致流程，只是各进程执行情况，并不代表真实执行顺序： 点击查看 父进程（0）：输出：i=0父进程0产生第一个子进程0-1 0-1：到下一轮for循环，i=1输出：i=1子进程0-1产生第一个子进程0-1-1 0-1-1：到下一轮for循环，i=2输出：i=2进程0-1-1产生第一个子进程0-1-1-10-1-1-1：到下一轮for循环，i=3输出：i=3进程0-1-1-1产生第一个子进程0-1-1-1-10-1-1-1-1：到下一轮for循环，i=40-1-1-1-1结束到下一轮for循环，i=40-1-1-1结束到下一轮for循环，i=3输出：i=3进程0-1-1产生第二个子进程0-1-1-20-1-1-2：到下一轮for循环，i=40-1-1-2结束到下一轮for循环，i=40-1-1结束到下一轮for循环，i=2输出：i=2子进程0-1产生第二个子进程0-1-2 0-1-2：到下一轮for循环，i=3输出：i=3进程0-1-2产生第一个子进程0-1-2-10-1-2-1：到下一轮for循环，i=40-1-2-1结束到下一轮for循环，i=40-1-2结束到下一轮for循环，i=3输出：i=3子进程0-1产生第三个子进程0-1-3 0-1-3：到下一轮for循环，i=40-1-3结束到下一轮for循环，i=40-1结束到下一轮for循环，i=1输出：i=1父进程0产生第二个子进程0-2 0-2：到下一轮for循环，i=2输出：i=2进程0-2产生第一个子进程0-2-10-2-1：到下一轮for循环，i=3输出：i=3进程0-2-1产生第一个子进程0-2-1-10-2-1-1：到下一轮for循环，i=40-2-1-1结束到下一轮for循环，i=40-2-1结束到下一轮for循环，i=3输出：i=3进程0-2产生第二个子进程0-2-20-2-2：到下一轮for循环，i=40-2-2结束到下一轮for循环，i=40-2结束到下一轮for循环，i=2输出：i=2父进程0产生第三个子进程0-3 0-3：到下一轮for循环，i=3输出：i=3进程0-3产生第一个子进程0-3-10-3-1：到下一轮for循环，i=40-3-1结束到下一轮for循环，i=40-3结束到下一轮for循环，i=3输出：i=3父进程0产生第四个子进程0-4 0-4：到下一轮for循环，i=40-4结束到下一轮for循环，i=4父进程0结束 共15行输出，分别为： 输出 次数 i=0 $2^0=1$ i=1 $2^1=2$ i=2 $2^2=4$ i=3 $2^3=8$ 在linux下的实际执行情况： 可以发现确实是15行，但是却有两个问题： 为什么最后产生了一个空行，在等待用户输入？ shell提示符其实是主进程死了以后，shell给出来的。因为实际运行结果是子进程死得晚，父进程死的早。其实，你不按回车，大家也都运行结束了，只是shell提示符出现得比某个子进程早。你看起来这个效果，其实这个提示符已经在上面显示了，那个时候主进程结束，shell给出了提示符，但此时子进程还没有结束，因此会继续输出，但这个时候shell已经进入了等待下一个命令的状态了，就像这样： ​ 可以发现，echo命令已经可以被shell接受了。 程序为什么分两部分输出了？ 这是因为后面的子进程因为他的父进程先死掉了，变成了孤儿进程，打印出他们的父进程pid，发现是1，也证明了这一点： 因此我们可以对程序进行如下修改： 点击查看代码 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;unistd.h&gt;int main(int argc, char const *argv[])&#123; int i,status,wait_pid; for (i = 0; i &lt; 4; i++) &#123; printf(&quot;i=%d,pid=%d,ppid=%d\\n&quot;, i,getpid(),getppid()); if(fork()&gt;0) &#123; wait_pid = wait(&amp;status); &#125; &#125; return 0;&#125; 对每个fork加上wait语句，就可以完全按照上面的进程树执行顺序执行，且不会有任何问题了。 PS：对于wait，如果其所有子进程都还在运行，则阻塞；如果是一部分子进程终止，而另一部分还在运行，那么父进程还会阻塞吗？答案是不会，只要有一个进程终止，wait就会返回。也就是说只要wait接收到一个SIGCHLD信号，wait()就会返回。对于两个或多个子进程的情况，需要调用wait两次或多次。说白了在每一个fork后面的父进程分支中都要有一个wait与之对应。与wait相关的详细知识请参照这位兄弟的博客：wait()函数的详细分析。 十三、重定向和管道，信号 xsh2.c是一个简易的模拟shell程序。 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char const *argv[])&#123; char buf[256], *argv1[256], **p, *cmd2, *argv2[256]; int sv, fd[2]; for (;;) &#123; printf(&quot;=&gt; &quot;); if (fgets(buf, sizeof(buf), stdin) == NULL) exit(0); if ((cmd2 = strstr(buf, &quot;|&quot;)) == NULL) exit(0); *cmd2++ = &#x27;\\0&#x27;; for (p = &amp;argv1[0], *p = strtok(buf, &quot; \\t\\n&quot;); *p != NULL; *++p = strtok(NULL, &quot; \\t\\n&quot;)) ; for (p = &amp;argv2[0], *p = strtok(cmd2, &quot; \\t\\n&quot;); *p != NULL; *++p = strtok(NULL, &quot; \\t\\n&quot;)) ; if (argv1[0] == NULL || argv2[0] == NULL) exit(0); pipe(fd); if (fork() == 0)// | 左边的写端进程 &#123; dup2(fd[1], 1); close(fd[1]); close(fd[0]); execvp(argv1[0], argv1); fprintf(stderr, &quot;** bad command 1: %m\\n&quot;); exit(1); &#125; else if (fork() == 0)// | 右边的读端进程 &#123; dup2(fd[0], 0); close(fd[0]); close(fd[1]);// 和第二题的类似，也不能省略 execvp(argv2[0], argv2); fprintf(stderr, &quot;** bad command 2: %m\\n&quot;); exit(1); &#125; close(fd[0]);// 第一题要省略的操作 close(fd[1]);// 第二题要省略的操作 wait(&amp;sv); wait(&amp;sv); &#125; return 0;&#125; 如果省略了这一条，对程序执行是没有什么影响的，但是循环多次以后，文件描述符一直不会被回收，导致资源耗尽，程序无法正常运行。 如果省略了这一条，就会产生重大问题。在写端进程写入结束后正常退出，读端在读取管道时，因为有个写入端一直没有关闭，导致读端的管道一直收不到结束信号，一直在等待读取，导致了死锁，读端程序不能正常结束。 goto只能在函数内跳转，全局跳转则可以跳转到保存的程序运行状态（包括堆栈等），就可以理解为玩游戏的SavePoint。但是如果你没保存，那就没法跳转，因此全局跳转只能跳转到执行过的位置。但是这个题目是有点问题的，goto语句也可以向前和向后跳转，因此此题可以忽略。 十四、进程间协作，Socket概述 也就是说，mmap()需要一个已经打开的文件的文件描述符，当然需要open()打开文件，至于为什么需要，解析说的很明白。 如果你打开的文件不关闭，你的程序一直执行，一直打开文件，打开的太多就会导致文件描述符资源耗尽，无法打开文件，但是当你程序退出时（正常退出或者异常终止），操作系统都会自动检测你已经打开的文件，自行关闭应该关闭的文件，因此也能正常持久化到磁盘文件。 咨询式锁定是很关键的，也就是你不自己调用fcntl()，你是不会被阻塞的，也就是说Linux给你提供了互斥访问的途径，你自己不用或者使用不当，还是会导致出现问题，这也是Linux“策略和机制相分离”的设计方法。它是一个重要的设计思路，当系统不能大包大揽时，系统提供“机制”，把“策略”留给程序员，简化了操作系统的设计，程序员正确操作，应该完成的功能也都能实现。这是一个典型的合理的“甩锅”行为。因特网和Linux设计上都遵循了这样的理念。SUID，bash中的条件判断，四则运算，都是相同的理念，它们简化了自己，仅提供“机制”，把“策略”留给应用程序，不失必备功能。C语言也一样，printf在C语言里也会是个函数，与语言本身无关，C语言自己设计得很简单，以至于常用C语言的程序员，不需要查阅任何手册，都能把语法记下来。C++，你试试？ 注意是以命令行参数方式传递，exec()虽然会清空原来的代码段，但是对文件描述符和信号的处理有所不同。 关于fork()和exec()父子进程对文件描述符和信号的继承问题总结如下： 信号 仅fork时子进程会继承父进程fork之前所设置的信号处理方式。 当有exec加载新程序时 子进程继承的处理方式是忽略或默认处理方式时，exec新程序后设置依然有效。 如果子进程继承是捕获处理方式时，exec新程序后将被还原为默认处理方式。 文件描述符 当你用fork建立一个子进程，父进程的所有内容会被“完完整整”的复制到子进程中。子进程是父进程的一个clone体，除了pid不同，其余一切相同。在fork后父、子进程对于每一个打开的文件描述符共享同一个文件表项，此时可能有多个文件描述符项指向同一文件表项。即使exec也会保留文件描述符，但是有时子进程不需要继承父进程的文件描述符，并且有时在exec后子进程继承下来的文件描述符有的是毫无意义的，Linux使用close_on_exec标志位来实现。当父进程打开文件时，只需要应用程序设置FD_CLOSEXEC标志位，则当fork后exec其他程序的时候，内核自动会将其继承的父进程FD关闭。因此原则上只要你不设置这个标志位，你fork子进程后，exec新程序依然可以用你在父进程或者原来的子进程中打开的文件。 十五、Socket编程 bind设置本地端点名，也可以用在客户端程序，不会阻塞； listen仅仅是给内核一个通知，开始监听到达的连接请求，不会阻塞； connect建立连接，设定远端端点名，进程阻塞，直到TCP连接建立（第二次握手）； accept接受一个连接请求，阻塞等待新连接的到来，直到TCP三次握手结束返回； 不执行signal(SIGCLD,SIG_ING)会产生僵尸进程。 所有的习题： Linux MOOC习题 1~5章Linux MOOC习题 6~10章Linux MOOC习题 11~15章","categories":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/categories/Linux/"},{"name":"习题","slug":"Linux/习题","permalink":"https://666wxy666.github.io/categories/Linux/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/tags/Linux/"},{"name":"习题","slug":"习题","permalink":"https://666wxy666.github.io/tags/%E4%B9%A0%E9%A2%98/"},{"name":"易错点","slug":"易错点","permalink":"https://666wxy666.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"MOOC","slug":"MOOC","permalink":"https://666wxy666.github.io/tags/MOOC/"}]},{"title":"大数据 习题","slug":"大数据-习题","date":"2020-06-18T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/06/18/大数据-习题/","link":"","permalink":"https://666wxy666.github.io/2020/06/18/%E5%A4%A7%E6%95%B0%E6%8D%AE-%E4%B9%A0%E9%A2%98/","excerpt":"自己随便整理了一下在学习“大数据”时遇到的一些习题，易错点之类的。","text":"自己随便整理了一下在学习“大数据”时遇到的一些习题，易错点之类的。 1、关于Spark中task，block，partition，split，core的关系 每一个过程的任务数，对应一个inputSplit, Partition输入可能以多个文件的形式存储在HDFS上，每个File都包含了很多块，称为Block。 当Spark读取这些文件作为输入时，会根据具体数据格式对应的InputFormat进行解析，一般是将若干个Block合并成一个输入分片，称为InputSplit，注意InputSplit不能跨越文件。 随后将为这些输入分片生成具体的Task。InputSplit与Task是一一对应的关系。随后这些具体的Task每个都会被分配到集群上的某个节点的某个Executor去执行。 每个节点可以起一个或多个Executor。 每个Executor由若干core组成，每个Executor的每个core一次只能执行一个Task。 注意： 这里的core是虚拟的core而不是机器的物理CPU核，可以理解为就是Executor的一个工作线程。 每个Task执行的结果就是生成了目标RDD的一个partiton。 Task被执行的并发度 = Executor数目$\\times$每个Executor核数（=core总个数） 至于partition的数目： 对于数据读入阶段，例如sc.textFile，输入文件被划分为多少InputSplit就会需要多少初始Task。 在Map阶段partition数目保持不变。 在Reduce阶段，RDD的聚合会触发shuffle操作，聚合后的RDD的partition数目跟具体操作有关，例如repartition操作会聚合成指定分区数，还有一些算子是可配置的。 RDD在计算的时候，每个分区都会起一个task，所以rdd的分区数目决定了总的task数目。申请的计算节点（Executor）数目和每个计算节点核数，决定了你同一时刻可以并行执行的task。比如：RDD有100个分区，那么计算的时候就会生成100个task，你的资源配置为10个计算节点，每个2个核，同一时刻可以并行的task数目为20，计算这个RDD就需要5个轮次。如果计算资源不变，你有101个task的话，就需要6个轮次，在最后一轮中，只有一个task在执行，其余核都在空转。如果资源不变，你的RDD只有2个分区，那么同一时刻只有2个task运行，其余18个核空转，造成资源浪费。这就是在spark调优中，增大RDD分区数目，增大任务并行度的原因。 2、HDFS体系架构HDFS采用了主从（Master/Slave）结构 模型，一个HDFS集群是由一个 NameNode和若干个 DataNode 组成的。其中 NameNode 作为主服务器，管理文件系统的命名空间和客户端对文件的 访问操作；集群中的 DataNode 管理存储的数据。HDFS 允许用户以文件的形 式存储数据。从内部来看，文件被分成 若干个数据块，而且这若干个数据块存 放在一组 DataNode 上。NameNode 执行文件系统的命名空间操作，比如打开、关闭、重命名文件或目录等，它也负责数据块到具体 DataNode 的映射。 DataNode 负责处理文件系统客户端的文件读写请求，并在 NameNode 的统 一调度下进行数据块的创建、删除和复制工作。 3、HDFS的读操作流程 初始化FileSystem，然后客户端用函数 open()打开文件。 FileSystem调用元数据节点，得到数据 块信息，并对每一个数据块、元数据节点返回，保存数据块的数据节点地址。 客户端调用Stream的read()函数开始读 取数据。 FSDataInputStream连接保存此文件第 一个数据块的最近的数据节点Datanode， data从数据节点读到客户端。 当第一个数据块读取完毕时， FSDataInputStream关闭和此数据节点的 连接，然后连接此文件下一个数据块的 最近的数据节点。 当客户端读取完毕数据的时候，调用 FSDataInputStream的close()函数，关闭连接。 4、HDFS的写操作流程 5、习题","categories":[{"name":"大数据","slug":"大数据","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"习题","slug":"大数据/习题","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"习题","slug":"习题","permalink":"https://666wxy666.github.io/tags/%E4%B9%A0%E9%A2%98/"},{"name":"易错点","slug":"易错点","permalink":"https://666wxy666.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"大数据","slug":"大数据","permalink":"https://666wxy666.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Spark","slug":"Spark","permalink":"https://666wxy666.github.io/tags/Spark/"},{"name":"HDFS","slug":"HDFS","permalink":"https://666wxy666.github.io/tags/HDFS/"},{"name":"MapReduce","slug":"MapReduce","permalink":"https://666wxy666.github.io/tags/MapReduce/"}]},{"title":"机器学习 DNN 手写识别","slug":"机器学习-DNN-手写识别","date":"2020-06-11T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/06/11/机器学习-DNN-手写识别/","link":"","permalink":"https://666wxy666.github.io/2020/06/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-DNN-%E6%89%8B%E5%86%99%E8%AF%86%E5%88%AB/","excerpt":"本文是关于经典深度神经网络DNN的应用手写识别的思路样例。","text":"本文是关于经典深度神经网络DNN的应用手写识别的思路样例。 一、题目请描述一个深度神经网络模型解决实际问题的例子。 包括问题描述，输入输出数据，训练、测试数据集，深度网络模型结构图，损失函数，训练方法，以及其他需要说明的内容。 二、问题描述下面将描述一个深度神经网络的典型经典例子：手写数字识别（OCR）。 ⼈类视觉系统是世界上众多奇迹之一。下面的手写数字序列： 大多数人毫不费力就能够认出这些数字为 504192。识别手写数字不是一件简单的事。尽管⼈类在理解我们眼睛展示出来的信息上非常擅长，但如果你尝试写出计算机程序来识别诸如上面的数字，就会明显感受到视觉模式识别的困难。看起来人类一下子就能完成的任务变得特别困难。关于我们识别形状——“9 顶上有一个圈，右下方则是一条竖线”这样的简单直觉——实际上算法上就很难轻易表达出来了。而在你试着让这些识别规则越发精准时，就会很快陷入各种混乱的异常或者特殊情形的困境中。实现一个可以识别手写数字的神经网络。这个神经网络不需要人类帮助便可以超过 96% 的准确率识别数字。实际上，最优的商业神经网络已经足够好到被银行和邮局分别用在账单核查和识别地址上了。 二、输入输出数据 1、输入数据一系列手写的数字，例如： 2、输出数据识别出的数字：504192 三、训练、测试数据集使用经典的MNIST 数据集作为数据源。MNIST 数据分为两个部分。第一部分包含 60,000 幅用于训练数据的图像。这些图像扫描⾃250 ⼈的手写样本。这些图像是28 × 28 ⼤小的灰度图像。第二部分是 10,000 幅用于测试数据的图像，同样是 28 × 28 的灰度图像。 训练集测试集样例 四、深度网络模型结构图我们可以把识别手写数字的问题分成两个子问题。首先，我们希望有个方式把包含许多数字的图像分成一系列单独的图像，每个包含单个数字。例如，我们想要把图像 分成六个单独的图像 一旦图像被分割，那么程序需要把每个单独的数字分类。例如，我们想要我们的程序能识别上面的第一个数字是 5。 有很多途径可以解决分割的问题。一种方法是尝试不同比分割方式，用数字分类器对每一个切分片段打分。如果数字分类器对每一个片段的置信度都较高，那么这个分割方式就能得到较高的分数；如果数字分类器在一或多个片段中出现问题，那么这种分割方式就会得到较低的分数。这种方法的思想是，如果分类器有问题，那么很可能是由于图像分割出错导致的。这种思想以及它的变化形式能够比较好地解决分割问题。因此，与其关心分割问题，我们不如把精力集中在解决第二个问题即分类单独的数字。 我们可以使用一个三层神经网络来识别单个数字： 标准的DNN的模型结构： 网络的输入层包含给输入像素的值进行编码的神经元。我们给网络的训练数据会有很多扫描得到的 28 × 28 的手写数字的图像组成，所有输入层包含有 784 = 28 × 28个神经元。为了简化，上图中我已经忽略了 784 中⼤部分的输入神经元。输入像素是灰度级的，值为 0.0 表示白色，值为 1.0 表示黑色，中间数值表示逐渐暗淡的灰色。 网络的中间层是隐藏层。我们用 n 来表示神经元的数量，我们将给 n 实验不同的数值。示例中用一个小的隐藏层来说明，仅仅包含 n = 15 个神经元。 网络的输出层包含有 10 个神经元。如果第一个神经元激活，即输出$\\approx1$，那么表明网络认为数字是一个 0。如果第二个神经元激活，就表明网络认为数字是一个 1。依此类推。更确切地说，我们把输出神经元的输出赋予编号 0 到 9，并计算出那个神经元有最高的激活值。比如，如果编号为 6 的神经元激活，那么我们的网络会猜到输入的数字是 6。其它神经元相同。 这里使用 10 个输出神经元，因为任务是能让神经网络告诉我们哪个数字（0, 1, 2, . . . , 9 ）能和输入图片匹配，但是使用 4 个输出神经元，即把每一个当做一个二进制值，结果取决于它的输出更靠近 0 还是 1 。四个神经元足够编码这个问题了，因为 24 = 16 ⼤于 10 种可能的输入。但是10 个输出神经元的神经网络比 4 个的识别效果更好。 在上述的三层神经网络加一个额外的一层就可以实现按位表示数字。额外的一层把原来的输出层转化为一个二进制表示： 将上述网络详细展开来说，我们可以选择两个大小为100的隐层和一个大小为10的输出层，因为MNIST数据集是手写0到9的灰度图像，类别有10个，所以最后的输出大小是10。隐层的激活函数可以使用ReLU，最后输出层的激活函数是Softmax，所以最后的输出层相当于一个分类器。加上一个输入层的话，多层感知器的结构是：输入层–&gt;隐层–&gt;隐层–&gt;输出层。 五、损失函及训练方法我们使用DNN反向传播算法和梯度下降算法进行学习训练。我们将用符号$x$来表示一个训练输入。为了方便，把每个训练输入$x$看作一个表示$28\\times28=784$维的向量。每个向量中的项目代表图像中单个像素的灰度值。我们用$y=y(x)$表示对应的期望输出，这里$y$是一个 10 维的向量。例如，如果有一个特定的画成6的训练图像$x$，那么$y(x) = (0, 0, 0, 0, 0, 0, 1, 0, 0, 0)^T$则是网络的期望输出。 我们希望有一个算法，能让我们找到权重和偏置，以⾄于网络的输出$y(x)$能够拟合所有的训练输入$x$。为了量化我们如何实现这个目标，我们定义一个代价损失函数：$$C(w,b)\\equiv{\\frac{1}{2n}}\\sum_x||y(x)-a||^2$$这里$w$表示所有的网络中权重的集合，$b$是所有的偏置，$n$是训练输入数据的个数，$a$是表示当输入为 $x$时输出的向量，输出$a$取决于$x$，$w$和$b$，求和则是在总的训练输入$x$上进行的。符号$||v||$是指向量 v 的模。我们的训练算法的目的是最小化权重和偏置的代价函数$C(w,b)$。换句话说，我们想要找到一系列能让代价尽可能小的权重和偏置。 也可以使用的是交叉熵损失函数，该函数在分类任务上比较常用。定义了一个损失函数之后，还有对它求平均值，训练程序必须返回平均损失作为第一个返回值，因为它会被后面反向传播算法所用到。同时我们还可以定义一个准确率函数，这个可以在我们训练的时候输出分类的准确率。$$H(p,q)=-\\sum_{i=1}^{n}p(x_i)\\log(q(x_i))$$ 梯度下降算法的基本步骤： 六、总结上述神经网络在测试集的准确度能达到95%左右，非常准确。 相较于SVM，准确度和性能均有较大提升。 深度神经网络（Deep Neural Networks，DNN）是一个非常有前景和创新的研究方向。除了手写识别（OCR），还有各个行业的经典样例，比如：图像方面的黑白照片变彩色照片的图像着色（LetThereBeColor）、图像风格化，将一幅图像的内容与另一幅图像的风格相结合（neural-style）、通过深度学习极大提高模糊图片的分辨率（srez）、实时捕获面部表情，调换到另外一个人的面部（Face2Face）、雅虎出品的成人图片分类器（open_nsfw）、成人视频分类器（Miles Deep）等等，就不一一列举了。总之深度神经网络和深度学习给出了在图像识别、语音识别和自然语言处理领域中众多问题的最好解决方案，重要性不言而喻。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://666wxy666.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://666wxy666.github.io/tags/Python/"},{"name":"机器学习","slug":"机器学习","permalink":"https://666wxy666.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"DNN","slug":"DNN","permalink":"https://666wxy666.github.io/tags/DNN/"}]},{"title":"大数据实战 Python可视化 Matplotlib可视化","slug":"大数据实战-Python可视化-Matplotlib可视化","date":"2020-06-10T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/06/10/大数据实战-Python可视化-Matplotlib可视化/","link":"","permalink":"https://666wxy666.github.io/2020/06/10/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%88%98-Python%E5%8F%AF%E8%A7%86%E5%8C%96-Matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96/","excerpt":"本文是关于大数据通过Python的Matplotlib实现数据可视化。","text":"本文是关于大数据通过Python的Matplotlib实现数据可视化。 一、实验环境： 虚拟机数量：1 系统版本：Centos 7.5 Anaconda版本：4.4.0 二、实验内容： 通过创建Kafka topic，使用Kafka Producer产生消息，然后通过编写sparkStreaming程序处理这些消息。 主要步骤： Matplotlib的介绍 基本绘图函数 图表的修饰项介绍 子图绘制 图像的保存 三、实验步骤：3.1Matplotlib的介绍：在Python中，主要运用matplotlib库进行数据可视化。matplotlib是Python最著名的绘图库，它提供了一整套和matlab相似的命令API，十分适合交互式地进行制图。而且也可以方便地将它作为绘图控件，嵌入GUI应用程序中。 3.2基本绘图函数：matplotlib的pyplot子库提供了和matlab类似的绘图API，方便用户快速绘制2D图表。pyplot模块中常见的用来绘制图形的主要有以下几种函数： 3.2.1plot:常用于绘制线型图，该方法具有可变长参数，参数color指定颜色，参数linestyle设置线的样式、参数marker设置标记类型，结果返回一个lines.Line2D对象的列表，lines.Line2D对象的属性可通过plot的关键字参数设置。 3.2.2scatter: 用于绘制散点图； 3.2.3hist:用于绘制直方图，其参数中较为重要的是bins，该参数指定bin(箱子)的个数，即柱状图中柱子的总数，该值默认为10； 3.2.4show: 显示图像。 3.3图表的修饰项介绍：对于大多数的图表装饰项，其主要实现方式主要有使用过程型的pyplot接口和面向对象的原生matplotlib API两种，分别对应的是函数编程和对象编程两种思想。 3.3.1title：设置或者获取图表标题； 3.3.2xlim：设置或者获取X轴范围； 3.3.3xlabel：设置或者获取X轴标签； 3.3.4**xticks(&lt;刻度&gt;,&lt;标签&gt;)**：设置或者获取X轴刻度和刻度标签； 3.3.5**text(x,y,z)**：将文本z绘制在图表的指定坐标(x,y) 3.3.6legend：自动创建图例，可以通过设置loc参数指定图例的位置。需要事先在添加图像时设置label参数。 3.3.7**twinx(ax)**：返回一个与子图对象ax的x轴一致y轴在右侧的子图对象ax2，用于绘制双轴图表。使用实例方法的形式为ax2=ax.twinx()。 3.3.8除了上面特别说明的，其它方法各自对应子图对象的的两个实例方法，以xlim为例，就是Axes.get_xlim和Axes.set_xlim。 3.4子图绘制：简单类型的Artists为标准的绘图元件，例如Line2D、Rectangle、Text、AxesImage等等。而容器类型则可以包含许多简单类型的Artists，使它们组织成一个整体，例如Axis、Axes、Figure等。 3.4.1figure：用来创建一个绘图对象，通常也可以不创建绘图对象而调用plot之类的函数直接绘图，matplotlib会自动创建一个绘图对象。通过figsize参数可以指定绘图对象的宽度和高度。如果需要同时绘制多幅图表的话，可以是给figure传递一个整数参数指定图表的序号，如果所指定序号的绘图对象已经存在的话，将不创建新的对象，而只是让它成为当前绘图对象； 3.4.2subplot：创建一个新的Figure，并返回一个含有已创建的subplot对象的NumPy数组。该方法的调用形式为：subplot(numRows,numCols, plotNum)，将整个绘图区域等分为numRows行、numCols列个子区域，然后按照从左到右，从上到下的顺序对每个子区域进行编号，左上的子区域的编号为1。如果numRows，numCols和plotNum的值都小于10，可以把它们缩写为一个整数，例如 subplot(321)和subplot(3,2,1)是相同的；对于绘图对象有add_subplot方法用于添加subplot对象； 3.4.3subplots：创建一个包含多个子图的Figure，返回Figure和一个或多个ax（子图）对象，可以通过设置sharex/sharey参数指定共享x轴/y轴； 3.4.4axes：同样往图表添加子图，不同之处在于子图可以设定在绘图区域的任意位置，axes的参数是一个形如[left,bottom, width,height]的列表，这些数值分别指定所创建的Axes对象相对于绘图对象的位置和大小，取值范围都在0到1之间。对于绘图对象有add_axes方法用于添加subplot对象。 3.5图像的保存：利用plt.savefig可以将当前图表保存到文件，该方法相当于Figure对象的实例方法savefig。具体参数如下： 3.5.1 fname：含有文件路径的字符串或Python的文件型对象； 3.5.2 dpi：图像分辨率（每英寸点数），默认为100； 3.5.3 facecolor，edgecolor，图像的背景色，默认为”w”，即白色； 3.5.4 format：显式设置文件格式（”png”、”pdf”、”svg”等）； 3.5.5 bbox_inches：图表需要保存的部分。 3.6Matplotlib 绘图示例3.6.1执行如下命令打开编程环境 12cdipython 3.6.2绘制世界人口与年份的关系图： 3.6.2.1导入实验所需的库 1234from datetime import datetimeimport matplotlib.dates as mdatesimport matplotlib.pyplot as plt 3.6.2.2year 和pop为年份和对应的全世界人口数辆（单位10亿） 123yearInt = [2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020]year = [str(item) for item in yearInt] # 将yearInt中的数字转换成strpop = [6.49, 6.558, 6.656, 6.725, 6.804, 6.884, 6.965, 7.043, 7.125, 7.207, 7.356, 7.380, 7.405, 7.440, 7.468, 8.020] 3.6.2.3绘图 123456xs = [datetime.strptime(d, &#x27;%Y&#x27;).date() for d in year] # 将year中的每个如&#x27;2005&#x27;的字符串转换成只包含年的日期plt.gca().xaxis.set_major_formatter(mdates.DateFormatter(&#x27;%Y&#x27;)) # gca()获得坐标轴；plt.gca().xaxis.set_major_locator(mdates.YearLocator()) # 年份plt.plot(xs, pop) # 绘制图表plt.gcf().autofmt_xdate() # 将x轴的日期自动旋转角度plt.show() # 显示图表 3.7在上一幅图表中添加另一条关于中国人品与年份关系的线，并对新图添加对应的修饰项3.7.1添加中国人口数量关系 123plt.figure()pop_cn = [1.30756, 1.31448, 1.32129, 1.32802, 1.33450, 1.34091, 1.34735, 1.35404, 1.36072, 1.36782, 1.36790, 1.36801, 1.36813, 1.36832, 1.36845, 1.36860] 3.7.2绘制人口数量和年份关系；year与pop仍然用之前的数据 12plt.plot(year, pop, color=&quot;g&quot;, label=&quot;World population&quot;)plt.plot(year, pop_cn, linestyle=&quot;--&quot;, color=&quot;r&quot;, label=&quot;China population&quot;) 3.7.3添加修饰项 3.7.3.1添加x，y轴标签 3.7.3.2添加注解。注解点为(2008, 6.725)，内容为年(2013) 3.7.3.3添加图例，loc=1,表示图例出现在恰当的位置 3.7.3.4添加title 12345plt.xlabel(&#x27;year&#x27;)plt.ylabel(&#x27;Population&#x27;)plt.text(&#x27;2008&#x27;, 6.725, &#x27;2013&#x27;)plt.legend(loc=1)plt.title(&quot;World Population Summary&quot;) 3.7.4显示图片 1plt.show() 3.8子图的绘制：利用plt.subplots函数创建包含多个子图的绘图对象，还可以设置子图个数。 3.8.1绘制x轴共享子图， 3.8.1.1子图个数设置为2，并且共享x轴 1f, (ax1, ax2) = plt.subplots(2, sharex=True) # f是Figure对象；ax1,ax2分别是Axes 3.8.1.2使用散点图绘制 12ax1.scatter(year, pop) # 绘制散点图ax2.scatter(year, pop_cn) 3.8.1.3添加修饰项：标题， 12ax1.set_title(&#x27;World Population Summary&#x27;) # 设置标题ax2.set_title(&quot;China Population Summary&quot;) 3.8.1.4显示图像 1plt.show() 3.8.2绘制双y轴子图，共享x轴。 3.8.2.1创建绘图对象fig 1fig = plt.figure() 3.8.2.2使用fig.add_subplot函数为绘图对象fig添加两个子图，ax4通过使用ax3的twinx方法创建，且与ax3共享x中，放置在y轴右侧 12ax3 = fig.add_subplot(111) # 参数是1个3位的整数或3个分隔的整数，描述子图的位置，分别是nrows,ncols,indexax4 = ax3.twinx() # 创建一个x轴，并创建一个与原y轴处于相对位置的新y轴 3.8.2.3绘制子图ax3， ax4 12ax3.plot(year, pop, color=&quot;g&quot;, label=&quot;World population&quot;)ax4.plot(year, pop_cn, linestyle=&quot;--&quot;, color=&quot;r&quot;, label=&quot;China population&quot;) 3.8.2.4添加修饰项：添加x,y轴标签、 标题 1234ax3.set_ylabel(&#x27;World population&#x27;)ax3.set_title(&quot;Double Y axis&quot;)ax4.set_ylabel(&#x27;China population&#x27;)ax4.set_xlabel(&#x27;Year&#x27;) 3.8.2.5显示图像 1plt.show() 3.9图像的保存：3.9.1代码使用双y轴的代码，代码末尾show（）方法改成保存方法即可 3.9.2使用plt.savfig()函数保存图像 3.9.2.1制定保存的名称，格式，像素，以及是否修渐空白区域。 1234567891011fig = plt.figure()ax3 = fig.add_subplot(111)ax3.plot(year, pop, color=&quot;g&quot;, label=&quot;World population&quot;)ax3.set_ylabel(&#x27;World population&#x27;)ax3.set_title(&quot;Double Y axis&quot;)ax4 = ax3.twinx()ax4.plot(year, pop_cn, linestyle=&quot;--&quot;, color=&quot;r&quot;, label=&quot;China population&quot;)ax4.set_ylabel(&#x27;China population&#x27;)ax4.set_xlabel(&#x27;Year&#x27;)plt.savefig(&#x27;figure.pdf&#x27;, dpi=400, bbox_inches=&#x27;tight&#x27;) # 去除空白区域plt.show() 3.9.2.2点击关闭弹出的效果图 3.9.2.3查看保存的文件：打开火狐浏览器，地址栏键入如下内容（生成图片的绝对路径） 四、附录所有的代码汇总plt.py 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from datetime import datetimeimport matplotlib.dates as mdatesimport matplotlib.pyplot as pltyearInt = [2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020]year = [str(item) for item in yearInt] # 将yearInt中的数字转换成strpop = [6.49, 6.558, 6.656, 6.725, 6.804, 6.884, 6.965, 7.043, 7.125, 7.207, 7.356, 7.380, 7.405, 7.440, 7.468, 8.020]xs = [datetime.strptime(d, &#x27;%Y&#x27;).date() for d in year] # 将year中的每个如&#x27;2005&#x27;的字符串转换成只包含年的日期plt.gca().xaxis.set_major_formatter(mdates.DateFormatter(&#x27;%Y&#x27;)) # gca()获得坐标轴；plt.gca().xaxis.set_major_locator(mdates.YearLocator()) # 年份plt.plot(xs, pop) # 绘制图表plt.gcf().autofmt_xdate() # 将x轴的日期自动旋转角度plt.show() # 显示图表plt.figure()pop_cn = [1.30756, 1.31448, 1.32129, 1.32802, 1.33450, 1.34091, 1.34735, 1.35404, 1.36072, 1.36782, 1.36790, 1.36801, 1.36813, 1.36832, 1.36845, 1.36860]plt.plot(year, pop, color=&quot;g&quot;, label=&quot;World population&quot;)plt.plot(year, pop_cn, linestyle=&quot;--&quot;, color=&quot;r&quot;, label=&quot;China population&quot;)plt.xlabel(&#x27;year&#x27;)plt.ylabel(&#x27;Population&#x27;)plt.text(&#x27;2008&#x27;, 6.725, &#x27;2013&#x27;)plt.legend(loc=1)plt.title(&quot;World Population Summary&quot;)plt.show()f, (ax1, ax2) = plt.subplots(2, sharex=True) # f是Figure对象；ax1,ax2分别是Axesax1.scatter(year, pop) # 绘制散点图ax2.scatter(year, pop_cn)ax1.set_title(&#x27;World Population Summary&#x27;) # 设置标题ax2.set_title(&quot;China Population Summary&quot;)plt.show()fig = plt.figure()ax3 = fig.add_subplot(111) # 参数是1个3位的整数或3个分隔的整数，描述子图的位置，分别是nrows,ncols,indexax4 = ax3.twinx() # 创建一个x轴，并创建一个与原y轴处于相对位置的新y轴ax3.plot(year, pop, color=&quot;g&quot;, label=&quot;World population&quot;)ax4.plot(year, pop_cn, linestyle=&quot;--&quot;, color=&quot;r&quot;, label=&quot;China population&quot;)ax3.set_ylabel(&#x27;World population&#x27;)ax3.set_title(&quot;Double Y axis&quot;)ax4.set_ylabel(&#x27;China population&#x27;)ax4.set_xlabel(&#x27;Year&#x27;)plt.show()fig = plt.figure()ax3 = fig.add_subplot(111)ax3.plot(year, pop, color=&quot;g&quot;, label=&quot;World population&quot;)ax3.set_ylabel(&#x27;World population&#x27;)ax3.set_title(&quot;Double Y axis&quot;)ax4 = ax3.twinx()ax4.plot(year, pop_cn, linestyle=&quot;--&quot;, color=&quot;r&quot;, label=&quot;China population&quot;)ax4.set_ylabel(&#x27;China population&#x27;)ax4.set_xlabel(&#x27;Year&#x27;)plt.savefig(&#x27;figure.pdf&#x27;, dpi=400, bbox_inches=&#x27;tight&#x27;) # 去除空白区域plt.show()","categories":[{"name":"大数据","slug":"大数据","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"实战","slug":"大数据/实战","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://666wxy666.github.io/tags/Python/"},{"name":"大数据","slug":"大数据","permalink":"https://666wxy666.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Matplotlib","slug":"Matplotlib","permalink":"https://666wxy666.github.io/tags/Matplotlib/"}]},{"title":"Linux 上机实战4 SimpleShell","slug":"Linux-上机实战4-SimpleShell","date":"2020-06-01T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/06/01/Linux-上机实战4-SimpleShell/","link":"","permalink":"https://666wxy666.github.io/2020/06/01/Linux-%E4%B8%8A%E6%9C%BA%E5%AE%9E%E6%88%984-SimpleShell/","excerpt":"本文是关于Linux中的一个简单的shell，支持运行多个命令以[;]分割，支持管道和重定向，支持CTRL-C终止内部命令而不终止simple shell本身，有完善的错误处理及醒目的颜色提示。","text":"本文是关于Linux中的一个简单的shell，支持运行多个命令以[;]分割，支持管道和重定向，支持CTRL-C终止内部命令而不终止simple shell本身，有完善的错误处理及醒目的颜色提示。 一、实验环境硬件： Intel i7 7700HQ，内存16GB； 软件： 基于Arch Linux的Manjaro Linux内核：Linux 5.4.39-1-MANJARO x86_64 C语言 二、基本步骤 编写代码grep+wc.c（代码源码见附件grep+wc.c或本文最后的附录）： 编译 在grep+wc.c的基础上进行拓展，编写代码simple_shell.c（代码源码见附件simple_shell.c或本文最后的附录）： 在编写时遇到了一个棘手的问题，就是关于“子进程对父进程信号的继承情况”。总结一下就是： 仅fork时子进程会继承父进程fork之前所设置的信号处理方式。 当有exec加载新程序时 子进程继承的处理方式是忽略或默认处理方式时，exec新程序后设置依然有效。 如果子进程继承是捕获处理方式时，exec新程序后将被还原为默认处理方式。 详细请查看这位大佬的文章子进程对父进程信号的继承情况详细分析（信号）【linux】（zs）。 编译 三、测试样例0、在Shell（zsh）里运行所给命令 1、grep+wc 2、simple_shell1.特殊命令 2.普通命令 3.重定向命令 4.管道命令 5.综合命令 6.错误命令 7.CTRL-C输入find / -name hello，在运行期间输入CTRL-C杀死正在运行的find程序。可以发现find命令停止，但是Simple Shell并没有退出（输入exit可以正常退出）。 四、项目地址本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看： 源码仓库 五、附录PS:程序源码均有详细的注释 1、grep+wc.c 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char const *argv[])&#123; int sv; int fd[2]; pipe(fd); if (fork() == 0) &#123; // 输入重定向 int fd0 = -1; fd0 = open(&quot;/etc/passwd&quot;, O_RDONLY); if (fd0 != -1) &#123; dup2(fd0, 0); close(fd0); &#125; // 管道输入端 dup2(fd[1], 1); close(fd[1]); close(fd[0]); // 执行管道前的命令 execlp(&quot;grep&quot;, &quot;grep&quot;, &quot;-v&quot;, &quot;usr&quot;, 0); exit(1); &#125; else &#123; if (fork() == 0) &#123; // 输出重定向 int fd1 = -1; fd1 = open(&quot;r.txt&quot;, O_CREAT | O_WRONLY | O_TRUNC, 0666); if (fd1 != -1) &#123; dup2(fd1, 1); close(fd1); &#125; // 管道输出端 dup2(fd[0], 0); close(fd[0]); close(fd[1]); // 执行管道后的命令 execlp(&quot;wc&quot;, &quot;wc&quot;, &quot;-l&quot;, 0); exit(1); &#125; &#125; close(fd[0]); close(fd[1]); wait(&amp;sv); wait(&amp;sv); // 执行第二个命令 execlp(&quot;cat&quot;, &quot;cat&quot;, &quot;r.txt&quot;, 0); return 0;&#125; 2、simple_shell.c 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;setjmp.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;// 颜色#define NONE &quot;\\e[0m&quot; // 复原#define RED &quot;\\e[0;31m&quot; // ERRORchar version[] = &quot;1.0&quot;; // 版本号int pipe_flag = 0; // 是否使用管道static jmp_buf env;int sv;// CTRL-C回调函数void sig_handler(int sig)&#123; if (pipe_flag) &#123; wait(&amp;sv); wait(&amp;sv); &#125; else &#123; wait(&amp;sv); &#125; printf(&quot;\\n&quot;); siglongjmp(env, 1);&#125;// 打印帮助void help()&#123; printf(&quot;**********************************************************\\n&quot;); printf(&quot;%27sHELP%27s\\n**********************************************************\\n&quot;, &quot;&quot;, &quot;&quot;); printf(&quot;Simple Shell %s by Sekiro May 21 2020\\n&quot;, version); printf(&quot;Usage: [COMMAND] [OPTION]... (&lt; [INFILE]) (| [COMMAND] [OPTION]... (&gt; [OUTFILE])) (;...;...)\\n&quot;); printf(&quot;Simple shell with redirect and pipe(Can also run multiple commands)\\nSpecial commands:\\n&quot;); printf(&quot;\\thelp\\tDisplay this help and continue\\n&quot;); printf(&quot;\\texit\\tExit simple shell\\n&quot;); printf(&quot;**********************************************************\\n&quot;);&#125;int main(int argc, char const *argv[])&#123; char buffer[256], *argv1[256], **p, *argv2[256], *buf, *end, *cmd2, *in, *out; int fd[2]; // CTRL-C信号自行处理 signal(SIGINT, sig_handler); for (;;) &#123; sigsetjmp(env, 1); // 打印提示符 printf(&quot;=&gt; &quot;); // 获取命令 if (fgets(buffer, sizeof(buffer), stdin) == NULL) exit(0); //没有输入任何命令 if (strlen(buffer) == 1) &#123; continue; &#125; // 命令最后加;用于判断 if (buffer[strlen(buffer) - 2] != &#x27;;&#x27;) &#123; buffer[strlen(buffer) - 1] = &#x27;;&#x27;; &#125; // 获取每一条;分割的命令，依次执行 for (buf = buffer; end = strstr(buf, &quot;;&quot;); buf = end) &#123; *end++ = &#x27;\\0&#x27;; pipe_flag = 0; // 获取管道命令，输入重定向文件和输出重定向文件 // note:必须先获取管道命令，in和out在进行分词操作，因为分词会修改buf，导致获取管道命令，in和out出错 cmd2 = strstr(buf, &quot;|&quot;); in = strstr(buf, &quot;&lt;&quot;); out = strstr(buf, &quot;&gt;&quot;); if (in != NULL) &#123; *in++ = &#x27;\\0&#x27;; in = strtok(in, &quot; \\t\\n&quot;); &#125; if (out != NULL) &#123; *out++ = &#x27;\\0&#x27;; out = strtok(out, &quot; \\t\\n&quot;); &#125; if (cmd2 != NULL) &#123; pipe_flag = 1; *cmd2++ = &#x27;\\0&#x27;; for (p = &amp;argv2[0], *p = strtok(cmd2, &quot; \\t\\n&quot;); *p != NULL; *++p = strtok(NULL, &quot; \\t\\n&quot;)) ; if (argv2[0] == NULL) &#123; fprintf(stderr, RED &quot;** No command 2 input!\\n&quot; NONE); continue; &#125; &#125; for (p = &amp;argv1[0], *p = strtok(buf, &quot; \\t\\n&quot;); *p != NULL; *++p = strtok(NULL, &quot; \\t\\n&quot;)) ; // 没有命令输入 if (argv1[0] == NULL) &#123; fprintf(stderr, RED &quot;** No command 1 input!\\n&quot; NONE); continue; &#125; // 输入了exit if (strcmp(argv1[0], &quot;exit&quot;) == 0) exit(0); // 输入了help if (strcmp(argv1[0], &quot;help&quot;) == 0) &#123; help(); continue; &#125; // 使用了管道 if (pipe_flag) &#123; pipe(fd); if (fork() == 0) &#123; // 输入重定向 int fd0 = -1; if (in != NULL) fd0 = open(in, O_RDONLY); if (fd0 != -1) &#123; dup2(fd0, 0); close(fd0); &#125; else if (in != NULL) &#123; fprintf(stderr, RED &quot;** No such file or directory: %s\\n&quot; NONE, in); help(); exit(1); &#125; // 管道输入端 dup2(fd[1], 1); close(fd[1]); close(fd[0]); // 执行管道前的命令 execvp(argv1[0], argv1); fprintf(stderr, RED &quot;** Bad command 1: %m\\n&quot; NONE); help(); exit(1); &#125; else &#123; if (fork() == 0) &#123; // 输出重定向 int fd1 = -1; if (out != NULL) fd1 = open(out, O_CREAT | O_WRONLY | O_TRUNC, 0666); if (fd1 != -1) &#123; dup2(fd1, 1); close(fd1); &#125; // 管道输出端 dup2(fd[0], 0); close(fd[0]); close(fd[1]); // 执行管道后的命令 execvp(argv2[0], argv2); fprintf(stderr, RED &quot;** Bad command 2: %m\\n&quot; NONE); help(); exit(1); &#125; &#125; close(fd[0]); close(fd[1]); wait(&amp;sv); wait(&amp;sv); &#125; // 没有使用管道 else &#123; if (fork() == 0) &#123; int fd0 = -1, fd1 = -1; // 输入重定向 if (in != NULL) fd0 = open(in, O_RDONLY); if (fd0 != -1) &#123; dup2(fd0, 0); close(fd0); &#125; else if (in != NULL) &#123; fprintf(stderr, RED &quot;** No such file or directory: %s\\n&quot; NONE, in); help(); exit(1); &#125; // 输出重定向 if (out != NULL) fd1 = open(out, O_CREAT | O_WRONLY | O_TRUNC, 0666); if (fd1 != -1) &#123; dup2(fd1, 1); close(fd1); &#125; // 执行命令 execvp(argv1[0], argv1); fprintf(stderr, RED &quot;** Bad command 1: %m\\n&quot; NONE); help(); exit(1); &#125; wait(&amp;sv); &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/categories/Linux/"},{"name":"上机实战","slug":"Linux/上机实战","permalink":"https://666wxy666.github.io/categories/Linux/%E4%B8%8A%E6%9C%BA%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"C","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://666wxy666.github.io/tags/Shell/"}]},{"title":"机器学习 实验 K-Means聚类","slug":"机器学习-实验-K-Means聚类","date":"2020-05-17T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/05/17/机器学习-实验-K-Means聚类/","link":"","permalink":"https://666wxy666.github.io/2020/05/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%AE%9E%E9%AA%8C-K-Means%E8%81%9A%E7%B1%BB/","excerpt":"本文是关于经典聚类算法K-Means的代码实现。","text":"本文是关于经典聚类算法K-Means的代码实现。 一、实验目标数据说明：目标是对 cluster.dat 里的数据进行聚类分析。其中，cluster.dat 包含了若干二维输入数据（但不包含其输出）。 使用 K-means 模型进行聚类，尝试使用不同的类别个数 K，并分析聚类结果。 按照 8:2 的比例随机将数据划分为训练集和测试集，至少尝试 3 个不同的 K 值，并画出不同 K 下的聚类结果，及不同模型在训练集和测试集上的损失。对结果进行讨论，发现能解释数据的最好的 K值。 二、实验环境 语言：Python 3.7（Anaconda3） IDE：PyCharm 2020.1.1 (Professional Edition) Packages： numpy：1.18.1 matplotlib：3.1.3 三、算法原理聚类是一种典型无监督学习，K-means算法是聚类的经典算法。目标是将原始数据集划分为k个簇，最小化损失函数（目标函数）是：$$SSE=\\sum_{n=1}^{N}\\sum_{k=1}^{K}r_{nk}dist(x_n-\\mu_k)$$ $\\mu_k$表示簇$C_k$的中心点（或其他能代表$C_k$的点）。 $x_n$被划分到簇$C_k$则$r_{nk}=1$，否则$r_{nk}=0$。 目标是找到簇的中心点$\\mu_k$及簇的划分$r_{nk}$使得目标函数SSE最小。 要解决上述问题就需要遍历所有可能的簇划分，显然这是不合适的。K-means算法使用了贪心策略求一个近似解，具体步骤如下： 将全部数据随机分为k类，计算每类的重心作为初始点。 计算所有数据点与各个簇中心之间的距离，将数据点划到与它距离最近的簇中。 根据簇中已有的样本点，重新计算簇中心（一般使用重心）。 重复2、3，直到数据点的簇划分不在变化或者达到了规定的最大迭代次数。 这是k-means算法的基本步骤，但是，这个算法有个很严重的问题，就是在将数据点划到与它距离最近的簇后，由于初始簇心选择不当，可能产生空簇，导致计算簇中心无法进行（簇的size=0，除数为0），我的解决方法是在计算簇心时，如果簇的size=0就先忽略，后面单独处理。计算完非空簇心后，依次选取与自己簇中心最远、次远……的点（因为距离自己的簇心越远，这个点分到该簇的概率越低）作为空簇的簇心，直到没有空簇，即所有的簇都有簇心，然后继续算法。 四、算法流程图这只是算法函数（algorithm）和其他一些部分的流程图，不是整个程序的流程图，整个程序要更复杂。 五、实验结果及分析 输入k的范围是[2,10]，测试集所占比例为0.2，最大迭代次数为20。 聚类结果 k从2~10的数据集、训练集和测试集的SSE如图： 可以发现k=2~4时SSE下降较快，k=4~10时下降较慢，由于我们的目标是使SSE减小，因此由图可以得出k=4为解释数据较好的k。并且在k=2时，重复实验甚至会出现完全不同的聚类结果，说明k=2太小。在k&gt;=6之后，SSE基本不下降，说明k再加大没有多大意义。 六、项目地址本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看： 七、附录kmeans.py： 1、基本配置、全局参数 点击查看代码 1234567891011121314151617181920212223242526import randomimport sysimport matplotlib.pyplot as pltimport numpy as npfrom sklearn.model_selection import train_test_split######################################################### 全局变量######################################################### 显示中文标签plt.rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;SimHei&#x27;]# 显示负号plt.rcParams[&#x27;axes.unicode_minus&#x27;] = False# 簇个数范围k_min = 1k_max = 1max_iteration = 10 # 最大迭代次数test_rate = 0.2 # 训练集所占比例all_point_num = 0data_x = [] # 点的x坐标列表data_y = [] # 点的y坐标列表data_SSE_list = [] # 数据集损失目标函数列表train_SSE_list = [] # 训练集损失目标函数列表test_SSE_list = [] # 测试集损失目标函数列表 2、读入数据 点击查看代码 123456789101112131415161718192021222324252627282930######################################################### 读入数据########################################################def read_data(path): global all_point_num global test_rate global max_iteration global k_min global k_max data = open(path) # 打开数据文件 for line in data: # 将数据文件的每一行按空格分隔，分别添加到x,y列表 data_x.append(float(line.split()[0])) data_y.append(float(line.split()[1])) all_point_num += 1 print(&quot;请输入k的范围（空格分隔，例如2 5，代表闭区间[2,5]）：&quot;, end=&quot;&quot;) k_min, k_max = map(int, input().split()) if k_min &gt; k_max or k_min &lt; 1 or k_max &lt; 1: print(&quot;ERROR: 簇的个数输入错误！&quot;) sys.exit(1) print(&quot;请输入测试集所占比例：&quot;, end=&quot;&quot;) test_rate = float(input()) if test_rate &lt; 0 or test_rate &gt; 1: print(&quot;ERROR: 测试集所占比例输入错误！&quot;) sys.exit(1) print(&quot;请输入最大迭代次数：&quot;, end=&quot;&quot;) max_iteration = int(input()) if max_iteration &lt; 0: print(&quot;ERROR: 最大迭代次数输入错误！&quot;) sys.exit(1) 3、算法计算 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081######################################################### 算法########################################################def algorithm(x, y, k): # 初始化 n = 0 # 迭代次数 SSE = 0 # 损失（目标）函数 point_array = np.array([x, y]) # 生成点的numpy数组，例如三个点(1，-1),(2，-2),(3，-3)生成[[ 1 2 3 ][ -1 -2 -3 ]] point_num = point_array.shape[1] # 获取点的个数，所给的数据集为1000个点，取0.8为800个 # 如果点的个数&lt;簇的个数，则报错异常退出 if point_num &lt; k: print(&quot;ERROR: 点的个数&lt;簇的个数！&quot;) sys.exit(1) distance = np.zeros(k) # 初始化k维0向量，用来存储这个点到的k个簇中心的距离 point_distance = np.zeros(point_num) # 初始化point_num维0向量，用来存储每个点到其簇中心的距离 center = np.zeros((2, k)) # 生成2*k的零矩阵，初始化k个簇的中心点，后面将先计算每个簇的重心作为初始簇中心 point_k1 = np.arange(0, k, 1) # 先生成0~k-1的数组，保证每个簇至少有一个点 point_k2 = np.random.randint(0, k, size=point_num - k) # 将剩下的点随机分到任意一个簇，返回长度为point_num-k的向量，每个为0~k-1的随机整数 point_k = np.concatenate((point_k1, point_k2)) # 将前两个数组合成为一个 np.random.shuffle(point_k) # 最后再打乱一次point_k数组，保证随机性 point_k_bak = point_k.copy() # point_k的备份，用于判断前后两次迭代是否发生变化 # 输出相关信息 print(&quot;点个数为：&quot;, point_num, sep=&quot;&quot;) # 开始K-means算法的迭代 # 只要迭代次数没有超过最大迭代次数上限max_iteration并且两次迭代的结果还有变化，就继续迭代 while n &lt;= max_iteration: # 计算每个簇的中心 size = np.bincount(point_k, minlength=k) # 计算每个簇的规模，k维向量，每一维为每个簇里点的个数 for i in range(k): # 对于k个簇中的每一个簇i # 不是空簇，防止出现除数为0，空簇下面单独处理 if size[i] != 0: # point_sum是一个二维向量，代表i簇中的所有点的x,y坐标值的和 point_sum = np.zeros(2) # 初始化为0 # 计算i簇中的所有点的x,y坐标值的和 for point in range(point_num): # 对于每一个点point if point_k[point] == i: # 如果这个点point属于簇i point_sum = point_sum + point_array[:, point] # 将这个点的x,y坐标加到point_sum上 # note: array[:, i]就是取array的第i列，刚好就是这个点 # 求平均数，因此要/这个簇中点的个数size[i] # 将计算出的簇中心存在center矩阵中的第i列，代表第i个簇的中心点 center[:, i] = point_sum / size[i] # 对所有的空簇单独处理 # 处理方式为把与自己所在的簇中心距离最大的点作为空簇的簇中心 for c in np.where(size == 0)[0]: # 将距离最大的点的所在簇改为空簇的簇号 point_k[np.argmax(point_distance)] = c # 将空簇中心改为这个点 center[:, c] = point_array[:, np.argmax(point_distance)] # 将每一个点分到与簇中心最近的簇 for point in range(point_num): # 对于每一个点point for i in range(k): # 对于k个簇中的每一个簇i # 计算该点point到该簇i的距离 # note: 使用矩阵的2范式，来计算欧氏距离 # point_array[:, point] - center[:, i]得到向量[p_x-c_x, p_y-c_y] # 对该向量求2范式刚好是欧式距离sqrt((p_x-c_x)^2+(p_y-c_y)^2) distance[i] = np.linalg.norm(point_array[:, point] - center[:, i]) # 使用numpy的argmin()返回distance中最小值的下标，也就是点point到簇中心距离最小的簇 point_k[point] = np.argmin(distance) # 将该点到其簇中心的距离记录下来 point_distance[point] = distance[point_k[point]] # 迭代次数+1 n += 1 # 判断两次迭代是否有变化，没有变化就跳出迭代循环 if (point_k == point_k_bak).all(): break # 将point_k备份 point_k_bak = point_k.copy() # 输出每次迭代目标函数值 SSE = np.sum(point_distance) print(&quot;n=&quot;, n - 1, &quot;，SSE=&quot;, SSE, sep=&quot;&quot;) # 输出相关信息 print(&quot;总迭代次数为：&quot;, n - 1, sep=&quot;&quot;) print(&quot;每个簇的中心：&quot;, sep=&quot;&quot;) for i in range(k): print(&quot;(&quot;, center[0, i], &quot;,&quot;, center[1, i], &quot;)&quot;, sep=&quot;&quot;) print(&quot;===================================================&quot;) return SSE, point_k 4、画图展示 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566######################################################### 画图展示######################################################### 根据每个点所在的簇，获取点的颜色，返回一个列表def get_color_list(point_k, k): # 随机生成k个颜色 RGB = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;] colors = [] i = 0 while i &lt; k: color = &quot;&quot; for j in range(6): color += RGB[random.randint(0, 14)] # 只有随机产生的颜色不相同，才加到colors中，颜色个数+1 if &quot;#&quot; + color not in colors and color != &quot;FFFFFF&quot;: colors.append(&quot;#&quot; + color) i += 1 # 对每个点，根据point_k中记录的点所在的簇，将颜色添加到列表中 color_list = [] for c in point_k: color_list.append(colors[c]) return color_list# 画散点图展示聚类结果（数据集，训练集、测试集）def show(x, y, result, x1, y1, result1, x2, y2, result2, k): # 数据集图 plt.subplot(131) # 设置标题 plt.title(&quot;K-Means数据集&quot;) # 绘制散点图 # note: scatter函数支持传入颜色列表，对每一个点使用列表相应下标对应的颜色 plt.scatter(x, y, c=get_color_list(result, k)) # 训练集图 plt.subplot(132) # 设置标题 plt.title(&quot;K-Means训练集&quot;) # 绘制散点图 plt.scatter(x1, y1, c=get_color_list(result1, k)) # 测试集图 plt.subplot(133) # 设置标题 plt.title(&quot;K-Means测试集&quot;) # 绘制散点图 plt.scatter(x2, y2, c=get_color_list(result2, k)) # 展示散点图 plt.show()# 画折线图展示SSE对比def show_SSE(): # 设置标题 plt.title(&quot;K-Means在不同k下的损失&quot;) # 设置x轴坐标 plt.xlim(k_min - 1, k_max + 2) plt.xlabel(&quot;k&quot;) # 设置x轴标注 plt.ylabel(&quot;SSE&quot;) # 设置y轴标注 # 绘制K-Means在不同k下训练集和测试集的损失 plt.plot(range(k_min, k_max + 1), data_SSE_list, lw=1, c=&#x27;blue&#x27;, marker=&#x27;v&#x27;, ms=4, label=&#x27;数据集&#x27;) plt.plot(range(k_min, k_max + 1), train_SSE_list, lw=1, c=&#x27;red&#x27;, marker=&#x27;s&#x27;, ms=4, label=&#x27;训练集&#x27;) plt.plot(range(k_min, k_max + 1), test_SSE_list, lw=1, c=&#x27;green&#x27;, marker=&#x27;o&#x27;, label=&#x27;测试集&#x27;) plt.legend() # 图例 plt.show() 5、开始运行 点击查看代码 12345678910111213141516171819202122232425262728293031######################################################### 开始运行######################################################### 读入数据read_data(&quot;cluster.dat&quot;)# 划分训练集和测试集train_x, test_x, train_y, test_y = train_test_split(data_x, data_y, test_size=test_rate, random_state=1)# 对k从2~5进行聚类for k_num in range(k_min, k_max + 1): print(&quot;###################################################&quot;) print(&quot;簇个数为：&quot;, k_num, sep=&quot;&quot;) # 数据集 print(&quot;数据集：&quot;) data_SSE, data_result = algorithm(data_x, data_y, k_num) data_SSE_list.append(data_SSE) # 训练集 print(&quot;训练集：&quot;) train_SSE, train_result = algorithm(train_x, train_y, k_num) train_SSE_list.append(train_SSE) # 测试集 print(&quot;测试集：&quot;) test_SSE, test_result = algorithm(test_y, test_y, k_num) test_SSE_list.append(test_SSE) # 输出平均SSE print(&quot;数据集最终平均损失函数AVG_SSE：&quot;, data_SSE / all_point_num) print(&quot;训练集最终平均损失函数AVG_SSE：&quot;, train_SSE / (all_point_num * (1 - test_rate))) print(&quot;测试集最终平均损失函数AVG_SSE：&quot;, test_SSE / (all_point_num * test_rate)) # 画图 show(data_x, data_y, data_result, train_x, train_y, train_result, test_x, test_y, test_result, k_num)# 画图展示SSEshow_SSE()","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://666wxy666.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"实验","slug":"机器学习/实验","permalink":"https://666wxy666.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://666wxy666.github.io/tags/Python/"},{"name":"机器学习","slug":"机器学习","permalink":"https://666wxy666.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"K-Means","slug":"K-Means","permalink":"https://666wxy666.github.io/tags/K-Means/"},{"name":"聚类","slug":"聚类","permalink":"https://666wxy666.github.io/tags/%E8%81%9A%E7%B1%BB/"}]},{"title":"大数据实战 Spark Streaming 实时计算Kafka数据","slug":"大数据实战-Spark-Streaming-实时计算Kafka数据","date":"2020-05-14T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/05/14/大数据实战-Spark-Streaming-实时计算Kafka数据/","link":"","permalink":"https://666wxy666.github.io/2020/05/14/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%88%98-Spark-Streaming-%E5%AE%9E%E6%97%B6%E8%AE%A1%E7%AE%97Kafka%E6%95%B0%E6%8D%AE/","excerpt":"本文是关于大数据通过Spark Streaming实现流计算Kafka数据进行单词计数。","text":"本文是关于大数据通过Spark Streaming实现流计算Kafka数据进行单词计数。 一、实验环境： 虚拟机数量：3(一主两从，主机名分别为：master、slave01、slave02) 系统版本：Centos 7.5 Zookeeper版本： Apache Zookeeper 3.4.10 Kafka版本：kafka_2.11-0.10.2.1 Spark版本：Apache Spark 2.1.1 二、实验内容： 通过创建Kafka topic，使用Kafka Producer产生消息，然后通过编写sparkStreaming程序处理这些消息。 主要步骤： 创建Spark Streaming项目工程 编写streaming程序 启动Zookeeper，Kafka集群 创建topic 启动Kafka生产者 准备作业环境 提交作业 三、实验步骤：3.1打开IDEA软件123cdcd idea-IC-172.4574.19/bin/idea.sh &amp; 3.2创建项目3.2.1创建同之前章节结构一致的项目spark_test, 设置语言级别为8。 3.2.2点击 Create New Project，进入如下图界面，按照图标依次点击，最后点击next。 3.2.3依次输入GroupId和ArtifactId和Version的值，随后点击next。 3.2.4进入如下界面，设置本地Maven项目的setting.xml文件和warehouse仓库，点击next按钮。 3.2.4.1本地setting.xml文件在/home/zkpk/apache-maven-3.5.0/conf目录下。 3.2.4.2本地仓库文件夹warehouse在/home/zkpk/apache-maven-3.5.0/warehouse。 3.2.5进入如下界面，输入工程名称spark_test，然后点击next，OK。 3.2.6工程创建完成后会自动打开一个名为zkpk的xml文件，按照以下修改： 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.zkpk.lab&lt;/groupId&gt; &lt;artifactId&gt;zkpk&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;inceptionYear&gt;2008&lt;/inceptionYear&gt; &lt;properties&gt; &lt;scala.version&gt;2.11.11&lt;/scala.version&gt; &lt;spark.version&gt;2.1.1&lt;/spark.version&gt; &lt;hadoop.version&gt;2.7.3&lt;/hadoop.version&gt; &lt;kafka.version&gt;0.10.2.1&lt;/kafka.version&gt; &lt;/properties&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;scala-tools.org&lt;/id&gt; &lt;name&gt;Scala-Tools Maven2 Repository&lt;/name&gt; &lt;url&gt;http://scala-tools.org/repo-releases&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;scala-tools.org&lt;/id&gt; &lt;name&gt;Scala-Tools Maven2 Repository&lt;/name&gt; &lt;url&gt;http://scala-tools.org/repo-releases&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.scala-lang&lt;/groupId&gt; &lt;artifactId&gt;scala-library&lt;/artifactId&gt; &lt;version&gt;$&#123;scala.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-core_2.11&lt;/artifactId&gt; &lt;version&gt;$&#123;spark.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-sql_2.11&lt;/artifactId&gt; &lt;version&gt;$&#123;spark.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-streaming_2.11&lt;/artifactId&gt; &lt;version&gt;$&#123;spark.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-streaming-kafka-0-10_2.11&lt;/artifactId&gt; &lt;version&gt;$&#123;spark.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt; &lt;artifactId&gt;kafka_2.11&lt;/artifactId&gt; &lt;version&gt;$&#123;kafka.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;sourceDirectory&gt;src/main/scala&lt;/sourceDirectory&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.scala-tools&lt;/groupId&gt; &lt;artifactId&gt;maven-scala-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;goal&gt;testCompile&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;scalaVersion&gt;$&#123;scala.version&#125;&lt;/scalaVersion&gt; &lt;args&gt; &lt;arg&gt;-target:jvm-1.5&lt;/arg&gt; &lt;/args&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-eclipse-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;downloadSources&gt;true&lt;/downloadSources&gt; &lt;buildcommands&gt; &lt;buildcommand&gt;ch.epfl.lamp.sdt.core.scalabuilder&lt;/buildcommand&gt; &lt;/buildcommands&gt; &lt;additionalProjectnatures&gt; &lt;projectnature&gt;ch.epfl.lamp.sdt.core.scalanature&lt;/projectnature&gt; &lt;/additionalProjectnatures&gt; &lt;classpathContainers&gt; &lt;classpathContainer&gt;org.eclipse.jdt.launching.JRE_CONTAINER&lt;/classpathContainer&gt; &lt;classpathContainer&gt;ch.epfl.lamp.sdt.launching.SCALA_CONTAINER&lt;/classpathContainer&gt; &lt;/classpathContainers&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;reporting&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.scala-tools&lt;/groupId&gt; &lt;artifactId&gt;maven-scala-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;scalaVersion&gt;$&#123;scala.version&#125;&lt;/scalaVersion&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/reporting&gt;&lt;/project&gt; 3.2.7保存修改的pom.xml文件后，点击工程名，依次选择Maven——&gt;Reimport，即可根据pom.xml文件导入依赖包。 3.2.8设置语言环境language level，点击菜单栏中的file，选择Project Structure，弹出如下对话框，选择Modules，选择Language level为8，然后点击Apply，点击OK。 3.2.9设置Java Compiler环境，点击菜单栏中的file，选择Setting，弹出如下对话框，依次选择Build，Execution——&gt;Compiler——&gt;Java Compiler，设置图中的Project bytecode version为1.8，设置图中的Target bytecode version为1.8，然后依次点击Apply和OK。 至此，Spark Maven工程创建完毕。 3.2.10在项目sclaa文件下的org.zkpk.lab下新建“kafka_streaming”Object。 创建完成后的工程结构： 3.3编写scala代码下面是部分代码截图，具体代码在本文的附录中。 3.4使用maven打包程序开始打包。 打包完成。 3.5启动Zookeeper集群3.5.1分别登录master和slave01、slave02节点，进入zookeeper安装目录，启动服务。 3.5.2在三个节点上分别运行bin/zkServer.sh status命令查看状态，出现follower或leader表示ZK启动成功。 3.6启动Kafka集群在 master 和 slave01、slave02节点分别启动 Kafka。 3.7创建Kafka topic名称需要和代码中保持一致。 3.8在一个终端上启动一个生产者,准备生产 3.9使用spark-submit提交spark 应用3.9.1将生成的jar包文件复制到/home/zkpk下。 3.9.2提交sparkjob之前需要将spark-streaming-kafka-0-10_2.11-2.1.0，kafka-clients-0.10.2.这两个jar添加到spark_home/jars/路径下，否则程序提交会报错。 3.9.3新开一个终端，在/home/zkpk目录下提交程序。 1spark-submit --class org.zkpk.lab.kafka_streaming zkpk-1.0.jar 3.10输入内容，查看结果切换到之前的Kafka生产者终端中输入如下内容，然后切换到sparkStreaming任务界面查看结果。 输入： 结果： 输入： 结果： 输入： 结果： 四、附录kafka_streaming.scala 点击查看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243package org.zkpk.labimport org.apache.kafka.common.serialization.StringDeserializerimport org.apache.spark.streaming.&#123;Seconds, StreamingContext&#125;import org.apache.spark.SparkConfimport org.apache.spark.streaming.kafka010._import org.apache.spark.streaming.kafka010.LocationStrategies.PreferConsistentimport org.apache.spark.streaming.kafka010.ConsumerStrategies.Subscribeobject kafka_streaming &#123; def main(args: Array[String]): Unit = &#123; val conf = new SparkConf().setMaster(&quot;local[2]&quot;).setAppName(&quot;kafka_test&quot;) val ssc = new StreamingContext(conf, Seconds(3)) val kafkaParams = Map[String, Object]( &quot;bootstrap.servers&quot; -&gt; &quot;master:9092&quot;, &quot;key.deserializer&quot; -&gt; classOf[StringDeserializer], &quot;value.deserializer&quot; -&gt; classOf[StringDeserializer], &quot;group.id&quot; -&gt; &quot;example&quot;, &quot;auto.offset.reset&quot; -&gt; &quot;latest&quot;, &quot;enable.auto.commit&quot; -&gt; (false: java.lang.Boolean) ) val topics = List(&quot;test_kafka&quot;).toSet val stream = KafkaUtils.createDirectStream [String,String]( ssc, PreferConsistent, Subscribe[String,String](topics,kafkaParams) ) val lines = stream.map(_.value) val words = lines.flatMap(_.split(&quot; &quot;)) val wordcounts = words.map((_,1)).reduceByKey(_+_) wordcounts.print() ssc.start() ssc.awaitTermination() &#125;&#125;","categories":[{"name":"大数据","slug":"大数据","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"实战","slug":"大数据/实战","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://666wxy666.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Spark","slug":"Spark","permalink":"https://666wxy666.github.io/tags/Spark/"},{"name":"Scala","slug":"Scala","permalink":"https://666wxy666.github.io/tags/Scala/"},{"name":"流计算","slug":"流计算","permalink":"https://666wxy666.github.io/tags/%E6%B5%81%E8%AE%A1%E7%AE%97/"},{"name":"Streaming","slug":"Streaming","permalink":"https://666wxy666.github.io/tags/Streaming/"},{"name":"Kafka","slug":"Kafka","permalink":"https://666wxy666.github.io/tags/Kafka/"}]},{"title":"Linux MOOC习题 6~10章","slug":"Linux-MOOC习题-6~10章","date":"2020-05-12T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/05/12/Linux-MOOC习题-6~10章/","link":"","permalink":"https://666wxy666.github.io/2020/05/12/Linux-MOOC%E4%B9%A0%E9%A2%98-6~10%E7%AB%A0/","excerpt":"自己随便整理了一下在学习Linux网课时遇到的一些习题，易错点之类的，接上文Linux MOOC习题 1~5章。","text":"自己随便整理了一下在学习Linux网课时遇到的一些习题，易错点之类的，接上文Linux MOOC习题 1~5章。 PS：第七章是上机实验。 六、Linux命令风格和文件系统 这两个题都忽略了“符号链接”的作用。 这俩没啥好说的。 在Linux中，一般是-1代表失败，&gt;=0的值代表成功。 八、文件和目录的权限，Shell 目录有执行权限（即x权限）意味着分析路径名过程中可检索该目录。 九、替换，元字符和转义 如果你是执行这个命令的操作员，估计你马上就心情不好了。由于拼错了单词，把DATABASE不小心写成了DATEBASE，灾难来了。未命名的变量被bash替换为空字符串，实际上你以root身份执行了最邪恶的一条命令： 1rm -rf /* 永远不要盲目自信，谁也保证不了自己不会犯错误，怎么才能避免这样的悲剧发生？ 尽量不要以root身份登录。 bash有选项，引用未定义的变量会出错而不是替换为空字符串，可以打开这个选项。早期的编程语言把引用的未定义过的变量自动加上定义，这种做法实际上太糟糕，最早的FORTRAN语言就这种做法，据说曾因此导致一次太空任务失败。 在设计你自己的系统时，建库命令能够从目录名开始建库，就是说要求建库之前/opt/data下不需要存在目录puma，而不是要求建库之前/opt/data有个空目录puma，这样的话，即使你的命令变成了 1rm -rf $DATEBASE 因为你的失误，会导致rm命令抱怨缺少参数而什么都不做，这个结果是可以接受的。 在Linux中，目前我已知的Shell的元字符有： 1空格 制表符 回车 &gt; &lt; | ; &amp; $ * [ ] ? \\ ( ) &#x27;&#x27; &quot; &quot; 反撇号` 第11题中，这三个命令都可以取消文件通配符*的特殊作用，让echo直接打印字符*，并且这个替换是Shell进行的，也就是说，echo拿到的命令都是一样的，他是分不清操作员输入的是哪个命令，这三个命令的参数： 而对于不转义的命令的参数： 1echo * 因此结果就很明显了： 十、shell流程控制：条件，循环与函数 B选项：明显的错误，then要么另起一行，要么前面加;。 C选项和D选项：都是没加fi，C选项还有其他的错误，这明显是和C语言之类的给混了。 所有的习题： Linux MOOC习题 1~5章Linux MOOC习题 6~10章Linux MOOC习题 11~15章","categories":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/categories/Linux/"},{"name":"习题","slug":"Linux/习题","permalink":"https://666wxy666.github.io/categories/Linux/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/tags/Linux/"},{"name":"习题","slug":"习题","permalink":"https://666wxy666.github.io/tags/%E4%B9%A0%E9%A2%98/"},{"name":"易错点","slug":"易错点","permalink":"https://666wxy666.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"MOOC","slug":"MOOC","permalink":"https://666wxy666.github.io/tags/MOOC/"}]},{"title":"计算机系统结构 实验5 指令调度与延迟分支","slug":"计算机系统结构-实验5-指令调度与延迟分支","date":"2020-05-11T00:00:00.000Z","updated":"2021-05-30T09:07:07.229Z","comments":true,"path":"2020/05/11/计算机系统结构-实验5-指令调度与延迟分支/","link":"","permalink":"https://666wxy666.github.io/2020/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AE%9E%E9%AA%8C5-%E6%8C%87%E4%BB%A4%E8%B0%83%E5%BA%A6%E4%B8%8E%E5%BB%B6%E8%BF%9F%E5%88%86%E6%94%AF/","excerpt":"本文是关于计算机系统结构实验五，指令调度与延迟分支。","text":"本文是关于计算机系统结构实验五，指令调度与延迟分支。 一、实验目的 加深对指令调度技术的理解。 加深对延迟分支技术的理解。 熟练掌握用指令调度技术解决流水线中的数据冲突的方法。 进一步理解指令调度技术对 CPU 性能的改进。 进一步理解延迟分支技术对 CPU 性能的改进。 二、实验步骤及结果分析1、启动 MIPSsim。 2、根据实验2的相关知识中关于流水线各段操作的描述，进一步理解流水线窗口中各段的功能，掌握各流水线寄存器的含义（双击各段，就可以看到各流水线寄存器中的内容）。①IF段： ②ID段： ③EX段： ④MEM段： ⑤WB段： 3、选择“配置”→“流水方式”选项，使模拟器工作在流水方式下。4、用指令调度技术解决流水线中的结构冲突与数据冲突： 启动 MIPSsim。用 MIPSsim 的“文件”-&gt;“载入程序”选项来加载 schedule.s（在模拟器所在文件夹下的“样例程序”文件夹中）。关闭定向功能，这是通过“配置“-&gt;”定向“选项来实现的。执行所载入的程序，通过查看统计数据和时钟周期图，找出并记录程序执行过程中各种冲突发生的次数，发生冲突的指令组合以及程序执行的总时钟周期数。 载入的程序： 执行结果： 寄存器的值 部分时钟周期图 统计 发现总共执行了33个周期，执行了15条指令，8次RAW停顿，RAW停顿有16个周期，RAW停顿占周期总数的百分比为48.48485%，所有的停顿为17个周期，占周期总数的百分比为51.51515%。$$吞吐率TP_1=\\frac{15}{33\\Delta{t}}$$ $$加速比S_1=\\frac{15\\times{5\\Delta{t}}}{33\\Delta{t}}\\approx{2.27}$$ 冲突的指令组合： 1-1和2-1，2-1和2-2，2-2和2-3，3-1和3-2，4-1和4-2，4-2和4-3，4-3和4-4，5-1和5-2共8对冲突，1-5组组内冲突，组间没有关联。 schedule.s： 点击查看代码 1234567891011121314151617181920212223242526.textmain:ADDIU $r1,$r0,A # 1-1LW $r2,0($r1) # 2-1ADD $r4,$r0,$r2 # 2-2SW $r4,0($r1) # 2-3LW $r6,4($r1) # 3-1ADD $r8,$r6,$r1 # 3-2MUL $r12,$r10,$r1 # 4-1ADD $r16,$r12,$r1 # 4-2ADD $r18,$r16,$r1 # 4-3SW $r18,16($r1) # 4-4LW $r20,8($r1) # 5-1MUL $r22,$r20,$r14 # 5-2MUL $r24,$r26,$r14 # 6-1TEQ $r0,$r0 # 7-1.dataA: .word 4,6,8​ 自己采用调度技术对程序进行指令调度，消除冲突（自己修改源程序）。将调度（修改）后的程序重新命名为 afer-schedule.s。（注意：调度方法灵活多样，在保证程序正确性的前提下自己随意调度，尽量减少冲突即可，不要求要达到最优。）载入 afer-schedule.s，执行该程序，观察程序在流水线中的执行情况，记录程序执行的总时钟周期数。 比较调度前和调度后的性能，论述指令调度对提高 CPU 性能的作用。 PS：调度后的程序见附录。 载入的程序： 执行结果： 寄存器的值 与不调度前完全一致，调度没有改变结果，调度正确。 时钟周期图 统计 发现总共执行了18个周期，执行了15条指令，1次RAW停顿，RAW停顿有1个周期，RAW停顿占周期总数的百分比为5.555555%，较没有静态调度的48.48485%少了很多，所有的停顿为2个周期，占周期总数的百分比为11.111111%，较没有静态调度的51.51515%也少了很多。$$吞吐率TP_2=\\frac{15}{18\\Delta{t}}$$ $$加速比S_2=\\frac{15\\times{5\\Delta{t}}}{18\\Delta{t}}\\approx{4.17}$$ 吞吐率和加速比是没有静态调度时的$\\frac{33}{18}\\approx{1.83}$倍。 5、用延迟分支技术减少分支指令对性能的影响： 在 MIPSsim 中载入 branch.s 样例程序（在本模拟器目录的“样例程序”文件夹中。关闭延迟分支功能。这是通过在“配置”-&gt;“延迟槽”选项来实现的。执行该程序，观察并记录发生分支延迟的时刻，记录该程序执行的总时钟周期数。 载入的程序： 执行结果： 寄存器的值 部分时钟周期图 统计 发现总共执行了38个周期，执行了18条指令，8次RAW停顿，RAW停顿有16个周期，RAW停顿占周期总数的百分比为42.10526%，控制停顿有2个周期，占周期总数的百分比为5.263158%，所有的停顿为19个周期，占周期总数的百分比为50%。发生分支延迟的时刻为第15个周期，延迟了2个周期。 $$ 吞吐率TP_1=\\frac{18}{38\\Delta{t}} $$ $$加速比S_1=\\frac{18\\times{5\\Delta{t}}}{38\\Delta{t}}\\approx{2.37}$$ 冲突的指令组合： 2-1和2-2，2-2和2-3，3-1和3-2，3-2和3-3共4对冲突，2组和3组组内冲突，组间没有关联。 branch.s： 点击查看代码 123456789101112131415161718.textmain:ADDI $r2,$r0,1024 # 1-1ADD $r3,$r0,$r0 # 1-2ADDI $r4,$r0,8 # 1-3loop: LW $r1,0($r2) # 2-1ADDI $r1,$r1,1 # 2-2SW $r1,0($r2) # 2-3ADDI $r3,$r3,4 # 3-1SUB $r5,$r4,$r3 # 3-2BGTZ $r5,loop # 3-3ADD $r7,$r0,$r6 # 4-1TEQ $r0,$r0 # 5-1​ 假设延迟槽为一个，自己对 branch.s 程序进行指令调度（自己修改源程序），将调度后的程序重新命名为 delayed-branch.s。 载入 delayed-branch.s，打开延迟分支功能，执行该程序，观察其时钟周期图，记录程序执行的总时钟周期数。 PS：调度后的程序见附录。 载入的程序： 执行结果： 寄存器的值 与不调度前完全一致，调度没有改变结果，调度正确。 部分时钟周期图 统计 发现总共执行了25个周期，执行了19条指令，4次RAW停顿，RAW停顿有4个周期，RAW停顿占周期总数的百分比为16%，较没有静态调度的42.10526%少了很多，控制停顿有0个周期，占周期总数的百分比为0%，比没有使用延迟分支技术的5.263158%少了，所有的停顿为5个周期，占周期总数的百分比为20%，较没有静态调度和延迟分支技术的50%也减少了。可以发现使用延迟分支技术后，控制停顿消失了。$$吞吐率TP_2=\\frac{19}{25\\Delta{t}}$$ $$加速比S_2=\\frac{19\\times{5\\Delta{t}}}{25\\Delta{t}}={3.8}$$ 吞吐率和加速比是没有静态调度和延迟分支技术时的$\\frac{19\\times{38}}{25\\times{18}}\\approx{1.60}$倍。 四、实验结论​ 静态调度优化代码和定向技术都能在一定程度上减少甚至消除数据冲突，尤其是RAW停顿，可以很好地提高性能，但是这两种方法对分支控制停顿没有任何帮助。但是延迟分支技术是由编译器通过重排指令序列，在分支指令后紧跟一条或几条延迟槽指令，不管分支是否成功，都顺序执行延迟槽中的指令，从而逻辑上“延长”分支指令的执行时间，减少甚至消除了控制停顿。因此这几种方法都能大幅度的减少停顿，从而提高CPU性能。 ​ 在查看延迟分支技术的统计信息时，发现使用延迟分支技术比不使用延迟分支技术多执行了一条指令，可能是由于分支取消机制当分支的实际执行方向和事先所预测的一样时，执行分支延迟槽中的指令，否则就将分支延迟槽中的指令转化成一个空操作，这条指令确实已经执行了，只是分支条件判断完后发现不该执行，然后就将执行的回滚，因此比不使用延迟分支技术多执行了一条指令。 五、附录1、after-schedule.s 点击查看代码 123456789101112131415161718192021222324.textmain:ADDIU $r1,$r0,A # 1-1MUL $r24,$r26,$r14 # 6-1MUL $r12,$r10,$r1 # 4-1LW $r2,0($r1) # 2-1LW $r6,4($r1) # 3-1ADD $r16,$r12,$r1 # 4-2ADD $r4,$r0,$r2 # 2-2LW $r20,8($r1) # 5-1ADD $r18,$r16,$r1 # 4-3SW $r4,0($r1) # 2-3MUL $r22,$r20,$r14 # 5-2SW $r18,16($r1) # 4-4ADD $r8,$r6,$r1 # 3-2TEQ $r0,$r0 # 7-1.dataA: .word 4,6,8 2、delay-branch.s 点击查看代码 1234567891011121314151617.textmain:ADDI $r2,$r0,1024 # 1-1ADD $r3,$r0,$r0 # 1-2ADDI $r4,$r0,8 # 1-3loop: LW $r1,0($r2) # 2-1ADDI $r3,$r3,4 # 3-1ADDI $r1,$r1,1 # 2-2SUB $r5,$r4,$r3 # 3-2SW $r1,0($r2) # 2-3BGTZ $r5,loop # 3-3ADD $r7,$r0,$r6 # 4-1TEQ $r0,$r0 # 5-1","categories":[{"name":"计算机系统结构","slug":"计算机系统结构","permalink":"https://666wxy666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"},{"name":"实验","slug":"计算机系统结构/实验","permalink":"https://666wxy666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"计算机系统结构","slug":"计算机系统结构","permalink":"https://666wxy666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"},{"name":"汇编","slug":"汇编","permalink":"https://666wxy666.github.io/tags/%E6%B1%87%E7%BC%96/"},{"name":"MIPS","slug":"MIPS","permalink":"https://666wxy666.github.io/tags/MIPS/"}]},{"title":"Linux 上机实战3 shell脚本程序设计","slug":"Linux-上机实战3-shell脚本程序设计","date":"2020-05-10T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/05/10/Linux-上机实战3-shell脚本程序设计/","link":"","permalink":"https://666wxy666.github.io/2020/05/10/Linux-%E4%B8%8A%E6%9C%BA%E5%AE%9E%E6%88%983-shell%E8%84%9A%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","excerpt":"本文是关于Linux中的shell脚本程序设计，有几个小Demo。","text":"本文是关于Linux中的shell脚本程序设计，有几个小Demo。 一、题目要求1、生成TCP 活动状况报告​ netstat –statistics 命令可以列出tcp等协议的统计信息。编写 shell 脚本程序，每隔1分钟生成1行信息：当前时间；这一分钟内 TCP 发送了多少报文；接收了多少报文；收发报文总数；行尾给出符号+或-或空格（+表示这分钟收发报文数比上分钟多10包以上，差别在 10 包或以内用空格，否则用符号-）。 运行示例如下： 2、下载bing 图库中图片​ 编写脚本程序bing.sh ，将访问这个图库中照片全部下载下来存放到本地 bing 目录中，上面 URL 中p=23 可以换成 p=1 到p=126 可访问 126 个页，每页有 12 个图，每个图的日期，中文说明信息和下载地址及文件名 html 文件中可提取。要求下载后的文件命名为“ 日期 中文说明 .jpg ” 例如 2019-08-03 野花草甸上的一只欧亚雕鸮，德国莱茵兰 普法尔茨 .jpg 命令行参数./bing.sh 后面可以跟两个参数，通过指定页号区间限定下载范围，没有参数时页号区间为 1-126。 要允许多个程序并发 例如：一个终端上启动 ./bing.sh 1 63 ，另一个终端上启动 ./bing.sh 64 126 ，这样在两个终端上同时下载，以加快任务完成的速度。 不重复下载已下载的图片 检查图片是否已下载，如果已下载，则不再下载，这样在一定程度上支持批量任务在被中断后可以从断点继续。 考虑下载文件出现故障的情况 如果一 个图片有 5MB ，接收 1.5MB 后网络断开，则残存一个不完整的图片文件。避免这种现象发生的一种方法是， wget 下载时使用一个临时文件名。判断 wget 是否成功，若成功则将文件改名为正式名称；若失败，删除临时文件。临时文件名的选取要考虑前述的并发问题，至少不可以固定一个名字导致两进程的争夺。 3、选做：获取更多图片对已设计好的bing sh 进一步扩充，允许下面的命令行参数： 1./bing.sh rand 500 实现的功能为：执行500 次随机获取。每次成功的随机获取会得到一个图片，检查一下这个图片是否本地已存在。如果已存在，丢弃，否则保存。 访问https ://bing.ioliu.cn/v1/rand? json 可得到一个 json 数据，每次得到的内容是随机的，其中含有图片的日期、说明信息和获取它的 url 网址。新获得的文件命名方式与以前的程序相同。要求：文件名不同但是内容完全相同的图片丢弃，例如，下面两个文件虽然名字不同，但是内容是一样的，只保留其中一个文件。 2019-05-03 Ruff male displaying its plumage, Varanger Peninsula, Norway.jpg 2019-05-02 挪威瓦朗厄尔半岛上一只展示翎颌的雄性涉禽.jpg 二、实验环境系统：Manjaro 20.0 基于 Arc Linux 编辑器：Visual Studio Code 三、实验步骤1、生成TCP 活动状况报告 先在终端中运行命令查看输出 1netstat --statistics 可以在Tcp下看到相关信息，我们感兴趣的内容是的上图红框圈起的部分，因此我们可以使用正则表达式配合grep、sed、awk命令，将它取出来。 1netstat --statistics | grep segments 发现还不够，继续使用grep提取： 1netstat --statistics | grep &#x27;[0-9][0-9]* segments 再添加一个过滤条件，最终成功获取了所需信息。 1netstat --statistics | grep &#x27;[0-9][0-9]* segments [rs][e][cn] 这样，我们就可以直接使用awk命令，获取所需的列即可。 1netstat --statistics | awk &#x27;/[0-9][0-9]* segments [rs][e][cn]/ &#123;print $1&#125;&#x27; 使用date命令，可以获取当前日期时间。 1date &#x27;+%Y-%m-%d %H:%M&#x27; 因为要隔一分钟获取一次，程序的基本框架就是： 详细的代码以及注释在最后的附录中，这里不再展示。 编写完后运行net.sh，发现不能运行，加上可执行权限即可。 1chmod u+x net.sh 运行程序 1./net.sh 2、下载bing 图库中图片 先去bing图库看一下网页的源码。 打开开发者工具。 我们感兴趣的内容即为下图中用红框圈起的3个部分。 使用wget命令尝试下载网页和图片。 12wget -O 1.html https://bing.ioliu.cn/\\?p\\=1wget -O photo.jpg http://h1.ioliu.cn/bing/WhiteStorksNest_ZH-CN9809680903_640x480.jpg\\?imageslim 查看下载的内容。 网页： 1vi 1.html 图片： 下面进行把html中我们感兴趣的内容通过正则表达式配合grep、sed、awk命令，将它取出来。 文字介绍 先将无用的标签删除。 1cat 1.html | sed &#x27;s/&lt;[^&lt;&gt;]*&gt;/\\n/g&#x27; | more 发现我们想要的文字介绍都有符号“©”，因此使用awk可以轻松取出。 1cat 1.html | sed &#x27;s/&lt;[^&lt;&gt;]*&gt;/\\n/g&#x27; | awk &#x27;/©/ &#123; print $0 &#125;&#x27; | more 最后，使用sed把后面无用的（）中的内容去掉即可。 1cat 1.html | sed &#x27;s/&lt;[^&lt;&gt;]*&gt;/\\n/g&#x27; | awk &#x27;/©/ &#123; print $0 &#125;&#x27; | sed &#x27;s/(.*)//g&#x27; | more 日期 同样是先将无用的标签去掉，发现日期有共同的特点就是“数字-数字-数字”，因此用awk即可取出。 1cat 1.html | sed &#x27;s/&lt;[^&lt;&gt;]*&gt;/\\n/g&#x27; | awk &#x27;/[0-9][0-9]*-[0-9][0-9]*-[0-9][0-9]*/ &#123; print $0 &#125;&#x27; | more 网址 因为网址在标签中，我们就不能先将标签取出了。发现我们所需的内容在一行中，不好操作，因此先将“src=””替换为换行，刚好使我们所需的网址位于每行的开头。 1cat 1.html | sed &#x27;s/src=&quot;/\\n/g&#x27; | more 发现所有的网址都以“http:”开头，因此使用awk即可轻松取出。 1cat 1.html | sed &#x27;s/src=&quot;/\\n/g&#x27; | awk &#x27;/^http:/ &#123; print $1 &#125;&#x27; | more 最后，用sed删掉行尾无用的内容即可。 1cat 1.html | sed &#x27;s/src=&quot;/\\n/g&#x27; | awk &#x27;/^http:/ &#123; print $1 &#125;&#x27; | sed &#x27;s/&quot;&gt;&lt;a//g&#x27; | more 最新版本修复了分辨率的问题，再使用sed将640x480改为1920x1080即可。 1cat 1.html | sed &#x27;s/src=&quot;/\\n/g&#x27; | awk &#x27;/^http:/ &#123; print $1 &#125;&#x27; | sed -e &#x27;s/&quot;&gt;&lt;a//g&#x27; -e &#x27;s/640x480/1920x1080/g&#x27; | more 详细的代码和注释见最后的附录。 运行程序，依然需要先赋予执行权限。 1sudo chmod u+x bing.sh 不带参数 1./bing.sh 发现程序正常运行。 在运行过程中故意强制退出。 因为程序强制退出，会留下一个下载未完全的文件。但是完全不会受到影响，下一次运行时，会自动接续下载。 两个参数 1./bing.sh 1 3 因为上一个命令已经下载了一部分，已经下载过的不会再下载，接着上一次下载的位置继续下载。 下载完成。 查看下载的图片，发现是刚好36张，1-3页。 一个参数（自己额外实现的功能） 如果只输入一个参数，那么将从第一页下载到输入的参数页数。 1./bing 2 因为上面已经下载了1-3页，因此不会重复下载。 并发执行（自己额外实现的功能，下载的内容有冲突） 终端1： 1./bing.sh 终端2： 1./bing.sh 1 3 我写的代码，专门考虑了并发的情况，使用当前进程id作为缓冲文件名，从而不会与其他的程序产生冲突。我额外实现了，并发执行时，即使下载的内容有冲突，也不会产生错误。但是可能有一个小问题就是如果第一个程序检测到了a图片没有下载，开始下载了，但是在第一个程序还没下载完成时，刚好第二个程序也检测到了a图片没有下载，可能会重复下载，但是如果第二个程序检测到了a图片已经下载完成，则不会重复下载，所以也无伤大雅，不会产生致命错误。 查看下载的图片： 并发执行（下载的内容无冲突） 终端1： 1./bing.sh 1 3 终端2： 1./bing.sh 4 6 如果下载的内容没有冲突就更不会产生任何问题了。 完美下载完成。 查看下载的图片，刚好是72张，1-6页。 差错处理 各种错误处理的情况： 3、选做：获取更多图片 先访问网址https://bing.ioliu.cn/v1/rand?type=json查看json文件的格式 把json中我们感兴趣的内容通过正则表达式配合grep、sed、awk命令，将它取出来： 这些都比较简单，根据json的key就很轻松的取出来了 文字介绍 1cat bing/$$.json | sed &#x27;s/.*&quot;copyright&quot;:&quot;\\(.*\\)(.*©.*)&quot;&#125;,.*/\\1/g&#x27; 日期 1cat bing/$$.json | sed &#x27;s/.*&quot;enddate&quot;:&quot;\\([0-9][0-9][0-9][0-9]\\)\\([0-9][0-9]\\)\\([0-9][0-9]\\)&quot;,.*/\\1-\\2-\\3/g&#x27; 网址 1cat bing/$$.json | sed &#x27;s/.*&quot;url&quot;:&quot;\\(http:.*imageslim\\)&quot;,.*/\\1/g&#x27; 详细的代码和注释见最后的附录。 运行程序，依然需要先赋予执行权限。 PS：v2.0在v1.0的基础上进行了修改，优化了部分代码，除了这次的功能，完全保留了v1.0的功能，并且random模式也可以并发，就不展示了。 查看下载的图片： 差错处理 各种错误处理的情况： 4、升级版bing.sh在bing2.sh的基础上升级的v3.0版的bing3.sh，优化了bing2.sh的部分判断逻辑和代码，相较于bing2.sh移除了diff和cmp比较，使用了更为高效的md5比较，且将md5校验信息存到文件中，供下次使用，加速判断。 运行截图： 这里都是展示了更为高级的并发下载的情况，非并发就不再展示了。 两个终端分别进行： 1./bing3.sh 1 3 1./bing3.sh 1 4 结果： 完美执行成功，且已经下载过的不会重复下载： 查看图片： 刚好1-4页48个图片加1个md5校验文件，共49个文件 md5校验文件md5.txt也成功生成了。 两个终端分别进行： 1./bing3.sh rand 10 1./bing3.sh rand 10 5、小修复修复了分辨率过小，导致下载的图片不清晰的问题，现在分辨率统一为1920x1080。 由文件大小也可以看出，分辨率已经给更改。 打开图片查看，图片已经很清晰了，分辨率为1920x1080。 四、实验总结及感受​ 在这次实验中，明显感受到了shell脚本程序的编程和C语言等有很大的差别，尤为要注意各种双引号，单引号，空格啊之类的，拉下来就完全错误。在实验中还遇到了一个很有意思的小问题，就是echo命令如果后面的变量中有换行的话，直接使用： 1echo $xxx 会将换行变成空格，但是如果加上双引号括起来，就能正常输出换行了： 1echo &quot;$xxx&quot; 在实验中还熟悉了各种分支循环命令的使用，在shell中的printf格式化输出，并且复习了前面学习的正则表达式和grep、sed、awk文本处理三剑客，收获很大。 五、项目地址本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看： 源码仓库 六、附录1、net.sh 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# 获取时间date_time=`date &#x27;+%Y-%m-%d %H:%M&#x27;`# 这一分钟开始时的TCP报文数data1=`netstat --statistics | grep &#x27;[0-9][0-9]* segments [rs][e][cn]&#x27;`# 发送send1=`echo $data1 | awk &#x27;&#123;print $4&#125;&#x27;`# 接收recv1=`echo $data1 | awk &#x27;&#123;print $1&#125;&#x27;`# 等60ssleep 60# 这一分钟结束时的TCP报文数data_temp=`netstat --statistics | grep &#x27;[0-9][0-9]* segments [rs][e][cn]&#x27;`# 发送send_temp=`echo $data_temp | awk &#x27;&#123;print $4&#125;&#x27;`# 接收recv_temp=`echo $data_temp | awk &#x27;&#123;print $1&#125;&#x27;`# 这一分钟内发送的TCP报文数send=`expr $send_temp - $send1`# 这一分钟内接收的TCP报文数recv=`expr $recv_temp - $recv1`# 这一分钟内收发TCP报文总数sum_temp=`expr $send + $recv`# 输出,第一次输出不加最后的符号printf &#x27;%-16s%8s%8s%8s\\n&#x27; &quot;$date_time&quot; &quot;$send&quot; &quot;$recv&quot; &quot;$sum_temp&quot;while truedo # 获取时间 date_time=`date &#x27;+%Y-%m-%d %H:%M&#x27;` # 等60s sleep 60 # 一分钟后的TCP报文数 data2=`netstat --statistics | grep &#x27;[0-9][0-9]* segments [rs][e][cn]&#x27;` # 发送 send2=`echo $data2 | awk &#x27;&#123;print $4&#125;&#x27;` # 接收 recv2=`echo $data2 | awk &#x27;&#123;print $1&#125;&#x27;` # 这一分钟内发送的TCP报文数 send=`expr $send2 - $send_temp` # 这一分钟内接收的TCP报文数 recv=`expr $recv2 - $recv_temp` # 这一分钟内收发TCP报文总数 sum2=`expr $send + $recv` # 判断最后的符号 # 后-前&gt;10,为+ if [ `expr $sum2 - $sum_temp` -gt 10 ] then sign=&#x27;+&#x27; # 前-后&gt;10,为- elif [ `expr $sum_temp - $sum2` -gt 10 ] then sign=&#x27;-&#x27; # 其他情况,为空格 else sign=&#x27; &#x27; fi # 输出 printf &#x27;%-16s%8s%8s%8s%5s\\n&#x27; &quot;$date_time&quot; &quot;$send&quot; &quot;$recv&quot; &quot;$sum2&quot; &quot;$sign&quot; # 保留上一次的数据,用于下一次比较 send_temp=$send2 recv_temp=$recv2 sum_temp=$sum2done 2、bing.sh 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134# 错误代号:# 1: 参数输入格式错误# 2: 输入的页数非整数# 3: 输入的页数范围不在[1,126]# 4: 开始页数&lt;结束页数# 5: 获取下载页面失败# 6: 获取下载图片失败NONE=&quot;\\e[0m&quot;RED=&quot;\\e[0;31m&quot;# 读取命令行参数，并进行错误处理if [ $# = 0 ]then start_page=1 end_page=126# 额外增加了一个，如果只输入一个参数，代表从第1页到输入的参数的页数elif [ $# = 1 ]then start_page=1 end_page=$1elif [ $# = 2 ]then start_page=$1 end_page=$2else printf $RED&#x27;Error: Please input the right arguments\\n&#x27;$NONE echo &quot;Usage: $0 [start page] [end page] download photos in pages from [start page] to [end page]&quot; echo &quot; or: $0 [end page] download photos in pages from [1] to [end page]&quot; echo &quot; or: $0 (with no arguments) download photos in pages from 1 to 126 by default&quot; exit 1fi# 输入的页数非整数if ! expr $start_page + 0 &gt; /dev/null 2&gt;&amp;1 || ! expr $end_page + 0 &gt; /dev/null 2&gt;&amp;1then printf $RED&#x27;Error: Your input page is not an integer\\n&#x27;$NONE echo &quot;Usage: $0 [start page] [end page] download photos in pages from [start page] to [end page]&quot; echo &quot; or: $0 [end page] download photos in pages from [1] to [end page]&quot; echo &quot; or: $0 (with no arguments) download photos in pages from 1 to 126 by default&quot; exit 2fi# 输入的页数范围不在[1,126]if [ $start_page -lt 1 -o $end_page -lt 1 -o $start_page -gt 126 -o $end_page -gt 126 ]then printf $RED&#x27;Error: Your input page not in the range [1,126]\\n&#x27;$NONE echo &quot;Usage: $0 [start page] [end page] download photos in pages from [start page] to [end page]&quot; echo &quot; or: $0 [end page] download photos in pages from [1] to [end page]&quot; echo &quot; or: $0 (with no arguments) download photos in pages from 1 to 126 by default&quot; exit 3fi# 开始页数&lt;结束页数if [ $start_page -gt $end_page ]then printf $RED&#x27;Error: Your input [start_page] &gt; [end page]\\n&#x27;$NONE echo &quot;Usage: $0 [start page] [end page] download photos in pages from [start page] to [end page]&quot; echo &quot; or: $0 [end page] download photos in pages from [1] to [end page]&quot; echo &quot; or: $0 (with no arguments) download photos in pages from 1 to 126 by default&quot; exit 4fiecho &quot;Your input page range is [$start_page,$end_page]&quot;# 判断并创建目录if [ ! -d bing ]then mkdir bing echo &quot;Work directory bing is created&quot;fi# 缓存目录这里使用当前进程ID号作为区分，防止受到影响，下面下载图片使用$$.jpg作为缓存也是同样的道理if [ ! -d bing/html_$$ ]then mkdir bing/html_$$ echo &quot;Cache directory bing/html_$$ is created&quot;fi# 对页范围内的循环下载for i in `seq $start_page $end_page`do # 判断是否已经下载 if [ ! -f bing/html_$$/$i.html ] then echo &quot;Download page $i……&quot; if wget -O bing/html_$$/$i.html &quot;https://bing.ioliu.cn/?p=$i&quot; &gt; /dev/null 2&gt;&amp;1 then echo &quot;Page $i download successfully&quot; else if [ -f bing/html_$$/$i.html ] then rm bing/html_$$/$i.html fi printf $RED&quot;Error: Page $i download failed\\n&quot;$NONE exit 5 fi else echo &quot;Page $i already exists&quot; fi # 获取该页所以图片信息 name_list=`cat bing/html_$$/$i.html | sed &#x27;s/&lt;[^&lt;&gt;]*&gt;/\\n/g&#x27; | awk &#x27;/©/ &#123; print $0 &#125;&#x27; | sed &#x27;s/(.*)//g&#x27;` date_list=`cat bing/html_$$/$i.html | sed &#x27;s/&lt;[^&lt;&gt;]*&gt;/\\n/g&#x27; | awk &#x27;/[0-9][0-9]*-[0-9][0-9]*-[0-9][0-9]*/ &#123; print $0 &#125;&#x27;` url_list=`cat bing/html_$$/$i.html | sed &#x27;s/src=&quot;/\\n/g&#x27; | awk &#x27;/^http:/ &#123; print $1 &#125;&#x27; | sed -e &#x27;s/&quot;&gt;&lt;a//g&#x27; -e &#x27;s/640x480/1920x1080/g&#x27;` # 对该页内图片循环下载 for j in `seq 1 12` do # 获取图片信息 name=`echo &quot;$name_list&quot; | awk &quot;NR==$j&quot;` date=`echo &quot;$date_list&quot; | awk &quot;NR==$j&quot;` url=`echo &quot;$url_list&quot; | awk &quot;NR==$j&quot;` file_name=&quot;$date $name.jpg&quot; # 清理残留缓存 if [ -f &quot;bing/$$.jpg&quot; ] then rm &quot;bing/$$.jpg&quot; fi # 判断是否已经下载 if [ ! -f &quot;bing/$file_name&quot; ] then echo &quot;Download photo $i-$j……&quot; if wget -O bing/$$.jpg &quot;$url&quot; &gt; /dev/null 2&gt;&amp;1 then mv &quot;bing/$$.jpg&quot; &quot;bing/$file_name&quot; echo &quot;Photo $i-$j download successfully&quot; else printf $RED&quot;Error: Photo $i-$j download failed\\n&quot;$NONE exit 6 fi else echo &quot;Photo $i-$j already exists&quot; fi donedone# 清理缓存echo &quot;Cleaning……&quot;if [ -d bing/html_$$ ]then rm -r bing/html_$$fiecho &quot;All done,Thanks for using!&quot; 3、bing2.sh 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251# 错误代号:# 1: 参数输入格式错误# 2: 输入的页数非整数# 3: 输入的页数范围不在[1,126]# 4: 开始页数&lt;结束页数# 5: 下载页面失败# 6: 下载图片失败# 7: 输入的随机次数非整数# 8: 输入的随机次数&lt;1# 9: 下载json失败# 10: 未知错误NONE=&quot;\\e[0m&quot;RED=&quot;\\e[0;31m&quot;# rand=0，代表普通模式；rand&gt;0代表随机模式，rand的数值代表随机的次数rand=0# 读取命令行参数，并进行错误处理if [ $# = 0 ]then start_page=1 end_page=126# 额外增加了一个，如果只输入一个参数，代表从第1页到输入的参数的页数elif [ $# = 1 ]then start_page=1 end_page=$1elif [ $# = 2 ]then # 随机模式 if [ $1 = &#x27;rand&#x27; ] then # 判断第二个参数是否为整数 if expr $2 + 0 &gt; /dev/null 2&gt;&amp;1 then # 输入的随机次数&lt;1 if [ $2 -lt 1 ] then printf $RED&#x27;Error: Your input [rand times] &lt; 1\\n&#x27;$NONE echo &quot;Usage: $0 [start page] [end page] download photos in pages from [start page] to [end page]&quot; echo &quot; or: $0 [end page] download photos in pages from [1] to [end page]&quot; echo &quot; or: $0 (with no arguments) download photos in pages from [1] to [126] by default&quot; echo &quot; or: $0 rand [rand times] rand download photos of [rand times]&quot; exit 8 else rand=$2 fi # 输入的随机次数非整数 else printf $RED&#x27;Error: Your input [rand times] is not an integer\\n&#x27;$NONE echo &quot;Usage: $0 [start page] [end page] download photos in pages from [start page] to [end page]&quot; echo &quot; or: $0 [end page] download photos in pages from [1] to [end page]&quot; echo &quot; or: $0 (with no arguments) download photos in pages from [1] to [126] by default&quot; echo &quot; or: $0 rand [rand times] rand download photos of [rand times]&quot; exit 7 fi # 普通模式 else start_page=$1 end_page=$2 # 输入的页数非整数 if ! expr $start_page + 0 &gt; /dev/null 2&gt;&amp;1 || ! expr $end_page + 0 &gt; /dev/null 2&gt;&amp;1 then printf $RED&#x27;Error: Your input page is not an integer\\n&#x27;$NONE echo &quot;Usage: $0 [start page] [end page] download photos in pages from [start page] to [end page]&quot; echo &quot; or: $0 [end page] download photos in pages from [1] to [end page]&quot; echo &quot; or: $0 (with no arguments) download photos in pages from [1] to [126] by default&quot; echo &quot; or: $0 rand [rand times] rand download photos of [rand times]&quot; exit 2 fi # 输入的页数范围不在[1,126] if [ $start_page -lt 1 -o $end_page -lt 1 -o $start_page -gt 126 -o $end_page -gt 126 ] then printf $RED&#x27;Error: Your input page not in the range [1,126]\\n&#x27;$NONE echo &quot;Usage: $0 [start page] [end page] download photos in pages from [start page] to [end page]&quot; echo &quot; or: $0 [end page] download photos in pages from [1] to [end page]&quot; echo &quot; or: $0 (with no arguments) download photos in pages from [1] to [126] by default&quot; echo &quot; or: $0 rand [rand times] rand download photos of [rand times]&quot; exit 3 fi # 开始页数&lt;结束页数 if [ $start_page -gt $end_page ] then printf $RED&#x27;Error: Your input [start_page] &gt; [end page]\\n&#x27;$NONE echo &quot;Usage: $0 [start page] [end page] download photos in pages from [start page] to [end page]&quot; echo &quot; or: $0 [end page] download photos in pages from [1] to [end page]&quot; echo &quot; or: $0 (with no arguments) download photos in pages from [1] to [126] by default&quot; echo &quot; or: $0 rand [rand times] rand download photos of [rand times]&quot; exit 4 fi fi# 参数输入格式错误else printf $RED&#x27;Error: Please input the right arguments\\n&#x27;$NONE echo &quot;Usage: $0 [start page] [end page] download photos in pages from [start page] to [end page]&quot; echo &quot; or: $0 [end page] download photos in pages from [1] to [end page]&quot; echo &quot; or: $0 (with no arguments) download photos in pages from [1] to [126] by default&quot; echo &quot; or: $0 rand [rand times] rand download photos of [rand times]&quot; exit 1fi# 判断并创建工作目录if [ ! -d bing ]then mkdir bing echo &quot;Work directory bing is created&quot;fi# 普通模式if [ $rand -eq 0 ]then echo &quot;##############Regular Mode##############&quot; echo &quot;Your input page range is [$start_page,$end_page]&quot; # 对页范围内的循环下载 for i in `seq $start_page $end_page` do # 缓存文件使用当前进程ID号$$.html命名，防止受到影响，下面下载图片使用$$.jpg作为缓存也是同样的道理 echo &quot;Download page $i……&quot; if wget -O bing/$$.html &quot;https://bing.ioliu.cn/?p=$i&quot; &gt; /dev/null 2&gt;&amp;1 then echo &quot;Page $i download successfully&quot; else if [ -f bing/$$.html ] then rm bing/$$.html fi printf $RED&quot;Error: Page $i download failed\\n&quot;$NONE exit 5 fi # 获取该页所以图片信息 name_list=`cat bing/$$.html | sed &#x27;s/&lt;[^&lt;&gt;]*&gt;/\\n/g&#x27; | awk &#x27;/©/ &#123; print $0 &#125;&#x27; | sed &#x27;s/(.*)//g&#x27;` date_list=`cat bing/$$.html | sed &#x27;s/&lt;[^&lt;&gt;]*&gt;/\\n/g&#x27; | awk &#x27;/[0-9][0-9]*-[0-9][0-9]*-[0-9][0-9]*/ &#123; print $0 &#125;&#x27;` url_list=`cat bing/$$.html | sed &#x27;s/src=&quot;/\\n/g&#x27; | awk &#x27;/^http:/ &#123; print $1 &#125;&#x27; | sed -e &#x27;s/&quot;&gt;&lt;a//g&#x27; -e &#x27;s/640x480/1920x1080/g&#x27;` # 对该页内图片循环下载 for j in `seq 1 12` do # 获取图片信息 name=`echo &quot;$name_list&quot; | awk &quot;NR==$j&quot;` date=`echo &quot;$date_list&quot; | awk &quot;NR==$j&quot;` url=`echo &quot;$url_list&quot; | awk &quot;NR==$j&quot;` file_name=&quot;$date $name.jpg&quot; # 判断是否已经下载 if [ ! -f &quot;bing/$file_name&quot; ] then echo &quot;Download photo $i-$j……&quot; if wget -O bing/$$.jpg &quot;$url&quot; &gt; /dev/null 2&gt;&amp;1 then mv &quot;bing/$$.jpg&quot; &quot;bing/$file_name&quot; echo &quot;Photo $i-$j download successfully&quot; else printf $RED&quot;Error: Photo $i-$j download failed\\n&quot;$NONE exit 6 fi else echo &quot;Photo $i-$j already exists&quot; fi done done # 清理缓存 echo &quot;Cleaning……&quot; rm bing/$$.html# 随机模式elif [ $rand -gt 0 ]then echo &quot;##############Random Mode##############&quot; echo &quot;Your input rand times is $rand&quot; # 循环随机下载 for k in `seq 1 $rand` do # 获取json if wget -O bing/$$.json &quot;https://bing.ioliu.cn/v1/rand?type=json&quot; &gt; /dev/null 2&gt;&amp;1 then # 获取图片信息 name=`cat bing/$$.json | sed &#x27;s/.*&quot;copyright&quot;:&quot;\\(.*\\)(.*©.*)&quot;&#125;,.*/\\1/g&#x27;` date=`cat bing/$$.json | sed &#x27;s/.*&quot;enddate&quot;:&quot;\\([0-9][0-9][0-9][0-9]\\)\\([0-9][0-9]\\)\\([0-9][0-9]\\)&quot;,.*/\\1-\\2-\\3/g&#x27;` url=`cat bing/$$.json | sed &#x27;s/.*&quot;url&quot;:&quot;\\(http:.*imageslim\\)&quot;,.*/\\1/g&#x27;` file_name=&quot;$date $name.jpg&quot; # 判断是否已经下载，先用文件名判断 if [ ! -f &quot;bing/$file_name&quot; ] then echo &quot;Download photo $k……&quot; if wget -O bing/$$ &quot;$url&quot; &gt; /dev/null 2&gt;&amp;1 then # 文件名不存在的，判断是否有文件大小相同的和内容相同的 same=0 for file in bing/*.jpg do # 先判断bing文件夹中是否有.jpg文件，如果没有的话*不会被替换，会出错 if [ &quot;$file&quot; = &#x27;bing/*.jpg&#x27; ] then break fi # 先比较文件大小是否相同，加快速度 if [ `stat -c%s &quot;$file&quot;` = `ls -l &quot;bing/$$&quot; | awk &#x27;&#123; print $5 &#125;&#x27;` ] then # 大小相同再比较内容 # diff命令主要用于比较文本文件，比较二进制文件效率较低 # if diff &quot;$file&quot; &quot;bing/$$&quot; &gt; /dev/null # then # # 相同 # same=1 # break # fi # md5sum计算文件md5值，进行比较 # if [ `md5sum &quot;$file&quot; | awk &#x27;&#123; print $1 &#125;&#x27;` = `md5sum &quot;bing/$$&quot; | awk &#x27;&#123; print $1 &#125;&#x27;` ] # then # # 相同 # same=1 # break # fi # cmp命令是逐字节比较 if cmp -s &quot;$file&quot; &quot;bing/$$&quot; then # 相同 same=1 break fi fi done if [ $same = 1 ] then rm bing/$$ echo &quot;Photo $k already exists&quot; else mv &quot;bing/$$&quot; &quot;bing/$file_name&quot; echo &quot;Photo $k download successfully&quot; fi else printf $RED&quot;Error: Photo $k download failed\\n&quot;$NONE exit 6 fi else echo &quot;Photo $k already exists&quot; fi else if [ -f bing/$$.json ] then rm bing/$$.json fi printf $RED&quot;Error: Json $k download failed\\n&quot;$NONE exit 9 fi done # 清理缓存 echo &quot;Cleaning……&quot; rm bing/$$.json# 未知错误else printf $RED&quot;Error: Unkonwn error\\n&quot;$NONE exit 10fiecho &quot;All done,Thanks for using!&quot; 4、bing3.sh 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265# 错误代号:# 1: 参数输入格式错误# 2: 输入的页数非整数# 3: 输入的页数范围不在[1,126]# 4: 开始页数&lt;结束页数# 5: 下载页面失败# 6: 下载图片失败# 7: 输入的随机次数非整数# 8: 输入的随机次数&lt;1# 9: 下载json失败# 10: 未知错误NONE=&quot;\\e[0m&quot;RED=&quot;\\e[0;31m&quot;# rand=0，代表普通模式；rand&gt;0代表随机模式，rand的数值代表随机的次数rand=0# 读取命令行参数，并进行错误处理if [ $# = 0 ]then start_page=1 end_page=126# 额外增加了一个，如果只输入一个参数，代表从第1页到输入的参数的页数elif [ $# = 1 ]then start_page=1 end_page=$1elif [ $# = 2 ]then # 随机模式 if [ $1 = &#x27;rand&#x27; ] then # 判断第二个参数是否为整数 if expr $2 + 0 &gt; /dev/null 2&gt;&amp;1 then # 输入的随机次数&lt;1 if [ $2 -lt 1 ] then printf $RED&#x27;Error: Your input [rand times] &lt; 1\\n&#x27;$NONE echo &quot;Usage: $0 [start page] [end page] download photos in pages from [start page] to [end page]&quot; echo &quot; or: $0 [end page] download photos in pages from [1] to [end page]&quot; echo &quot; or: $0 (with no arguments) download photos in pages from [1] to [126] by default&quot; echo &quot; or: $0 rand [rand times] rand download photos of [rand times]&quot; exit 8 else rand=$2 fi # 输入的随机次数非整数 else printf $RED&#x27;Error: Your input [rand times] is not an integer\\n&#x27;$NONE echo &quot;Usage: $0 [start page] [end page] download photos in pages from [start page] to [end page]&quot; echo &quot; or: $0 [end page] download photos in pages from [1] to [end page]&quot; echo &quot; or: $0 (with no arguments) download photos in pages from [1] to [126] by default&quot; echo &quot; or: $0 rand [rand times] rand download photos of [rand times]&quot; exit 7 fi # 普通模式 else start_page=$1 end_page=$2 # 输入的页数非整数 if ! expr $start_page + 0 &gt; /dev/null 2&gt;&amp;1 || ! expr $end_page + 0 &gt; /dev/null 2&gt;&amp;1 then printf $RED&#x27;Error: Your input page is not an integer\\n&#x27;$NONE echo &quot;Usage: $0 [start page] [end page] download photos in pages from [start page] to [end page]&quot; echo &quot; or: $0 [end page] download photos in pages from [1] to [end page]&quot; echo &quot; or: $0 (with no arguments) download photos in pages from [1] to [126] by default&quot; echo &quot; or: $0 rand [rand times] rand download photos of [rand times]&quot; exit 2 fi # 输入的页数范围不在[1,126] if [ $start_page -lt 1 -o $end_page -lt 1 -o $start_page -gt 126 -o $end_page -gt 126 ] then printf $RED&#x27;Error: Your input page not in the range [1,126]\\n&#x27;$NONE echo &quot;Usage: $0 [start page] [end page] download photos in pages from [start page] to [end page]&quot; echo &quot; or: $0 [end page] download photos in pages from [1] to [end page]&quot; echo &quot; or: $0 (with no arguments) download photos in pages from [1] to [126] by default&quot; echo &quot; or: $0 rand [rand times] rand download photos of [rand times]&quot; exit 3 fi # 开始页数&lt;结束页数 if [ $start_page -gt $end_page ] then printf $RED&#x27;Error: Your input [start_page] &gt; [end page]\\n&#x27;$NONE echo &quot;Usage: $0 [start page] [end page] download photos in pages from [start page] to [end page]&quot; echo &quot; or: $0 [end page] download photos in pages from [1] to [end page]&quot; echo &quot; or: $0 (with no arguments) download photos in pages from [1] to [126] by default&quot; echo &quot; or: $0 rand [rand times] rand download photos of [rand times]&quot; exit 4 fi fi# 参数输入格式错误else printf $RED&#x27;Error: Please input the right arguments\\n&#x27;$NONE echo &quot;Usage: $0 [start page] [end page] download photos in pages from [start page] to [end page]&quot; echo &quot; or: $0 [end page] download photos in pages from [1] to [end page]&quot; echo &quot; or: $0 (with no arguments) download photos in pages from [1] to [126] by default&quot; echo &quot; or: $0 rand [rand times] rand download photos of [rand times]&quot; exit 1fi# 判断并创建工作目录if [ ! -d bing ]then mkdir bing echo &quot;Work directory bing is created&quot;fi# 普通模式if [ $rand -eq 0 ]then echo &quot;##############Regular Mode##############&quot; echo &quot;Your input page range is [$start_page,$end_page]&quot; # 对页范围内的循环下载 for i in `seq $start_page $end_page` do # 缓存文件使用当前进程ID号$$.html命名，防止受到影响，下面下载图片使用$$.jpg作为缓存也是同样的道理 echo &quot;Download page $i……&quot; if wget -O bing/$$.html &quot;https://bing.ioliu.cn/?p=$i&quot; &gt; /dev/null 2&gt;&amp;1 then echo &quot;Page $i download successfully&quot; else if [ -f bing/$$.html ] then rm bing/$$.html fi printf $RED&quot;Error: Page $i download failed\\n&quot;$NONE exit 5 fi # 获取该页所以图片信息 name_list=`cat bing/$$.html | sed &#x27;s/&lt;[^&lt;&gt;]*&gt;/\\n/g&#x27; | awk &#x27;/©/ &#123; print $0 &#125;&#x27; | sed &#x27;s/(.*)//g&#x27;` date_list=`cat bing/$$.html | sed &#x27;s/&lt;[^&lt;&gt;]*&gt;/\\n/g&#x27; | awk &#x27;/[0-9][0-9]*-[0-9][0-9]*-[0-9][0-9]*/ &#123; print $0 &#125;&#x27;` url_list=`cat bing/$$.html | sed &#x27;s/src=&quot;/\\n/g&#x27; | awk &#x27;/^http:/ &#123; print $1 &#125;&#x27; | sed -e &#x27;s/&quot;&gt;&lt;a//g&#x27; -e &#x27;s/640x480/1920x1080/g&#x27;` # 对该页内图片循环下载 for j in `seq 1 12` do # 获取图片信息 name=`echo &quot;$name_list&quot; | awk &quot;NR==$j&quot;` date=`echo &quot;$date_list&quot; | awk &quot;NR==$j&quot;` url=`echo &quot;$url_list&quot; | awk &quot;NR==$j&quot;` file_name=&quot;$date $name.jpg&quot; # 判断是否已经下载 if [ ! -f &quot;bing/$file_name&quot; ] then echo &quot;Download photo $i-$j……&quot; if wget -O bing/$$.jpg &quot;$url&quot; &gt; /dev/null 2&gt;&amp;1 then same=0 # 先判断md5文件是否存在，如果不存在，说明bing空目录，直接改名 if [ -f &quot;bing/md5.txt&quot; ] then # 文件名不存在的，判断是否有文件大小相同的和md5相同的 cat bing/md5.txt | while read line do # 先比较文件大小是否相同，加快速度 if [ `stat -c%s &quot;bing/$$.jpg&quot;` = `echo &quot;$line&quot; | awk &#x27;&#123; print $1 &#125;&#x27;` ] then # md5sum计算文件md5值，进行比较 if [ `md5sum &quot;bing/$$.jpg&quot; | awk &#x27;&#123; print $1 &#125;&#x27;` = `echo &quot;$line&quot; | awk &#x27;&#123; print $2 &#125;&#x27;` ] then # 相同 same=1 break fi fi done fi if [ $same = 1 ] then rm &quot;bing/$$.jpg&quot; echo &quot;Photo $i-$j already exists&quot; else mv &quot;bing/$$.jpg&quot; &quot;bing/$file_name&quot; echo &quot;Photo $i-$j download successfully&quot; # 生成文件大小和MD5校验信息 echo &quot;`stat -c%s &quot;bing/$file_name&quot;` &quot;`md5sum &quot;bing/$file_name&quot;` &gt;&gt; bing/md5.txt fi else printf $RED&quot;Error: Photo $i-$j download failed\\n&quot;$NONE exit 6 fi else echo &quot;Photo $i-$j already exists&quot; fi done done # 清理缓存 echo &quot;Cleaning……&quot; rm bing/$$.html# 随机模式elif [ $rand -gt 0 ]then echo &quot;##############Random Mode##############&quot; echo &quot;Your input rand times is $rand&quot; # 循环随机下载 for k in `seq 1 $rand` do # 获取json if wget -O &quot;bing/$$.json&quot; &quot;https://bing.ioliu.cn/v1/rand?type=json&quot; &gt; /dev/null 2&gt;&amp;1 then # 获取图片信息 name=`cat bing/$$.json | sed &#x27;s/.*&quot;copyright&quot;:&quot;\\(.*\\)(.*©.*)&quot;&#125;,.*/\\1/g&#x27;` date=`cat bing/$$.json | sed &#x27;s/.*&quot;enddate&quot;:&quot;\\([0-9][0-9][0-9][0-9]\\)\\([0-9][0-9]\\)\\([0-9][0-9]\\)&quot;,.*/\\1-\\2-\\3/g&#x27;` url=`cat bing/$$.json | sed &#x27;s/.*&quot;url&quot;:&quot;\\(http:.*imageslim\\)&quot;,.*/\\1/g&#x27;` file_name=&quot;$date $name.jpg&quot; # 判断是否已经下载，先用文件名判断 if [ ! -f &quot;bing/$file_name&quot; ] then echo &quot;Download photo $k……&quot; if wget -O &quot;bing/$$.jpg&quot; &quot;$url&quot; &gt; /dev/null 2&gt;&amp;1 then same=0 # 先判断md5文件是否存在，如果不存在，说明bing空目录，直接改名 if [ -f &quot;bing/md5.txt&quot; ] then # 文件名不存在的，判断是否有文件大小相同的和md5相同的 cat bing/md5.txt | while read line do # 先比较文件大小是否相同，加快速度 if [ `stat -c%s &quot;bing/$$.jpg&quot;` = `echo &quot;$line&quot; | awk &#x27;&#123; print $1 &#125;&#x27;` ] then # md5sum计算文件md5值，进行比较 if [ `md5sum &quot;bing/$$.jpg&quot; | awk &#x27;&#123; print $1 &#125;&#x27;` = `echo &quot;$line&quot; | awk &#x27;&#123; print $2 &#125;&#x27;` ] then # 相同 same=1 break fi fi done fi if [ $same = 1 ] then rm &quot;bing/$$.jpg&quot; echo &quot;Photo $k already exists&quot; else mv &quot;bing/$$.jpg&quot; &quot;bing/$file_name&quot; echo &quot;Photo $k download successfully&quot; # 生成文件大小和MD5校验信息 echo &quot;`stat -c%s &quot;bing/$file_name&quot;` &quot;`md5sum &quot;bing/$file_name&quot;` &gt;&gt; bing/md5.txt fi else printf $RED&quot;Error: Photo $k download failed\\n&quot;$NONE exit 6 fi else echo &quot;Photo $k already exists&quot; fi else if [ -f bing/$$.json ] then rm bing/$$.json fi printf $RED&quot;Error: Json $k download failed\\n&quot;$NONE exit 9 fi done # 清理缓存 echo &quot;Cleaning……&quot; rm bing/$$.json# 未知错误else printf $RED&quot;Error: Unkonwn error\\n&quot;$NONE exit 10fiecho &quot;All done,Thanks for using!&quot;","categories":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/categories/Linux/"},{"name":"上机实战","slug":"Linux/上机实战","permalink":"https://666wxy666.github.io/categories/Linux/%E4%B8%8A%E6%9C%BA%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://666wxy666.github.io/tags/Shell/"}]},{"title":"机器学习 实验 决策树","slug":"机器学习-实验-决策树","date":"2020-04-26T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/04/26/机器学习-实验-决策树/","link":"","permalink":"https://666wxy666.github.io/2020/04/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%AE%9E%E9%AA%8C-%E5%86%B3%E7%AD%96%E6%A0%91/","excerpt":"本文是关于20问读心游戏的决策树代码实现。","text":"本文是关于20问读心游戏的决策树代码实现。 一、问题：以20问读心游戏为例，以ID3算法（即信息增益算法）为基础，构造并绘制决策树，最后可以进行简单的测试游玩. 二、实验环境 语言：Python 3.6（Anaconda3） IDE：PyCharm 2020.1.1 (Professional Edition) Packages： python standard library numpy：1.16.2 scipy：1.2.1 pandas：0.24.2 networkx：2.4 graphviz：0.13.2 matplotlib：3.2.1 三、实验结果 四、项目地址本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看： 五、附录数据集data_set.txt： 点击查看 男 运动员 70后 光头 80后 离婚 选秀 篮球 内地 演员是 是 否 否 是 否 否 是 是 否 姚明是 是 否 否 是 是 否 否 是 否 刘翔是 是 是 是 否 否 否 是 否 否 科比是 是 否 否 是 否 否 否 否 否 c罗是 否 否 否 否 否 否 否 否 是 刘德华是 否 否 否 否 否 是 否 是 否 毛不易是 否 是 否 否 否 否 否 否 是 周杰伦是 否 是 否 否 否 否 否 是 是 黄渤是 否 是 是 否 否 否 否 是 是 徐峥否 是 否 否 是 否 否 否 是 否 张怡宁否 是 否 否 否 是 否 否 是 否 郎平否 是 否 否 否 否 否 否 是 否 朱婷否 否 否 否 否 否 是 否 是 是 杨超越否 否 否 否 是 是 否 否 是 是 杨幂否 否 否 否 否 否 否 否 否 否 邓紫棋否 否 否 否 是 否 是 否 否 否 徐佳莹否 否 否 否 是 否 否 否 是 是 赵丽颖 代码decision_tree.py： 1、全局配置 点击查看代码 123456789101112131415161718# -*- coding: utf-8 -*-from math import logimport matplotlib.pyplot as plt######################################################### 基本配置######################################################### 显示中文标签plt.rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;SimHei&#x27;]# 设置决策树样式# boxstyle为文本框的类型，sawtooth是锯齿形，fc是边框线粗细# arrowstyle是树的线为箭头样式decision_node = dict(boxstyle=&quot;sawtooth&quot;, fc=&quot;0.8&quot;)leaf_node = dict(boxstyle=&quot;round4&quot;, fc=&quot;0.8&quot;)arrow = dict(arrowstyle=&quot;&lt;-&quot;) 2、构造决策树 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157######################################################### 构造决策树######################################################### 读入并创建数据集def create_data_set(): data_set = [] # 数据从文件获取 # f = open(r&#x27;data_set.txt&#x27;, encoding=&#x27;UTF-8&#x27;) # text = f.read().splitlines() # print(&quot;data_set.txt的内容为：&quot;) # for line in text: # temp = line.split(&#x27;\\t&#x27;) # print(temp) # data_set.append(temp) # 数据在程序中写死 data_set.append([&quot;男&quot;, &quot;运动员&quot;, &quot;70后&quot;, &quot;光头&quot;, &quot;80后&quot;, &quot;离婚&quot;, &quot;选秀&quot;, &quot;篮球&quot;, &quot;内地&quot;, &quot;演员&quot;]) data_set.append([&quot;是&quot;, &quot;是&quot;, &quot;否&quot;, &quot;否&quot;, &quot;是&quot;, &quot;否&quot;, &quot;否&quot;, &quot;是&quot;, &quot;是&quot;, &quot;否&quot;, &quot;姚明&quot;]) data_set.append([&quot;是&quot;, &quot;是&quot;, &quot;否&quot;, &quot;否&quot;, &quot;是&quot;, &quot;是&quot;, &quot;否&quot;, &quot;否&quot;, &quot;是&quot;, &quot;否&quot;, &quot;刘翔&quot;]) data_set.append([&quot;是&quot;, &quot;是&quot;, &quot;是&quot;, &quot;是&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;是&quot;, &quot;否&quot;, &quot;否&quot;, &quot;科比&quot;]) data_set.append([&quot;是&quot;, &quot;是&quot;, &quot;否&quot;, &quot;否&quot;, &quot;是&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;c罗&quot;]) data_set.append([&quot;是&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;是&quot;, &quot;刘德华&quot;]) data_set.append([&quot;是&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;是&quot;, &quot;否&quot;, &quot;是&quot;, &quot;否&quot;, &quot;毛不易&quot;]) data_set.append([&quot;是&quot;, &quot;否&quot;, &quot;是&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;是&quot;, &quot;周杰伦&quot;]) data_set.append([&quot;是&quot;, &quot;否&quot;, &quot;是&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;是&quot;, &quot;是&quot;, &quot;黄渤&quot;]) data_set.append([&quot;是&quot;, &quot;否&quot;, &quot;是&quot;, &quot;是&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;是&quot;, &quot;是&quot;, &quot;徐峥&quot;]) data_set.append([&quot;否&quot;, &quot;是&quot;, &quot;否&quot;, &quot;否&quot;, &quot;是&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;是&quot;, &quot;否&quot;, &quot;张怡宁&quot;]) data_set.append([&quot;否&quot;, &quot;是&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;是&quot;, &quot;否&quot;, &quot;否&quot;, &quot;是&quot;, &quot;否&quot;, &quot;郎平&quot;]) data_set.append([&quot;否&quot;, &quot;是&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;是&quot;, &quot;否&quot;, &quot;朱婷&quot;]) data_set.append([&quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;是&quot;, &quot;否&quot;, &quot;是&quot;, &quot;是&quot;, &quot;杨超越&quot;]) data_set.append([&quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;是&quot;, &quot;是&quot;, &quot;否&quot;, &quot;否&quot;, &quot;是&quot;, &quot;是&quot;, &quot;杨幂&quot;]) data_set.append([&quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;邓紫棋&quot;]) data_set.append([&quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;是&quot;, &quot;否&quot;, &quot;是&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;徐佳莹&quot;]) data_set.append([&quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;是&quot;, &quot;否&quot;, &quot;否&quot;, &quot;否&quot;, &quot;是&quot;, &quot;是&quot;, &quot;赵丽颖&quot;]) attr = data_set[0] del (data_set[0]) print(&quot;属性集：&quot;) print(attr) print(&quot;数据集：&quot;) print(data_set) return data_set, attr# 如果数据集中的axis列，值为value，那么取出这一行，且去掉这一列，加入子数据集中def split_data_set(data_set, axis, value): sub_data_set = [] for line in data_set: if line[axis] == value: # 去掉这一列 # note: 用循环，较为麻烦 # newline = [] # for i in range(len(line)): # if i != axis: # newline.append(line[i]) # sub_data_set.append(newline) # note: 易错点，如果直接newline = line，其实是newline和line指向同一个地址，会修改data_set中的值 newline = line[:] del newline[axis] sub_data_set.append(newline) return sub_data_set# 计算信息熵def calc_info_ent(data_set): # 数据集样本条数n num = len(data_set) # 标签计数字典 count = &#123;&#125; for i in data_set: # 获取样本最后一列的标签 current_label = i[-1] # 如果当前标签不在计数字典里，则初始化 if current_label not in count.keys(): count[current_label] = 0 count[current_label] += 1 # 信息熵初始化 info_ent = 0.0 # 计算信息熵:sum(-P(X)log(P(x))) for key in count.keys(): # 计算概率 probability = float(count[key]) / num # -P(X)log(P(x)) info_ent -= probability * log(probability, 2) return info_ent# 选出信息增益最大的最优属性def best_split(data_set): # 属性个数，data_set最后一列是标签，不是属性 feature_num = len(data_set[0]) - 1 # 初始信息熵,也就是根节点的信息熵 base_ent = calc_info_ent(data_set) # 初始化 best_info_gain = 0.0 best_index = -1 # axis为列号 for axis in range(feature_num): # 获取每一列数据并去重 row = [] for line in data_set: row.append(line[axis]) unique_row = set(row) new_ent = 0.0 # value为列可能的取值，在20问读心游戏里为：是/否 for value in unique_row: # 取出axis列的值为value的子数据集 sub_data_set = split_data_set(data_set, axis, value) # 计算条件概率 probability = float(len(sub_data_set)) / len(data_set) # 计算条件熵 new_ent += probability * calc_info_ent(sub_data_set) # 计算信息增益 info_gain = base_ent - new_ent if info_gain &gt; best_info_gain: best_info_gain = info_gain best_index = axis return best_index# 递归方式创建决策树# data_set为当前数据集，attr为剩余的还未用过的属性集def create_tree(data_set, attr): # 获取标签，data_set的最后一列 # note: 因为递归，data_set会改变，每次要从新的data_set中获取 true_labels = [] for line in data_set: true_labels.append(line[-1]) # 递归终止条件：标签全部相同（例如全是‘姚明’），或者只有一个标签，没必要再进行下去，直接返回这个标签 if true_labels.count(true_labels[0]) == len(true_labels): return true_labels[0] # 递归终止条件：数据集中只有一个属性（只有一列，标签列，实际没有意义），没必要继续下去，直接返回列中相同值最多的标签 if len(data_set[0]) == 1: return max(true_labels, key=true_labels.count) # 从当前数据集和剩余的属性集attr中获取最优属性(信息增益最大)的索引和属性名 best_index = best_split(data_set) best_attr = attr[best_index] # 开始创建决策树 # 初始化字典，创建根节点，第一个属性对应的也是一个字典 root = &#123;best_attr: &#123;&#125;&#125; # 获取最优属性对应的列并去重 best_row = [] for line in data_set: best_row.append(line[best_index]) unique_row = set(best_row) # value为列可能的取值，在20问读心游戏里为：是/否 for value in unique_row: # 新建子属性集合，并且将用完的属性从属性集中删除 # note: 最好是不要改变attr的内容，新建一个sub_attr拷贝attr，对sub_attr做删除操作 sub_attr = attr[:] del sub_attr[best_index] # 递归构造决策树 # note: root[best_attr]是一个字典 # 根据当前best_attr属性的所有可能的取值value进行构造，在20问读心游戏里为：是/否 # 也就是说构造出的决策树是二叉树 root[best_attr][value] = create_tree(split_data_set(data_set, best_index, value), sub_attr) return root 3、绘制决策树 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159######################################################### 绘制决策树（ps: 为了让画出来的树更美观，借鉴学习了《机器学习实战》中的好思路）######################################################### 获取树的层数def get_depth(decision_tree): max_depth = 0 # 将决策树dict的key转化为list并获取根结点属性名称 root_attr = list(decision_tree.keys())[0] # 根据根节点属性获取子树 sub_tree = decision_tree[root_attr] # 对子树字典所有的key，也就是root_attr所有的取值（在20问读心游戏里为：是/否）遍历 for key in sub_tree.keys(): # 如果是字典对象，说明还未到叶子，继续递归 if isinstance(sub_tree[key], dict): depth = get_depth(sub_tree[key]) + 1 # 如果不是字典对象，说明已经到达叶子，停止递归 else: depth = 1 # 判断深度是否大于最大深度 if depth &gt; max_depth: max_depth = depth return max_depth# 获取树的叶子节点个数，也就是标签数def get_leaf_num(decision_tree): num = 0 # 将决策树dict的key转化为list并获取根结点属性名称 root_attr = list(decision_tree.keys())[0] # 根据根节点属性获取子树 sub_tree = decision_tree[root_attr] # 对子树字典所有的key，也就是root_attr所有的取值（在20问读心游戏里为：是/否）遍历 for key in sub_tree.keys(): # 如果是字典对象，说明还未到叶子，继续递归 if isinstance(sub_tree[key], dict): num += get_leaf_num(sub_tree[key]) # 如果不是字典对象，说明已经到达叶子，停止递归 else: num += 1 return num# 创建图对象，初始化，画图def create_plot(decision_tree): # 定义一个背景为白色的画布，并把画布清空 fig = plt.figure(1, facecolor=&#x27;white&#x27;) fig.clf() # ax_prop为图形的样式，没有坐标轴标签 ax_prop = dict(xticks=[], yticks=[]) # 使用subplot为定义了一个图，一行一列一个图， # frameon=False代表没有矩形边框 # note: 在python里，[函数名称].[变量名]相当于是全局变量 # ax1相当于是图对象，在其它函数中使用 create_plot.ax1 = plt.subplot(111, frameon=False, **ax_prop) # total_width和total_depth分别代表初始决策树的叶子节点数目和深度，不改变 plot_tree.total_width = float(get_leaf_num(decision_tree)) plot_tree.total_depth = float(get_depth(decision_tree)) # 图的大小是长0~1，宽0~1 # note: x_offset实质是每个叶子的x坐标的位置 # 第一片叶子的x为0.5/叶子数目，因此初始的x_offset设为-0.5/叶子数目 # 每次将x_offset+(1/x_offset)，也就是第一个叶子不紧贴边框，有0.5/叶子数目的内边距 # 例如绘制3个叶子，坐标应为1/3、2/3、3/3 # 但这样整个图形会偏右，因此将初始的x_offset设为-0.5/3 # 这样的话，每个叶子向左移了0.5/3，坐标变成了0.5/3、1.5/3、2.5/3，就刚好让图形在正中间了 # 初始的y_offset显然为1，也就是最高点，每下降一层将y_offset-(1/深度)即可 plot_tree.x_offset = -0.5 / plot_tree.total_width plot_tree.y_offset = 1.0 # 初始根节点位置为图形的正中间最上方，即(0.5, 1.0) # 初始节点文本为空，等待获取 plot_tree(decision_tree, (0.5, 1.0), &#x27;&#x27;) plt.show()# 递归画出决策树# parent_pos为父节点位置，也就是当前决策树根节点的父节点位置# arrow_text为父节点指来的箭头上的内容（在20问读心游戏里为：是/否）def plot_tree(decision_tree, parent_pos, arrow_text): # 获取当前决策树叶子数目 # note: leaf_num与plot_tree.total_depth不同，前者针对的是当前的决策树，后者是针对的原来的整个决策树 leaf_num = get_leaf_num(decision_tree) # 将决策树dict的key转化为list并获取根结点属性名称 root_attr = list(decision_tree.keys())[0] # root_pos为当前决策树的根节点的位置 # note: 计算方法为 # 拆分为三部分： # 1. plot_tree.x_offset：初始的x偏移，基准值 # 2. float(numLeafs) / 2.0 / plotTree.totalW： # float(numLeafs) * (1 / plotTree.totalW)为该决策树所包含的所有叶子所占的横坐标宽度 # / 2.0就是这个宽度的中间点 # 3. 0.5 / plotTree.totalW：因为x_offset初始有-0.5/plotTree.totalW的偏移 # 导致该节点并不是在区域中点，而是向左有个0.5/plotTree.totalW偏移 # 因此+0.5 / plotTree.totalW，使其位于区域正中 # 最终的公式经过合并就是下式： root_pos = (plot_tree.x_offset + (1.0 + float(leaf_num)) / 2.0 / plot_tree.total_width, plot_tree.y_offset) # 画出由当前子决策树父节点指来的箭头和箭头上的文本（在20问读心游戏里为：是/否）以及箭头指向的当前决策树的根节点 plot_arrow_text(root_pos, parent_pos, arrow_text) # 节点类型为决策类型decision_node，不是叶子 plot_node(root_pos, parent_pos, decision_node, root_attr) # 根据根节点属性获取子树 sub_tree = decision_tree[root_attr] # note: 每下降一层，将y_offset减1.0 / plot_tree.total_depth plot_tree.y_offset = plot_tree.y_offset - 1.0 / plot_tree.total_depth # 对子树字典所有的key，也就是root_attr所有的取值（在20问读心游戏里为：是/否）遍历 for key in sub_tree.keys(): # 如果是字典对象，说明还未到叶子，继续递归 if isinstance(sub_tree[key], dict): # note: 子决策树为sub_tree[key] # 子决策树的父节点为当前决策树的根节点 # 当前决策树指向子决策树的箭头上的文本为key，因为key不是字符串，要进行类型转换 plot_tree(sub_tree[key], root_pos, str(key)) # 如果不是字典对象，说明已经到达叶子，停止递归 else: # 每到一个叶子，就把x_offset加1.0 / plot_tree.total_width plot_tree.x_offset = plot_tree.x_offset + 1.0 / plot_tree.total_width # 画出叶子、箭头 # (plot_tree.x_offset, plot_tree.y_offset)刚好是叶子的坐标 # root_pos为当前决策树的根节点坐标 # 节点类型为叶子类型leaf_node # 因为是叶子，sub_tree[key]为字符串类型，也就是标签 plot_node((plot_tree.x_offset, plot_tree.y_offset), root_pos, leaf_node, sub_tree[key]) # 画出箭头上的文本 # 当前决策树指向叶子的箭头上的文本为key，因为key不是字符串，要进行类型转换 plot_arrow_text((plot_tree.x_offset, plot_tree.y_offset), root_pos, str(key)) # note: 易错点，每次递归结束需要将y_offset加1.0 / plot_tree.total_depth，回到上一层 plot_tree.y_offset = plot_tree.y_offset + 1.0 / plot_tree.total_depth# 画节点和指向节点的箭头的函数# root_pos为子节点的位置，也就是箭头指向的位置# parent_pos为父节点的位置，也就是箭头尾部所在的位置# node_type为节点类型，两种：决策节点（decision_node）和叶节点（leaf_node）# node_text为要显示的文本，也就是节点的内容，即属性的名称（例如：男、运动员……）def plot_node(root_pos, parent_pos, node_type, node_text): # note: annotate用于在图形上给数据添加文本注解，支持带箭头的划线工具 # 参数如下： # s：注释文本的内容 # xy：被注释的坐标点，二维元组形如(x,y) # xytext：注释文本的坐标点，也就是文本写的地方，也是二维元组，默认与xy相同 # xycoords：被注释点的坐标系属性，axes fraction是以子绘图区左下角为参考，单位是百分比 # textcoords：注释文本的坐标系属性，默认与xycoords属性值相同 # va=&quot;center&quot;，ha=&quot;center&quot;表示注释的坐标以注释框的正中心为准，而不是注释框的左下角(v代表垂直方向，h代表水平方向) # bbox是注释框的风格和颜色深度，fc越小，注释框的颜色越深，支持输入一个字典 # arrowprops：箭头的样式，字典型数据，在画图的开头定义了 create_plot.ax1.annotate(node_text, xy=parent_pos, xycoords=&#x27;axes fraction&#x27;, xytext=root_pos, textcoords=&#x27;axes fraction&#x27;, va=&quot;center&quot;, ha=&quot;center&quot;, bbox=node_type, arrowprops=arrow)# 画箭头上文本的函数# root_pos为子节点的位置，也就是箭头指向的位置# parent_pos为父节点的位置，也就是箭头尾部所在的位置# text为要显示的文本，也就是箭头上写的内容，即属性的取值（在20问读心游戏里为：是/否）def plot_arrow_text(root_pos, parent_pos, arrow_text): # 文本的位置应该处于箭头中间，也就是文本坐标=箭头头坐标+（箭头尾坐标-箭头头坐标）/2，因为箭头是向下指的 x_mid = root_pos[0] + (parent_pos[0] - root_pos[0]) / 2.0 y_mid = root_pos[1] + (parent_pos[1] - root_pos[1]) / 2.0 create_plot.ax1.text(x_mid, y_mid, arrow_text, va=&quot;center&quot;, ha=&quot;center&quot;, rotation=30) 4、测试函数 点击查看代码 12345678910111213141516171819202122232425262728293031######################################################### 测试函数######################################################### 根据决策树decision_tree(决策树字典对象)和标签列表labels对输入的测试向量test进行分类，输出类别# test为列表，样例：[&#x27;是&#x27;, &#x27;否&#x27;, &#x27;否&#x27;, &#x27;否&#x27;, &#x27;否&#x27;, &#x27;否&#x27;, &#x27;否&#x27;, &#x27;否&#x27;, &#x27;否&#x27;, &#x27;是&#x27;]# note: 与决策树建立一样，也是使用递归，从根节点查起，直到叶子def classify(decision_tree, labels, test): # 将决策树dict的key转化为list并获取根结点属性名称 # note: 易错点，如果不转化为list会产生错误： # TypeError: &#x27;dict_keys&#x27; object does not support indexing # 原因是python3改变了dict.keys，返回的是dict_keys对象，支持iterable # 但不支持indexable，我们可以将其明确的转化成list来解决 root_attr = list(decision_tree.keys())[0] # 根据根节点属性获取子树 # note: 子树也是一个字典对象，key为该属性的取值（在20问读心游戏里为：是/否） # value也是一个字典对象，key为下一个属性，value为下一个属性对应的子树 sub_tree = decision_tree[root_attr] # 根据根节点属性名称获取在标签列表中对应的索引，并根据索引获取测试向量test该属性对应的值（在20问读心游戏里为：是/否） value = test[labels.index(root_attr)] # 根据value的值（在20问读心游戏里为：是/否）获取决策树的子树字典 tree_of_value = sub_tree[value] # 用isinstance判断得到的对象是不是字典对象 # 如果是字典，就不是叶子，继续递归 # 如果不是字典，就是叶子，停止递归，tree_of_value就是分类结果 if isinstance(tree_of_value, dict): label = classify(tree_of_value, labels, test) else: label = tree_of_value return label 5、开始运行 点击查看代码 1234567891011121314151617######################################################### 开始运行######################################################### 读入并创建数据集和属性集data_set, attr = create_data_set()# 复制一份属性集attr用于递归，因为递归会将attr内容改变attr_copy = attr.copy()decision_tree = create_tree(data_set, attr_copy)print(&quot;决策树结构为：&quot;)print(decision_tree)# 绘制决策树print(&quot;绘制决策树……&quot;)create_plot(decision_tree)print(&quot;决策树的深度为：%d&quot; % get_depth(decision_tree))print(&quot;决策树叶子数目为：%d&quot; % get_leaf_num(decision_tree)) 6、测试游玩 点击查看代码 123456789101112131415######################################################### 测试########################################################print(&quot;是否要进行测试（1是，0否）：&quot;)flag = int(input())while flag == 1: print(&quot;请输入测试向量（以空格分隔每个问题的答案）：&quot;) test = input().split() result = classify(decision_tree, attr, test) print(&quot;测试结果为：%s&quot; % result) print(&quot;是否要进行测试（1是，0否）：&quot;) flag = int(input())print(&quot;程序成功退出，感谢使用……&quot;)","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://666wxy666.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"实验","slug":"机器学习/实验","permalink":"https://666wxy666.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://666wxy666.github.io/tags/Python/"},{"name":"机器学习","slug":"机器学习","permalink":"https://666wxy666.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"决策树","slug":"决策树","permalink":"https://666wxy666.github.io/tags/%E5%86%B3%E7%AD%96%E6%A0%91/"}]},{"title":"计算机系统结构 实验3 使用MIPS指令实现求两个数组的点积","slug":"计算机系统结构-实验3-使用MIPS指令实现求两个数组的点积","date":"2020-04-25T00:00:00.000Z","updated":"2021-05-30T09:07:07.229Z","comments":true,"path":"2020/04/25/计算机系统结构-实验3-使用MIPS指令实现求两个数组的点积/","link":"","permalink":"https://666wxy666.github.io/2020/04/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AE%9E%E9%AA%8C3-%E4%BD%BF%E7%94%A8MIPS%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E7%82%B9%E7%A7%AF/","excerpt":"本文是关于计算机系统结构实验三，使用MIPS指令实现求两个数组的点积。","text":"本文是关于计算机系统结构实验三，使用MIPS指令实现求两个数组的点积。 一、实验目的 通过实验熟悉实验 1 和实验 2 的内容。 增强汇编语言编程能力。 学会使用模拟器中的定向功能进行优化。 了解对代码进行优化的方法。 二、实验原理​ 通过编写MIPS汇编程序，实现向量点积的功能。在模拟器MIPSsim上执行所写的汇编程序，连续执行，查看寄存器相关结果，判断所写的汇编程序是否正确。然后观察时钟周期图窗口的执行过程和冲突的指令，查看统计窗口的信息，来判断定向前后和优化前后的执行效率高低。 三、实验步骤及结果分析1、自行编写一个计算两个向量点积的汇编程序，该程序要求可以实现求两个向量点积计算后的结果。 向量的点积：假设有两个 n 维向量 a、b，则 a 与 b 的点积为：$$a{\\cdot}b=\\sum_{i=1}^na_ib_i=a_1b_1+a_2b_2+\\cdots+a_nb_n$$两个向量元素使用数组进行数据存储，要求向量的维度不得小于10 PS：汇编程序见附录。 2、启动 MIPSsim。 3、载入自己编写的程序，观察流水线输出结果。 载入的代码： 执行： 执行到结束： 寄存器 我编写的汇编程序是向量$(1,2,3,4,5,6,7,8,9,10,11,12)\\cdot(1,2,3,4,5,6,7,8,9,10,11,12)$=650，R7为结果寄存器，发现结果符合预期，说明编写的汇编程序正确。 时钟周期图 可以看到有较多停顿，主要是LW命令与MUL命令，MUL命令与ADD命令和一些控制停顿。 统计 发现RAW停顿有72个周期，停顿次数较多，可以进行优化。共执行了187个周期，RAW停顿占周期总数的百分比为38.50267%，所有的停顿为84个周期，占周期总数的百分比为44.91978%，效率很低。$$吞吐率TP_1=\\frac{102}{187\\Delta{t}}$$ $$加速比S_1=\\frac{102\\times{5\\Delta{t}}}{187\\Delta{t}}\\approx{2.73}$$ 4、使用定向功能再次执行代码，与刚才执行结果进行比较，观察执行效率的不同。 寄存器 结果正确。 时钟周期图 在使用定向技术后，发现停顿明显减少。 统计 发现RAW停顿有24个周期，停顿次数比没有定向技术时的72个少了很多。共执行了139个周期，比没有定向技术时的187个也少了很多，RAW停顿占周期总数的百分比为17.26619%，所有的停顿为36个周期，占周期总数的百分比为25.89928%，较没有定向技术时的44.91978%也减少了很多。 $$ 吞吐率TP_2=\\frac{102}{139\\Delta{t}} $$ $$ 加速比S_2=\\frac{102\\times{5\\Delta{t}}}{139\\Delta{t}}\\approx{3.67} $$ 吞吐率和加速比是没有定向技术时的$\\frac{187}{139}\\approx{1.35}$倍。 5、采用静态调度方法重排指令序列，减少相关，优化程序PS：静态调度后的汇编程序见附录。 载入代码 寄存器 结果正确。 时钟周期图 在使用静态调度后，发现停顿几乎没有了。 统计 发现RAW停顿有12个周期，停顿次数比没有静态调度时的72个少了很多。共执行了127个周期，比没有静态调度时的187个也少了很多，RAW停顿占周期总数的百分比为9.448819%，所有的停顿为24个周期，占周期总数的百分比为18.89764%，较没有静态调度时的44.91978%也减少了很多。 $$ 吞吐率TP_3=\\frac{102}{127\\Delta{t}} $$ $$ 加速比S_2=\\frac{102\\times{5\\Delta{t}}}{127\\Delta{t}}\\approx{4.02} $$ 吞吐率和加速比是没有静态调度时的$\\frac{187}{127}\\approx{1.47}$倍。 6、对优化后的程序使用定向功能执行，与刚才执行结果进行比较，观察执行效率的不同。 寄存器 结果正确。 时钟周期图 在使用静态调度和分支技术后，发现所有的RAW停顿都没有了，只剩下了控制停顿。 统计 发现没有RAW停顿。共执行了115个周期，比没有静态调度和定向技术时的187个也少了非常多，RAW停顿占周期总数的百分比为0%，所有的停顿为12个周期，全都是控制停顿，占周期总数的百分比为10.43478%，较没有静态调度和定向技术时的44.91978%也减少了非常多，没有RAW停顿也说明这个静态调度是最优调度。 $$ 吞吐率TP_4=\\frac{102}{115\\Delta{t}} $$ $$ 加速比S_2=\\frac{102\\times{5\\Delta{t}}}{115\\Delta{t}}\\approx{4.43} $$ 吞吐率和加速比是没有静态调度和定向技术时的$\\frac{187}{115}\\approx{1.63}$倍。 四、附录1、初始的汇编代码 点击查看代码 12345678910111213141516171819.textmain:ADDIU $r1,$r0,array1ADDIU $r2,$r0,array2ADDIU $r3,$r0,12ADDIU $r7,$r0,0loop:LW $r4,0($r1)LW $r5,0($r2)MUL $r6,$r4,$r5ADD $r7,$r7,$r6ADDI $r1,$r1,4ADDI $r2,$r2,4ADDI $r3,$r3,-1BGTZ $r3,loopTEQ $r0,$r0.dataarray1: .word 1,2,3,4,5,6,7,8,9,10,11,12array2: .word 1,2,3,4,5,6,7,8,9,10,11,12 2、经过静态调度后的汇编代码 点击查看代码 12345678910111213141516171819.textmain:ADDIU $r1,$r0,array1ADDIU $r2,$r0,array2ADDIU $r3,$r0,12ADDIU $r7,$r0,0loop:LW $r4,0($r1)LW $r5,0($r2)ADDI $r1,$r1,4ADDI $r2,$r2,4MUL $r6,$r4,$r5ADDI $r3,$r3,-1ADD $r7,$r7,$r6BGTZ $r3,loopTEQ $r0,$r0.dataarray1: .word 1,2,3,4,5,6,7,8,9,10,11,12array2: .word 1,2,3,4,5,6,7,8,9,10,11,12","categories":[{"name":"计算机系统结构","slug":"计算机系统结构","permalink":"https://666wxy666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"},{"name":"实验","slug":"计算机系统结构/实验","permalink":"https://666wxy666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"计算机系统结构","slug":"计算机系统结构","permalink":"https://666wxy666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"},{"name":"汇编","slug":"汇编","permalink":"https://666wxy666.github.io/tags/%E6%B1%87%E7%BC%96/"},{"name":"MIPS","slug":"MIPS","permalink":"https://666wxy666.github.io/tags/MIPS/"}]},{"title":"Linux 上机实战2 遍历目录","slug":"Linux-上机实战2-遍历目录","date":"2020-04-20T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/04/20/Linux-上机实战2-遍历目录/","link":"","permalink":"https://666wxy666.github.io/2020/04/20/Linux-%E4%B8%8A%E6%9C%BA%E5%AE%9E%E6%88%982-%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95/","excerpt":"本文是关于Linux中的ls的简化版，遍历目录小程序。","text":"本文是关于Linux中的ls的简化版，遍历目录小程序。 一、题目要求编程实现程序list.c，列表普通磁盘文件，包括文件名和文件大小。 使用vi编辑文件，熟悉工具vi。 使用Linux的系统调用和库函数。 体会Shell文件通配符的处理方式以及命令对选项的处理方式。 对选项的处理，自行编程逐个分析命令行参数。不考虑多选项挤在一个命令行参数内的情况。 与ls命令类似，处理对象可以有0到多个 0个：列出当前目录下所有文件 普通文件：列出文件 目录：列出目录下所有文件 实现自定义选项r,a,l,h,m以及– r 递归方式列出子目录（每项要含路径，类似find的-print输出风格，需 要设计递归程序） a 列出文件名第一个字符为圆点的普通文件（默认情况下不列出文件名 首字符为圆点的文件） l 后跟一整数，限定文件大小的最小值（字节） h 后跟一整数，限定文件大小的最大值（字节） m 后跟一整数n，限定文件的最近修改时间必须在n天内 – 显式地终止命令选项分析 编辑，编译 vi list.c make list 或者gcc list.c –o list 运行举例 ./list –l 100 –h 5000 /bin /etc 列出大小在100~5000之间的文件 ./list –a -r -l 50000 –m 2 递归式列出当前目录树下大小超50KB且2天内修改过的文件（包括文件名首字符为圆点的文件） ./list – -l ./list * 二、基本步骤 使用**Xshell**登录到Ubuntu服务器 开始编写代码**list.c**： 1vim list.c 编写代码（代码源码见附件list.c和list2.c和本文最后的附录） 编写完成后保存退出 1:wq 编译 1gcc -Wall list.c -o list 1gcc -Wall list2.c -o list2 三、测试样例1、说明（重要）v1.0是基本要求，但是在基础要求上增加了： -？帮助选项 -d 详细模式选项，类似ls命令，可以显示权限，类型，link数，所有者，修改日期，路径…… 选项在路径之前和之后均可分析 不同种类的文件分不同颜色显示：白色为普通磁盘文件，黄色为目录文件，青色为其他文件，红色为ERROR 完备的差错控制，从分析指令到执行指令阶段，均有完善的差错控制。在执行阶段遇到的文件权限等非致命错误不会打断程序的运行，程序会在屏幕上输出错误信息后继续读取下面的文件 v2.0是在v1.0的基础上进行修改的版本，除保留有v1.0的全部功能外，又增加了： 支持输入长选项（具体使用请使用–help或-？查看） 支持长短选项混合 2、测试样例①帮助 1./list -? 1./list2 -? 1./list2 --help ②正常运行 1./list -l 100 -h 5000 /bin /etc 1./list2 -low=100 -high=5000 /bin /etc 1./list -a -r -l 50000 -m 2 也可以混合输入长短选项 1./list2 --all --r --low=50000 -m 2 使用–终止选项分析 1./list -- -l 1./list2 -- -l 1./list * 1./list2 * 增加的-d(–detail)功能 1./list -d -a 1./list2 --detail --recursive ③出错处理两个版本的出错控制基本一致，就不对每一个命令都展示两个版本了 例如输错了选项 1./list -la /home/wxy -h后面没有参数 1./list /home/wxy -h -l后面虽然有参数，但是不是整数 1./list2 --low=abc /home/wxy 长选项格式输入错误 1./list2 -l=12a 长选项格式输入错误 1./list2 --m1abc 路径不存在 1./list /12345 没有权限 1./list2 /root -all -recursive 等等情况，不再一一展示 四、项目地址本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看： 源码仓库 五、附录PS:程序源码均有详细的注释 1、list.c 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;dirent.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#include &lt;pwd.h&gt;#include &lt;grp.h&gt;//颜色#define NONE &quot;\\e[0m&quot; //复原#define RED &quot;\\e[0;31m&quot; //ERROR#define YELLOW &quot;\\e[0;33m&quot; //目录#define CYAN &quot;\\e[0;36m&quot; //除普通文件和目录文件外的文件#define OPTION_NUM 7 //选项种类数目（除&#x27;--&#x27;以外）//****************选项枚举****************enum OPT&#123; _r, //-r 递归方式列出子目录 _a, //-a 列出文件名第一个字符为圆点的普通文件 _d, //-d 展示文件的详细信息（默认只展示文件路径） _l, //-l 后跟一整数，限定文件大小的最小值（字节） _h, //-h 后跟一整数，限定文件大小的最大值（字节） _m, //-m 后跟一整数n，限定文件的最近修改时间必须在n天内 _help, //-? 显示帮助&#125; opt;//-- 显式地终止命令选项分析//**************************************char split[] = &quot;****************************************\\n&quot;; //分割线char version[] = &quot;1.0&quot;; //版本号char **path; //路径int path_num = 0; //用于记录路径的数目int opts[OPTION_NUM] = &#123;0&#125;; //用来存储选项是否开启，数组的每个位置对应相应选项，值为0表示未开启，为1表示开启long max_size = 0; //最大文件尺寸long min_size = 0; //最小文件尺寸time_t limit_day = 0; //最早修改在几天前time_t current_time = 0; //当前系统时间void free_path(); //释放path分配的空间void help(); //打印帮助信息void analyse_input(int argc, char const *argv[]); //分析输入的命令的函数void show_analyse_result(); //输出命令解析的结果void run(char *path); //对一个路径按照选项运行命令void show_mode(mode_t mode); //输出文件的权限及文件类型（用于-d选项中）void show(struct stat st, char *path); //展示文件信息int main(int argc, char const *argv[])&#123; time(&amp;current_time); //获取指令执行时的时间 analyse_input(argc, argv); //分析用户的输入 //用户加了帮助选项，输出帮助信息后退出 if (opts[_help]) &#123; help(); exit(EXIT_SUCCESS); &#125; //用户没有帮助选项，输出命令解析的结果并运行该命令 else &#123; show_analyse_result(); int i = 0; for (i = 0; i &lt; path_num; i++) &#123; run(path[i]); &#125; &#125; free_path(); return 0;&#125;/** * @name: free_path * @author: * @msg: 释放path分配的空间 * @param: 无 * @return: 无 */void free_path()&#123; int i = 0; for (i = 0; i &lt; path_num; i++) free(path[i]); free(path);&#125;/** * @name: help * @author: * @msg: 打印帮助信息 * @param: 无 * @return: 无 */void help()&#123; printf(&quot;%18sHELP%18s\\n%s&quot;, &quot;&quot;, &quot;&quot;, split); printf(&quot;List %s by Sekiro Apr 10 2020\\n&quot;, version); printf(&quot;Usage: ./list [OPTION]... [PATH]...\\n&quot;); printf(&quot;List informaton about the FILEs in these PATHs(the current directory by default)\\nOptions:\\n&quot;); printf(&quot;\\t-r\\t\\tList subdirectories recursively\\n&quot;); printf(&quot;\\t-a\\t\\tDo not hide entries starting with .\\n&quot;); printf(&quot;\\t-d\\t\\tShow detail information of file(only file path by default)\\n&quot;); printf(&quot;\\t-l &lt;bytes&gt;\\tMinmum of file size\\n&quot;); printf(&quot;\\t-h &lt;bytes&gt;\\tMaxmum of file size\\n&quot;); printf(&quot;\\t-m &lt;days&gt;\\tLimit file last changed time\\n&quot;); printf(&quot;\\t-?\\t\\tDisplay this help and exit\\n&quot;); printf(&quot;Color:\\n&quot;); printf(&quot;\\tWHITE: Regular file\\n&quot;); printf(YELLOW &quot;\\tYELLOW: Directory file\\n&quot; NONE); printf(CYAN &quot;\\tCYAN: Other file\\n&quot; NONE); printf(RED &quot;\\tRED: Error\\n&quot; NONE); printf(&quot;%s&quot;, split);&#125;/** * @name: analyse_input * @author: * @msg: 分析输入的命令的函数 * @param: 同main函数 * @return: 无 */void analyse_input(int argc, char const *argv[])&#123; path = (char **)malloc(argc * sizeof(char *)); int i = 1; int flag = 1; //记录选项分析是否终止，终止为0，未终止为1 for (i = 1; i &lt; argc; i++) &#123; //以-开头的是选项 if (flag &amp;&amp; argv[i][0] == &#x27;-&#x27;) &#123; if (strlen(argv[i]) == 1) &#123; printf(RED &quot;ERROR: Input option wrong, please input the right option\\n&quot; NONE); printf(&quot;Here are some tips:\\n&quot;); help(); free_path(); exit(EXIT_FAILURE); &#125; else if (strlen(argv[i]) == 2) &#123; switch (argv[i][1]) &#123; case &#x27;r&#x27;: opts[_r] = 1; break; case &#x27;a&#x27;: opts[_a] = 1; break; case &#x27;d&#x27;: opts[_d] = 1; break; case &#x27;l&#x27;: opts[_l] = 1; //判断-l选项后面有没有参数 if (i &lt; argc - 1) &#123; char *stop; long int size = strtol(argv[++i], &amp;stop, 10); //stop长度为0代表进行了有效的转换 if (strlen(stop) == 0) &#123; min_size = size; &#125; else &#123; printf(RED &quot;ERROR: Input option -l wrong, there is no required min size, please input the right option\\n&quot; NONE); printf(&quot;Here are some tips:\\n&quot;); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; else &#123; printf(RED &quot;ERROR: Input option -l wrong, there is no required min size, please input the right option\\n&quot; NONE); printf(&quot;Here are some tips:\\n&quot;); help(); free_path(); exit(EXIT_FAILURE); &#125; break; case &#x27;h&#x27;: opts[_h] = 1; //判断-h选项后面有没有参数 if (i &lt; argc - 1) &#123; char *stop; long int size = strtol(argv[++i], &amp;stop, 10); //stop长度为0代表进行了有效的转换 if (strlen(stop) == 0) &#123; max_size = size; &#125; else &#123; printf(RED &quot;ERROR: Input option -h wrong, there is no required max size, please input the right option\\n&quot; NONE); printf(&quot;Here are some tips:\\n&quot;); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; else &#123; printf(RED &quot;ERROR: Input option -h wrong, there is no required max size, please input the right option\\n&quot; NONE); printf(&quot;Here are some tips:\\n&quot;); help(); free_path(); exit(EXIT_FAILURE); &#125; break; case &#x27;m&#x27;: opts[_m] = 1; //判断-m选项后面有没有参数 if (i &lt; argc - 1) &#123; char *stop; long int day = strtol(argv[++i], &amp;stop, 10); //stop长度为0代表进行了有效的转换 if (strlen(stop) == 0) &#123; limit_day = day; &#125; else &#123; printf(RED &quot;ERROR: Input option -m wrong, there is no required limit day, please input the right option\\n&quot; NONE); printf(&quot;Here are some tips:\\n&quot;); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; else &#123; printf(RED &quot;ERROR: Input option -m wrong, there is no required limit day, please input the right option\\n&quot; NONE); printf(&quot;Here are some tips:\\n&quot;); help(); free_path(); exit(EXIT_FAILURE); &#125; break; case &#x27;?&#x27;: opts[_help] = 1; break; case &#x27;-&#x27;: flag = 0; break; default: printf(RED &quot;ERROR: Input option wrong, please input the right option\\n&quot; NONE); printf(&quot;Here are some tips:\\n&quot;); help(); free_path(); exit(EXIT_FAILURE); break; &#125; &#125; else &#123; printf(RED &quot;ERROR: Input option wrong, please input the right option\\n&quot; NONE); printf(&quot;Here are some tips:\\n&quot;); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; else &#123; //不是-开头的认为是路径或者--后面的全部认为是路径 path[path_num] = (char *)malloc(strlen(argv[i]) * sizeof(char)); strcpy(path[path_num++], argv[i]); &#125; &#125; if (opts[_l] &amp;&amp; opts[_h]) &#123; if (min_size &gt; max_size) &#123; printf(RED &quot;ERROR: Min size of file is less than Max size of file, please input the right option\\n&quot; NONE); printf(&quot;Here are some tips:\\n&quot;); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; //没有输入路径，默认为当前工作目录 if (path_num == 0) &#123; path[path_num] = (char *)malloc(sizeof(char) * 255); if (!getcwd(path[path_num++], sizeof(char) * 255)) &#123; printf(RED &quot;ERROR: Get current work path wrong\\n&quot; NONE); free_path(); exit(EXIT_FAILURE); &#125; &#125;&#125;/** * @name: show_analyse_result * @author: * @msg: 输出命令解析的结果 * @param: 无 * @return: 无 */void show_analyse_result()&#123; printf(&quot;Input Analyse Results are:\\n&quot;); int i = 0; for (i = 0; i &lt; OPTION_NUM; i++) &#123; switch (i) &#123; case _r: if (opts[i]) &#123; printf(&quot;-r: True\\n&quot;); &#125; else &#123; printf(&quot;-r: False\\n&quot;); &#125; break; case _a: if (opts[i]) &#123; printf(&quot;-a: True\\n&quot;); &#125; else &#123; printf(&quot;-a: False\\n&quot;); &#125; break; case _d: if (opts[i]) &#123; printf(&quot;-d: True\\n&quot;); &#125; else &#123; printf(&quot;-d: False\\n&quot;); &#125; break; case _l: if (opts[i]) &#123; printf(&quot;-l: True\\tMin Size:%ld\\n&quot;, min_size); &#125; else &#123; printf(&quot;-l: False\\n&quot;); &#125; break; case _h: if (opts[i]) &#123; printf(&quot;-h: True\\tMax Size:%ld\\n&quot;, max_size); &#125; else &#123; printf(&quot;-h: False\\n&quot;); &#125; break; case _m: if (opts[i]) &#123; printf(&quot;-m: True\\tLimit Day:%ld\\n&quot;, limit_day); &#125; else &#123; printf(&quot;-m: False\\n&quot;); &#125; break; case _help: if (opts[i]) &#123; printf(&quot;-?: True\\n&quot;); &#125; else &#123; printf(&quot;-?: False\\n&quot;); &#125; break; default: printf(RED &quot;ERROR: Unknown error, please consult me\\n&quot; NONE); break; &#125; &#125; printf(&quot;%s&quot;, split); printf(&quot;Path Count is: %d\\nPath:\\n&quot;, path_num); for (i = 0; i &lt; path_num; i++) &#123; printf(&quot;%s\\n&quot;, path[i]); &#125; printf(&quot;%s&quot;, split);&#125;/** * @name: run * @msg: 对一个路径按照选项运行命令 * @param： path为这个路径 * @return: 无 */void run(char *path)&#123; struct stat st; //stat结构体 DIR *dir; //目录句柄 struct dirent *entry; //dirent结构体 char current_path[255]; //当前的路径，最长255 //note:一定要用lstat，否则可能会出现有些文件打不开的情况，下面同理 int ret = lstat(path, &amp;st); //取出当前路径的i节点信息 //成功获取stat if (ret == 0) &#123; //如果是目录 if (S_ISDIR(st.st_mode)) &#123; //打开目录 dir = opendir(path); //打开失败 if (dir == NULL) &#123; printf(RED &quot;ERROR[%d] open dir \\&quot;%s\\&quot;: %s\\n&quot; NONE, errno, path, strerror(errno)); &#125; //打开成功 else &#123; entry = readdir(dir); //只要没有读到目录尾就一直读 while (entry != NULL) &#123; //去掉目录中的.和.. if (strcmp(entry-&gt;d_name, &quot;.&quot;) != 0 &amp;&amp; strcmp(entry-&gt;d_name, &quot;..&quot;) != 0) &#123; //构造当前目录下各文件路径 strcpy(current_path, path); //忽略路径最后一个字符为‘/’ if (current_path[strlen(current_path) - 1] != &#x27;/&#x27;) &#123; strcat(current_path, &quot;/&quot;); &#125; strcat(current_path, entry-&gt;d_name); //获取当前目录下面各文件的stat ret = lstat(current_path, &amp;st); //成功获取stat if (ret == 0) &#123; //输出 //是否显示.开头的文件(包括目录文件) if (opts[_a] || entry-&gt;d_name[0] != &#x27;.&#x27;) &#123; show(st, current_path); //如果还是目录并且指定了选项-r，则进行递归 //也就是说current_path一定是目录 if (S_ISDIR(st.st_mode) &amp;&amp; opts[_r]) &#123; run(current_path); &#125; &#125; &#125; //失败输出错误信息 else &#123; printf(RED &quot;ERROR[%d] read file \\&quot;%s\\&quot;: %s\\n&quot; NONE, errno, current_path, strerror(errno)); &#125; &#125; //继续读下一个 entry = readdir(dir); &#125; closedir(dir); &#125; &#125; //如果是文件，直接打印 else &#123; show(st, path); &#125; &#125; //失败输出错误信息 else &#123; printf(RED &quot;ERROR[%d] read file \\&quot;%s\\&quot;: %s\\n&quot; NONE, errno, path, strerror(errno)); &#125;&#125;/** * @name: show_mode * @author: * @msg: //输出文件的权限及文件类型（用于-d选项中） * @param：mode_t mode，文件的mode * @return: 无 */void show_mode(mode_t mode)&#123; int pos = 0; char str[] = &quot;----------&quot;; if (S_ISREG(mode)) str[pos] = &#x27;-&#x27;; //普通文件 else if (S_ISBLK(mode)) str[pos] = &#x27;b&#x27;; //块设备文件 else if (S_ISDIR(mode)) str[pos] = &#x27;d&#x27;; //目录文件 else if (S_ISCHR(mode)) str[pos] = &#x27;c&#x27;; //字符设备文件 else if (S_ISLNK(mode)) str[pos] = &#x27;l&#x27;; //符号连接文件 else if (S_ISFIFO(mode)) str[pos] = &#x27;p&#x27;; //命名管道文件 //按位取与，获得文件所有者权限 pos++; if (S_IRUSR &amp; mode) str[pos] = &#x27;r&#x27;; pos++; if (S_IWUSR &amp; mode) str[pos] = &#x27;w&#x27;; pos++; if (S_IXUSR &amp; mode) str[pos] = &#x27;x&#x27;; //按位取与，获得同组用户权限 pos++; if (S_IRGRP &amp; mode) str[pos] = &#x27;r&#x27;; pos++; if (S_IWGRP &amp; mode) str[pos] = &#x27;w&#x27;; pos++; if (S_IXGRP &amp; mode) str[pos] = &#x27;x&#x27;; //按位取与，获得其他用户权限 pos++; if (S_IROTH &amp; mode) str[pos] = &#x27;r&#x27;; pos++; if (S_IWOTH &amp; mode) str[pos] = &#x27;w&#x27;; pos++; if (S_IXOTH &amp; mode) str[pos] = &#x27;x&#x27;; printf(&quot;%s&quot;, str);&#125;/** * @name: show * @author: * @msg: 展示文件信息 * @param: st为文件stat结构体，path为文件路径 * @return: 无 */void show(struct stat st, char *path)&#123; //是否对文件大小最小值有要求 //如果opts[_l]为1，说明有要求，!opts[_l]=0 //0||st.st_size &gt; min_size=st.st_size &gt; min_size //因此刚好可以限制文件大小 //如果opts[_l]为0，说明没有要求，!opts[_l]=1 //1||st.st_size &gt; min_size=1 //因此限制无效，直接通过，没有限制文件大小 //以下其他命令同理 if (!opts[_l] || st.st_size &gt;= min_size) &#123; //是否对文件大小最大值有要求 if (!opts[_h] || st.st_size &lt;= max_size) &#123; //是否对文件修改时间有要求 //st_mtime域代表了文件的最近改变时间 //((current_time - st.st_mtime) / (24 * 60 * 60))可以得到天数 if (!opts[_m] || ((current_time - st.st_mtime) / (24 * 60 * 60)) &lt; limit_day) &#123; if (opts[_d]) &#123; show_mode(st.st_mode); struct passwd *user; user = getpwuid(st.st_uid); struct group *group; group = getgrgid(st.st_gid); char *time_str; time_str = ctime(&amp;st.st_ctime); //将日期最后的&#x27;\\n&#x27;去掉 time_str[strlen(time_str) - 1] = &#x27;\\0&#x27;; if (S_ISDIR(st.st_mode)) &#123; printf(&quot;%5lu %-10s%-10s%-15ld%s &quot; YELLOW &quot;%s\\n&quot; NONE, st.st_nlink, user-&gt;pw_name, group-&gt;gr_name, st.st_size, time_str, path); &#125; else if (S_ISREG(st.st_mode)) &#123; printf(&quot;%5lu %-10s%-10s%-15ld%s %s\\n&quot;, st.st_nlink, user-&gt;pw_name, group-&gt;gr_name, st.st_size, time_str, path); &#125; else &#123; printf(&quot;%5lu %-10s%-10s%-15ld%s &quot; CYAN &quot;%s\\n&quot; NONE, st.st_nlink, user-&gt;pw_name, group-&gt;gr_name, st.st_size, time_str, path); &#125; &#125; else &#123; if (S_ISDIR(st.st_mode)) &#123; printf(YELLOW &quot;%s\\n&quot; NONE, path); &#125; else if (S_ISREG(st.st_mode)) &#123; printf(&quot;%s\\n&quot;, path); &#125; else &#123; printf(CYAN &quot;%s\\n&quot; NONE, path); &#125; &#125; &#125; &#125; &#125;&#125; 2、list2.c 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770/* * @Copyright: Copyright (c) 2020 S All Rights Reserved. * @Description: 列表Linux文件，在Ubuntu 18.04上进行的编程，较1.0版本增加了长选项分析的功能 * @Version: 2.0 * @Author: * @Date: 2020-04-09 17:57:29 * @LastEditors: * @LastEditTime: 2020-04-13 14:10:59 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;dirent.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#include &lt;pwd.h&gt;#include &lt;grp.h&gt;//颜色#define NONE &quot;\\e[0m&quot; //复原#define RED &quot;\\e[0;31m&quot; //ERROR#define YELLOW &quot;\\e[0;33m&quot; //目录#define CYAN &quot;\\e[0;36m&quot; //除普通文件和目录文件外的文件#define OPTION_NUM 7 //选项种类数目（除&#x27;--&#x27;以外）//****************选项枚举****************enum OPT&#123; _r, //-r, --recursive 递归方式列出子目录 _a, //-a, --all 列出文件名第一个字符为圆点的普通文件 _d, //-d, --detail 展示文件的详细信息（默认只展示文件路径） _l, //-l, --low 后跟一整数，限定文件大小的最小值（字节） _h, //-h, --high 后跟一整数，限定文件大小的最大值（字节） _m, //-m, --mdays 后跟一整数n，限定文件的最近修改时间必须在n天内 _help, //-?, --help 显示帮助&#125; opt;//-- 显式地终止命令选项分析//**************************************char split[] = &quot;****************************************\\n&quot;; //分割线char version[] = &quot;2.0&quot;; //版本号char **path; //路径int path_num = 0; //用于记录路径的数目int opts[OPTION_NUM] = &#123;0&#125;; //用来存储选项是否开启，数组的每个位置对应相应选项，值为0表示未开启，为1表示开启long max_size = 0; //最大文件尺寸long min_size = 0; //最小文件尺寸time_t limit_day = 0; //最早修改在几天前time_t current_time = 0; //当前系统时间void free_path(); //释放path分配的空间void help(); //打印帮助信息void analyse_input(int argc, char const *argv[]); //分析输入的命令的函数void show_analyse_result(); //输出命令解析的结果void run(char *path); //对一个路径按照选项运行命令void show_mode(mode_t mode); //输出文件的权限及文件类型（用于-d选项中）void show(struct stat st, char *path); //展示文件信息int main(int argc, char const *argv[])&#123; time(&amp;current_time); //获取指令执行时的时间 analyse_input(argc, argv); //分析用户的输入 //用户加了帮助选项，输出帮助信息后退出 if (opts[_help]) &#123; help(); exit(EXIT_SUCCESS); &#125; //用户没有帮助选项，输出命令解析的结果并运行该命令 else &#123; show_analyse_result(); int i = 0; for (i = 0; i &lt; path_num; i++) &#123; run(path[i]); &#125; &#125; free_path(); return 0;&#125;/** * @name: free_path * @author: * @msg: 释放path分配的空间 * @param: 无 * @return: 无 */void free_path()&#123; int i = 0; for (i = 0; i &lt; path_num; i++) free(path[i]); free(path);&#125;/** * @name: help * @author: * @msg: 打印帮助信息 * @param: 无 * @return: 无 */void help()&#123; printf(&quot;%18sHELP%18s\\n%s&quot;, &quot;&quot;, &quot;&quot;, split); printf(&quot;List %s by Sekiro Apr 13 2020\\n&quot;, version); printf(&quot;Usage: ./list [OPTION]... [PATH]...\\n&quot;); printf(&quot;List informaton about the FILEs in these PATHs(the current directory by default)\\nOptions:\\n&quot;); printf(&quot;\\t-r, --recursive\\t\\tList subdirectories recursively\\n&quot;); printf(&quot;\\t-a, --all\\t\\tDo not hide entries starting with .\\n&quot;); printf(&quot;\\t-d, --detail\\t\\tShow detail information of file(only file path by default)\\n&quot;); printf(&quot;\\t-l, --low=&lt;bytes&gt;\\tMinmum of file size\\n&quot;); printf(&quot;\\t-h, --high=&lt;bytes&gt;\\tMaxmum of file size\\n&quot;); printf(&quot;\\t-m, --mdays=&lt;days&gt;\\tLimit file last changed time\\n&quot;); printf(&quot;\\t-?, --help\\t\\tDisplay this help and exit\\n&quot;); printf(&quot;Color:\\n&quot;); printf(&quot;\\tWHITE: Regular file\\n&quot;); printf(YELLOW &quot;\\tYELLOW: Directory file\\n&quot; NONE); printf(CYAN &quot;\\tCYAN: Other file\\n&quot; NONE); printf(RED &quot;\\tRED: Error\\n&quot; NONE); printf(&quot;%s&quot;, split);&#125;/** * @name: analyse_input * @author: * @msg: 分析输入的命令的函数 * @param: 同main函数 * @return: 无 */void analyse_input(int argc, char const *argv[])&#123; path = (char **)malloc(argc * sizeof(char *)); int i = 1; int flag = 1; //记录选项分析是否终止，终止为0，未终止为1 for (i = 1; i &lt; argc; i++) &#123; //以-开头的是选项 if (flag &amp;&amp; argv[i][0] == &#x27;-&#x27;) &#123; if (strlen(argv[i]) == 1) &#123; printf(RED &quot;ERROR: Input option wrong, please input the right option\\n&quot; NONE); printf(&quot;Here are some tips:\\n&quot;); help(); free_path(); exit(EXIT_FAILURE); &#125; else if (strlen(argv[i]) == 2) &#123; switch (argv[i][1]) &#123; case &#x27;r&#x27;: opts[_r] = 1; break; case &#x27;a&#x27;: opts[_a] = 1; break; case &#x27;d&#x27;: opts[_d] = 1; break; case &#x27;l&#x27;: opts[_l] = 1; //判断-l选项后面有没有参数 if (i &lt; argc - 1) &#123; char *stop; long int size = strtol(argv[++i], &amp;stop, 10); //stop长度为0代表进行了有效的转换 if (strlen(stop) == 0) &#123; min_size = size; &#125; else &#123; printf(RED &quot;ERROR: Input option -l wrong, there is no required min size, please input the right option\\n&quot; NONE); printf(&quot;Here are some tips:\\n&quot;); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; else &#123; printf(RED &quot;ERROR: Input option -l wrong, there is no required min size, please input the right option\\n&quot; NONE); printf(&quot;Here are some tips:\\n&quot;); help(); free_path(); exit(EXIT_FAILURE); &#125; break; case &#x27;h&#x27;: opts[_h] = 1; //判断-h选项后面有没有参数 if (i &lt; argc - 1) &#123; char *stop; long int size = strtol(argv[++i], &amp;stop, 10); //stop长度为0代表进行了有效的转换 if (strlen(stop) == 0) &#123; max_size = size; &#125; else &#123; printf(RED &quot;ERROR: Input option -h wrong, there is no required max size, please input the right option\\n&quot; NONE); printf(&quot;Here are some tips:\\n&quot;); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; else &#123; printf(RED &quot;ERROR: Input option -h wrong, there is no required max size, please input the right option\\n&quot; NONE); printf(&quot;Here are some tips:\\n&quot;); help(); free_path(); exit(EXIT_FAILURE); &#125; break; case &#x27;m&#x27;: opts[_m] = 1; //判断-m选项后面有没有参数 if (i &lt; argc - 1) &#123; char *stop; long int day = strtol(argv[++i], &amp;stop, 10); //stop长度为0代表进行了有效的转换 if (strlen(stop) == 0) &#123; limit_day = day; &#125; else &#123; printf(RED &quot;ERROR: Input option -m wrong, there is no required limit day, please input the right option\\n&quot; NONE); printf(&quot;Here are some tips:\\n&quot;); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; else &#123; printf(RED &quot;ERROR: Input option -m wrong, there is no required limit day, please input the right option\\n&quot; NONE); printf(&quot;Here are some tips:\\n&quot;); help(); free_path(); exit(EXIT_FAILURE); &#125; break; case &#x27;?&#x27;: opts[_help] = 1; break; case &#x27;-&#x27;: flag = 0; break; default: printf(RED &quot;ERROR: Input option wrong, please input the right option\\n&quot; NONE); printf(&quot;Here are some tips:\\n&quot;); help(); free_path(); exit(EXIT_FAILURE); break; &#125; &#125; //长度&gt;2的情况，也就是长选项 else &#123; if (strchr(argv[i], &#x27;=&#x27;)) &#123; if (strstr(argv[i], &quot;--low=&quot;)) &#123; opts[_l] = 1; //判断--low选项后面有没有参数 if (strlen(argv[i]) &gt; 6) &#123; char *stop; long int size = strtol(argv[i] + sizeof(char) * 6, &amp;stop, 10); //stop长度为0代表进行了有效的转换 if (strlen(stop) == 0) &#123; min_size = size; &#125; else &#123; printf(RED &quot;ERROR: Input option --low wrong, there is no required min size, please input the right option\\n&quot; NONE); printf(&quot;Here are some tips:\\n&quot;); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; else &#123; printf(RED &quot;ERROR: Input option --low wrong, there is no required min size, please input the right option\\n&quot; NONE); printf(&quot;Here are some tips:\\n&quot;); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; else if (strstr(argv[i], &quot;--high=&quot;)) &#123; opts[_h] = 1; //判断--high选项后面有没有参数 if (strlen(argv[i]) &gt; 7) &#123; char *stop; long int size = strtol(argv[i] + sizeof(char) * 7, &amp;stop, 10); //stop长度为0代表进行了有效的转换 if (strlen(stop) == 0) &#123; max_size = size; &#125; else &#123; printf(RED &quot;ERROR: Input option --high wrong, there is no required max size, please input the right option\\n&quot; NONE); printf(&quot;Here are some tips:\\n&quot;); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; else &#123; printf(RED &quot;ERROR: Input option --high wrong, there is no required max size, please input the right option\\n&quot; NONE); printf(&quot;Here are some tips:\\n&quot;); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; else if (strstr(argv[i], &quot;--mdays=&quot;)) &#123; opts[_m] = 1; //判断--mdays选项后面有没有参数 if (strlen(argv[i]) &gt; 8) &#123; char *stop; long int day = strtol(argv[i] + sizeof(char) * 8, &amp;stop, 10); //stop长度为0代表进行了有效的转换 if (strlen(stop) == 0) &#123; limit_day = day; &#125; else &#123; printf(RED &quot;ERROR: Input option --mdays wrong, there is no required limit day, please input the right option\\n&quot; NONE); printf(&quot;Here are some tips:\\n&quot;); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; else &#123; printf(RED &quot;ERROR: Input option --mdays wrong, there is no required limit day, please input the right option\\n&quot; NONE); printf(&quot;Here are some tips:\\n&quot;); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; else &#123; printf(RED &quot;ERROR: Input option wrong, please input the right option\\n&quot; NONE); printf(&quot;Here are some tips:\\n&quot;); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; else &#123; if (strcmp(&quot;--recursive&quot;, argv[i]) == 0) &#123; opts[_r] = 1; &#125; else if (strcmp(&quot;--all&quot;, argv[i]) == 0) &#123; opts[_a] = 1; &#125; else if (strcmp(&quot;--detail&quot;, argv[i]) == 0) &#123; opts[_d] = 1; &#125; else if (strcmp(&quot;--help&quot;, argv[i]) == 0) &#123; opts[_help] = 1; &#125; else &#123; printf(RED &quot;ERROR: Input option wrong, please input the right option\\n&quot; NONE); printf(&quot;Here are some tips:\\n&quot;); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; &#125; &#125; else &#123; //不是-开头的认为是路径或者--后面的全部认为是路径 path[path_num] = (char *)malloc(strlen(argv[i]) * sizeof(char)); strcpy(path[path_num++], argv[i]); &#125; &#125; if (opts[_l] &amp;&amp; opts[_h]) &#123; if (min_size &gt; max_size) &#123; printf(RED &quot;ERROR: Min size of file is less than Max size of file, please input the right option\\n&quot; NONE); printf(&quot;Here are some tips:\\n&quot;); help(); free_path(); exit(EXIT_FAILURE); &#125; &#125; //没有输入路径，默认为当前工作目录 if (path_num == 0) &#123; path[path_num] = (char *)malloc(sizeof(char) * 255); if (!getcwd(path[path_num++], sizeof(char) * 255)) &#123; printf(RED &quot;ERROR: Get current work path wrong\\n&quot; NONE); free_path(); exit(EXIT_FAILURE); &#125; &#125;&#125;/** * @name: show_analyse_result * @author: * @msg: 输出命令解析的结果 * @param: 无 * @return: 无 */void show_analyse_result()&#123; printf(&quot;Input Analyse Results are:\\n&quot;); int i = 0; for (i = 0; i &lt; OPTION_NUM; i++) &#123; switch (i) &#123; case _r: if (opts[i]) &#123; printf(&quot;-r, --recursive: True\\n&quot;); &#125; else &#123; printf(&quot;-r, --recursive: False\\n&quot;); &#125; break; case _a: if (opts[i]) &#123; printf(&quot;-a, --all:\\t True\\n&quot;); &#125; else &#123; printf(&quot;-a, --all:\\t False\\n&quot;); &#125; break; case _d: if (opts[i]) &#123; printf(&quot;-d, --detail:\\t True\\n&quot;); &#125; else &#123; printf(&quot;-d, --detail:\\t False\\n&quot;); &#125; break; case _l: if (opts[i]) &#123; printf(&quot;-l, --low:\\t True\\tMin Size:%ld\\n&quot;, min_size); &#125; else &#123; printf(&quot;-l, --low:\\t False\\n&quot;); &#125; break; case _h: if (opts[i]) &#123; printf(&quot;-h, --high:\\t True\\tMax Size:%ld\\n&quot;, max_size); &#125; else &#123; printf(&quot;-h, --high:\\t False\\n&quot;); &#125; break; case _m: if (opts[i]) &#123; printf(&quot;-m, --mdays:\\t True\\tLimit Day:%ld\\n&quot;, limit_day); &#125; else &#123; printf(&quot;-m, --mdays:\\t False\\n&quot;); &#125; break; case _help: if (opts[i]) &#123; printf(&quot;-?, --help:\\t True\\n&quot;); &#125; else &#123; printf(&quot;-?, --help:\\t False\\n&quot;); &#125; break; default: printf(RED &quot;ERROR: Unknown error, please consult me\\n&quot; NONE); break; &#125; &#125; printf(&quot;%s&quot;, split); printf(&quot;Path Count is: %d\\nPath:\\n&quot;, path_num); for (i = 0; i &lt; path_num; i++) &#123; printf(&quot;%s\\n&quot;, path[i]); &#125; printf(&quot;%s&quot;, split);&#125;/** * @name: run * @msg: 对一个路径按照选项运行命令 * @param： path为这个路径 * @return: 无 */void run(char *path)&#123; struct stat st; //stat结构体 DIR *dir; //目录句柄 struct dirent *entry; //dirent结构体 char current_path[255]; //当前的路径，最长255 //note:一定要用lstat，否则可能会出现有些文件打不开的情况，下面同理 int ret = lstat(path, &amp;st); //取出当前路径的i节点信息 //成功获取stat if (ret == 0) &#123; //如果是目录 if (S_ISDIR(st.st_mode)) &#123; //打开目录 dir = opendir(path); //打开失败 if (dir == NULL) &#123; printf(RED &quot;ERROR[%d] open dir \\&quot;%s\\&quot;: %s\\n&quot; NONE, errno, path, strerror(errno)); &#125; //打开成功 else &#123; entry = readdir(dir); //只要没有读到目录尾就一直读 while (entry != NULL) &#123; //去掉目录中的.和.. if (strcmp(entry-&gt;d_name, &quot;.&quot;) != 0 &amp;&amp; strcmp(entry-&gt;d_name, &quot;..&quot;) != 0) &#123; //构造当前目录下各文件路径 strcpy(current_path, path); //忽略路径最后一个字符为‘/’ if (current_path[strlen(current_path) - 1] != &#x27;/&#x27;) &#123; strcat(current_path, &quot;/&quot;); &#125; strcat(current_path, entry-&gt;d_name); //获取当前目录下面各文件的stat ret = lstat(current_path, &amp;st); //成功获取stat if (ret == 0) &#123; //输出 //是否显示.开头的文件(包括目录文件) if (opts[_a] || entry-&gt;d_name[0] != &#x27;.&#x27;) &#123; show(st, current_path); //如果还是目录并且指定了选项-r，则进行递归 //也就是说current_path一定是目录 if (S_ISDIR(st.st_mode) &amp;&amp; opts[_r]) &#123; run(current_path); &#125; &#125; &#125; //失败输出错误信息 else &#123; printf(RED &quot;ERROR[%d] read file \\&quot;%s\\&quot;: %s\\n&quot; NONE, errno, current_path, strerror(errno)); &#125; &#125; //继续读下一个 entry = readdir(dir); &#125; closedir(dir); &#125; &#125; //如果是文件，直接打印 else &#123; show(st, path); &#125; &#125; //失败输出错误信息 else &#123; printf(RED &quot;ERROR[%d] read file \\&quot;%s\\&quot;: %s\\n&quot; NONE, errno, path, strerror(errno)); &#125;&#125;/** * @name: show_mode * @author: * @msg: //输出文件的权限及文件类型（用于-d选项中） * @param：mode_t mode，文件的mode * @return: 无 */void show_mode(mode_t mode)&#123; int pos = 0; char str[] = &quot;----------&quot;; if (S_ISREG(mode)) str[pos] = &#x27;-&#x27;; //普通文件 else if (S_ISBLK(mode)) str[pos] = &#x27;b&#x27;; //块设备文件 else if (S_ISDIR(mode)) str[pos] = &#x27;d&#x27;; //目录文件 else if (S_ISCHR(mode)) str[pos] = &#x27;c&#x27;; //字符设备文件 else if (S_ISLNK(mode)) str[pos] = &#x27;l&#x27;; //符号连接文件 else if (S_ISFIFO(mode)) str[pos] = &#x27;p&#x27;; //命名管道文件 //按位取与，获得文件所有者权限 pos++; if (S_IRUSR &amp; mode) str[pos] = &#x27;r&#x27;; pos++; if (S_IWUSR &amp; mode) str[pos] = &#x27;w&#x27;; pos++; if (S_IXUSR &amp; mode) str[pos] = &#x27;x&#x27;; //按位取与，获得同组用户权限 pos++; if (S_IRGRP &amp; mode) str[pos] = &#x27;r&#x27;; pos++; if (S_IWGRP &amp; mode) str[pos] = &#x27;w&#x27;; pos++; if (S_IXGRP &amp; mode) str[pos] = &#x27;x&#x27;; //按位取与，获得其他用户权限 pos++; if (S_IROTH &amp; mode) str[pos] = &#x27;r&#x27;; pos++; if (S_IWOTH &amp; mode) str[pos] = &#x27;w&#x27;; pos++; if (S_IXOTH &amp; mode) str[pos] = &#x27;x&#x27;; printf(&quot;%s&quot;, str);&#125;/** * @name: show * @author: * @msg: 展示文件信息 * @param: st为文件stat结构体，path为文件路径 * @return: 无 */void show(struct stat st, char *path)&#123; //是否对文件大小最小值有要求 //如果opts[_l]为1，说明有要求，!opts[_l]=0 //0||st.st_size &gt; min_size=st.st_size &gt; min_size //因此刚好可以限制文件大小 //如果opts[_l]为0，说明没有要求，!opts[_l]=1 //1||st.st_size &gt; min_size=1 //因此限制无效，直接通过，没有限制文件大小 //以下其他命令同理 if (!opts[_l] || st.st_size &gt;= min_size) &#123; //是否对文件大小最大值有要求 if (!opts[_h] || st.st_size &lt;= max_size) &#123; //是否对文件修改时间有要求 //st_mtime域代表了文件的最近改变时间 //((current_time - st.st_mtime) / (24 * 60 * 60))可以得到天数 if (!opts[_m] || ((current_time - st.st_mtime) / (24 * 60 * 60)) &lt; limit_day) &#123; if (opts[_d]) &#123; show_mode(st.st_mode); struct passwd *user; user = getpwuid(st.st_uid); struct group *group; group = getgrgid(st.st_gid); char *time_str; time_str = ctime(&amp;st.st_ctime); //将日期最后的&#x27;\\n&#x27;去掉 time_str[strlen(time_str) - 1] = &#x27;\\0&#x27;; if (S_ISDIR(st.st_mode)) &#123; printf(&quot;%5lu %-10s%-10s%-15ld%s &quot; YELLOW &quot;%s\\n&quot; NONE, st.st_nlink, user-&gt;pw_name, group-&gt;gr_name, st.st_size, time_str, path); &#125; else if (S_ISREG(st.st_mode)) &#123; printf(&quot;%5lu %-10s%-10s%-15ld%s %s\\n&quot;, st.st_nlink, user-&gt;pw_name, group-&gt;gr_name, st.st_size, time_str, path); &#125; else &#123; printf(&quot;%5lu %-10s%-10s%-15ld%s &quot; CYAN &quot;%s\\n&quot; NONE, st.st_nlink, user-&gt;pw_name, group-&gt;gr_name, st.st_size, time_str, path); &#125; &#125; else &#123; if (S_ISDIR(st.st_mode)) &#123; printf(YELLOW &quot;%s\\n&quot; NONE, path); &#125; else if (S_ISREG(st.st_mode)) &#123; printf(&quot;%s\\n&quot;, path); &#125; else &#123; printf(CYAN &quot;%s\\n&quot; NONE, path); &#125; &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/categories/Linux/"},{"name":"上机实战","slug":"Linux/上机实战","permalink":"https://666wxy666.github.io/categories/Linux/%E4%B8%8A%E6%9C%BA%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"C","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/tags/Linux/"}]},{"title":"机器学习 条件熵","slug":"机器学习-条件熵","date":"2020-04-18T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/04/18/机器学习-条件熵/","link":"","permalink":"https://666wxy666.github.io/2020/04/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%9D%A1%E4%BB%B6%E7%86%B5/","excerpt":"本文是关于条件熵的知识拓展。","text":"本文是关于条件熵的知识拓展。 一、问题：假定数据库有𝑁个人，第𝑛个人的先验概率$\\gamma_n$，有𝐾个问题，假定第𝑛个人对第𝑘个问题答案为“是”的概率为$a_{nk}$，请给出给定第𝑘个问题条件下，数据集的条件熵的计算公式。 二、解析原来的条件熵公式为： $$H(Y|X)=\\sum_{x}{P(x)H(Y|X=x)}$$ 因为此题中X的取值只有两个即‘是’和‘否’，因此公式变为： $$H(Y|X)=P(X=是)H(Y|X=是)+P(X=否)H(Y|X=否)$$ 因此先计算对于第k个问题，X=‘是’的样本占总样本的概率P(X=是)和X=‘否’的样本占总样本的概率P(X=否)。 分子为对于第k个问题回答为‘是’的个数即： $$\\sum^{N}_{i=1}{(N\\times\\gamma_i\\times a_{ik})}$$ 分母为总数N，因此P(X=是)： $$P(X=是)=\\frac{\\sum^{N}_{i=1}{(N\\times\\gamma_i\\times a_{ik}})}{N}$$ $$P(X=是)=\\sum^{N}_{i=1}{(\\gamma_i\\times a_{ik})}$$ 同理，P(X=否)： $$P(X=否)=\\frac{\\sum^{N}_{i=1}{[N\\times\\gamma_i\\times (1-a_{ik})}]}{N}$$ $$P(X=否)=\\sum^{N}_{i=1}{[\\gamma_i\\times (1-a_{ik})]}$$ 然后在计算对于第k个问题，X=‘是’的数据集上Y的信息熵和X=‘否’的数据集上Y的信息熵，也就是： $$H(Y|X=是)=-\\sum^{N}_{j=1}{(p(x_j)\\log p(x_j))}$$ $$H(Y|X=否)=-\\sum^{N}_{j=1}{(q(x_j)\\log q(x_j))}$$ 因此要先计算对于第k个问题，X=‘是’的时候，对应每个人‘j’的概率$p(x_j)$。 分子为对于第k个问题，X=‘是’的时候，‘j’这个人的个数： $$N\\times\\gamma_j\\times{a_{jk}}$$ 分母为对于第k个问题所有X=‘是’的个数，也就是上述的P(X=是)的分子： $$\\sum^{N}_{i=1}{(N\\times\\gamma_i\\times a_{ik})}$$ 或者写为： $$P(X=是)\\times{N}$$ 因此$p(x_j)$： $$p(x_j)=\\frac{N\\times\\gamma_j\\times{a_{jk}}}{\\sum^{N}_{i=1}{(N\\times\\gamma_i\\times a_{ik}})}$$ $$p(x_j)=\\frac{\\gamma_j\\times{a_{jk}}}{\\sum^{N}_{i=1}{(\\gamma_i\\times a_{ik})}}$$ 同理X=‘否’的时候，对应每个人‘j’的概率$q(x_j)$： $$q(x_j)=\\frac{N\\times\\gamma_j\\times{(1-a_{jk})}}{\\sum^{N}_{i=1}{[N\\times\\gamma_i\\times (1-a_{jk})}]}$$ $$q(x_j)=\\frac{\\gamma_j\\times{(1-a_{jk})}}{\\sum^{N}_{i=1}{[\\gamma_i\\times (1-a_{jk})]}}$$ 综上所述，可以得出条件熵的最终公式为：","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://666wxy666.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"难点","slug":"难点","permalink":"https://666wxy666.github.io/tags/%E9%9A%BE%E7%82%B9/"},{"name":"机器学习","slug":"机器学习","permalink":"https://666wxy666.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"现代交换原理 MOOC习题 1~4章","slug":"现代交换原理-MOOC习题-1~4章","date":"2020-04-17T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/04/17/现代交换原理-MOOC习题-1~4章/","link":"","permalink":"https://666wxy666.github.io/2020/04/17/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86-MOOC%E4%B9%A0%E9%A2%98-1~4%E7%AB%A0/","excerpt":"自己随便整理了一下在学习“现代交换原理”网课时遇到的一些习题，易错点之类的。","text":"自己随便整理了一下在学习“现代交换原理”网课时遇到的一些习题，易错点之类的。 第一章 交换概论 都是类似的道理，话音业务需要实时、高可靠、恒定速率，因此电路交换适合，异步显然不适合于话音业务。 电路交换是先建立好链路，在进行的交换。路由选择是先进行的，信息转发在建立好的链路上进行。分组交换是上面描述的特点。 通信网三要素是：交换设备、传输设备、终端设备。 交换网络的三要素是：交换单元、不同交换单元间的拓扑连接、控制方式。 第二章 交换网络 交换单元的端口类型有两种：控制端口和状态端口。 T接线器： 话音存储器（SM）：固定每个存储单元8bit存话音，存储单元的数量m就是时隙数m。 控制存储器（CM）：存储单元大小为$\\log_2{m}$，所以时隙数一般都是2的幂次，存储单元的数量m也是时隙数m。 S接线器没有话音存储器，控制存储器（CM），可以把S接线器的所有的控制存储器看成$m\\times{n}$个方格，m为时隙数，n为入（出）线数： S接线器所含CM的数量就是入（出）线数n，也就是一列为一个CM，共有n列。 每个CM所含的存储单元的数量为入（出）线的时隙数m，也就是每个格代表一个存储单元，每个CM有m个存储单元，m行。 每个存储单元的大小为$\\log_2{m}$bit。 $N\\times{N}$的Banyan网络需要$k=\\log_2{N}$级，如果要使用$2\\times{2}$的交换单元构建，那么每层就需要$\\frac{N}{2}$个交换单元，k层共需要$k\\times{\\frac{N}{2}}=\\frac{N}{2}\\times{\\log_2{N}}$，如果是M层的话，则需要$m\\times{\\frac{N}{2}\\times{\\log_2{N}}}$个$2\\times{2}$的交换单元。 因此这个题需要$3\\times{\\frac{8}{2}\\times{\\log_2{8}}}=36$个$2\\times{2}$的交换单元。 第三章 电路交换 常识知识。 示意图： B+C-&gt;A： 这三个题都是基础知识。 直连？应该是可以实现不经过交换设备的语音通信。 用户模块的处理机与区域处理机相连，区域处理机又与其他区域处理机和中央处理机相连。 周期级程序是按一定周期进行的各种扫描和驱动，例如200ms摘挂机扫描。开通业务应该是基本级程序负责。 第四章 分组交换 TCP连接的建立不是路由器基本功能。 ISDN全称是综合业务数字网，不需要支持模拟业务。 ATM 适配层（AAL）主要负责百 ATM 层与高层之间的信元转发过程。从上层收到信息后，AAL 将数据分割成 ATM 信元；从 ATM 层收到信息后，AAL 必须重度新组合数据形成一专个上层能够辨识的格式。上述操作称之为分段与重组（SAR），它是 AAL 的主要任务。此外不同的 AAL 支持属不同的流量或服务类型。 MPLS标记可以任意级，标记栈实现多级标记，Label可以有多个。 A、MPLS和ATM和帧中继都是路由选择和数据转发分开进行，都是面向连接的，但是不需要为每一次通信业务都建立新的连接；而传统IP网是无连接的，路由选择和数据转发同时进行。 B、MPLS和ATM都是虚连接，使用时连接，不需要时可以拆除连接，不是永久连接。 C、MPLS使用的是Label标记方式的逻辑连接，ATM是VPI/VCI方式的逻辑连接，都是逻辑虚连接。 D、MPLS通过LDP等协议，在LSR和LER、LSR和LSR之间完成标记信息的分发，形成与FEC对应的LSP路径。 同上一个题的D选项。 入口LER接收分组，完成第三层功能，判定分组所属的FEC，并给分组加上标记形成MPLS标记分组。 LSR依据分组上的标记以及标记转发表通过交换单元对其进行转发，不再进行任何第三层处理，也就是只处理标记部分，不处理IP分组头。 出口 LER 将分组中的标记去掉后转发至目的地。 MPLS与ATM/FR类似，标记都是本地（逐段）有效的，需要路由器进行标记转换。 所有的习题： 现代交换原理 MOOC习题 1~4章现代交换原理 MOOC习题 5~6章","categories":[{"name":"现代交换原理","slug":"现代交换原理","permalink":"https://666wxy666.github.io/categories/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"},{"name":"习题","slug":"现代交换原理/习题","permalink":"https://666wxy666.github.io/categories/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"习题","slug":"习题","permalink":"https://666wxy666.github.io/tags/%E4%B9%A0%E9%A2%98/"},{"name":"易错点","slug":"易错点","permalink":"https://666wxy666.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"MOOC","slug":"MOOC","permalink":"https://666wxy666.github.io/tags/MOOC/"},{"name":"现代交换原理","slug":"现代交换原理","permalink":"https://666wxy666.github.io/tags/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"},{"name":"网课","slug":"网课","permalink":"https://666wxy666.github.io/tags/%E7%BD%91%E8%AF%BE/"}]},{"title":"计算机系统结构 实验4 使用MIPS指令实现冒泡排序法","slug":"计算机系统结构-实验4-使用MIPS指令实现冒泡排序法","date":"2020-04-16T00:00:00.000Z","updated":"2021-05-30T09:07:07.229Z","comments":true,"path":"2020/04/16/计算机系统结构-实验4-使用MIPS指令实现冒泡排序法/","link":"","permalink":"https://666wxy666.github.io/2020/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AE%9E%E9%AA%8C4-%E4%BD%BF%E7%94%A8MIPS%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%B3%95/","excerpt":"本文是关于计算机系统结构实验四，使用MIPS指令实现冒泡排序法。","text":"本文是关于计算机系统结构实验四，使用MIPS指令实现冒泡排序法。 一、实验目的 掌握静态调度方法 增强汇编语言编程能力 学会使用模拟器中的定向功能进行优化 二、实验原理​ 通过编写MIPS汇编程序，实现冒泡排序的功能。在模拟器MIPSsim上执行所写的汇编程序，查看结果，判断所写的汇编程序是否正确。然后观察时钟周期图窗口的执行过程和冲突的指令，查看统计窗口的信息，来判断定向前后和优化前后的执行效率高低。 三、实验步骤及结果分析1、自行编写一个实现冒泡排序的汇编程序，该程序要求可以实现对一维整数数组进行冒泡排序。冒泡排序算法的运作如下： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点， 最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 要求数组长度不得小于10 PS：汇编程序见附录。 2、启动 MIPSsim。 3、载入自己编写的程序，观察流水线输出结果。载入的代码： 执行结果： 内存中的数组 原数组是{5,4,11,3,7,1,10,6,8,9,2}，排序后是{1,2,3,4,5,6,7,8,9,10,11}，结果符合预期，说明编写的汇编程序正确。 部分时钟周期图 可以看到有非常多的停顿，主要是DSUB命令与BGTZ命令的RAW停顿，还有一些控制停顿。 统计 发现RAW停顿有417个周期，停顿次数非常多，可以进行优化。共执行了1076个周期，RAW停顿占周期总数的百分比为38.75465%，所有的停顿为537个周期，占周期总数的百分比为49.90706%，效率很低。$$吞吐率TP_1=\\frac{538}{1076\\Delta{t}}$$ $$加速比S_1=\\frac{538\\times{5\\Delta{t}}}{1076\\Delta{t}}={2.5}$$ 4、使用定向功能再次执行代码，与刚才执行结果进行比较，观察执行效率的不同。 内存中的数组 结果正确。 部分时钟周期图 在使用定向技术后，发现停顿明显减少。 统计 发现RAW停顿有175个周期，停顿周期数比没有定向技术时的417个少了很多； 共执行了834个周期，比没有定向技术时的1076个也少了很多； RAW停顿占周期总数的百分比为20.98321%，较没有定向技术时的38.75465%也减少了很多； 所有的停顿为295个周期，占周期总数的百分比为35.3717%，较没有定向技术时的49.90706%也减少了很多； $$吞吐率TP_2=\\frac{538}{834\\Delta{t}}$$ $$加速比S_2=\\frac{538\\times{5\\Delta{t}}}{834\\Delta{t}}\\approx{3.23}$$吞吐率和加速比是没有定向技术时的$\\frac{1076}{834}\\approx{1.29}$倍。 5、采用静态调度方法重排指令序列，减少相关，优化程序因为主要是DSUB命令与BGTZ命令的RAW停顿，分支指令的操作数需要用到前面的结果，因此将后面pass中执行的ADDIU $r4, $r4, 1和DSUB $r8, $r2, $r4拿到loop2中执行，从而减少RAW停顿。 PS：静态调度后的汇编程序见附录。 载入代码 内存中的数组 结果正确。 部分时钟周期图 在使用静态调度后，发现停顿少了很多。 统计 发现RAW停顿有142个周期，停顿周期数比没有静态调度时的417个少了很多； 共执行了801个周期，比没有静态调度时的1076个也少了很多； RAW停顿占周期总数的百分比为17.72784%，较没有静态调度时的38.75465%也减少了很多； 所有的停顿为262个周期，占周期总数的百分比为32.70911%，较没有静态调度时的49.90706%也减少了很多； $$吞吐率TP_3=\\frac{538}{801\\Delta{t}}$$ $$加速比S_3=\\frac{538\\times{5\\Delta{t}}}{801\\Delta{t}}\\approx{3.36}$$ 吞吐率和加速比是没有静态调度时的$\\frac{1076}{801}\\approx{1.34}$倍。 6、对优化后的程序使用定向功能执行，与刚才执行结果进行比较，观察执行效率的不同。 内存中的数组 结果正确。 部分时钟周期图 在使用静态调度和定向技术后，发现所有的RAW停顿几乎没有了，几乎只剩下了控制停顿。 统计 发现RAW停顿有10个周期，停顿周期数比没有静态调度和定向技术时的417个少了非常多； 共执行了669个周期，比没有静态调度和定向技术时的1076个也少了非常多； RAW停顿占周期总数的百分比为1.494768%，较没有静态调度和定向技术时的38.75465%也减少了非常多； 所有的停顿为130个周期，占周期总数的百分比为19.43199%，较没有静态调度和定向技术时的49.90706%也减少了很多； $$吞吐率TP_4=\\frac{538}{669\\Delta{t}}$$ $$加速比S_4=\\frac{538\\times{5\\Delta{t}}}{669\\Delta{t}}\\approx{4.02}$$ 吞吐率和加速比是没有静态调度和定向技术时的$\\frac{1076}{669}\\approx{1.61}$倍。 四、实验遇到的问题​ 本次实验中遇到了一个问题，如果main到下一个标签（比如loop1）只有一行汇编代码，在载入程序时，loop1的基地址就会和main重合，变为0x00000000，这样就导致loop1被覆盖，使载入的程序与自己编写的汇编程序不符，产生错误或者结果出错。但是如果&gt;=2行汇编代码就不会有问题，我怀疑是MIPSsim程序的bug。 五、附录1、初始的汇编代码 点击查看代码 12345678910111213141516171819202122232425262728293031.textmain:ADDIU $r1, $r0, 11 # 数组长度n&#x3D;11ADDIU $r2, $r1, -1 # 外循环i&#x3D;n-1&#x3D;10loop1:ADDIU $r3, $r0, array # 数组起始地址ADDIU $r4, $r0, 0 # 内循环j&#x3D;0loop2:LW $r5, 0($r3) # a[j]LW $r6, 4($r3) # a[j+1]DSUB $r7, $r6, $r5 # a[j+1]-a[j]BGTZ $r7, pass # a[j+1]&gt;a[j]，不交换，跳到pass；SW $r6, 0($r3) # a[j+1]&lt;a[j]，交换SW $r5, 4($r3)pass:ADDIU $r4, $r4, 1 # j++ADDIU $r3, $r3, 4 # 取数组的下一个元素DSUB $r8, $r2, $r4 # i-jBGTZ $r8, loop2 # i&gt;j，跳转到loop2，继续内循环ADDIU $r2, $r2, -1 # i--BGTZ $r2, loop1 # i&gt;0，跳转到loop1，继续外循环TEQ $r0, $r0.dataarray: .word 5,4,11,3,7,1,10,6,8,9,2 2、经过静态调度后的汇编代码 点击查看代码 12345678910111213141516171819202122232425262728293031.textmain:ADDIU $r1, $r0, 11 # 数组长度n&#x3D;11ADDIU $r2, $r1, -1 # 外循环i&#x3D;n-1&#x3D;10loop1:ADDIU $r3, $r0, array # 数组起始地址ADDIU $r4, $r0, 0 # 内循环j&#x3D;0loop2:LW $r5, 0($r3) # a[j]LW $r6, 4($r3) # a[j+1]ADDIU $r4, $r4, 1 # j++DSUB $r7, $r6, $r5 # a[j+1]-a[j]DSUB $r8, $r2, $r4 # i-jBGTZ $r7, pass # a[j+1]&gt;a[j]，不交换，跳到pass；SW $r6, 0($r3) # a[j+1]&lt;a[j]，交换SW $r5, 4($r3)pass:ADDIU $r3, $r3, 4 # 取数组的下一个元素BGTZ $r8, loop2 # i&gt;j，跳转到loop2，继续内循环ADDIU $r2, $r2, -1 # i--BGTZ $r2, loop1 # i&gt;0，跳转到loop1，继续外循环TEQ $r0, $r0.dataarray: .word 5,4,11,3,7,1,10,6,8,9,2","categories":[{"name":"计算机系统结构","slug":"计算机系统结构","permalink":"https://666wxy666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"},{"name":"实验","slug":"计算机系统结构/实验","permalink":"https://666wxy666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"计算机系统结构","slug":"计算机系统结构","permalink":"https://666wxy666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"},{"name":"汇编","slug":"汇编","permalink":"https://666wxy666.github.io/tags/%E6%B1%87%E7%BC%96/"},{"name":"MIPS","slug":"MIPS","permalink":"https://666wxy666.github.io/tags/MIPS/"},{"name":"实验","slug":"实验","permalink":"https://666wxy666.github.io/tags/%E5%AE%9E%E9%AA%8C/"}]},{"title":"Linux 上机实战1 正则表达式","slug":"Linux-上机实战1-正则表达式","date":"2020-03-28T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/03/28/Linux-上机实战1-正则表达式/","link":"","permalink":"https://666wxy666.github.io/2020/03/28/Linux-%E4%B8%8A%E6%9C%BA%E5%AE%9E%E6%88%981-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"本文是关于Linux中的文本处理三剑客（grep，sed，awk），以及正则表达式应用的一个样例，获取北京某时刻PM2.5的数据，然后进行处理，输出到csv文件中，并画图表展示。","text":"本文是关于Linux中的文本处理三剑客（grep，sed，awk），以及正则表达式应用的一个样例，获取北京某时刻PM2.5的数据，然后进行处理，输出到csv文件中，并画图表展示。 一、题目要求：​ 从因特网上搜索 Web 页，用 wget 获取网页，处理网页 html 文本数据，从中提取出当前时间点北京各监测站的 PM2.5 浓度，输出如下 CSV 格式数据：2020 03 09 13:00:00, 海淀区万柳 ,732020 03 09 13:00:00, 昌平镇 ,672020 03 09 13:00:00, 奥体中心 ,662020 03 09 13:00:00, 海淀区万柳 ,732020 03 09 13:00:00, 昌平镇 ,732020 03 09 13:00:00, 奥体中心 ,75​ 撰写实验报告，要求：写出对数据的分析和处理思路，列出各个处理步骤并给出解释。 二、详细步骤： 从因特网上搜索 Web 页，找到与含有北京各监测站的 PM2.5 浓度的网站，我找到了**绿色呼吸网**，网站如下： 使用**Xshell**登录到Ubuntu服务器： 使用**wget**命令获取该网页： 1wget http://www.pm25.com/city/beijing.html 使用**cat**命令查看该网页的内容： 1cat beijing.html | more 我们关注的内容： ​ ①数据更新的时间： ​ ②各监测点PM2.5浓度数据： 发现时间的地方有个*“更新时间：”**，监测点名称的地方都有“pjadt_location”*，而PM2.5浓度的地方都有**“pjadt_pm25”。根据这个特性，先使用*awk**命令将需要的行保留下来。下面先进行编写1.awk***： 1vim 1.awk 运行以下命令，对所需行进行过滤： 1cat beijing.html | awk -f 1.awk | more 发现除了我们想要的行还多出了这几行： 经过观察，发现*“PM2.5”**浓度这一行与我们所需的行的区别是，我们所需的行有μg*，而**“PM2.5”浓度这一行没有： 我们重新对*“1.awk”**进行编辑，直接将“监测站点”*这一行排除，并且对**“PM2.5”浓度这一行采用额外的过滤规则: 重新运行以下命令，对所需行进行过滤： 1cat beijing.html | awk -f 1.awk | more 发现已经筛选出了所需要的行。 现在再利用*sed**命令将html标签”&lt;&gt;“*中的内容和**“更新时间：”这个无用的信息删除： 1cat beijing.html | awk -f 1.awk | sed -e &#x27;s/&lt;[^&lt;&gt;]*&gt;//g&#x27; -e &#x27;s/更新时间：//g&#x27; | more 发现已经只剩余我们想要的数据。 但是这些数据不在同一行，且没有明显特征，无法进行*awk**命令，因此先使用tr***命令将这些行合并为一行，以空格分隔： 1cat beijing.html | awk -f 1.awk | sed -e &#x27;s/&lt;[^&lt;&gt;]*&gt;//g&#x27; -e &#x27;s/更新时间：//g&#x27; | tr &#x27;\\n&#x27; &#x27; &#x27; | more 最后利用*awk**命令将所需内容规格化输出即可，先编辑“2.awk”***： 1vim 2.awk 利用*for**循环输出，NF*为列数，刚好循环$$(NF-2)/4$$次，第一个**%s为*日期**，第二个%s*为**时间，第三个*%s**为监测点名称*，第四个**%s为*PM2.5浓度**，再运行以下awk***命令，即可得到格式化的输出： 1cat beijing.html | awk -f 1.awk | sed -e &#x27;s/&lt;[^&lt;&gt;]*&gt;//g&#x27; -e &#x27;s/更新时间：//g&#x27; | tr &#x27;\\n&#x27; &#x27; &#x27; | awk -f 2.awk | more 发现输出已经符合题目要求。 将结果重定向到文件**“beijing.csv”**： 12cat beijing.html | awk -f 1.awk | sed -e &#x27;s/&lt;[^&lt;&gt;]*&gt;//g&#x27; -e &#x27;s/更新时间：//g&#x27; | tr &#x27;\\n&#x27; &#x27; &#x27; | awk -f 2.awk &gt; beijing.csvvim beijing.csv 将*beijing.csv**发送到电脑，并将编码转为ANSI***： 由于不同时间的数据有所不同，因此我的过滤语句考虑了不同时间点的情况*（北京一共有12个监测点，有时有的监测点没有数据，因此是只有11个监测点的数据）**，直接运行以下命令就可以直接将数据导出为beijing.csv***，以下为另一时间点的数据情况： 12wget http://www.pm25.com/city/beijing.htmlcat beijing.html | awk -f 1.awk | sed -e &#x27;s/&lt;[^&lt;&gt;]*&gt;//g&#x27; -e &#x27;s/更新时间：//g&#x27; | tr &#x27;\\n&#x27; &#x27; &#x27; | awk -f 2.awk &gt; beijing.csv 三、总结本文以一个样例，详细介绍了Linux中的文本处理三剑客（grep，sed，awk），以及正则表达式的相关知识，希望对你的Linux学习有所帮助。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/categories/Linux/"},{"name":"上机实战","slug":"Linux/上机实战","permalink":"https://666wxy666.github.io/categories/Linux/%E4%B8%8A%E6%9C%BA%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"C","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/tags/Linux/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://666wxy666.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"Shell","slug":"Shell","permalink":"https://666wxy666.github.io/tags/Shell/"}]},{"title":"计算机系统结构 实验1&2","slug":"计算机系统结构-实验1&2","date":"2020-03-26T00:00:00.000Z","updated":"2021-05-30T09:07:07.229Z","comments":true,"path":"2020/03/26/计算机系统结构-实验1&2/","link":"","permalink":"https://666wxy666.github.io/2020/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AE%9E%E9%AA%8C1&2/","excerpt":"本文是关于计算机系统结构实验一（MIPS指令系统和MIPS体系结构）和实验二（流水线及流水线中的冲突），遇到的一些问题。","text":"本文是关于计算机系统结构实验一（MIPS指令系统和MIPS体系结构）和实验二（流水线及流水线中的冲突），遇到的一些问题。 一、关于字B:byte 字节指令 H:half word 半字节指令 W:word 字节指令 二、关于访存按字或半字访存，无论给定地址是字（半字）中的哪一个字节的地址，都会自动转换为该字（半字）的首字节的地址。例如：MIPS中字长4字节，32位（红色框）；半字2字节，16位（蓝色框）。无论你给定的是第一个红框里的7C(0x00000000)/00(0x00000001)/08(0x00000002)/24(0x00000003)的哪一的地址，只要是按字访存，都会自动转换为7C的地址0x00000000，取出的内容都是2408007C，**一定要注意，这里是小端法存储**。 小端法：高内存地址放整数的高位，低内存地址放整数的低位，这种方式叫倒着放，术语叫小端对齐。电脑X86和手机ARM都是小端对齐的。 大端法：高内存地址放整数的低位，低内存地址放整数的高位，这种方式叫正着放，术语叫大端对齐。很多Unix服务器的cpu都是大端对齐的。 大端和小端字节序不是由操作系统决定的，而是由cpu架构决定的。 三、关于返回地址关于这里的**返回地址**，后面的所有其他跳转指令的返回地址均指的是：当前指令的下一条指令的地址，也就是跳转指令如果不跳转（分支失败）的下一条指令的地址。例如：当前的指令的地址是0x00000068，那么返回地址就是0x00000072。还要注意offset要左移两位并进行符号位扩展后才能与PC相加得到转移地址。这里左移两位的目的是，将offset*4，使之成为4的倍数。也就是说PC+offset&lt;&lt;2代表了PC的后offset+1（因为PC+offset&lt;&lt;2的PC已经+1了）条指令为转移指令。 四、关于定向技术在定向技术中，因为其采用的是静态指令调度。非运算类指令必须在 ID段 得到之前指令的定向数据。并不能像运算类执行一样在 EX段 得到定向数据；如图所示： 五、关于STALL“绿色ID后跟绿色ID” 和 “绿色STALL后跟绿色ID”的区别：绿色ID表示该周期ID可以执行，但是存在RAW冲突，因此执行失败，因此紧接着要做绿色ID；绿色STALL表示该周期由于上一条指令的红色STALL，导致该指令此周期停顿，下一周期执行绿色ID。","categories":[{"name":"计算机系统结构","slug":"计算机系统结构","permalink":"https://666wxy666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"},{"name":"实验","slug":"计算机系统结构/实验","permalink":"https://666wxy666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"计算机系统结构","slug":"计算机系统结构","permalink":"https://666wxy666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"},{"name":"汇编","slug":"汇编","permalink":"https://666wxy666.github.io/tags/%E6%B1%87%E7%BC%96/"},{"name":"MIPS","slug":"MIPS","permalink":"https://666wxy666.github.io/tags/MIPS/"}]},{"title":"大数据实战 Spark Java单词计数","slug":"大数据实战-Spark-Java单词计数","date":"2020-03-15T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/03/15/大数据实战-Spark-Java单词计数/","link":"","permalink":"https://666wxy666.github.io/2020/03/15/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%88%98-Spark-Java%E5%8D%95%E8%AF%8D%E8%AE%A1%E6%95%B0/","excerpt":"本文是关于大数据通过Spark实现Java单词计数。","text":"本文是关于大数据通过Spark实现Java单词计数。 一、实验环境： 虚拟机数量：1 系统版本：Centos 7.5 Spark版本：Apache Spark 2.1.1 JDK版本： jdk-8u131-linux-x64 IDEA版本：ideaIC-2017.2.7 二、实验内容： 创建spark项目 使用Java API 编写wordcount 打印结果 三、实验步骤：3.1新建数据源3.1.1在/home/zkpk目录下创建worddata.txt文件 12cdvim worddata.txt 3.1.2输入以下内容作为JavaWordCount程序的源数据 123456789hello hi hi sparkhello spark hello hi sparksqlhello hi hi sparkstreaminghello hi sparkgraphxhello hello worldhello java c pythonhello scala go htmlhi hi hello spark hdfshello hadoop 3.1.3打开IDEA，创建Java任务 123cdcd idea-IC-172.4574.19/bin/idea.sh &amp; 3.2创建Spark Maven工程，使用Java API 编写wordcount3.2.1点击 Create New Project 3.2.2进入如下图界面，按照图标依次点击，最后点击next 3.2.3依次输入GroupId和ArtifactId和Version的值，随后点击next 3.2.4进入如下界面，设置本地Maven项目的setting.xml文件和warehouse仓库，点击next按钮 3.2.4.1本地setting.xml文件在/home/zkpk/apache-maven-3.5.0/conf目录下 3.2.4.2本地仓库文件夹warehouse在/home/zkpk/apache-maven-3.5.0/warehouse 3.2.5进入如下界面，输入工程名称spark_test，然后点击next，OK 3.2.6工程创建完成后会自动打开一个名为zkpk的xml文件，按照以下修改： 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.zkpk.lab&lt;/groupId&gt; &lt;artifactId&gt;zkpk&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;inceptionYear&gt;2008&lt;/inceptionYear&gt; &lt;properties&gt; &lt;scala.version&gt;2.11.11&lt;/scala.version&gt; &lt;spark.version&gt;2.1.1&lt;/spark.version&gt; &lt;/properties&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;scala-tools.org&lt;/id&gt; &lt;name&gt;Scala-Tools Maven2 Repository&lt;/name&gt; &lt;url&gt;http://scala-tools.org/repo-releases&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;scala-tools.org&lt;/id&gt; &lt;name&gt;Scala-Tools Maven2 Repository&lt;/name&gt; &lt;url&gt;http://scala-tools.org/repo-releases&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.scala-lang&lt;/groupId&gt; &lt;artifactId&gt;scala-library&lt;/artifactId&gt; &lt;version&gt;$&#123;scala.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-core_2.11&lt;/artifactId&gt; &lt;version&gt;$&#123;spark.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-sql_2.11&lt;/artifactId&gt; &lt;version&gt;$&#123;spark.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;sourceDirectory&gt;src/main/scala&lt;/sourceDirectory&gt; &lt;testSourceDirectory&gt;src/test/scala&lt;/testSourceDirectory&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.scala-tools&lt;/groupId&gt; &lt;artifactId&gt;maven-scala-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;goal&gt;testCompile&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;scalaVersion&gt;$&#123;scala.version&#125;&lt;/scalaVersion&gt; &lt;args&gt; &lt;arg&gt;-target:jvm-1.5&lt;/arg&gt; &lt;/args&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-eclipse-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;downloadSources&gt;true&lt;/downloadSources&gt; &lt;buildcommands&gt; &lt;buildcommand&gt;ch.epfl.lamp.sdt.core.scalabuilder&lt;/buildcommand&gt; &lt;/buildcommands&gt; &lt;additionalProjectnatures&gt; &lt;projectnature&gt;ch.epfl.lamp.sdt.core.scalanature&lt;/projectnature&gt; &lt;/additionalProjectnatures&gt; &lt;classpathContainers&gt; &lt;classpathContainer&gt;org.eclipse.jdt.launching.JRE_CONTAINER&lt;/classpathContainer&gt; &lt;classpathContainer&gt;ch.epfl.lamp.sdt.launching.SCALA_CONTAINER&lt;/classpathContainer&gt; &lt;/classpathContainers&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;reporting&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.scala-tools&lt;/groupId&gt; &lt;artifactId&gt;maven-scala-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;scalaVersion&gt;$&#123;scala.version&#125;&lt;/scalaVersion&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/reporting&gt;&lt;/project&gt; 3.2.7保存修改的pom.xml文件后，点击工程名，依次选择Maven——&gt;Reimport，即可根据pom.xml文件导入依赖包，出现下图就代表正在导入依赖包 3.2.8设置语言环境language level，点击菜单栏中的file，选择Project Structure，弹出如下对话框，选择Modules，选择Language level为8，然后点击Apply，点击OK 3.2.9设置Java Compiler环境，点击菜单栏中的file，选择Setting，弹出如下对话框，依次选择Build，Execution——&gt;Compiler——&gt;Java Compiler，设置图中的Project bytecode version为1.8，设置图中的Target bytecode version为1.8，然后依次点击Apply和OK 至此，Spark Maven工程创建完毕 3.2.10在main文件夹下新建文件夹，在弹出的对话框中，输入新文件夹名称为java，点击ok 3.2.11右击先创建的java目录，依次选择Mark Directory as—&gt;Sources Root，此时就可以在java目录中创建类了，我们右键点击java目录，依次选择New——&gt;Java——&gt;Class，弹出对话框，输入Java Class的名字：JavaWordCount，然后点击ok 3.2.12编写如下Java代码，实现词频统计，我在原有的参考答案上又新增了可以根据次品的大小，从大到小排序展示的功能，下面是代码截图，具体代码在本文的附录中 3.3运行程序，查看结果选中程序JavaWordCount，在代码界面点击鼠标右键，出现如下提示框，选择并点击Run JavaWordCount.main()，运行程序，并在终端界面查看程序输出结果 四、附录1、JavaWordCount.java 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import org.apache.spark.api.java.JavaPairRDD;import org.apache.spark.api.java.JavaRDD;import org.apache.spark.sql.SparkSession;import scala.Tuple2;import java.util.Arrays;import java.util.List;import java.util.regex.Pattern;public final class JavaWordCount &#123; private static final Pattern SPACE = Pattern.compile(&quot; &quot;); public static void main(String[] args) throws Exception&#123; SparkSession ss = SparkSession .builder() .master(&quot;local&quot;) .appName(&quot;JavaWordCount&quot;) .getOrCreate(); JavaRDD&lt;String&gt; lines = ss.read().textFile(&quot;file:///home/zkpk/worddata.txt&quot;).javaRDD(); JavaRDD&lt;String&gt; words = lines.flatMap(s -&gt; Arrays.asList(SPACE.split(s)).iterator()); JavaPairRDD&lt;String, Integer&gt; wordAndOne = words.mapToPair(s -&gt; new Tuple2&lt;&gt;(s, 1)); JavaPairRDD&lt;String, Integer&gt; wordAndNum = wordAndOne.reduceByKey((i1, i2) -&gt; i1 + i2); //自己额外实现了可以根据词频的大小，从大到小排序展示的功能 List&lt;Tuple2&lt;String, Integer&gt;&gt; result = wordAndNum //先将key和value交换 .mapToPair((row) -&gt; new Tuple2&lt;&gt;(row._2,row._1)) //按照交换后的key也就是词频倒排序 .sortByKey(false) //再将key和value交换回来，回到单词在前，词频在后的状态 .mapToPair((row) -&gt; new Tuple2&lt;&gt;(row._2,row._1)) .collect(); for (Tuple2&lt;?,?&gt; tuple : result)&#123; System.out.println(tuple._1() + &quot;: &quot; + tuple._2()); &#125; ss.stop(); &#125;&#125; 2、ScalaWordCount.scala 点击查看代码 1234567891011121314151617181920212223242526272829package org.zkpk.labimport org.apache.spark.rdd.RDDimport org.apache.spark.&#123;SparkConf, SparkContext&#125;class ScalaWordCount &#123;&#125;object ScalaWordCount&#123; def main(args: Array[String]): Unit = &#123; val list = List(&quot;hello hi hi spark &quot;, &quot;hello spark hello hi sparksql &quot;, &quot;hello hi hi sparkstreaming &quot;, &quot;hello hi sparkgraphx&quot;) val sparkConf = new SparkConf().setAppName(&quot;word-count&quot;).setMaster(&quot;local[*]&quot;) val sc = new SparkContext(sparkConf) val lines: RDD[String] = sc.parallelize(list) val words: RDD[String] = lines.flatMap((line: String) =&gt; &#123;line.split(&quot; &quot;)&#125;) val wordAndOne: RDD[(String, Int)] = words.map((word: String) =&gt; &#123;(word, 1)&#125;) val wordAndNum: RDD[(String, Int)] = wordAndOne.reduceByKey((count1: Int, count2: Int) =&gt; &#123;count1+ count2&#125;) val ret = wordAndNum.sortBy(kv =&gt; kv._2, false) println(ret.collect().mkString(&quot;,&quot;)) ret.saveAsTextFile(args(0)) sc.stop() &#125;&#125;","categories":[{"name":"大数据","slug":"大数据","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"实战","slug":"大数据/实战","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://666wxy666.github.io/tags/Java/"},{"name":"大数据","slug":"大数据","permalink":"https://666wxy666.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Spark","slug":"Spark","permalink":"https://666wxy666.github.io/tags/Spark/"},{"name":"Scala","slug":"Scala","permalink":"https://666wxy666.github.io/tags/Scala/"}]},{"title":"Linux MOOC习题 1~5章","slug":"Linux-MOOC习题-1~5章","date":"2020-03-10T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/03/10/Linux-MOOC习题-1~5章/","link":"","permalink":"https://666wxy666.github.io/2020/03/10/Linux-MOOC%E4%B9%A0%E9%A2%98-1~5%E7%AB%A0/","excerpt":"自己随便整理了一下在学习Linux网课时遇到的一些习题，易错点之类的。","text":"自己随便整理了一下在学习Linux网课时遇到的一些习题，易错点之类的。 废话不多说，直接开始： PS：第一章是课程介绍。 二、开始使用Linux和文本文件的处理 第1题其实是很基础的问题，早期的终端一般由键盘、显示器和RS232串行通信接口构成，没有磁盘存储器，其实可以想象成和打字机差不多的东西，他就是直接在显示器上显示了，不需要磁盘存储器。 第2题也比较基础： 行律的作用是： 一行内字符的缓冲、回显和编辑，直到按下回车键； 数据的加工，类似第二题中的将“\\n”替换为“\\r\\n”； 将CTRL-C字符转换为终止进程的信号； 驱动程序其实是串口与行律的接口，负责上行和下行字符流。 这俩题没啥好说的，基础知识。 并不是这样的，CTRL-C确实传送了字符**（Ctrl+字母组合键可以产生ASCII码为1-26的控制字符，字母序号是几，ASCII码就是几，Ctrl+C的ASCII码应为3）**，其实还是行律的作用，他将CTRL-C字符转换为终止进程的信号，从而通知Linux主机，进程终止。 这俩题都是关于uniq命令的。 123uniq -uuniq -duniq 第一个命令，-u代表unique，只打印没有重复的行； 第二个命令，-d代表duplicated，只打印重复的行，注意重复的行只打印一次； 第三个命令，啥也不加就是都打印，但是也是复的行只打印一次； 还有就是关于重复的行，意思其实是连续的紧邻的两行内容相同才被叫做重复的行，因此第10题是错的。 这个题不难，写出来的目的是只要记得 Less is more 就很好想了，less是more的升级版。 这俩题也不多解释了，od不可打印字符也可以显示，tr是用于翻译，把string1出现的字符替换为string2中对应的字符，ASCII字符0也可以翻译。 1tr string1 string2 三、正则表达式 先说一下正则表达式的**元字符**，有6个，分别是： 1. * [ \\ ^ $ 关于他们各自的含义不多说，自行百度，一定要注意的是]不是元字符，很容易搞错。 而关于单字符正则表达式，显而易见，就是匹配一个字符呗，不过有特殊的: \\加一个字符构成的转义字符，看做单字符正则表达式； 1\\. \\* \\[ \\\\ \\^ \\$ []定义的集合也被看做单字符正则表达式; 因为.本来的含义是匹配任意字符，转义后就是单字符.，因此都是单字符正则表达式，而$在尾部时和^在首部时有特殊含义，因此转义之前不是，转义后就是单字符​了。 这个题就比较有意思了，先看一下sed命令的基本用法： 1sed &#x27;s/正则表达式/字符串/g&#x27; 文件名列表 s选项的意思是替换，将文件中匹配第一个//中的正则表达式的内容替换为第二个//中的字符串。 然后我们在看上题‘’中的正则表达式（也就是第一个//中的内容） 1\\[[^][]*] 可以分为三部分： 因为[是元字符，加\\转义后就变成了真正的[。 1\\[ 中间这一部分是一个集合[]，重复一次或多次[]*，集合里面的^代表排除，排除了]和[，意思就是说除]和[外的字符重复一次或多次。那么这就有一个问题，第一个[为什么不与第一个]匹配，反而去和最后一个]匹配呢？个人觉得，因为如果与第一个]匹配，就有了[^]，这显然是错误的正则表达式，那么就继续向后匹配，因此就匹配到了最后面的]。 1[^][]* 因为]不是元字符，也没有[与它匹配，它就是单纯的一个字符]。 1] 综上所述，这个正则表达式可以匹配“[非]和[的字符任意多个]”，类似[参考文献23]这样的，但是如果[]里面还有]和[，就匹配不到了。再看上面的题，第二个//里面是空的，那么就是把匹配到的内容删除，很好理解。 四、文件比较，文件通配符 vi的基本用法，在命令状态 12345678:q 退出（:quit的缩写）:q! 退出且不保存（:quit!的缩写）:wq 保存并退出:wq! 保存并退出即使文件没有写入权限（强制保存退出）:x 保存并退出（类似:wq，但是只有在有更改的情况下才保存）:exit 保存并退出（和:x相同）:qa 退出所有(:quitall的缩写):cq 退出且不保存（即便有错误） 另外在“正常模式”下输入“ZZ”来保存并退出Vim（和:x相同），或者“ZQ”不保存并退出（和:q!相同）注意此处ZZ大写和小写是完全不同的。 diff一般用于比较文本文件。 五、文件管理和目录管理 在Linux中，Shell会自动帮你进项一些替换，实际运行的命令其实是： 1cp src/x.c src/xx.c src/xxx.c src/x.h src/xx.h src/xxx.h…… 如果有好多.c和.h文件（超过两个），cp就会报错： cp: target xxx is not a directory 但是如果只有两个.c或.h文件，那么就会产生非常严重的后果，实际运行了下面的命令： 1cp src/x.c src/y.c 这是非常危险的，这样y.c的内容会被x.c覆盖，这是我们不愿意看到的。 那么应该用什么命令来实现题目的要求呢？ 1cp src/*.[ch] . 我们显示地指定复制到.（当前目录），就不会出现问题了。 这也是在Linux中很怪的地方，明明你不能写这个文件，但是你却可以删除，如果不加-f，删除只读文件时会有提示，但是加了-f就没有任何提示了。还有一点需要注意的是，如第6题所说，加了-f也不能删除无权限删除的文件。 关于第10题，不像Windows，在Linux中这些后缀都是约定俗成的，只是为了做标记用，好区分而已，没有实际意义。 所有的习题： Linux MOOC习题 1~5章Linux MOOC习题 6~10章Linux MOOC习题 11~15章","categories":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/categories/Linux/"},{"name":"习题","slug":"Linux/习题","permalink":"https://666wxy666.github.io/categories/Linux/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/tags/Linux/"},{"name":"习题","slug":"习题","permalink":"https://666wxy666.github.io/tags/%E4%B9%A0%E9%A2%98/"},{"name":"易错点","slug":"易错点","permalink":"https://666wxy666.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"MOOC","slug":"MOOC","permalink":"https://666wxy666.github.io/tags/MOOC/"}]},{"title":"Hello Blog","slug":"我的第一篇博客","date":"2020-02-10T00:00:00.000Z","updated":"2021-05-30T09:07:07.225Z","comments":true,"path":"2020/02/10/我的第一篇博客/","link":"","permalink":"https://666wxy666.github.io/2020/02/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"HELLO BLOG 欢迎来到我的博客，这是我的第一篇博客文章。","text":"HELLO BLOG 欢迎来到我的博客，这是我的第一篇博客文章。 如果有什么问题，欢迎到我的Github与我交流。","categories":[{"name":"其他","slug":"其他","permalink":"https://666wxy666.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"first","slug":"first","permalink":"https://666wxy666.github.io/tags/first/"}]}],"categories":[{"name":"集锦","slug":"集锦","permalink":"https://666wxy666.github.io/categories/%E9%9B%86%E9%94%A6/"},{"name":"Android","slug":"集锦/Android","permalink":"https://666wxy666.github.io/categories/%E9%9B%86%E9%94%A6/Android/"},{"name":"Java","slug":"Java","permalink":"https://666wxy666.github.io/categories/Java/"},{"name":"Android项目","slug":"Java/Android项目","permalink":"https://666wxy666.github.io/categories/Java/Android%E9%A1%B9%E7%9B%AE/"},{"name":"C/C++","slug":"C-C","permalink":"https://666wxy666.github.io/categories/C-C/"},{"name":"项目","slug":"C-C/项目","permalink":"https://666wxy666.github.io/categories/C-C/%E9%A1%B9%E7%9B%AE/"},{"name":"算法设计","slug":"C-C/算法设计","permalink":"https://666wxy666.github.io/categories/C-C/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"},{"name":"软件工程","slug":"C-C/软件工程","permalink":"https://666wxy666.github.io/categories/C-C/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"现代交换原理","slug":"现代交换原理","permalink":"https://666wxy666.github.io/categories/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"},{"name":"实验","slug":"现代交换原理/实验","permalink":"https://666wxy666.github.io/categories/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/%E5%AE%9E%E9%AA%8C/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://666wxy666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"实验","slug":"计算机组成原理/实验","permalink":"https://666wxy666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AE%9E%E9%AA%8C/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://666wxy666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"实验","slug":"计算机网络/实验","permalink":"https://666wxy666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%AE%9E%E9%AA%8C/"},{"name":"CSAPP","slug":"集锦/CSAPP","permalink":"https://666wxy666.github.io/categories/%E9%9B%86%E9%94%A6/CSAPP/"},{"name":"操作系统","slug":"C-C/操作系统","permalink":"https://666wxy666.github.io/categories/C-C/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"编译原理","slug":"C-C/编译原理","permalink":"https://666wxy666.github.io/categories/C-C/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"Python","slug":"集锦/Python","permalink":"https://666wxy666.github.io/categories/%E9%9B%86%E9%94%A6/Python/"},{"name":"机器学习","slug":"机器学习","permalink":"https://666wxy666.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"实验","slug":"机器学习/实验","permalink":"https://666wxy666.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8C/"},{"name":"大数据","slug":"大数据","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"实战","slug":"大数据/实战","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%AE%9E%E6%88%98/"},{"name":"拓展学习","slug":"C-C/拓展学习","permalink":"https://666wxy666.github.io/categories/C-C/%E6%8B%93%E5%B1%95%E5%AD%A6%E4%B9%A0/"},{"name":"Python","slug":"Python","permalink":"https://666wxy666.github.io/categories/Python/"},{"name":"爬虫","slug":"Python/爬虫","permalink":"https://666wxy666.github.io/categories/Python/%E7%88%AC%E8%99%AB/"},{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/categories/Linux/"},{"name":"拓展学习","slug":"Linux/拓展学习","permalink":"https://666wxy666.github.io/categories/Linux/%E6%8B%93%E5%B1%95%E5%AD%A6%E4%B9%A0/"},{"name":"习题","slug":"现代交换原理/习题","permalink":"https://666wxy666.github.io/categories/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/%E4%B9%A0%E9%A2%98/"},{"name":"习题","slug":"Linux/习题","permalink":"https://666wxy666.github.io/categories/Linux/%E4%B9%A0%E9%A2%98/"},{"name":"习题","slug":"大数据/习题","permalink":"https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E4%B9%A0%E9%A2%98/"},{"name":"上机实战","slug":"Linux/上机实战","permalink":"https://666wxy666.github.io/categories/Linux/%E4%B8%8A%E6%9C%BA%E5%AE%9E%E6%88%98/"},{"name":"计算机系统结构","slug":"计算机系统结构","permalink":"https://666wxy666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"},{"name":"实验","slug":"计算机系统结构/实验","permalink":"https://666wxy666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E5%AE%9E%E9%AA%8C/"},{"name":"其他","slug":"其他","permalink":"https://666wxy666.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://666wxy666.github.io/tags/Java/"},{"name":"Android","slug":"Android","permalink":"https://666wxy666.github.io/tags/Android/"},{"name":"集锦","slug":"集锦","permalink":"https://666wxy666.github.io/tags/%E9%9B%86%E9%94%A6/"},{"name":"C++","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"QT","slug":"QT","permalink":"https://666wxy666.github.io/tags/QT/"},{"name":"算法设计","slug":"算法设计","permalink":"https://666wxy666.github.io/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"},{"name":"分治","slug":"分治","permalink":"https://666wxy666.github.io/tags/%E5%88%86%E6%B2%BB/"},{"name":"动态规划","slug":"动态规划","permalink":"https://666wxy666.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"软件工程","slug":"软件工程","permalink":"https://666wxy666.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"现代交换原理","slug":"现代交换原理","permalink":"https://666wxy666.github.io/tags/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"},{"name":"MPLS","slug":"MPLS","permalink":"https://666wxy666.github.io/tags/MPLS/"},{"name":"SIP","slug":"SIP","permalink":"https://666wxy666.github.io/tags/SIP/"},{"name":"JobShop","slug":"JobShop","permalink":"https://666wxy666.github.io/tags/JobShop/"},{"name":"Verilog","slug":"Verilog","permalink":"https://666wxy666.github.io/tags/Verilog/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://666wxy666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"FPGA","slug":"FPGA","permalink":"https://666wxy666.github.io/tags/FPGA/"},{"name":"MiniSYS","slug":"MiniSYS","permalink":"https://666wxy666.github.io/tags/MiniSYS/"},{"name":"C","slug":"C","permalink":"https://666wxy666.github.io/tags/C/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://666wxy666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"DNS","slug":"DNS","permalink":"https://666wxy666.github.io/tags/DNS/"},{"name":"Linux","slug":"Linux","permalink":"https://666wxy666.github.io/tags/Linux/"},{"name":"CSAPP","slug":"CSAPP","permalink":"https://666wxy666.github.io/tags/CSAPP/"},{"name":"操作系统","slug":"操作系统","permalink":"https://666wxy666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"进程","slug":"进程","permalink":"https://666wxy666.github.io/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"线程","slug":"线程","permalink":"https://666wxy666.github.io/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"同步互斥","slug":"同步互斥","permalink":"https://666wxy666.github.io/tags/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/"},{"name":"读者写者","slug":"读者写者","permalink":"https://666wxy666.github.io/tags/%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85/"},{"name":"生产者消费者","slug":"生产者消费者","permalink":"https://666wxy666.github.io/tags/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/"},{"name":"编译原理","slug":"编译原理","permalink":"https://666wxy666.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"语法分析","slug":"语法分析","permalink":"https://666wxy666.github.io/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"},{"name":"词法分析","slug":"词法分析","permalink":"https://666wxy666.github.io/tags/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"},{"name":"Python","slug":"Python","permalink":"https://666wxy666.github.io/tags/Python/"},{"name":"机器学习","slug":"机器学习","permalink":"https://666wxy666.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"华为云","slug":"华为云","permalink":"https://666wxy666.github.io/tags/%E5%8D%8E%E4%B8%BA%E4%BA%91/"},{"name":"分类","slug":"分类","permalink":"https://666wxy666.github.io/tags/%E5%88%86%E7%B1%BB/"},{"name":"大数据","slug":"大数据","permalink":"https://666wxy666.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Spark","slug":"Spark","permalink":"https://666wxy666.github.io/tags/Spark/"},{"name":"Scala","slug":"Scala","permalink":"https://666wxy666.github.io/tags/Scala/"},{"name":"Streaming","slug":"Streaming","permalink":"https://666wxy666.github.io/tags/Streaming/"},{"name":"Kafka","slug":"Kafka","permalink":"https://666wxy666.github.io/tags/Kafka/"},{"name":"流计算","slug":"流计算","permalink":"https://666wxy666.github.io/tags/%E6%B5%81%E8%AE%A1%E7%AE%97/"},{"name":"日志","slug":"日志","permalink":"https://666wxy666.github.io/tags/%E6%97%A5%E5%BF%97/"},{"name":"难点","slug":"难点","permalink":"https://666wxy666.github.io/tags/%E9%9A%BE%E7%82%B9/"},{"name":"小游戏","slug":"小游戏","permalink":"https://666wxy666.github.io/tags/%E5%B0%8F%E6%B8%B8%E6%88%8F/"},{"name":"爬虫","slug":"爬虫","permalink":"https://666wxy666.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"RNN","slug":"RNN","permalink":"https://666wxy666.github.io/tags/RNN/"},{"name":"Shell","slug":"Shell","permalink":"https://666wxy666.github.io/tags/Shell/"},{"name":"习题","slug":"习题","permalink":"https://666wxy666.github.io/tags/%E4%B9%A0%E9%A2%98/"},{"name":"易错点","slug":"易错点","permalink":"https://666wxy666.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"MOOC","slug":"MOOC","permalink":"https://666wxy666.github.io/tags/MOOC/"},{"name":"HDFS","slug":"HDFS","permalink":"https://666wxy666.github.io/tags/HDFS/"},{"name":"MapReduce","slug":"MapReduce","permalink":"https://666wxy666.github.io/tags/MapReduce/"},{"name":"DNN","slug":"DNN","permalink":"https://666wxy666.github.io/tags/DNN/"},{"name":"Matplotlib","slug":"Matplotlib","permalink":"https://666wxy666.github.io/tags/Matplotlib/"},{"name":"K-Means","slug":"K-Means","permalink":"https://666wxy666.github.io/tags/K-Means/"},{"name":"聚类","slug":"聚类","permalink":"https://666wxy666.github.io/tags/%E8%81%9A%E7%B1%BB/"},{"name":"计算机系统结构","slug":"计算机系统结构","permalink":"https://666wxy666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"},{"name":"汇编","slug":"汇编","permalink":"https://666wxy666.github.io/tags/%E6%B1%87%E7%BC%96/"},{"name":"MIPS","slug":"MIPS","permalink":"https://666wxy666.github.io/tags/MIPS/"},{"name":"决策树","slug":"决策树","permalink":"https://666wxy666.github.io/tags/%E5%86%B3%E7%AD%96%E6%A0%91/"},{"name":"网课","slug":"网课","permalink":"https://666wxy666.github.io/tags/%E7%BD%91%E8%AF%BE/"},{"name":"实验","slug":"实验","permalink":"https://666wxy666.github.io/tags/%E5%AE%9E%E9%AA%8C/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://666wxy666.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"first","slug":"first","permalink":"https://666wxy666.github.io/tags/first/"}]}