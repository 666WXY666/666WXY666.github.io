<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>苇名一心的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://666wxy666.github.io/"/>
  <updated>2020-05-07T14:02:05.891Z</updated>
  <id>https://666wxy666.github.io/</id>
  
  <author>
    <name>苇名一心</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大数据 习题</title>
    <link href="https://666wxy666.github.io/2020/05/07/%E5%A4%A7%E6%95%B0%E6%8D%AE-%E4%B9%A0%E9%A2%98/"/>
    <id>https://666wxy666.github.io/2020/05/07/%E5%A4%A7%E6%95%B0%E6%8D%AE-%E4%B9%A0%E9%A2%98/</id>
    <published>2020-05-07T13:47:17.443Z</published>
    <updated>2020-05-07T14:02:05.891Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>自己随便整理了一下在学习“大数据”时遇到的一些习题，易错点之类的。</p><a id="more"></a><h2 id="1、关于Spark中task，block，partition，split，core的关系"><a href="#1、关于Spark中task，block，partition，split，core的关系" class="headerlink" title="1、关于Spark中task，block，partition，split，core的关系"></a>1、关于Spark中task，block，partition，split，core的关系</h2><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507215355.png" alt="第5讲-第4章-大数据处理-Spark框架" style="zoom:67%"><blockquote><p>每一个过程的任务数，对应一个inputSplit, Partition输入可能以多个文件的形式存储在HDFS上，每个File都包含了很多块，称为Block。</p><p>当Spark读取这些文件作为输入时，会根据具体数据格式对应的InputFormat进行解析，一般是将若干个Block合并成一个输入分片，称为InputSplit，注意InputSplit不能跨越文件。</p><p>随后将为这些输入分片生成具体的Task。InputSplit与Task是一一对应的关系。随后这些具体的Task每个都会被分配到集群上的某个节点的某个Executor去执行。</p><ul><li><p>每个节点可以起一个或多个Executor。</p></li><li><p>每个Executor由若干core组成，每个Executor的每个core一次只能执行一个Task。</p><p>注意： 这里的core是虚拟的core而不是机器的物理CPU核，可以理解为就是Executor的一个工作线程。</p></li><li><p>每个Task执行的结果就是生成了目标RDD的一个partiton。</p><p>Task被执行的并发度 = Executor数目$\times$每个Executor核数（=core总个数）</p></li><li><p>至于partition的数目：</p><ul><li>对于数据读入阶段，例如sc.textFile，输入文件被划分为多少InputSplit就会需要多少初始Task。</li><li>在Map阶段partition数目保持不变。</li><li>在Reduce阶段，RDD的聚合会触发shuffle操作，聚合后的RDD的partition数目跟具体操作有关，例如repartition操作会聚合成指定分区数，还有一些算子是可配置的。</li><li>RDD在计算的时候，每个分区都会起一个task，所以rdd的分区数目决定了总的task数目。申请的计算节点（Executor）数目和每个计算节点核数，决定了你同一时刻可以并行执行的task。<br>比如：<br>RDD有100个分区，那么计算的时候就会生成100个task，你的资源配置为10个计算节点，每个2个核，同一时刻可以并行的task数目为20，计算这个RDD就需要5个轮次。如果计算资源不变，你有101个task的话，就需要6个轮次，在最后一轮中，只有一个task在执行，其余核都在空转。如果资源不变，你的RDD只有2个分区，那么同一时刻只有2个task运行，其余18个核空转，造成资源浪费。这就是在spark调优中，增大RDD分区数目，增大任务并行度的原因。</li></ul></li></ul></blockquote><h2 id="2、HDFS体系架构"><a href="#2、HDFS体系架构" class="headerlink" title="2、HDFS体系架构"></a>2、HDFS体系架构</h2><p>HDFS采用了主从（Master/Slave）结构 模型，一个HDFS集群是由一个 NameNode和若干个 DataNode 组成的。其中 NameNode 作为主服务器，管理文件系统的命名空间和客户端对文件的 访问操作；集群中的 DataNode 管理存储的数据。HDFS 允许用户以文件的形 式存储数据。从内部来看，文件被分成 若干个数据块，而且这若干个数据块存 放在一组 DataNode 上。NameNode 执行文件系统的命名空间操作，比如打开、关闭、重命名文件或目录等，它也负责数据块到具体 DataNode 的映射。 DataNode 负责处理文件系统客户端的文件读写请求，并在 NameNode 的统 一调度下进行数据块的创建、删除和复制工作。</p><h2 id="3、HDFS的读操作流程"><a href="#3、HDFS的读操作流程" class="headerlink" title="3、HDFS的读操作流程"></a>3、HDFS的读操作流程</h2><ol><li>初始化FileSystem，然后客户端用函数 open()打开文件。</li><li>FileSystem调用元数据节点，得到数据 块信息，并对每一个数据块、元数据节点返回，保存数据块的数据节点地址。</li><li>客户端调用Stream的read()函数开始读 取数据。</li><li>FSDataInputStream连接保存此文件第 一个数据块的最近的数据节点Datanode， data从数据节点读到客户端。</li><li>当第一个数据块读取完毕时， FSDataInputStream关闭和此数据节点的 连接，然后连接此文件下一个数据块的 最近的数据节点。</li><li>当客户端读取完毕数据的时候，调用 FSDataInputStream的close()函数，关闭连接。</li></ol><h2 id="4、HDFS的写操作流程"><a href="#4、HDFS的写操作流程" class="headerlink" title="4、HDFS的写操作流程"></a>4、HDFS的写操作流程</h2><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507220050.jpg" alt="Pag4" style="zoom:80%"><h2 id="5、习题"><a href="#5、习题" class="headerlink" title="5、习题"></a>5、习题</h2><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507215507.jpg" alt="Page1" style="zoom:80%"> <img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507215615.jpg" alt="Page2" style="zoom:80%"> <img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507215630.jpg" alt="Page3" style="zoom:80%"> <img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507220134.jpg" alt="第3讲-第2章-大数据存储-NoSQL数据库" style="zoom:80%"><details><summary><p>未完待续……</p></summary><div class="content"><p>敬请期待……</p></div></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己随便整理了一下在学习“大数据”时遇到的一些习题，易错点之类的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="习题" scheme="https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E4%B9%A0%E9%A2%98/"/>
    
    
      <category term="习题" scheme="https://666wxy666.github.io/tags/%E4%B9%A0%E9%A2%98/"/>
    
      <category term="易错点" scheme="https://666wxy666.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"/>
    
      <category term="大数据" scheme="https://666wxy666.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Spark" scheme="https://666wxy666.github.io/tags/Spark/"/>
    
      <category term="HDFS" scheme="https://666wxy666.github.io/tags/HDFS/"/>
    
      <category term="MapReduce" scheme="https://666wxy666.github.io/tags/MapReduce/"/>
    
  </entry>
  
  <entry>
    <title>现代交换原理 MOOC习题 1~4章</title>
    <link href="https://666wxy666.github.io/2020/05/07/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86-MOOC%E4%B9%A0%E9%A2%98-1~4%E7%AB%A0/"/>
    <id>https://666wxy666.github.io/2020/05/07/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86-MOOC%E4%B9%A0%E9%A2%98-1~4%E7%AB%A0/</id>
    <published>2020-05-07T02:37:07.224Z</published>
    <updated>2020-05-07T14:25:40.520Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>自己随便整理了一下在学习“现代交换原理”网课时遇到的一些习题，易错点之类的。</p><a id="more"></a><h2 id="第一章-交换概论"><a href="#第一章-交换概论" class="headerlink" title="第一章 交换概论"></a>第一章 交换概论</h2><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507105053.jpg" alt="2020-05-07_104537" style="zoom:80%"> <img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507105117.jpg" alt="2020-05-07_104811" style="zoom:80%"><blockquote><p>都是类似的道理，话音业务需要实时、高可靠、恒定速率，因此电路交换适合，异步显然不适合于话音业务。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507105241.jpg" alt="2020-05-07_104943" style="zoom:80%"><blockquote><p>电路交换是先建立好链路，在进行的交换。路由选择是先进行的，信息转发在建立好的链路上进行。分组交换是上面描述的特点。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507105428.jpg" alt="2020-05-07_105021" style="zoom:80%"><blockquote><p>通信网三要素是：<strong>交换设备</strong>、<strong>传输设备</strong>、<strong>终端设备</strong>。</p><p>交换网络的三要素是：<strong>交换单元</strong>、不同交换单元间的<strong>拓扑连接</strong>、<strong>控制方式</strong>。</p></blockquote><h2 id="第二章-交换网络"><a href="#第二章-交换网络" class="headerlink" title="第二章 交换网络"></a>第二章 交换网络</h2><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507110011.jpg" alt="2020-05-07_110001" style="zoom:80%"><blockquote><p>交换单元的端口类型有两种：控制端口和状态端口。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507110554.jpg" alt="2020-05-07_110356" style="zoom:80%"><blockquote><p>T接线器：</p><ul><li><p>话音存储器（SM）：固定每个存储单元8bit存话音，存储单元的数量m就是时隙数m。</p></li><li><p>控制存储器（CM）：存储单元大小为$\log_2{m}$，所以时隙数一般都是2的幂次，存储单元的数量m也是时隙数m。</p></li></ul></blockquote><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507110608.jpg" alt="2020-05-07_110547" style="zoom:80%"><blockquote><p>S接线器没有话音存储器，控制存储器（CM），可以把S接线器的所有的控制存储器看成$m\times{n}$个方格，m为时隙数，n为入（出）线数：</p><ul><li>S接线器所含CM的数量就是入（出）线数n，也就是一列为一个CM，共有n列。</li><li>每个CM所含的存储单元的数量为入（出）线的时隙数m，也就是每个格代表一个存储单元，每个CM有m个存储单元，m行。</li><li>每个存储单元的大小为$\log_2{m}$bit。</li></ul></blockquote><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507114923.jpg" alt="2020-05-07_114828" style="zoom:80%"><blockquote><p>$N\times{N}$的Banyan网络需要$k=\log_2{N}$级，如果要使用$2\times{2}$的交换单元构建，那么每层就需要$\frac{N}{2}$个交换单元，k层共需要$k\times{\frac{N}{2}}=\frac{N}{2}\times{\log_2{N}}$，如果是M层的话，则需要$m\times{\frac{N}{2}\times{\log_2{N}}}$个$2\times{2}$的交换单元。</p><p>因此这个题需要$3\times{\frac{8}{2}\times{\log_2{8}}}=36$个$2\times{2}$的交换单元。</p></blockquote><h2 id="第三章-电路交换"><a href="#第三章-电路交换" class="headerlink" title="第三章 电路交换"></a>第三章 电路交换</h2><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507120505.jpg" alt="2020-05-07_120218" style="zoom:80%"> <img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507120512.jpg" alt="2020-05-07_120231" style="zoom:80%"> <img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507120522.jpg" alt="2020-05-07_120244" style="zoom:80%"> <img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507120530.jpg" alt="2020-05-07_120310" style="zoom:80%"> <img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507120538.jpg" alt="2020-05-07_120324" style="zoom:80%"> <img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507120551.jpg" alt="2020-05-07_120336" style="zoom:80%"> <img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507120610.jpg" alt="2020-05-07_120432" style="zoom:80%"> <img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507120618.jpg" alt="2020-05-07_120449" style="zoom:80%"><h2 id="第四章-分组交换"><a href="#第四章-分组交换" class="headerlink" title="第四章 分组交换"></a>第四章 分组交换</h2><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507121042.jpg" alt="2020-05-07_120658" style="zoom:80%"> <img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507121049.jpg" alt="2020-05-07_120714" style="zoom:80%"> <img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507121056.jpg" alt="2020-05-07_120733" style="zoom:80%"> <img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507121103.jpg" alt="2020-05-07_120808" style="zoom:80%"> <img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507121110.jpg" alt="2020-05-07_120850" style="zoom:80%"> <img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507121116.jpg" alt="2020-05-07_121004" style="zoom:80%"> <img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507121127.jpg" alt="2020-05-07_121012" style="zoom:80%"> <img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507121133.jpg" alt="2020-05-07_121029" style="zoom:80%"><details><summary><p>未完待续……</p></summary><div class="content"><p>所有的习题：</p><p><a href="https://666wxy666.github.io/2020/05/07/现代交换原理-MOOC习题-1~4章/">现代交换原理 MOOC习题 1~4章</a></p></div></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己随便整理了一下在学习“现代交换原理”网课时遇到的一些习题，易错点之类的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="现代交换原理" scheme="https://666wxy666.github.io/categories/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"/>
    
      <category term="习题" scheme="https://666wxy666.github.io/categories/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/%E4%B9%A0%E9%A2%98/"/>
    
    
      <category term="习题" scheme="https://666wxy666.github.io/tags/%E4%B9%A0%E9%A2%98/"/>
    
      <category term="易错点" scheme="https://666wxy666.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"/>
    
      <category term="网课" scheme="https://666wxy666.github.io/tags/%E7%BD%91%E8%AF%BE/"/>
    
      <category term="MOOC" scheme="https://666wxy666.github.io/tags/MOOC/"/>
    
      <category term="现代交换原理" scheme="https://666wxy666.github.io/tags/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux MOOC习题 10~章</title>
    <link href="https://666wxy666.github.io/2020/05/07/Linux-MOOC%E4%B9%A0%E9%A2%98-10~%E7%AB%A0/"/>
    <id>https://666wxy666.github.io/2020/05/07/Linux-MOOC%E4%B9%A0%E9%A2%98-10~%E7%AB%A0/</id>
    <published>2020-05-07T01:46:38.801Z</published>
    <updated>2020-05-07T14:21:59.055Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>自己随便整理了一下在学习Linux网课时遇到的一些习题，易错点之类的，接上文<a href="https://666wxy666.github.io/2020/04/29/Linux-MOOC习题-5~9章/">Linux MOOC习题 5~9章</a>。</p><a id="more"></a><h2 id="十、shell流程控制：条件、循环与函数"><a href="#十、shell流程控制：条件、循环与函数" class="headerlink" title="十、shell流程控制：条件、循环与函数"></a>十、shell流程控制：条件、循环与函数</h2><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507100115.jpg" alt="2020-05-07_095339" style="zoom:80%"><blockquote><ul><li>B选项：明显的错误，<code>then</code>要么另起一行，要么前面加<code>;</code>。</li><li>C选项和D选项：都是没加<code>fi</code>，C选项还有其他的错误，这明显是和C语言之类的给混了。</li></ul></blockquote><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507101924.jpg" alt="2020-05-07_095526" style="zoom:80%"> <img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507102056.jpg" alt="2020-05-07_095602" style="zoom:80%"> <img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507102115.jpg" alt="2020-05-07_095632" style="zoom:80%"><h2 id="十一、进程的基本概念"><a href="#十一、进程的基本概念" class="headerlink" title="十一、进程的基本概念"></a>十一、进程的基本概念</h2><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507102145.jpg" alt="2020-05-07_095819" style="zoom:80%"> <img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507102202.jpg" alt="2020-05-07_095837" style="zoom:80%"><blockquote><ul><li><code>int a[N] = { 2 };</code>的意思是把<code>a[N]</code>第一个元素赋值为2，其他的赋值为0，也就是说，所有的元素都被赋值了，因此占空间很大。</li><li><code>int a[N];</code>的<code>a[N]</code>没有赋初值，只需记录a的长度即可，占用空间很小。</li></ul><p>从图中（test是第一种赋值的，test2是第二种不赋值的）也可以看出，差别巨大：</p><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507103601.jpg" alt="2020-05-07_103457" style="zoom:80%"></blockquote><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200507102210.jpg" alt="2020-05-07_100015" style="zoom:80%"><blockquote><p>忙等待主要是占用CPU，和内存没啥关系。</p></blockquote><details><summary><p>未完待续……</p></summary><div class="content"><p>所有的习题：</p><p><a href="https://666wxy666.github.io/2020/04/28/Linux-MOOC习题-1~4章/">Linux MOOC习题 1~4章</a></p><p><a href="https://666wxy666.github.io/2020/04/29/Linux-MOOC习题-5~9章/">Linux MOOC习题 5~9章</a></p><p><a href="https://666wxy666.github.io/2020/05/07/Linux-MOOC习题-10~章/">Linux MOOC习题 10~章</a></p></div></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己随便整理了一下在学习Linux网课时遇到的一些习题，易错点之类的，接上文&lt;a href=&quot;https://666wxy666.github.io/2020/04/29/Linux-MOOC习题-5~9章/&quot;&gt;Linux MOOC习题 5~9章&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://666wxy666.github.io/categories/Linux/"/>
    
      <category term="习题" scheme="https://666wxy666.github.io/categories/Linux/%E4%B9%A0%E9%A2%98/"/>
    
    
      <category term="Linux" scheme="https://666wxy666.github.io/tags/Linux/"/>
    
      <category term="习题" scheme="https://666wxy666.github.io/tags/%E4%B9%A0%E9%A2%98/"/>
    
      <category term="易错点" scheme="https://666wxy666.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"/>
    
      <category term="网课" scheme="https://666wxy666.github.io/tags/%E7%BD%91%E8%AF%BE/"/>
    
      <category term="MOOC" scheme="https://666wxy666.github.io/tags/MOOC/"/>
    
  </entry>
  
  <entry>
    <title>Linux 拓展学习</title>
    <link href="https://666wxy666.github.io/2020/04/29/Linux-%E6%8B%93%E5%B1%95%E5%AD%A6%E4%B9%A0/"/>
    <id>https://666wxy666.github.io/2020/04/29/Linux-%E6%8B%93%E5%B1%95%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-04-29T12:40:47.779Z</published>
    <updated>2020-05-07T13:49:34.063Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简单的写了一些Linux的课外拓展学习的相关知识和问题。</p><a id="more"></a><h2 id="一、命令的参数"><a href="#一、命令的参数" class="headerlink" title="一、命令的参数"></a>一、命令的参数</h2><p>编写一个小程序，可以显示命令的选项和参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d:%p [%s]\n"</span>, i, argv[i], argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429205057.jpg" alt="2020-04-29_205032" style="zoom:80%"><h2 id="二、关于控制printf输出的颜色"><a href="#二、关于控制printf输出的颜色" class="headerlink" title="二、关于控制printf输出的颜色"></a>二、关于控制printf输出的颜色</h2><p>编写程序hello.c，编译和运行程序，得到类似以下结果：</p><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429204547.png" alt="图片1" style="zoom:80%"><p>可以通过</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\<span class="number">033</span>[</span><br></pre></td></tr></table></figure><p>来控制printf输出的颜色，格式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"\033[字背景颜色;字体颜色m 字符串 \033[0m"</span> );</span><br></pre></td></tr></table></figure><p>注意，一定要在printf最后使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\<span class="number">033</span>[<span class="number">0</span>m</span><br></pre></td></tr></table></figure><p>来消除前面的作用，否则前面的设置对后面的printf都有效果。</p><table><thead><tr><th align="center">ANSI控制码</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center">\033[0m</td><td align="center">关闭所有属性</td></tr><tr><td align="center">\033[1m</td><td align="center">设置高亮度</td></tr><tr><td align="center">\033[4m</td><td align="center">下划线</td></tr><tr><td align="center">\033[5m</td><td align="center">闪烁</td></tr><tr><td align="center">\033[7m</td><td align="center">反显</td></tr><tr><td align="center">\033[8m</td><td align="center">消隐</td></tr><tr><td align="center">\033[30m —\033[37m</td><td align="center">设置前景色</td></tr><tr><td align="center">\033[40m—\033[47m</td><td align="center">设置背景色</td></tr><tr><td align="center">\033[nA</td><td align="center">光标上移n行</td></tr><tr><td align="center">\03[nB</td><td align="center">光标下移n行</td></tr><tr><td align="center">\033[nC</td><td align="center">光标右移n行</td></tr><tr><td align="center">\033[nD</td><td align="center">光标左移n行</td></tr></tbody></table><p>字背景颜色范围: 40–49</p><p>字颜色范围: 30—39</p><table><thead><tr><th align="center">字背景颜色代号</th><th align="center">字背景颜色</th><th align="center">字颜色代号</th><th align="center">字颜色</th></tr></thead><tbody><tr><td align="center">40</td><td align="center">黑</td><td align="center">30</td><td align="center">黑</td></tr><tr><td align="center">41</td><td align="center">红</td><td align="center">31</td><td align="center">红</td></tr><tr><td align="center">42</td><td align="center">绿</td><td align="center">32</td><td align="center">绿</td></tr><tr><td align="center">43</td><td align="center">黄</td><td align="center">33</td><td align="center">黄</td></tr><tr><td align="center">44</td><td align="center">蓝</td><td align="center">34</td><td align="center">蓝</td></tr><tr><td align="center">45</td><td align="center">紫</td><td align="center">35</td><td align="center">紫</td></tr><tr><td align="center">46</td><td align="center">青</td><td align="center">36</td><td align="center">青</td></tr><tr><td align="center">47</td><td align="center">白</td><td align="center">37</td><td align="center">白</td></tr></tbody></table><p>小程序具体代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NONE <span class="meta-string">"\e[0m"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RED <span class="meta-string">"\e[0;31m"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CYAN <span class="meta-string">"\e[0;36m"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(RED <span class="string">"Hello "</span> CYAN <span class="string">"World!\n"</span> NONE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\e[0;31mHello \e[0;36mWorld!\n\e[0m"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里\e和\033是一个意思，e的八进制代码就是033，这两个print其实效果是一样的，前面那个printf中多个连续的“xxx”字符串会被自动整合为一个字符串，其实最终执行的就是第二个printf。</p><p>效果：</p><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429211041.jpg" alt="2020-04-29_210711"><h2 id="三、关于Linux中bash的变量、替换和元字符"><a href="#三、关于Linux中bash的变量、替换和元字符" class="headerlink" title="三、关于Linux中bash的变量、替换和元字符"></a>三、关于Linux中bash的变量、替换和元字符</h2><p>要求只列出所有bash进程的状态，使用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep bash</span><br></pre></td></tr></table></figure><p>但grep进程自身也被输出了：</p><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429211423.jpg" alt="2020-04-29_211412" style="zoom:80%"><p>使用以下的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep [b]ash</span><br><span class="line">ps -ef | grep \\bash</span><br><span class="line">ps -ef | grep b\\ash</span><br><span class="line">ps -ef | grep b\ash</span><br><span class="line">ps -ef | grep ba\\sh</span><br></pre></td></tr></table></figure><ol><li><p>可以</p><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429211802.jpg" alt="2020-04-29_211631" style="zoom:80%"><p>上面这5个命令的核心目的其实是改变grep在</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef</span><br></pre></td></tr></table></figure><p>命令中的显示形式，例如这一个，我们使用三通（tee）命令将在grep命令过滤之前的输出定向到一个文件中。</p><p>先将原命令试一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | tee 1.txt | grep bash</span><br><span class="line">cat 1.txt</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429214710.jpg" alt="2020-04-29_214703" style="zoom:80%"><p>与1这个命令进行一下对比：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | tee 1.txt | grep [b]ash</span><br><span class="line">cat 1.txt</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429212708.jpg" alt="2020-04-29_212451" style="zoom:80%"><p>我们可以很明显的看到，grep命令确实改变了，因为正则表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[b]ash</span><br></pre></td></tr></table></figure><p>是可以匹配bash的，但是却不能匹配[b]ash，因此第一行的-bash这一行被取了出来，而最后grep这一行，由于不匹配[b]ash，就取不出来了，刚好实现了我们只列出所有bash进程的状态的目的，下面的几个命令大同小异。</p></li><li><p>不可以</p><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429211917.jpg" alt="2020-04-29_211651" style="zoom:80%"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | tee 1.txt | grep \\bash</span><br><span class="line">cat 1.txt</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429213025.jpg" alt="2020-04-29_213015" style="zoom:80%"><p>首先，\是Shell的元字符，先被\转义为真正的单个字符\，因此传给grep的正则表达式其实是\bash，而在正则表达式中，\b有特殊含义，是单词边界，因此就连bash和\bash全部都没有匹配到。</p></li><li><p>可以</p><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429211852.jpg" alt="2020-04-29_211709" style="zoom:80%"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | tee 1.txt | grep b\\ash</span><br><span class="line">cat 1.txt</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429213823.jpg" alt="2020-04-29_213811" style="zoom:80%"><p>和2一样，传给grep的正则表达式为b\ash，在正则表达式中\a是没有意义的，因此\被丢弃，正则表达式其实就是bash，所以第一行的-bash这一行被取了出来，而最后grep这一行，由于不匹配b\ash，就取不出来了。</p></li><li><p>不可以</p><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429212003.jpg" alt="2020-04-29_211730" style="zoom:80%"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | tee 1.txt | grep b\ash</span><br><span class="line">cat 1.txt</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429214303.jpg" alt="2020-04-29_214256" style="zoom:80%"><p>首先，\a先经过Shell的替换，因\a是没有特殊含义的，因此\被直接丢掉，传给grep的正则表达式为bash，这就和使用这个命令是一样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep bash</span><br></pre></td></tr></table></figure><p>显然是不能实现目的。</p></li><li><p>不可以</p><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429212010.jpg" alt="2020-04-29_211747" style="zoom:80%"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | tee 1.txt | grep ba\\sh</span><br><span class="line">cat 1.txt</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429214922.jpg" alt="2020-04-29_214914" style="zoom:80%"><p>这个和2基本是一样的，和3唯一的区别就是，第3个中\a对正则表达式而言是没有特殊含义的，但是\s对正则表达式而言是有特殊含义的，\s代表空白字符（可能是空格、制表符、其他空白），也就是说，grep匹配到的应该是类似于：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ba h</span><br></pre></td></tr></table></figure><p>这种的字符串，显然-bash和ba\sh都不符合，因此就什么都没取到。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单的写了一些Linux的课外拓展学习的相关知识和问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://666wxy666.github.io/categories/Linux/"/>
    
      <category term="拓展学习" scheme="https://666wxy666.github.io/categories/Linux/%E6%8B%93%E5%B1%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Linux" scheme="https://666wxy666.github.io/tags/Linux/"/>
    
      <category term="拓展" scheme="https://666wxy666.github.io/tags/%E6%8B%93%E5%B1%95/"/>
    
      <category term="难点" scheme="https://666wxy666.github.io/tags/%E9%9A%BE%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Linux MOOC习题 5~9章</title>
    <link href="https://666wxy666.github.io/2020/04/29/Linux-MOOC%E4%B9%A0%E9%A2%98-5~9%E7%AB%A0/"/>
    <id>https://666wxy666.github.io/2020/04/29/Linux-MOOC%E4%B9%A0%E9%A2%98-5~9%E7%AB%A0/</id>
    <published>2020-04-29T01:54:47.814Z</published>
    <updated>2020-05-07T14:21:09.554Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>自己随便整理了一下在学习Linux网课时遇到的一些习题，易错点之类的，接上文<a href="https://666wxy666.github.io/2020/04/28/Linux-MOOC习题-1~4章/">Linux MOOC习题 1~4章</a>。</p><a id="more"></a><p><strong><em>PS：第七章是上机实验，第一次上机实验详见我的另一篇文章：<a href="https://666wxy666.github.io/2020/03/31/Linux-上机实战1-正则表达式/">Linux 上机实战1 正则表达式</a>，第二次的实验因为是提交阶段暂不公开，后面可能会发。</em></strong></p><h2 id="五、文件管理和目录管理"><a href="#五、文件管理和目录管理" class="headerlink" title="五、文件管理和目录管理"></a>五、文件管理和目录管理</h2><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429100515.jpg" alt="2020-04-28_212515" style="zoom:80%"> <img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429101043.jpg" alt="2020-04-28_212629" style="zoom:80%"><blockquote><p>在Linux中，Shell会自动帮你进项一些替换，实际运行的命令其实是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp src/x.c src/xx.c src/xxx.c src/x.h src/xx.h src/xxx.h……</span><br></pre></td></tr></table></figure><p>如果有好多.c和.h文件（超过两个），cp就会报错：</p><div class="note"><p>cp: target xxx is not a directory</p></div><p>但是如果只有两个.c或.h文件，那么就会产生非常严重的后果，实际运行了下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp src/x.c src/y.c</span><br></pre></td></tr></table></figure><p>这是非常危险的，这样y.c的内容会被x.c覆盖，这是我们不愿意看到的。</p><p>那么应该用什么命令来实现题目的要求呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp src/*.[ch] .</span><br></pre></td></tr></table></figure><p>我们显示地指定复制到.（当前目录），就不会出现问题了。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429102232.jpg" alt="2020-04-28_212656" style="zoom:80%"><blockquote><p>这也是在Linux中很怪的地方，明明你不能写这个文件，但是你却可以删除，如果不加-f，删除只读文件时会有提示，但是加了-f就没有任何提示了。还有一点需要注意的是，如第6题所说，加了-f也不能删除无权限删除的文件。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429102450.jpg" alt="2020-04-28_212714" style="zoom:80%"> <img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429102603.jpg" alt="2020-04-28_212737" style="zoom:80%"> <img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429102659.jpg" alt="2020-04-28_212800" style="zoom:80%"><blockquote><p>关于第10题，不像Windows，在Linux中这些后缀都是约定俗成的，只是为了做标记用，好区分而已，没有实际意义。</p></blockquote><h2 id="六、Linux命令风格和文件系统"><a href="#六、Linux命令风格和文件系统" class="headerlink" title="六、Linux命令风格和文件系统"></a>六、Linux命令风格和文件系统</h2><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429102845.jpg" alt="2020-04-28_213047" style="zoom:80%"><blockquote><p>这两个题都忽略了“符号链接”的作用。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429103011.jpg" alt="2020-04-28_213114" style="zoom:80%"> <img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429103030.jpg" alt="2020-04-28_213125" style="zoom:80%"><blockquote><p>这俩没啥好说的。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429103227.jpg" alt="2020-04-28_213133" style="zoom:80%"><blockquote><p>在Linux中，一般是-1代表失败，&gt;=0的值代表成功。</p></blockquote><h2 id="八、文件和目录的权限、Shell"><a href="#八、文件和目录的权限、Shell" class="headerlink" title="八、文件和目录的权限、Shell"></a>八、文件和目录的权限、Shell</h2><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429103454.jpg" alt="2020-04-28_213341" style="zoom:80%"><blockquote><p>目录有执行权限（即x权限）意味着分析路径名过程中可检索该目录。</p></blockquote><h2 id="九、替换、元字符和转义"><a href="#九、替换、元字符和转义" class="headerlink" title="九、替换、元字符和转义"></a>九、替换、元字符和转义</h2><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429103639.jpg" alt="2020-04-28_213427" style="zoom:80%"><blockquote><p>如果你是执行这个命令的操作员，估计你马上就心情不好了。由于拼错了单词，把DATABASE不小心写成了DATEBASE，灾难来了。未命名的变量被bash替换为空字符串，实际上你以root身份执行了最邪恶的一条命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /*</span><br></pre></td></tr></table></figure><p>永远不要盲目自信，谁也保证不了自己不会犯错误，怎么才能避免这样的悲剧发生？</p><ol><li><p>尽量不要以root身份登录。</p></li><li><p>bash有选项，引用未定义的变量会出错而不是替换为空字符串，可以打开这个选项。早期的编程语言把引用的未定义过的变量自动加上定义，这种做法实际上太糟糕，最早的FORTRAN语言就这种做法，据说曾因此导致一次太空任务失败。</p></li><li><p>在设计你自己的系统时，建库命令能够从目录名开始建库，就是说要求建库之前/opt/data下不需要存在目录puma，而不是要求建库之前/opt/data有个空目录puma，这样的话，即使你的命令变成了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf $DATEBASE</span><br></pre></td></tr></table></figure><p>因为你的失误，会导致rm命令抱怨缺少参数而什么都不做，这个结果是可以接受的。</p></li></ol></blockquote><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429103652.jpg" alt="2020-04-28_213530" style="zoom:80%"><blockquote><p>在Linux中，目前我已知的Shell的元字符有：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">空格 制表符 回车 &gt; &lt; | ; &amp; $ * [ ] ? \ ( ) '' " " 反撇号`</span><br></pre></td></tr></table></figure><p>第11题中，这三个命令都可以取消文件通配符*的特殊作用，让echo直接打印字符*，并且这个替换是Shell进行的，也就是说，echo拿到的命令都是一样的，他是分不清操作员输入的是哪个命令，这三个命令的参数：</p><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429105050.jpg" alt="2020-04-29_105040" style="zoom:80%"><p>而对于不转义的命令的参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo *</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429105236.jpg" alt="2020-04-29_105224" style="zoom:80%"><p>因此结果就很明显了：</p><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429104247.jpg" alt="2020-04-29_104233" style="zoom:80%"></blockquote><details><summary><p>未完待续……</p></summary><div class="content"><p>所有的习题：</p><p><a href="https://666wxy666.github.io/2020/04/28/Linux-MOOC习题-1~4章/">Linux MOOC习题 1~4章</a></p><p><a href="https://666wxy666.github.io/2020/04/29/Linux-MOOC习题-5~9章/">Linux MOOC习题 5~9章</a></p><p><a href="https://666wxy666.github.io/2020/05/07/Linux-MOOC习题-10~章/">Linux MOOC习题 10~章</a></p></div></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己随便整理了一下在学习Linux网课时遇到的一些习题，易错点之类的，接上文&lt;a href=&quot;https://666wxy666.github.io/2020/04/28/Linux-MOOC习题-1~4章/&quot;&gt;Linux MOOC习题 1~4章&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://666wxy666.github.io/categories/Linux/"/>
    
      <category term="习题" scheme="https://666wxy666.github.io/categories/Linux/%E4%B9%A0%E9%A2%98/"/>
    
    
      <category term="Linux" scheme="https://666wxy666.github.io/tags/Linux/"/>
    
      <category term="习题" scheme="https://666wxy666.github.io/tags/%E4%B9%A0%E9%A2%98/"/>
    
      <category term="易错点" scheme="https://666wxy666.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"/>
    
      <category term="网课" scheme="https://666wxy666.github.io/tags/%E7%BD%91%E8%AF%BE/"/>
    
      <category term="MOOC" scheme="https://666wxy666.github.io/tags/MOOC/"/>
    
  </entry>
  
  <entry>
    <title>Linux MOOC习题 1~4章</title>
    <link href="https://666wxy666.github.io/2020/04/28/Linux-MOOC%E4%B9%A0%E9%A2%98-1~4%E7%AB%A0/"/>
    <id>https://666wxy666.github.io/2020/04/28/Linux-MOOC%E4%B9%A0%E9%A2%98-1~4%E7%AB%A0/</id>
    <published>2020-04-28T13:08:08.946Z</published>
    <updated>2020-05-07T14:21:02.708Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>自己随便整理了一下在学习Linux网课时遇到的一些习题，易错点之类的。</p><a id="more"></a><p>废话不多说，直接开始：</p><p><strong><em>PS：第一章是课程介绍。</em></strong></p><h2 id="二、开始使用Linux和文本文件的处理"><a href="#二、开始使用Linux和文本文件的处理" class="headerlink" title="二、开始使用Linux和文本文件的处理"></a>二、开始使用Linux和文本文件的处理</h2><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200428215021.jpg" alt="2020-04-28_211643" style="zoom:80%"><blockquote><p>第1题其实是很基础的问题，早期的终端一般由键盘、显示器和RS232串行通信接口构成，没有磁盘存储器，其实可以想象成和打字机差不多的东西，他就是直接在显示器上显示了，不需要磁盘存储器。</p><p>第2题也比较基础：</p><ul><li><p>行律的作用是：</p><ul><li><p>一行内字符的缓冲、回显和编辑，直到按下回车键；</p></li><li><p>数据的加工，类似第二题中的将“\n”替换为“\r\n”；</p></li><li><p>将CTRL-C字符转换为终止进程的信号；</p></li></ul></li><li><p>驱动程序其实是串口与行律的接口，负责上行和下行字符流。</p></li></ul></blockquote><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200428215752.jpg" alt="2020-04-28_211738" style="zoom:80%"><blockquote><p>这俩题没啥好说的，基础知识。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200428215946.jpg" alt="2020-04-28_211810" style="zoom:80%"><blockquote><p>并不是这样的，CTRL-C确实传送了字符<strong><em>（Ctrl+字母组合键可以产生ASCII码为1-26的控制字符，字母序号是几，ASCII码就是几，Ctrl+C的ASCII码应为3）</em></strong>，其实还是行律的作用，他将CTRL-C字符转换为终止进程的信号，从而通知Linux主机，进程终止。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200428220440.jpg" alt="2020-04-28_211920" style="zoom:80%"> <img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200428220658.jpg" alt="2020-04-28_211921" style="zoom:80%"><blockquote><p>这俩题都是关于uniq命令的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uniq -u</span><br><span class="line">uniq -d</span><br><span class="line">uniq</span><br></pre></td></tr></table></figure><p>第一个命令，-u代表unique，只打印没有重复的行；</p><p>第二个命令，-d代表duplicated，只打印重复的行，注意重复的行只打印一次；</p><p>第三个命令，啥也不加就是都打印，但是也是复的行只打印一次；</p><p>还有就是关于重复的行，意思其实是连续的紧邻的两行内容相同才被叫做重复的行，因此第10题是错的。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200428221248.jpg" alt="2020-04-28_211949" style="zoom:80%"><blockquote><p>这个题不难，写出来的目的是只要记得</p><div class="note"><p>Less is more</p></div><p>就很好想了，less是more的升级版。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200428221932.jpg" alt="2020-04-28_212008" style="zoom:80%"> <img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200428221942.jpg" alt="2020-04-28_212044" style="zoom:80%"><blockquote><p>这俩题也不多解释了，od不可打印字符也可以显示，tr是用于翻译，把string1出现的字符替换为string2中对应的字符，ASCII字符0也可以翻译。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tr string1 string2</span><br></pre></td></tr></table></figure></blockquote><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429095034.jpg" alt="2020-04-28_212253" style="zoom:80%"><blockquote><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429095238.png" alt="7992DB2C9EF7FC68967A6E866A101062" style="zoom:50%"></blockquote><h2 id="三、正则表达式"><a href="#三、正则表达式" class="headerlink" title="三、正则表达式"></a>三、正则表达式</h2><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200428222324.jpg" alt="2020-04-28_212126" style="zoom:80%"><blockquote><p>先说一下正则表达式的<strong><em>元字符</em></strong>，有6个，分别是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. * [ \ ^ $</span><br></pre></td></tr></table></figure><p>关于他们各自的含义不多说，自行百度，一定要注意的是]不是元字符，很容易搞错。</p><p>而关于单字符正则表达式，显而易见，就是匹配一个字符呗，不过有特殊的:</p><ul><li><p>\加一个字符构成的转义字符，看做单字符正则表达式；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\. \* \[ \\ \^ \$</span><br></pre></td></tr></table></figure></li><li><p>[]定义的集合也被看做单字符正则表达式;</p></li></ul><p>因为.本来的含义是匹配任意字符，转义后就是单字符.，因此都是单字符正则表达式，而$在尾部时和^在首部时有特殊含义，因此转义之前不是，转义后就是单字符​了。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429091111.jpg" alt="2020-04-28_212154" style="zoom:80%"><blockquote><p>这个题就比较有意思了，先看一下sed命令的基本用法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed 's/正则表达式/字符串/g' 文件名列表</span><br></pre></td></tr></table></figure><p>s选项的意思是替换，将文件中匹配第一个//中的正则表达式的内容替换为第二个//中的字符串。</p><p>然后我们在看上题‘’中的正则表达式（也就是第一个//中的内容）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\[[^][]*]</span><br></pre></td></tr></table></figure><p>可以分为三部分：</p><ol><li><p>因为[是元字符，加\转义后就变成了真正的[。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\[</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>中间这一部分是一个集合[]，重复一次或多次[]*，集合里面的^代表排除，排除了]和[，意思就是说除]和[外的字符重复一次或多次。那么这就有一个问题，第一个[为什么不与第一个]匹配，反而去和最后一个]匹配呢？个人觉得，因为如果与第一个]匹配，就有了[^]，这显然是错误的正则表达式，那么就继续向后匹配，因此就匹配到了最后面的]。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[^][]*</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>因为]不是元字符，也没有[与它匹配，它就是单纯的一个字符]。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">]</span><br></pre></td></tr></table></figure></li></ol><p>综上所述，这个正则表达式可以匹配“[非]和[的字符任意多个]”，类似[参考文献23]这样的，但是如果[]里面还有]和[，就匹配不到了。再看上面的题，第二个//里面是空的，那么就是把匹配到的内容删除，很好理解。</p></blockquote><h2 id="四、文件比较，文件通配符"><a href="#四、文件比较，文件通配符" class="headerlink" title="四、文件比较，文件通配符"></a>四、文件比较，文件通配符</h2><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429093945.jpg" alt="2020-04-28_212239" style="zoom:80%"><blockquote><p>vi的基本用法，在命令状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">:q      退出（:quit的缩写）</span><br><span class="line">:q!     退出且不保存（:quit!的缩写）</span><br><span class="line">:wq     保存并退出</span><br><span class="line">:wq!    保存并退出即使文件没有写入权限（强制保存退出）</span><br><span class="line">:x      保存并退出（类似:wq，但是只有在有更改的情况下才保存）</span><br><span class="line">:exit   保存并退出（和:x相同）</span><br><span class="line">:qa     退出所有(:quitall的缩写)</span><br><span class="line">:cq     退出且不保存（即便有错误）</span><br></pre></td></tr></table></figure><p>另外在“正常模式”下输入“ZZ”来保存并退出Vim（和:x相同），或者“ZQ”不保存并退出（和:q!相同）注意此处ZZ大写和小写是完全不同的。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200429095046.jpg" alt="2020-04-28_212356" style="zoom:80%"><blockquote><p>diff一般用于比较文本文件。</p></blockquote><details><summary><p>未完待续……</p></summary><div class="content"><p>所有的习题：</p><p><a href="https://666wxy666.github.io/2020/04/28/Linux-MOOC习题-1~4章/">Linux MOOC习题 1~4章</a></p><p><a href="https://666wxy666.github.io/2020/04/29/Linux-MOOC习题-5~9章/">Linux MOOC习题 5~9章</a></p><p><a href="https://666wxy666.github.io/2020/05/07/Linux-MOOC习题-10~章/">Linux MOOC习题 10~章</a></p></div></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己随便整理了一下在学习Linux网课时遇到的一些习题，易错点之类的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://666wxy666.github.io/categories/Linux/"/>
    
      <category term="习题" scheme="https://666wxy666.github.io/categories/Linux/%E4%B9%A0%E9%A2%98/"/>
    
    
      <category term="Linux" scheme="https://666wxy666.github.io/tags/Linux/"/>
    
      <category term="习题" scheme="https://666wxy666.github.io/tags/%E4%B9%A0%E9%A2%98/"/>
    
      <category term="易错点" scheme="https://666wxy666.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"/>
    
      <category term="网课" scheme="https://666wxy666.github.io/tags/%E7%BD%91%E8%AF%BE/"/>
    
      <category term="MOOC" scheme="https://666wxy666.github.io/tags/MOOC/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫小Demo：学堂在线课程</title>
    <link href="https://666wxy666.github.io/2020/04/07/Python%E7%88%AC%E8%99%AB%E5%B0%8FDemo/"/>
    <id>https://666wxy666.github.io/2020/04/07/Python%E7%88%AC%E8%99%AB%E5%B0%8FDemo/</id>
    <published>2020-04-07T11:43:33.300Z</published>
    <updated>2020-04-08T14:42:43.756Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>本文是关于Python中的Spider的小Demo，通过Python的scrapy爬取京学堂在线课程的相关数据。</strong></p><a id="more"></a><h2 id="一、编译环境："><a href="#一、编译环境：" class="headerlink" title="一、编译环境："></a>一、编译环境：</h2><p>PyCharm 2019.3.4 (Professional Edition)</p><p>Build #PY-193.6911.25, built on March 18, 2020</p><p>Runtime version: 11.0.6+8-b520.43 amd64</p><p>VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o</p><p>Windows 10 10.0</p><p>GC: ParNew, ConcurrentMarkSweep</p><p>Memory: 725M</p><p>Cores: 8</p><p>Registry: ide.balloon.shadow.size=0</p><p>Non-Bundled Plugins:</p><p>GrepConsole,Statistic,cn.yiiguxing.plugin.translate,com.chrisrm.idea.MaterialThemeUI,com.notime.intellijPlugin.backgroundImagePlus,com.wakatime.intellij.plugin,izhangzhihao.rainbow.brackets,mobi.hsz.idea.gitignore, net.vektah.codeglance, org.intellij.gitee</p><p>Python Version：3.7（Anaconda3）</p><p>Package：</p><p>scrapy==2.0.1</p><h2 id="二、详细步骤"><a href="#二、详细步骤" class="headerlink" title="二、详细步骤"></a>二、详细步骤</h2><h3 id="①准备工作"><a href="#①准备工作" class="headerlink" title="①准备工作"></a>①准备工作</h3><ol><li>在Pycharm中新建一个Pure Python项目（记得要按照一中的要求配好Python环境）。</li></ol><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200407214757.jpg" alt="2020-04-07_214715" style="zoom:67%"><ol start="2"><li>打开Pycharm的下方的终端（Terminal），当然这些也可以在系统终端里操作，不过可能需要的步骤多一些，还是直接在Pycharm里方便一些。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200408164806.png" alt="2020-04-08_164744"></p><ol start="3"><li><p>在终端里输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy startproject myScrapy</span><br></pre></td></tr></table></figure><p>本来是可以在我们刚刚创建的项目里新建一个名为“myScrapy”的scrapy项目的，但是不知道为什么竟然报错了：</p><p><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200408190345.png" alt="2020-04-08_190330"></p><p>这是什么奇奇怪怪的错误，我都没有“d:\bld\scrapy_1584555997548_h_env\python.exe”这个目录，经过查找相关问题的资料，问题可能是出在Python环境上，因为我上一次新建项目时并没有报错，这一次我直接用的上一个项目的环境，网上还有一种说法是Scrapy的bug，详见</p><p><a href="https://github.com/scrapy/scrapy/issues/4289" target="_blank" rel="external nofollow noopener noreferrer">Fatal error launching scrapy&gt;1.6.0 from Anaconda Prompt</a></p><p><a href="https://github.com/conda-forge/scrapy-feedstock/issues/37" target="_blank" rel="external nofollow noopener noreferrer">Issue with conda-forge scrapy&gt;1.6.0 on Windows</a></p><p>目前找到了两种解决方案：</p><ol><li><p>把python环境复制到报错的那个目录（d:\bld\scrapy_1584555997548_h_env\python.exe），然后在创建scrapy项目，但这个解决方法有点愚蠢，就没有采用。</p></li><li><p>在scrapy命令前面添加“python -m”选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m scrapy startproject myScrapy</span><br></pre></td></tr></table></figure><p>就可以正常创建了。</p><p>关于Python的-m选项，官方给出的解释是“run library module as a script”，简单来说就是将库中的Python模块当作脚本去运行。</p><p>特别感谢简书的大佬<a href="https://www.jianshu.com/p/323fc9a1d7d2" target="_blank" rel="external nofollow noopener noreferrer">ccw1078</a>提供的解释，很清晰明了，有兴趣的可以去瞅一下，因为和本文的主题爬虫没啥关系，在这里就不赘述了。</p></li></ol></li></ol><ol start="4"><li><p>出现这些提示就代表创建成功了。</p><p><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200408192211.jpg" alt="2020-04-08_192151"></p><p>然后在spiders文件里新建一个spider.py文件，用于写爬虫。</p></li><li><p>我们来看一下目前scrapy项目的目录结构。</p><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200408203358.jpg" alt="2020-04-08_203310" style="zoom:67%"><p>__init__.py：pycharm生成的文件，简化导入语句用的，可以忽略，没啥用，建议删了，留着可能会出问题。</p><p>spiders：存放你Spider爬虫源文件</p><p>​ spider.py：代码主要在这里写。</p><p>items.py：数据容器。</p><p>middlewares.py：Downloader Middlewares(下载器中间件)和Spider Middlewares(蜘蛛中间件)实现的地方。</p><p>pipelines.py：项目管道文件，相当于数据中转站。实现数据的清洗，储存，验证。</p><p>settings.py：scrapy的全局配置。</p><p>scrapy.cfg：配置文件。</p><p>scrapy已经帮我们把大体框架写好了，我们主要要修改的文件是spider.py，items.py，pipelines.py，settings.py。</p></li><li><p>这是爬虫spider的基本工作方式，想要深入了解的可以去网上查找资料。</p></li></ol><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200408201638.png" alt="scrapy" style="zoom:33%"><h3 id="②开始写代码"><a href="#②开始写代码" class="headerlink" title="②开始写代码"></a>②开始写代码</h3><ol><li><p>先来写items.py。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyscrapyItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    <span class="comment"># define the fields for your item here like:</span></span><br><span class="line">    <span class="comment"># name = scrapy.Field()</span></span><br><span class="line">    school = scrapy.Field()</span><br><span class="line">    num = scrapy.Field()</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li><li><p>再来搞settings.py，这个只需要找到这个注释掉的语句，把#去掉就OK了，就像这样：</p><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200408210722.jpg" alt="2020-04-08_210710" style="zoom:67%"></li><li><p>pipelines.py就很好写了，基本可以当模板来用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyscrapyPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 这个就是爬虫生成的文件，可以支持好多种格式，这里使用的是json文件</span></span><br><span class="line">            self.file = open(<span class="string">'MyData.json'</span>, <span class="string">'w'</span>, encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">            print(err)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        dict_item = dict(item)</span><br><span class="line">        json_str = json.dumps(dict_item, ensure_ascii=<span class="literal">False</span>) + <span class="string">"\n"</span></span><br><span class="line">        self.file.write(json_str)</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        self.file.close()</span><br></pre></td></tr></table></figure></li><li><p>spider.py是我们主要写的核心部分。这里需要一些html的xpath相关知识来对项进行定位，可以自行查找相关资料。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved.</span></span><br><span class="line"><span class="string">@Project: xuetangzaixian</span></span><br><span class="line"><span class="string">@Description: </span></span><br><span class="line"><span class="string">@Version: </span></span><br><span class="line"><span class="string">@Author: 苇名一心</span></span><br><span class="line"><span class="string">@Date: 2020-04-08 20:31</span></span><br><span class="line"><span class="string">@LastEditors: 苇名一心</span></span><br><span class="line"><span class="string">@LastEditTime: 2020-04-08 20:31</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> myScrapy.myScrapy.items <span class="keyword">import</span> MyscrapyItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mySpider</span><span class="params">(scrapy.spiders.Spider)</span>:</span></span><br><span class="line">    <span class="comment"># spider的名字</span></span><br><span class="line">    name = <span class="string">"xuetang"</span></span><br><span class="line">    <span class="comment"># 限制spider爬取的域名</span></span><br><span class="line">    allowed_domains = [<span class="string">"www.xuetangx.com/"</span>]</span><br><span class="line"><span class="comment"># 爬虫要爬取的网页，是一个列表，按顺序爬取</span></span><br><span class="line">    start_urls = [<span class="string">"http://www.xuetangx.com/partners"</span>]</span><br><span class="line"><span class="comment"># 这是一种方式，可以爬取网页中所有的项</span></span><br><span class="line">    <span class="comment"># def parse(self, response):</span></span><br><span class="line">    <span class="comment">#     item = MyscrapyItem()</span></span><br><span class="line">    <span class="comment">#     for each in response.xpath("/html/body/article[1]/section/ul/*"):</span></span><br><span class="line">    <span class="comment">#         item['school'] = each.xpath("a/div[2]/h3/text()").extract()</span></span><br><span class="line">    <span class="comment">#         item['num'] = each.xpath("a/div[2]/p[1]/text()").extract()</span></span><br><span class="line">    <span class="comment">#         if item['num']:</span></span><br><span class="line">    <span class="comment">#             item['num'] = re.findall(r'\d+', item['num'][0])</span></span><br><span class="line">    <span class="comment">#         if item['school'] and item['num']:</span></span><br><span class="line">    <span class="comment">#             yield (item)</span></span><br><span class="line">    <span class="comment"># 这是第二种方式，使用for循环，制定爬取项的数目</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        item = MyscrapyItem()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">144</span>):</span><br><span class="line">            item[<span class="string">'school'</span>] = response.xpath \</span><br><span class="line">                (<span class="string">"/html/body/article[1]/section/ul/li[&#123;&#125;]/a/div[2]/h3/text()"</span>.format(i)).extract()</span><br><span class="line">            item[<span class="string">'num'</span>] = response.xpath \</span><br><span class="line">                (<span class="string">"/html/body/article[1]/section/ul/li[&#123;&#125;]/a/div[2]/p[1]/text()"</span>.format(i)).extract()</span><br><span class="line">            <span class="comment"># 判断爬取的项目是否为空，把非空的项目提交</span></span><br><span class="line">            <span class="keyword">if</span> item[<span class="string">'school'</span>] <span class="keyword">and</span> item[<span class="string">'num'</span>]:</span><br><span class="line">                <span class="keyword">yield</span> (item)</span><br></pre></td></tr></table></figure></li></ol><h3 id="③可以开始运行啦"><a href="#③可以开始运行啦" class="headerlink" title="③可以开始运行啦"></a>③可以开始运行啦</h3><ol><li><p>在运行前要先在项目根目录下建立一个begin.py文件来控制scrapy爬虫的运行。</p><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200408212615.jpg" alt="2020-04-08_212604" style="zoom:80%"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> cmdline</span><br><span class="line"><span class="comment"># "xuetang"是我们上面spider.py中定义的爬虫名</span></span><br><span class="line">cmdline.execute(<span class="string">"scrapy crawl xuetang"</span>.split())</span><br></pre></td></tr></table></figure></li><li><p>最终的项目结构（__init__.py没啥用，删了）：</p><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200408212844.jpg" alt="2020-04-08_212834" style="zoom:67%"></li><li><p>运行begin.py就可以开始爬虫了。</p><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200408212955.jpg" alt="2020-04-08_212946" style="zoom:67%"><p>出现这些提示就表示成功了，运行完毕后会发现项目根目录出现了我们在pipelines.py中设置好的MyData.json。</p><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200408222346.jpg" alt="2020-04-08_222333" style="zoom:67%"></li><li><p>打开MyData.json看一下，Perfect！</p><img src="https://cdn.jsdelivr.net/gh/666WXY666/cdn/img/placeholder/large.svg" data-original="https://gitee.com/wxy_666/images/raw/master/20200408222427.jpg" alt="2020-04-08_222417" style="zoom:67%"><p>有了这个json文件，我们就可以利用Python的pandas、numpy等工具进行各种处理，然后用matplotlib等模块进行画图了。</p></li></ol><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本文只是对Python的scrapy爬虫进行了简单的介绍和用一个小Demo讲述了如何使用scrapy爬取网页数据，希望对你有所帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文是关于Python中的Spider的小Demo，通过Python的scrapy爬取京学堂在线课程的相关数据。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://666wxy666.github.io/categories/Python/"/>
    
      <category term="爬虫" scheme="https://666wxy666.github.io/categories/Python/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Python" scheme="https://666wxy666.github.io/tags/Python/"/>
    
      <category term="爬虫" scheme="https://666wxy666.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="数据处理" scheme="https://666wxy666.github.io/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
      <category term="学堂在线" scheme="https://666wxy666.github.io/tags/%E5%AD%A6%E5%A0%82%E5%9C%A8%E7%BA%BF/"/>
    
      <category term="课程" scheme="https://666wxy666.github.io/tags/%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hello Blog</title>
    <link href="https://666wxy666.github.io/2020/03/19/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>https://666wxy666.github.io/2020/03/19/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-03-19T03:08:51.637Z</published>
    <updated>2020-03-31T12:21:28.836Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p class="p center large">HELLO BLOG</p><p>欢迎来到我的博客，这是我的第一篇博客测试文章。</p><a id="more"></a><p>如果有什么问题，欢迎到我的Github提问我。</p>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;p center large&quot;&gt;HELLO BLOG&lt;/p&gt;&lt;p&gt;欢迎来到我的博客，这是我的第一篇博客测试文章。&lt;/p&gt;
    
    </summary>
    
    
      <category term="其他" scheme="https://666wxy666.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="first" scheme="https://666wxy666.github.io/tags/first/"/>
    
  </entry>
  
</feed>
