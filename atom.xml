<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>苇名一心的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://666wxy666.github.io/"/>
  <updated>2020-10-09T08:05:07.116Z</updated>
  <id>https://666wxy666.github.io/</id>
  
  <author>
    <name>苇名一心</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>交换原理 实验2 摘挂机检测实验</title>
    <link href="https://666wxy666.github.io/2020/10/09/%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86-%E5%AE%9E%E9%AA%8C2-%E6%91%98%E6%8C%82%E6%9C%BA%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/"/>
    <id>https://666wxy666.github.io/2020/10/09/%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86-%E5%AE%9E%E9%AA%8C2-%E6%91%98%E6%8C%82%E6%9C%BA%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/</id>
    <published>2020-10-08T16:00:00.000Z</published>
    <updated>2020-10-09T08:05:07.116Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文是关于交换原理实验二——摘挂机检测实验报告记录。</p><a id="more"></a><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><p>摘挂机检测实验用来考查学生对摘挂机检测原理的掌握情况。</p><h2 id="二、实验内容和实验步骤"><a href="#二、实验内容和实验步骤" class="headerlink" title="二、实验内容和实验步骤"></a>二、实验内容和实验步骤</h2><h3 id="1、实验原理及设计"><a href="#1、实验原理及设计" class="headerlink" title="1、实验原理及设计"></a>1、实验原理及设计</h3><p>设用户在挂机状态时扫描输出为“0”，用户在摘机状态时扫描输出为“1”，摘挂机扫描程序的执行周期为200ms，那么摘机识别，就是在200ms的周期性扫描中找到从“0”到“1”的变化点，挂机识别就是在200ms的周期性扫描中找到从“1”到“0”的变化点。</p><p>在我们的实验中，我们把前200ms的线路状态保存以备这次可以读取，同时读出这次的线路状态，把前200ms的线路状态取反与这次的线路状态相与，如果为1，就说明检测到摘机消息了。同理，我们把这次的线路状态取反再与前200ms的线路状态相与，如果为1就说明检测到挂机消息了，然后把摘挂机信号作为事件放入摘挂机队列中。</p><h3 id="2、实验主要数据结构"><a href="#2、实验主要数据结构" class="headerlink" title="2、实验主要数据结构"></a>2、实验主要数据结构</h3><p>函数功能为：检测到摘、挂机事件，并把该事件放入到摘挂机事件队列中。</p><p>函数原型：</p><pre><code class="c">void scanfor200(int linestate200[LINEMAX],int  linestate[LINEMAX],UpOnnode * head1, UpOnnode*  end1);</code></pre><p>其中LINEMAX为线路总数，是定义在”bconstant.h”中的一个宏,linestate200[LINEMAX]为已保存的200ms前线路状态，linestate[LINEMAX]为当前的线路状态，head1,end1为摘挂机队列的首尾指针，该队列已经在主程序中进行了初始化。我们所要做的就是把检测到的摘挂机事件以摘挂机队列节点的形式插入到摘挂机事件队列中。</p><p>数据结构说明： </p><pre><code class="c">&quot;bconstant.h&quot;    //以下的数据结构都已在该文件中定义 LINEMAX    //最大线路数； int  linestate200[LINEMAX],linestate[LINEMAX]    //线路从0开始编号；状态：1：有电流，0无电流； enum UporOn {ehandup,ehandon}    //为摘挂机区别符：ehandup表示摘机，ehandon表示挂机； struct  UpOnnode      //摘挂机队列节点结构 {    UporOn  phonestate;        //摘挂机区别符；    int  linenum;               //线路号（从0开始）；    struct UpOnnode* next;      //指向下一节点的指针；};</code></pre><p>注意事项：</p><ol><li><p>我们编写的模块是基础实验部分预加载的本局交换系统的一个模块而已，在系统中head1头指针和end1尾指针已经完成初始化。为方便起见，我们的摘挂机事件队列是一个包含头节点的单向链表，并且头指针指向该头节点，尾指针在初始化时也指向了该节点。所以在我们的函数编写中应保证头指针始终指向该头节点上、尾指针指向摘挂机事件队列的最末一个节点。</p></li><li><p>注意把这次扫描的线路状态值保存在前200ms扫描线路状态数组中,以便主程周期调用。</p></li></ol><h3 id="3、实验效果检验"><a href="#3、实验效果检验" class="headerlink" title="3、实验效果检验"></a>3、实验效果检验</h3><p>当调度表初始化正确时，能够进行正常的通话；如果初始化不正确，可能会造成周期性程序的不正常调用，例如位间隔调度的延迟会造成识别位间隔的延误甚至丢失。</p><h3 id="4、实验步骤"><a href="#4、实验步骤" class="headerlink" title="4、实验步骤"></a>4、实验步骤</h3><ol><li>熟悉实验平台和测试环境；</li><li>编写C程序实现所要求的功能；</li><li>运行测试程序；</li><li>完成实验报告。</li></ol><h2 id="三、源代码"><a href="#三、源代码" class="headerlink" title="三、源代码"></a>三、源代码</h2><pre><code class="c">#include &quot;bconstant.h&quot;extern &quot;C&quot; _declspec(dllexport) void scanfor200(int linestate200[LINEMAX], int linestate[LINEMAX], UpOnnode *head1, UpOnnode *end1){    int i;    for (i = 0; i &lt;= LINEMAX; i++)    {        struct UpOnnode *newNode = new struct UpOnnode;        if (!linestate200[i] &amp;&amp; linestate[i])        {            newNode-&gt;phonestate = ehandup;        }        if (!linestate[i] &amp;&amp; linestate200[i])        {            newNode-&gt;phonestate = ehandon;        }        newNode-&gt;linenum = i;        newNode-&gt;next = 0;        end1-&gt;next = newNode;        end1 = newNode;        linestate200[i] = linestate[i];    }    return;}// 此函数不需修改extern &quot;C&quot; _declspec(dllexport) void freenode(UpOnnode *node){    delete node;}</code></pre><h2 id="四、实验结果"><a href="#四、实验结果" class="headerlink" title="四、实验结果"></a>四、实验结果</h2><p>运行程序后，能正确检测摘挂机动作并且能进行通话，与预期结果相符，成功。</p><h2 id="五、实验心得"><a href="#五、实验心得" class="headerlink" title="五、实验心得"></a>五、实验心得</h2><p>这次实验也比较简单，主要用来考察对摘挂机检测的原理的掌握情况。在实验中遇到的比较困难的就是新节点添加到链表中指针如何分配，因为大一学过的知识时间比较久了，记得不是很清晰，于是就先复习了链表相关的知识，最终也成功实现了要求的功能。通过这次实验， 我加深了对摘挂机检测原理的掌握（检测到摘挂机事件，都将该事件添加到队列中），深入了解了摘挂机的详细过程，增强了对实验平台的熟悉和对软件的了解，收获很大。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是关于交换原理实验二——摘挂机检测实验报告记录。&lt;/p&gt;
    
    </summary>
    
    
      <category term="交换原理" scheme="https://666wxy666.github.io/categories/%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"/>
    
      <category term="实验" scheme="https://666wxy666.github.io/categories/%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="实验" scheme="https://666wxy666.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
      <category term="交换原理" scheme="https://666wxy666.github.io/tags/%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>交换原理 实验1 时间表调度实验</title>
    <link href="https://666wxy666.github.io/2020/10/09/%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86-%E5%AE%9E%E9%AA%8C1-%E6%97%B6%E9%97%B4%E8%A1%A8%E8%B0%83%E5%BA%A6%E5%AE%9E%E9%AA%8C/"/>
    <id>https://666wxy666.github.io/2020/10/09/%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86-%E5%AE%9E%E9%AA%8C1-%E6%97%B6%E9%97%B4%E8%A1%A8%E8%B0%83%E5%BA%A6%E5%AE%9E%E9%AA%8C/</id>
    <published>2020-10-08T16:00:00.000Z</published>
    <updated>2020-10-09T08:04:57.622Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文是关于交换原理实验一——时间表调度实验报告记录。</p><a id="more"></a><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><p>驱动交换网络实验用来考查学生对时间表调度原理的掌握情况。</p><h2 id="二、实验内容和实验步骤"><a href="#二、实验内容和实验步骤" class="headerlink" title="二、实验内容和实验步骤"></a>二、实验内容和实验步骤</h2><h3 id="1、实验原理及设计"><a href="#1、实验原理及设计" class="headerlink" title="1、实验原理及设计"></a>1、实验原理及设计</h3><p>在程控数字交换的体系结构中，周期级程序（例如摘挂机检测程序、脉冲识别程序、位间隔识别程序）是由时间表调度实现的。所谓时间表调度，是指每经过交换系统的最短有效时间（这通常是指各周期性程序周期的最大公约数），都会检查调度表的调度要求，如果某个程序在这时需要执行，则调度程序开始执行它。</p><p>在我们设计的时间表调度实验中，这个调度表的调度是静态的。所谓静态，是指我们的调度表是在系统初始化的时候就建立起来的，在系统运行的情况下不再改动。</p><p>实验要求的就是这个调度表的初始化。这个调度表如下：</p><table><thead><tr><th align="center">时间（10ms) \任务</th><th align="center">0：摘挂机检测任务</th><th align="center">1：脉冲检测任务</th><th align="center">2：位间隔检测任务</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0/1</td><td align="center">0/1</td><td align="center">0/1</td></tr><tr><td align="center">1</td><td align="center">0/1</td><td align="center">0/1</td><td align="center">0/1</td></tr><tr><td align="center">……</td><td align="center">……</td><td align="center">……</td><td align="center">……</td></tr><tr><td align="center">……</td><td align="center">……</td><td align="center">……</td><td align="center">……</td></tr><tr><td align="center">……</td><td align="center">……</td><td align="center">……</td><td align="center">……</td></tr><tr><td align="center">18</td><td align="center">0/1</td><td align="center">0/1</td><td align="center">0/1</td></tr><tr><td align="center">19</td><td align="center">0/1</td><td align="center">0/1</td><td align="center">0/1</td></tr></tbody></table><p>我们这个交换系统提供了三个周期性调度程度（摘挂机检测程序、脉冲识别程序和位间隔识别程序），它们的调用周期分别为 200ms、10ms 和 100ms，所以我们系统的最小调度时间为 10ms。如图所示，每隔 10ms,我们就会检查这个表的一行，如果该行上某一列为 1，我们就执列所对应的任务，如果为 0，就什么都不做。每当执行到这个表的最后一行，调度任务会返回第一行循环执行。而你所要做的就是按照你的理解来填写这个调度表。</p><h3 id="2、实验主要数据结构"><a href="#2、实验主要数据结构" class="headerlink" title="2、实验主要数据结构"></a>2、实验主要数据结构</h3><p>函数功能：完成调度表的初始化；</p><p>函数原型：</p><pre><code class="c">initSchTable(int ScheduleTable[SchTabLen][SchTabWdh])；</code></pre><p>其中 SchTalLen 和 SchTabWdh 为在 bconstant.h 中的宏定义：</p><pre><code class="c">#define SchTabLen 20 //代表这个调度表为 20 行（相邻行之间的时间间隔为 10ms); #define SchTabWdh 3 //代表三个周期性调度任务——0：摘挂机检测任务；1：脉冲检测任务；2：位间隔检测任务；</code></pre><h3 id="3、实验效果检验"><a href="#3、实验效果检验" class="headerlink" title="3、实验效果检验"></a>3、实验效果检验</h3><p>当调度表初始化正确时，能够进行正常的通话；如果初始化不正确，可能会造成周期性程序的不正常调用，例如位间隔调度的延迟会造成识别位间隔的延误甚至丢失。</p><h3 id="4、实验步骤"><a href="#4、实验步骤" class="headerlink" title="4、实验步骤"></a>4、实验步骤</h3><ol><li>熟悉实验平台和测试环境；</li><li>编写C程序实现所要求的功能；</li><li>运行测试程序；</li><li>完成实验报告。</li></ol><h2 id="三、源代码"><a href="#三、源代码" class="headerlink" title="三、源代码"></a>三、源代码</h2><pre><code class="c">#include &quot;bconstant.h&quot;extern &quot;C&quot; _declspec(dllexport) void initSchTable(intScheduleTable[SchTabLen][SchTabWdh]){    int i;    for (i = 0; i != SchTabLen; i++)    {        //最小时间间隔为10ms        //对摘挂机状态进行初始化        if (i % 20 == 0) //因为调度周期为200ms，也就是每隔20个最小间隔执行一次        {            ScheduleTable[i][0] = 1;        }        else        {            ScheduleTable[i][0] = 0;        }        //对脉冲识别进行初始化        ScheduleTable[i][1] = 1; //因为调度周期为10ms，也就是每个最小间隔都执行一次        //对为间隔识别进行初始化        if (i % 10 == 0) //因为调度周期为100ms，也就是每隔10个最小间隔执行一次        {            ScheduleTable[i][2] = 1;        }        else        {            ScheduleTable[i][2] = 0;        }    }    return;}</code></pre><h2 id="四、实验结果"><a href="#四、实验结果" class="headerlink" title="四、实验结果"></a>四、实验结果</h2><p>运行程序后，调度表初始化正确，周期性程序正常调用，能够进行正常的通话。</p><h2 id="五、实验心得"><a href="#五、实验心得" class="headerlink" title="五、实验心得"></a>五、实验心得</h2><p>这是第一个交换原理的实验，是较为基础的实验，只是对数组的静态初始化，为以后的实验打下基础。我观察了模拟环境下的电路接通情形，让我对时间调度有了一个形象生动的认识，加深了这部分知识记忆和理解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是关于交换原理实验一——时间表调度实验报告记录。&lt;/p&gt;
    
    </summary>
    
    
      <category term="交换原理" scheme="https://666wxy666.github.io/categories/%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"/>
    
      <category term="实验" scheme="https://666wxy666.github.io/categories/%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="实验" scheme="https://666wxy666.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
      <category term="交换原理" scheme="https://666wxy666.github.io/tags/%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>交换原理 实验4 拨打SIP电话</title>
    <link href="https://666wxy666.github.io/2020/10/09/%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86-%E5%AE%9E%E9%AA%8C4-%E6%8B%A8%E6%89%93SIP%E7%94%B5%E8%AF%9D/"/>
    <id>https://666wxy666.github.io/2020/10/09/%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86-%E5%AE%9E%E9%AA%8C4-%E6%8B%A8%E6%89%93SIP%E7%94%B5%E8%AF%9D/</id>
    <published>2020-10-08T16:00:00.000Z</published>
    <updated>2020-10-09T08:11:51.747Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文是关于交换原理实验四——拨打SIP电话及抓包分析实验报告记录。</p><a id="more"></a><p>这些项目的源码、可执行程序、报告等已经存放于我的Github，欢迎下载查看：</p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/666WXY666/SIP-EXP" target="_blank"><img src="https://github-readme-stats.vercel.app/api/pin/?username=666WXY666&repo=SIP-EXP&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/pin/?username=666WXY666&repo=SIP-EXP&show_owner=true" srcset="data:image/png;base64,666"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是关于交换原理实验四——拨打SIP电话及抓包分析实验报告记录。&lt;/p&gt;
    
    </summary>
    
    
      <category term="交换原理" scheme="https://666wxy666.github.io/categories/%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"/>
    
      <category term="实验" scheme="https://666wxy666.github.io/categories/%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="实验" scheme="https://666wxy666.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
      <category term="交换原理" scheme="https://666wxy666.github.io/tags/%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"/>
    
      <category term="SIP" scheme="https://666wxy666.github.io/tags/SIP/"/>
    
  </entry>
  
  <entry>
    <title>交换原理 实验3 MPLS编程实验</title>
    <link href="https://666wxy666.github.io/2020/10/09/%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86-%E5%AE%9E%E9%AA%8C3-MPLS%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    <id>https://666wxy666.github.io/2020/10/09/%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86-%E5%AE%9E%E9%AA%8C3-MPLS%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/</id>
    <published>2020-10-08T16:00:00.000Z</published>
    <updated>2020-10-09T08:05:41.390Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文是关于交换原理实验三——MPLS编程实验报告记录。</p><a id="more"></a><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><p>安排的三个编程实验主要用于加强学生对MPLS交换中标记请求、标记分配与分发、标记分组转发的理解。</p><h2 id="二、实验内容和实验步骤"><a href="#二、实验内容和实验步骤" class="headerlink" title="二、实验内容和实验步骤"></a>二、实验内容和实验步骤</h2><h3 id="1、实验原理及设计"><a href="#1、实验原理及设计" class="headerlink" title="1、实验原理及设计"></a>1、实验原理及设计</h3><p>多协议标记交换MPLS（Multiple Protocol Labeled  Switching）技术是将第二层交换和第三层路由结合起来的一种L2/L3集成数据传输技术。MPLS是一项面向连接的交换技术，因此有建立连接的过程。各个MPLS设备运行  路由协议，在标记分发协议LDP的控制下根据计算得到的路由在相邻的路由器进行标记分配和分发，从而通过标记的拼接建立起从网络入口到出口的标记交换路径LSP。 </p><p>在数据转发过程中，入口标记路由器LER根据数据流的属性比如网络层目的地址等将分组映射到某一转发等价类FEC，并为分组绑定标记。核心标记交换路由器LSR只需根据分组中所携带的标记进行转发即可。出口标记路由器LER弹出标记，根据分组的网络层目的地址将分组转发到下一跳。MPLS节点（MPLS标记交换路由器LSR或MPLS边缘路由器LER）均要创建和维护传统的路由表和标记信息库LIB。</p><p>路由表记录记录路由信息，用于转发网络层分组和标记分发从而建立标记交换路径。LIB记录了本地节点分配的标记与从邻接MPLS节点收到的标记之间的映射关系，用于标记分组的转发。</p><p>MPLS技术的核心实质在于：</p><ol><li>网络中分组基于标记的转发；</li><li>LDP协议控制下的进行标记分发从而建立标记交换路径LSP；</li></ol><h3 id="2、实验主要数据结构"><a href="#2、实验主要数据结构" class="headerlink" title="2、实验主要数据结构"></a>2、实验主要数据结构</h3><p>所需要的头文件：”mplsconstant.h”</p><p>其中的主要数据结构为：</p><pre><code class="c">//发送的请求信息包数据结构struct ReqType{    int iFirstNode;   //请求信息包的源节点    int iEndNode;     //请求信息包的目的节点    double ipaddress; //请求信息包包含的网络层目的IP地址前缀（例如197.42）};//路由表表项的数据结构struct routertype{    double ipaddress; //网络层目的地址前缀    int nexthop;      //下一跳节点    int lasthop;      //上一跳节点    int inpoint;      //入端口号    int outpoint;     //出端口号};//标记信息表表项的数据结构struct libtype{    double ipaddress; //网络层目的地址前缀    int inpoint;      //入端口号    int outpoint;     //出端口号    int inlabel;      //入标记值    int outlabel;     //出标记值};//发送的标记信息包数据结构struct LabelPack{    int iFirstNode; //源节点号    int iEndNode;   //目的节点号    int labelvalue; //标签值};struct funcusedtype{    struct libtype libinfo;     //包含的标记信息表项    struct LabelPack labelinfo; //包含的标记信息包数据结构};//发送的标记分组信息包类型struct LabelledDataPack{    int iFirstNode;              //源节点号    int iEndNode;                //目的节点号    struct MessageType DataInfo; //包含的标记分组类型信息};//标记分组类型struct MessageType{    double ipaddress; //网络层目的地址前缀    int labelvalue; //输出标签值};</code></pre><h4 id="①标记请求实验："><a href="#①标记请求实验：" class="headerlink" title="①标记请求实验："></a>①标记请求实验：</h4><pre><code class="c">extern &quot;C&quot; _declspec(dllexport) struct  ReqType req_process(int idnow,struct routertype routenow){    struct ReqType reqtemp;    return  reqtemp;}</code></pre><p>参数意义：</p><p>int idnow：当前的节点号；</p><p>struct routertype routenow：当前所指的路由表的表项；</p><p>函数要求：</p><p>根据提供的当前节点号和路由表表项值产生标记请求包；</p><p>过程描述：</p><p>标记请求包的源节点号由当前节点号提供，目的节点号和ip地址前缀由当前所指的路由表表项的下一跳节点和ip地址前缀提供；</p><h4 id="②标记分配与分发实验："><a href="#②标记分配与分发实验：" class="headerlink" title="②标记分配与分发实验："></a>②标记分配与分发实验：</h4><pre><code class="c">extern  &quot;C&quot; _declspec(dllexport) struct  funcusedtype label_process(struct routertype routenow,int labelout,int  idnow){    struct  funcusedtype tempstruct;    return  tempstruct;}</code></pre><p>参数意义：</p><p>struct routertype routenow：当前所指的路由表表项；</p><p>int labelout：分配的输出标签号；</p><p>int idnow：当前的节点号；</p><p>函数要求：</p><p>该函数要求根据提供的路由表当前表项、分配的输出标签号和当前节点号，构造一funcusedtype信息包。注：各节点的输入标签可以自由选定，但必须是1-9的整数；</p><p>过程描述：</p><p>该funcusedtype信息包的libinfo部分可由当前的路由表表项、当前分配的标签号的有关部分构成；labelinfo部分由当前节点号和当前的路由表表项的有关部分构成；    </p><h4 id="③标记分组转发实验"><a href="#③标记分组转发实验" class="headerlink" title="③标记分组转发实验"></a>③标记分组转发实验</h4><pre><code class="c">extern &quot;C&quot; _declspec(dllexport) struct  LabelledDataPack pack_process(struct routertype routenow,struct libtype  libnow,int idnow){    struct LabelledDataPack packtemp;    return packtemp;}</code></pre><p>参数意义：</p><p>struct routertype routenow：当前所指的路由表表项；</p><p>struct libtype libnow：当前的标签信息表表项；</p><p>int idnow：当前的节点号；</p><p>函数要求:</p><p>该函数要求根据提供的路由表表项、标签信息表表项和当前节点号，构造出一个标签数据信息包。</p><p>过程描述：</p><p>该标签信息包的源节点、目的节点、IP地址前缀和标签值均可由当前节点号、路由表表项和标签信息表表项构成；</p><h3 id="3、实验效果检验"><a href="#3、实验效果检验" class="headerlink" title="3、实验效果检验"></a>3、实验效果检验</h3><p>建立连接阶段、数据传输阶段、拆除阶段，三阶段均可正常进行。</p><h3 id="4、实验步骤"><a href="#4、实验步骤" class="headerlink" title="4、实验步骤"></a>4、实验步骤</h3><ol><li>熟悉实验平台和测试环境；</li><li>编写C程序实现所要求的功能；</li><li>运行测试程序；</li><li>完成实验报告。</li></ol><h2 id="三、源代码"><a href="#三、源代码" class="headerlink" title="三、源代码"></a>三、源代码</h2><h3 id="①标记请求实验：-1"><a href="#①标记请求实验：-1" class="headerlink" title="①标记请求实验："></a>①标记请求实验：</h3><pre><code class="c">#include &quot;mplsconstant.h&quot;extern &quot;C&quot; _declspec(dllexport) struct ReqType req_process(int idnow, struct routertype routenow){    struct ReqType reqtemp;    reqtemp.iFirstNode = idnow;             //源节点号由当前节点号提供    reqtemp.iEndNode = routenow.nexthop;    //目的节点号由当前路由表表项的下一跳节点提供    reqtemp.ipaddress = routenow.ipaddress; //IP地址前缀由当前路由表表项的IP地址前缀提供    return reqtemp;}</code></pre><h3 id="②标记分配与分发实验：-1"><a href="#②标记分配与分发实验：-1" class="headerlink" title="②标记分配与分发实验："></a>②标记分配与分发实验：</h3><pre><code class="c">#include &quot;mplsconstant.h&quot;extern &quot;C&quot; _declspec(dllexport) struct funcusedtype label_process(struct routertype routenow, int labelout, int idnow){    struct funcusedtype tempstruct;    //包含的标记信息表项    tempstruct.libinfo.ipaddress = routenow.ipaddress; //网络层目的地址前缀    tempstruct.libinfo.inpoint = routenow.inpoint;     //入端口号    tempstruct.libinfo.outpoint = routenow.outpoint;   //出端口号    tempstruct.libinfo.inlabel = 1;                    //入标记值    tempstruct.libinfo.outlabel = labelout;            //出标记值    //包含的标记信息包数据结构    tempstruct.labelinfo.iFirstNode = idnow;          //当前节点号    tempstruct.labelinfo.iEndNode = routenow.lasthop; //当前的路由表表项的上一跳节点    tempstruct.labelinfo.labelvalue = 1;              //与tempstruct.libinfo.inlabel保持一致    return tempstruct;}</code></pre><h3 id="③标记分组转发实验-1"><a href="#③标记分组转发实验-1" class="headerlink" title="③标记分组转发实验"></a>③标记分组转发实验</h3><pre><code class="c">#include &quot;mplsconstant.h&quot;extern &quot;C&quot; _declspec(dllexport) struct LabelledDataPack pack_process(struct routertype routenow, struct libtype libnow, int idnow){    struct LabelledDataPack packtemp;    packtemp.iFirstNode = idnow;          //源节点号    packtemp.iEndNode = routenow.nexthop; //目的节点号    //包含的标记分组类型信息    packtemp.DataInfo.ipaddress = routenow.ipaddress; //网络层目的地址前缀    packtemp.DataInfo.labelvalue = libnow.outlabel;   //输出标签值    return packtemp;}</code></pre><h2 id="四、实验结果"><a href="#四、实验结果" class="headerlink" title="四、实验结果"></a>四、实验结果</h2><p>运行程序后，建立连接阶段、数据传输阶段、拆除阶段，三阶段均可正常进行，实验成功。</p><h2 id="五、实验心得"><a href="#五、实验心得" class="headerlink" title="五、实验心得"></a>五、实验心得</h2><p>这次实验要编写三个程序，但是基本框架都已经规定好了，对照指导书上结构体和函数的说明，只需要简单的创建结构体和赋值操作就能很轻松地完成。加强了我对MPLS的原理和标记请求、标记分配与分发、标记分组转发过程的理解和认识。实验虽然简单，但是很有意义，收获很多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是关于交换原理实验三——MPLS编程实验报告记录。&lt;/p&gt;
    
    </summary>
    
    
      <category term="交换原理" scheme="https://666wxy666.github.io/categories/%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"/>
    
      <category term="实验" scheme="https://666wxy666.github.io/categories/%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="实验" scheme="https://666wxy666.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
      <category term="交换原理" scheme="https://666wxy666.github.io/tags/%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/"/>
    
      <category term="MPLS" scheme="https://666wxy666.github.io/tags/MPLS/"/>
    
  </entry>
  
  <entry>
    <title>C++工程项目 JobShop</title>
    <link href="https://666wxy666.github.io/2020/09/30/C++%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE-JobShop/"/>
    <id>https://666wxy666.github.io/2020/09/30/C++%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE-JobShop/</id>
    <published>2020-09-29T16:00:00.000Z</published>
    <updated>2020-09-30T02:28:22.402Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>本文是计算机导论的程序设计实战项目，实现单词消除游戏，具体项目及要求请点击查看。</strong></p><a id="more"></a><h2 id="一、任务概述"><a href="#一、任务概述" class="headerlink" title="一、任务概述"></a>一、任务概述</h2><p><img src="https://gitee.com/wxy_666/images/raw/master/20200930101945.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200930101945.jpg" srcset="data:image/png;base64,666" alt="2020-09-30_101902"></p><p>完成这一任务必须满足以下约束条件：</p><p>约束1：程序启动后首先接受产品加工请求输入，确认当天的需求后不再接受新的订单。对每个产品需满足加工工序约束，即只有其前一个工序加工完毕，才能加工其后一个工序。每个工序的加工时间已知，且所需机器固定(每台机器都不能被其他机器替代)，均作为程序的输入。</p><p><img src="https://gitee.com/wxy_666/images/raw/master/20200930102043.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200930102043.jpg" srcset="data:image/png;base64,666" alt="2020-09-30_102028"></p><p>表1. 要输入的参数</p><table><thead><tr><th></th><th>产品1</th><th>产品2</th><th>产品3</th><th>…</th></tr></thead><tbody><tr><td>操作1</td><td>（7，<em>M</em>1）</td><td>（10，<em>M</em>2）</td><td>（7，<em>M</em>1）</td><td>…</td></tr><tr><td>操作2</td><td>（12，<em>M</em>2）</td><td>（17，<em>M</em>1）</td><td>（22，<em>M</em>2）</td><td>…</td></tr><tr><td>操作3</td><td>（15，<em>M</em>3）</td><td></td><td></td><td>…</td></tr><tr><td>…</td><td></td><td></td><td></td><td>…</td></tr></tbody></table><p>约束2：每台机器同一时间只能加工一个操作，一旦开始加工一个操作就要加工完成，期间不允许中断。</p><h2 id="二、运行环境"><a href="#二、运行环境" class="headerlink" title="二、运行环境"></a>二、运行环境</h2><p>电脑硬件配置：</p><ul><li><p>处理器：Intel i7 7700HQ</p></li><li><p>显卡：NVIDIA GeForce GTX 1050 Ti</p></li><li><p>内存：16GB</p></li></ul><p>编程语言：C++</p><h2 id="三、程序输入"><a href="#三、程序输入" class="headerlink" title="三、程序输入"></a>三、程序输入</h2><p>输入参数如下：</p><ol><li>产品的数目<em>n</em>；</li><li>所用机器数目<em>m</em>；</li><li>表1所示的各工序的加工时间，所用机器约束。</li></ol><p>要求开发两个版本：命令行版本和动画版本。</p><p>具体说明如下：</p><ul><li><p>命令行版本，要求实现文件输入和键盘输入，文件和命令行同时输出。</p></li><li><p>动画版本，要求实现图形界面输入，文件和动画同时输出。</p></li></ul><h3 id="1、文件输入"><a href="#1、文件输入" class="headerlink" title="1、文件输入"></a>1、文件输入</h3><p>文件名为input.txt，文本文件格式为：</p><p>首行输入产品数和机器数，格式为：</p><pre><code>&lt;产品数目&gt; &lt;空格&gt;&lt;机器数目&gt;&lt;\n&gt;</code></pre><p>之后每一行代表一个产品的加工订单，‘-1’表示结束。</p><p>每行的订单输入格式规定如下：</p><pre><code>&lt;产品序号&gt;&lt;空格&gt;&lt;(&gt;&lt;按顺序的工序所花时间&gt;&lt;,&gt;&lt;工序指定机器号&gt;&lt;)&gt;&lt;空格&gt;...&lt;\n&gt; </code></pre><p>例如上面表1的加工三个产品的订单，输入文件内容为：</p><p>3 3 </p><p><strong>1 (7,1) (3,2) (15,3)</strong></p><p><strong>2 (10,2) (17,1)</strong></p><p><strong>3 (7,1) (22,2)</strong></p><p><strong>-1</strong></p><p>在软件系统开发期间，老师会提供几组测试数据（输入文件和参照方案）给同学们，便于大家测试。最后验收的时候，老师会现场给定新的测试数据，来验证各组程序的算法优劣。</p><h3 id="2、从键盘输入"><a href="#2、从键盘输入" class="headerlink" title="2、从键盘输入"></a>2、从键盘输入</h3><p>命令行方式下，首先输入产品数和机器数，格式为：</p><pre><code>&lt;产品数目&gt; &lt;空格&gt;&lt;机器数目&gt;&lt;\n&gt;</code></pre><p>之后每一行代表一个产品的加工订单，输入‘-1’表示结束输入。</p><p>每行的订单输入格式规定如下：</p><pre><code>&lt;产品序号&gt;&lt;空格&gt;&lt;(&gt;&lt;按顺序的工序所花时间&gt;&lt;,&gt;&lt;工序指定机器号&gt;&lt;)&gt;&lt;空格&gt;...&lt;ENTER&gt;</code></pre><p>例如上面表1的加工三个产品的订单输入，可以用键盘输入为：</p><p>3 3 </p><p><strong>1 (7,1) (3,2) (15,3)</strong></p><p><strong>2 (10,2) (17,1)</strong></p><p><strong>3 (7,1) (22,2)</strong></p><p><strong>-1</strong></p><p> 在输出过程中，随机增加故障</p><h3 id="3、图形界面输入"><a href="#3、图形界面输入" class="headerlink" title="3、图形界面输入"></a>3、图形界面输入</h3><p>图形窗口中设计总产品数目和机器数目的输入框，工序所花时间的输入框、工序指定机器号的输入框，工序确认的按钮，下一产品的按钮，以及订单收齐确认按钮。界面元素大致如图1所示。</p><p>初始输入时，首先输入产品总数和机器总数，然后是产品1的加工要求，用户输入工序时间和机器号后，按工序确认可以产生一个工序操作，顺序产生多道工序后可以按“下一产品”按钮进入下一个产品的工序输入。依次操作直到所有产品的加工要求输入完成，按“订单确认”按钮启动程序计算。</p><h2 id="三、程序输出"><a href="#三、程序输出" class="headerlink" title="三、程序输出"></a>三、程序输出</h2><p>在满足以上约束条件的前提下，安排所输入订单的<em>n</em>个产品在<em>m</em>台机器上的加工，要求给出产品的各操作在机器上的加工顺序，以及各操作的起始加工时间。</p><p>要求开发两个版本：命令行版本和动画版本。具体说明如下：</p><p>命令行版本，要求实现文件输入和键盘输入，文件和命令行同时输出。</p><p>动画版本，要求实现图形界面输入，文件和动画同时输出。</p><h3 id="1、文件输出"><a href="#1、文件输出" class="headerlink" title="1、文件输出"></a>1、文件输出</h3><p>文件名为output.txt，文本文件格式为：</p><p>一行代表一个机器的加工序列，最后一行输出‘End &lt;最终结束时间&gt;’表示方案的最终完成时间。</p><p>每行的机器加工序列输出格式规定如下：</p><pre><code>&lt;M&gt;&lt;机器号&gt;&lt;空格&gt;&lt;(&gt;&lt;起始时间,产品号-工序号,终止时间&gt;&lt;)&gt;&lt;空格&gt;...&lt;\n&gt;</code></pre><p>例如上面表1的加工三个产品的方案输出，文件内容为：</p><p><strong>M1 (0,1-1,7) (7,3-1,14) (29,2-2,46)</strong> </p><p><strong>M2 (7,1-2,19) (19,2-1,29) (29,3-2,51)</strong></p><p><strong>M3 (19,1-3,34)</strong></p><p><strong>End 51</strong></p><p> 通过时间轴，动态的打印出各个计划</p><h3 id="2、命令行输出"><a href="#2、命令行输出" class="headerlink" title="2、命令行输出"></a>2、命令行输出</h3><p>命令行方式下，一行代表一个机器的加工序列，最后一行输出‘End &lt;最终结束时间&gt;’表示方案的最终完成时间。</p><p>每行的机器加工序列输出格式规定如下：</p><p><m>&lt;机器号&gt;&lt;空格&gt;&lt;(&gt;&lt;起始时间,产品号-工序号,终止时间&gt;&lt;)&gt;&lt;空格&gt;…&lt;\n&gt;</m></p><p>例如上面表1的加工三个产品的方案输出，命令行显示为：</p><p><strong>M1 (0,1-1,7) (7,3-1,14) (29,2-2,46)</strong> </p><p><strong>M2 (7,1-2,19) (19,2-1,29) (29,3-2,51)</strong></p><p><strong>M3 (19,1-3,34)</strong></p><p><strong>End 51</strong></p><h3 id="3、图形界面输出"><a href="#3、图形界面输出" class="headerlink" title="3、图形界面输出"></a>3、图形界面输出</h3><p>要求在图形窗口中用绘制的甘特图来表示操作在机器上的安排。</p><p><img src="https://gitee.com/wxy_666/images/raw/master/20200930101715.gif" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200930101715.gif" srcset="data:image/png;base64,666" alt="img"></p><p>例如，图2所示的甘特图给出了上文提及的3个产品在3台机器上加工的一个安排，其中给出了每台机器上的操作的加工排序以及每个操作的开始加工时间。图2所示的加工安排满足产品加工约束和表1所示的机器加工约束。例如，产品1的第1个操作加工完毕再加工第2个操作，第2个操作加工完毕再加工第3个操作。产品1的第1、2、3个操作分别在机器1、2、3上加工，加工时间分别是7、12、15，满足表1中的约束。</p><h3 id="4、动画输出"><a href="#4、动画输出" class="headerlink" title="4、动画输出"></a>4、动画输出</h3><h2 id="四、核心调度算法"><a href="#四、核心调度算法" class="headerlink" title="四、核心调度算法"></a>四、核心调度算法</h2><p><em>n</em>个产品在<em>m</em>台机器上加工，满足约束条件的加工安排有很多。我们设定最优解为所有产品加工完成所需时间最短，则需要找到一个加工安排，使得所有产品最快完成加工。</p><p>要想获得所有产品加工完成时间更短的方案，我们需要借助调度算法。以下是可选的调度算法。</p><h3 id="（1）调度规则算法"><a href="#（1）调度规则算法" class="headerlink" title="（1）调度规则算法"></a>（1）调度规则算法</h3><p>当一台机器加工完毕一个操作而变为空闲状态后，通常有多个操作请求在该机器上加工，此时，需要决定该机器下一步加工哪个操作。用调度规则可做出这一决策。调度规则在每次迭代中按照优先规则调度一个操作，直至生成一个完整调度。如果要用调度规则生成一个较好的安排，需要借助Giffler &amp; Thompson算法。</p><h3 id="（2）邻域搜索算法"><a href="#（2）邻域搜索算法" class="headerlink" title="（2）邻域搜索算法"></a>（2）邻域搜索算法</h3><p>采用析取图为问题建模，然后基于析取图模型构造解的邻域。邻域搜索的基本思想为：在每次迭代中，选取当前解的邻域中的最好解作为下一个解，只要目标函数值减少，该过程就不断继续，直到找到局部最优点。典型的邻域搜索算法包括模拟退火、禁忌搜索算法。</p><h3 id="（3）演化算法"><a href="#（3）演化算法" class="headerlink" title="（3）演化算法"></a>（3）演化算法</h3><p>需要将问题的解表示为一个编码，用一个群体来表示一组解。群体经过若干世代的进化，最终产生的最优个体即为问题的最优解。</p><p>第1种算法相对较简单，对于小规模问题效果较好，但对较大规模问题效果不够理想；第2、3种算法较复杂，需要了解一些背景知识，对大规模问题的性能也较好。</p><p>建议同学们用关键词“车间调度”、“Job shop调度”“Job shop scheduling”在学校图书馆电子数据库中查找并阅读相关文献，然后选择一种算法实现。</p><p>最终，所有参与此游戏开发的小组会将结果：程序运行时间、最优解方案加工时间两个时间值按一定权重进行评比，形成一个排行榜。所以选择算法时，要综合考虑最短的算法运行时间和解决方案最优，两者平衡。</p><h2 id="五、实现要求"><a href="#五、实现要求" class="headerlink" title="五、实现要求"></a>五、实现要求</h2><ol><li>以小组为单位完成上述任务要求，只要能完成输入订单的方案输出，满足约束规则，就可通过。</li><li>必须完成两个版本：命令行版本和动画版本的开发，按时参加验收。为了保证验收，要求各小组的程序运行时间不能超过10分钟。</li><li>必须在指定时间内提交概要设计文档和程序代码。</li></ol><h2 id="六、评价规则"><a href="#六、评价规则" class="headerlink" title="六、评价规则"></a>六、评价规则</h2><p>所有参与此游戏开发的小组会将结果：程序运行时间、最优解方案加工时间两个时间值按一定权重进行评比，形成一个排行榜。</p><p>大作业成绩会基于这个排行榜得分。另外再综合软件的扩展功能、程序代码结构、小组协作度等附加项，形成最终分数。</p><h2 id="五、项目地址"><a href="#五、项目地址" class="headerlink" title="五、项目地址"></a>五、项目地址</h2><p>本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看：</p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/666WXY666/JobShop" target="_blank"><img src="https://github-readme-stats.vercel.app/api/pin/?username=666WXY666&repo=JobShop&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/pin/?username=666WXY666&repo=JobShop&show_owner=true" srcset="data:image/png;base64,666"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文是计算机导论的程序设计实战项目，实现单词消除游戏，具体项目及要求请点击查看。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="https://666wxy666.github.io/categories/C-C/"/>
    
      <category term="项目" scheme="https://666wxy666.github.io/categories/C-C/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="C++" scheme="https://666wxy666.github.io/tags/C/"/>
    
      <category term="工程" scheme="https://666wxy666.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="JobShop" scheme="https://666wxy666.github.io/tags/JobShop/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理 FPGA编程实验</title>
    <link href="https://666wxy666.github.io/2020/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-FPGA%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
    <id>https://666wxy666.github.io/2020/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-FPGA%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/</id>
    <published>2020-09-12T16:00:00.000Z</published>
    <updated>2020-09-13T09:00:58.975Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>本文是计算机机组成原理在MiniSYS系统上的FPGA编程实验项目。</strong></p><a id="more"></a><p>这些项目的源码、可执行程序、报告等已经存放于我的Github，欢迎下载查看：</p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/666WXY666/ComOrgPri-MiniSYS" target="_blank"><img src="https://github-readme-stats.vercel.app/api/pin/?username=666WXY666&repo=ComOrgPri-MiniSYS&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/pin/?username=666WXY666&repo=ComOrgPri-MiniSYS&show_owner=true" srcset="data:image/png;base64,666"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文是计算机机组成原理在MiniSYS系统上的FPGA编程实验项目。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机组成原理" scheme="https://666wxy666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="实验" scheme="https://666wxy666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="工程" scheme="https://666wxy666.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="项目" scheme="https://666wxy666.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="Verilog" scheme="https://666wxy666.github.io/tags/Verilog/"/>
    
      <category term="计算机组成原理" scheme="https://666wxy666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="FPGA" scheme="https://666wxy666.github.io/tags/FPGA/"/>
    
      <category term="MiniSYS" scheme="https://666wxy666.github.io/tags/MiniSYS/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 实验集锦</title>
    <link href="https://666wxy666.github.io/2020/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%AE%9E%E9%AA%8C%E9%9B%86%E9%94%A6/"/>
    <id>https://666wxy666.github.io/2020/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%AE%9E%E9%AA%8C%E9%9B%86%E9%94%A6/</id>
    <published>2020-09-09T16:00:00.000Z</published>
    <updated>2020-09-13T08:57:29.437Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>本文是计算机网络相关实验项目工程集锦。</strong></p><a id="more"></a><p>这些项目的源码、可执行程序、报告等已经存放于我的Github，欢迎下载查看：</p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/666WXY666/ComputerNetwork-Exp" target="_blank"><img src="https://github-readme-stats.vercel.app/api/pin/?username=666WXY666&repo=ComputerNetwork-Exp&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/pin/?username=666WXY666&repo=ComputerNetwork-Exp&show_owner=true" srcset="data:image/png;base64,666"></a><div class="btns rounded center grid3">            <a class="button" href="https://github.com/666WXY666/ComputerNetwork-Exp/blob/master/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%95%B0%E6%8D%AE%E5%88%86%E7%BB%84%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E5%88%86%E6%9E%90.pdf" target="_blank" rel="external nofollow noopener noreferrer" title="网络层数据分组的捕获和分析"><i class="fas fa-download"></i>网络层数据分组的捕获和分析</a><a class="button" href="https://github.com/666WXY666/ComputerNetwork-Exp/tree/master/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0" target="_blank" rel="external nofollow noopener noreferrer" title="数据链路层滑动窗口协议的设计与实现"><i class="fas fa-download"></i>数据链路层滑动窗口协议的设计与实现</a><a class="button" href="https://github.com/666WXY666/CSAPP-Report/blob/master/%E5%AE%9E%E9%AA%8C4-%E9%94%AE%E7%9B%98%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E4%BF%AE%E6%94%B9.pdf" target="_blank" rel="external nofollow noopener noreferrer" title="DNS中继服务器的简单实现"><i class="fas fa-download"></i>DNS中继服务器的简单实现</a>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文是计算机网络相关实验项目工程集锦。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://666wxy666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="实验" scheme="https://666wxy666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="C++" scheme="https://666wxy666.github.io/tags/C/"/>
    
      <category term="工程" scheme="https://666wxy666.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="C" scheme="https://666wxy666.github.io/tags/C/"/>
    
      <category term="项目" scheme="https://666wxy666.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="计算机网络" scheme="https://666wxy666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="DNS" scheme="https://666wxy666.github.io/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 实验集锦</title>
    <link href="https://666wxy666.github.io/2020/09/04/CSAPP-%E5%AE%9E%E9%AA%8C%E9%9B%86%E9%94%A6/"/>
    <id>https://666wxy666.github.io/2020/09/04/CSAPP-%E5%AE%9E%E9%AA%8C%E9%9B%86%E9%94%A6/</id>
    <published>2020-09-03T16:00:00.000Z</published>
    <updated>2020-09-03T02:28:03.957Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>本文是CSAPP（深入理解计算机系统）项目工程集锦。</strong></p><a id="more"></a><p>这些项目的源码、可执行程序、报告等已经存放于我的Github，欢迎下载查看：</p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/666WXY666/CSAPP-Report" target="_blank"><img src="https://github-readme-stats.vercel.app/api/pin/?username=666WXY666&repo=CSAPP-Report&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/pin/?username=666WXY666&repo=CSAPP-Report&show_owner=true" srcset="data:image/png;base64,666"></a><div class="btns rounded center grid3">            <a class="button" href="https://github.com/666WXY666/CSAPP-Report/blob/master/%E5%AE%9E%E9%AA%8C1-LINUX%E7%8E%AF%E5%A2%83%E5%92%8CGCC%E5%B7%A5%E5%85%B7%E9%93%BE.pdf" target="_blank" rel="external nofollow noopener noreferrer" title="LINUX环境和GCC工具链"><i class="fas fa-download"></i>LINUX环境和GCC工具链</a><a class="button" href="https://github.com/666WXY666/CSAPP-Report/blob/master/%E5%AE%9E%E9%AA%8C3-%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA.pdf" target="_blank" rel="external nofollow noopener noreferrer" title="缓冲区溢出"><i class="fas fa-download"></i>缓冲区溢出</a><a class="button" href="https://github.com/666WXY666/CSAPP-Report/blob/master/%E5%AE%9E%E9%AA%8C4-%E9%94%AE%E7%9B%98%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E4%BF%AE%E6%94%B9.pdf" target="_blank" rel="external nofollow noopener noreferrer" title="键盘驱动程序的分析与修改"><i class="fas fa-download"></i>键盘驱动程序的分析与修改</a>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文是CSAPP（深入理解计算机系统）项目工程集锦。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂项" scheme="https://666wxy666.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="工程" scheme="https://666wxy666.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="Linux" scheme="https://666wxy666.github.io/tags/Linux/"/>
    
      <category term="C" scheme="https://666wxy666.github.io/tags/C/"/>
    
      <category term="项目" scheme="https://666wxy666.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="CSAPP" scheme="https://666wxy666.github.io/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>操作系统 内存管理</title>
    <link href="https://666wxy666.github.io/2020/09/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://666wxy666.github.io/2020/09/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2020-09-02T16:00:00.000Z</published>
    <updated>2020-09-13T08:56:14.653Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>本文是操作系统内存管理的基本实验。</strong></p><a id="more"></a><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><p>在本次实验中，需要从不同的侧面了解Windows  的虚拟内存机制。在Windows操作系统中，可以通过一些API 操纵虚拟内存。主要需要了解以下几方面：</p><ol><li>Windows  虚拟存储系统的组织</li><li>如何控制虚拟内存空间</li><li>如何编写内存追踪和显示工具</li><li>详细了解与内存相关的API 函数的使用</li></ol><h2 id="二、实验需求"><a href="#二、实验需求" class="headerlink" title="二、实验需求"></a>二、实验需求</h2><p>编写一个包含两个线程的进程，一个线程用于模拟内存分配活动，一个线程用于跟踪第一个线程的内存行为。模拟内存活动的线程可以从一个文件中读出要进行的内存操作，每个内存操作包含如下内容：</p><ul><li>时间：开始执行的时间</li><li>块数：分配内存的粒度</li><li>操作：包括保留一个区域、提交一个区域、释放一个区域、回收一个区域以及锁与解锁一个区域；可以将这些操作编号，存放于文件中</li><li>大小：指块的大小</li><li>访问权限：共五种PAGE_READONLY、PAGE_READWRITE、PAGE_EXCUTE、PAGE_EXECUTE_READ 和PAGE_EXECUTE_READWRITE。可以将这些权限编号，存放于文件中。跟踪线程将页面大小、已使用的地址范围、物理内存总量以及虚拟内存总量等信息显示出来。</li></ul><h2 id="二、运行环境"><a href="#二、运行环境" class="headerlink" title="二、运行环境"></a>二、运行环境</h2><p>电脑硬件配置：</p><ul><li><p>处理器：Intel i7 7700HQ</p></li><li><p>显卡：NVIDIA GeForce GTX 1050 Ti</p></li><li><p>内存：16GB</p></li></ul><p>软件：</p><ul><li><p>编程语言：C++</p></li><li><p>IDE：Microsoft Visual Studio 2019</p></li><li><p>Windows SDK版本：10.0</p></li><li><p>平台工具集：Visual Studio 2019（v142）</p></li></ul><h2 id="三、实验原理"><a href="#三、实验原理" class="headerlink" title="三、实验原理"></a>三、实验原理</h2><p>内存管理是Windows执行体的一部分，位于Ntoskrnl.exe 文件中，是整个操作系统的重要组成部分。物理内存是固定的，内存条的容量多大，物理内存就有多大。但是如果程序运行很多或者程序本身很大的话，就会导致大量的物理内存占用，甚至导致物理内存消耗殆尽。</p><p>虚拟内存就是在硬盘上划分一块页面文件，充当内存。当程序在运行时，有一部分资源还没有用上或者同时打开几个程序却只操作其中一个程序时，系统没必要将程序所有的资源都放在物理内存中。于是，系统将这些暂时不用的资源放在虚拟内存上，等到需要时在调出来用。这也是虚拟内存的优点：需要的时候才真正分配内存。</p><p>默认情况下，32位Windows上每个用户进程可以占有2GB的私有地址空间，操作系统占有剩下的2GB。Windows在x86体系结构上利用二级页表结构来实现虚拟地址向物理地址的变换。一个32位虚拟地址被解释为三个独立的分量——页目录索引、页表索引和字节索引——它们用于找出描述页面映射结构的索引。页面大小及页表项的宽度决定了页目录和页表索引的宽度。比如，在x86 系统中，因为一页包含4096字节，于是字节索引被确定为12位宽（2^12=4096）。</p><p>应用程序有三种使用内存方法：</p><ul><li>以页为单位的虚拟内存分配方法，适合于大型对象或结构数组</li><li>内存映射文件方法，适合于大型数据流文件以及多个进程之间的数据共享</li><li>内存堆方法，适合于大量的小型内存申请</li></ul><p>本次实验主要是针对第一种使用方式。应用程序通过API函数 VirtualAlloc和VirtualAllocEx等实现以页为单位的虚拟内存分配方法。首先保留地址空间，然后向此地址空间提交物理页面，也可以同时实现保留和提交。保留地址空间是为线程将来使用保留一块虚拟地址。在已保留的区域中，提交页面必须指出将物理存储器提交到何处以及提交多少。提交页面在访问时会转变为物理内存中的有效页面。</p><h2 id="四、实验步骤"><a href="#四、实验步骤" class="headerlink" title="四、实验步骤"></a>四、实验步骤</h2><p>1、编译运行makefile.cpp，生成opfile文件。opfile里记录了几个不同的内存操作，包括时间、块数、操作、大小、访问权限。生成了包括5个权限和6个操作任意组合共30个操作。</p><img src="https://gitee.com/wxy_666/images/raw/master/20200902170741.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200902170741.png" srcset="data:image/png;base64,666" alt="1" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200902170806.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200902170806.png" srcset="data:image/png;base64,666" alt="2" style="zoom:80%;"><p>2、将生成的opfile复制到memory-op的工程目录下</p><img src="https://gitee.com/wxy_666/images/raw/master/20200902171008.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200902171008.png" srcset="data:image/png;base64,666" alt="3" style="zoom:80%;"><p>3、编译运行memory-op.cpp，产生两个线程，一个从opfile文件里读取内存操作，模拟内存活动，另一个跟踪第一个的内存行为，将结果输出，并保存在out.txt文件中。</p><img src="https://gitee.com/wxy_666/images/raw/master/20200902171020.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200902171020.png" srcset="data:image/png;base64,666" alt="4" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200902171049.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200902171049.png" srcset="data:image/png;base64,666" alt="5" style="zoom:80%;"><p>4、输出结果</p><img src="https://gitee.com/wxy_666/images/raw/master/20200902171100.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200902171100.png" srcset="data:image/png;base64,666" alt="6" style="zoom:80%;"><h2 id="五、相关的API-函数"><a href="#五、相关的API-函数" class="headerlink" title="五、相关的API 函数"></a>五、相关的API 函数</h2><pre><code class="c">//可以通过GetSystemInfo，GlobalMemoryStatus 和VirtualQuery 来查询进程虚空间的状态。主要的信息来源如下：VOID GetSystemInfo （ LPSYSTEM_INFO lpSystemInfo ）;//结构SYSTEMINFO 定义如下：typedef struct _SYSTEM_INFO {DWORD dwOemld;DWORD dwPageSize;LPVOID lpMinimumApplicationAddress;LPVOID lpMaximumApplicationAddress;DWORD dwActiveProcessorMask;DWORD dwNumberOfProcessors;DWORD dwProcessorType;DWORD dwAllocationGranularity;DWORD dwReserved;} SYSTEM_INFO, *LPSYSTEM_INFO;//函数VOID GlobalMemoryStatus （LPMEMORYSTATUS lpBuffer）;//数据结构MEMORYSTATUS 定义如下：typedef struct _ MEMORYSTATUS {DWORD dwLength;DWORD dwMemoryLoad;DWORD dwTotalPhys;DWORD dwAvailPhys;DWORD dwTotalPageFile;DWORD dwAvailPageFile;DWORD dwTotalVirtual;DWORD dwAvailVirtual;} MEMORYSTATUS, * LPMEMORYSTATUS;DWORD VirtualQuery （ LPCVOLD lpAddress,PMEMORY_BASIC_INFORMATION lpBuffer, DWORD dwLength）;//主要数据结构MEMORY_BASIC_INFORMATION 定义如下：typedef struct _ MEMORY_BASIC_INFORMATION {PVOID BaseAddress;PVOID AllocationBase;DWORD AllocationProtect;DWORD RegionSize;DWORD State;DWORD Protect;DWORD Type;} MEMORY_BASIC_INFORMATION;typedef MEMORY_BASIC_INFORMATION * PMEMORY_BASIC_INFORMATION;//还有一些函数，例如VirtualAlloc，VirtualAllocEx，VirtualFree 和VirtualFreeEx 等，用于虚拟内存的管理，详情请见Microsoft 的Win32 API Reference Manual。</code></pre><h2 id="六、项目地址"><a href="#六、项目地址" class="headerlink" title="六、项目地址"></a>六、项目地址</h2><p>本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看：</p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/666WXY666/czxt-mem" target="_blank"><img src="https://github-readme-stats.vercel.app/api/pin/?username=666WXY666&repo=czxt-mem&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/pin/?username=666WXY666&repo=czxt-mem&show_owner=true" srcset="data:image/png;base64,666"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文是操作系统内存管理的基本实验。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="https://666wxy666.github.io/categories/C-C/"/>
    
      <category term="操作系统" scheme="https://666wxy666.github.io/categories/C-C/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="C++" scheme="https://666wxy666.github.io/tags/C/"/>
    
      <category term="工程" scheme="https://666wxy666.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="操作系统" scheme="https://666wxy666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="内存管理" scheme="https://666wxy666.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>操作系统 读者写者(生产者消费者)</title>
    <link href="https://666wxy666.github.io/2020/09/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85(%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85)/"/>
    <id>https://666wxy666.github.io/2020/09/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85(%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85)/</id>
    <published>2020-09-02T16:00:00.000Z</published>
    <updated>2020-09-13T08:56:27.149Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>本文是操作系统进程同步互斥关于读者写者(生产者消费者)的基本实验。</strong></p><a id="more"></a><h2 id="一、需求"><a href="#一、需求" class="headerlink" title="一、需求"></a>一、需求</h2><p>本课程实验内容引自《Windows 内核实验教程》(陈向群、林斌等编著，机械工业出版社，2002.9)。</p><p>在Windows 环境下，创建一个包含n 个线程的控制进程。用这n 个线程来表示n个读者或写者。每个线程按相应测试数据文件的要求，进行读写操作。请用信号量机制分别实现读者优先和写者优先的读者-写者问题。</p><p>读者-写者问题的读写操作限制：</p><ul><li>写-写互斥</li><li>读-写互斥</li><li>读-读允许</li></ul><p>读者优先的附加限制：如果一个读者申请进行读操作时已有另一读者正在进行读操作，则该读者可直接开始读操作。</p><p>写者优先的附加限制：如果一个读者申请进行读操作时已有另一写者在等待访问共享资源，则该读者必须等到没有写者处于等待状态后才能开始读操作。</p><p>运行结果显示要求：要求在每个线程创建、发出读写操作申请、开始读写操作和结束读写操作时分别显示一行提示信息，以确信所有处理都遵守相应的读写操作限制。</p><h2 id="二、运行环境"><a href="#二、运行环境" class="headerlink" title="二、运行环境"></a>二、运行环境</h2><p>电脑硬件配置：</p><ul><li><p>处理器：Intel i7 7700HQ</p></li><li><p>显卡：NVIDIA GeForce GTX 1050 Ti</p></li><li><p>内存：16GB</p></li></ul><p>软件：</p><ul><li><p>编程语言：C++</p></li><li><p>IDE：Microsoft Visual Studio 2019</p></li><li><p>Windows SDK版本：10.0</p></li><li><p>平台工具集：Visual Studio 2019（v142）</p></li></ul><h2 id="三、核心算法"><a href="#三、核心算法" class="headerlink" title="三、核心算法"></a>三、核心算法</h2><h3 id="读者优先："><a href="#读者优先：" class="headerlink" title="读者优先："></a>读者优先：</h3><pre><code class="c">//信号量：mutex=1;//对read_count的互斥操作RP_Write=1;//保证读者优先，读者与写者互斥//读者：wait(mutex);read_count++;if(read_count==1)    wait(&amp;RP_Write);signal(mutex);读临界区……wait(mutex);read_count--;if(read_count==0)    signal(&amp;RP_Write);signal(mutex);//写者：wait(&amp;RP_Write);写临界区……signal(&amp;RP_Write);</code></pre><h3 id="写者优先："><a href="#写者优先：" class="headerlink" title="写者优先："></a>写者优先：</h3><pre><code class="c">//信号量：mutex1=1;//保证每个读者按顺序依次进入临界区mutex2=1;//对read_count的互斥操作mutex3=1;//对write_count的互斥操作cs_Read =1;//保证写者优先，读者与写者互斥cs_Write=1;//保证如果有读者正在读，写者等待当前读者读完后再写//读者：wait(mutex1);wait(&amp;cs_Read);wait(mutex2);read_count++;if(read_count==1)    wait(&amp;cs_Write);signal(mutex2);signal(&amp;cs_Read);signal(mutex1);读临界区……wait(mutex2);read_count--;if(read_count==0)    signal(&amp;cs_Write);signal(mutex2);//写者：wait(mutex3);write_count++;if(write_count==1)    wait(&amp;cs_Read);signal(mutex3);wait(&amp;cs_Write);写临界区……signal(&amp;cs_Write);wait(mutex3);write_count--;if(write_count==0)    signal(&amp;cs_Read);signal(mutex3);</code></pre><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><ol><li>屏幕输入：<ul><li>1则选择读者优先，调用ReaderPriority(“thread.dat”)函数；</li><li>2则选择写者优先，调用WriterPriority(“thread.dat”)函数；</li><li>3则退出。</li></ul></li><li>从thread.dat文件读入读者写者线程信息。<h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3>屏幕输出各读者写者线程信息。</li></ol><h2 id="五、测试样例："><a href="#五、测试样例：" class="headerlink" title="五、测试样例："></a>五、测试样例：</h2><ol><li><p>输入1</p><p>可以看出，写者进程4、2、6虽然都请求了写操作，但是却是等待所有的读者1、3、5读完了再按顺序进行的写入操作，符合读者优先的要求。</p></li><li><p>输入2</p><p>可以看出，除了第一个读者进程1在读文件外，虽然读者3、5都请求了读操作，但由于写者进程4、2、6请求了写操作，因为写者优先，所以读者3、5都要等待写者4、2、6写入完成才能读，而写者4、2、6必须等待读者进程1读操作完成后才能写。读者1读操作完成后，写者4、2、6按顺序写入文件，写入完成后，读者3、5同时读文件，符合写者优先的要求。</p></li><li><p>输入3</p><p>释放线程，程序退出。</p></li></ol><table><thead><tr><th><img src="https://gitee.com/wxy_666/images/raw/master/20200902162507.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200902162507.png" srcset="data:image/png;base64,666" alt="1" style="zoom:80%;"></th><th><img src="https://gitee.com/wxy_666/images/raw/master/20200902162646.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200902162646.png" srcset="data:image/png;base64,666" alt="2" style="zoom:80%;"></th></tr></thead><tbody><tr><td><img src="https://gitee.com/wxy_666/images/raw/master/20200902162709.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200902162709.png" srcset="data:image/png;base64,666" alt="3" style="zoom:80%;"></td><td><img src="https://gitee.com/wxy_666/images/raw/master/20200902162718.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200902162718.png" srcset="data:image/png;base64,666" alt="4" style="zoom:80%;"></td></tr><tr><td><img src="https://gitee.com/wxy_666/images/raw/master/20200902162729.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200902162729.png" srcset="data:image/png;base64,666" alt="5" style="zoom:80%;"></td><td></td></tr></tbody></table><h2 id="六、项目地址"><a href="#六、项目地址" class="headerlink" title="六、项目地址"></a>六、项目地址</h2><p>本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看：</p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/666WXY666/czxt-readerwriter" target="_blank"><img src="https://github-readme-stats.vercel.app/api/pin/?username=666WXY666&repo=czxt-readerwriter&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/pin/?username=666WXY666&repo=czxt-readerwriter&show_owner=true" srcset="data:image/png;base64,666"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文是操作系统进程同步互斥关于读者写者(生产者消费者)的基本实验。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="https://666wxy666.github.io/categories/C-C/"/>
    
      <category term="操作系统" scheme="https://666wxy666.github.io/categories/C-C/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="C++" scheme="https://666wxy666.github.io/tags/C/"/>
    
      <category term="工程" scheme="https://666wxy666.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="操作系统" scheme="https://666wxy666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="读者写者" scheme="https://666wxy666.github.io/tags/%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85/"/>
    
      <category term="生产者消费者" scheme="https://666wxy666.github.io/tags/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    
      <category term="进程" scheme="https://666wxy666.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="同步互斥" scheme="https://666wxy666.github.io/tags/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/"/>
    
      <category term="信号量" scheme="https://666wxy666.github.io/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统 进程线程管理通信与同步互斥</title>
    <link href="https://666wxy666.github.io/2020/09/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86%E9%80%9A%E4%BF%A1%E4%B8%8E%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/"/>
    <id>https://666wxy666.github.io/2020/09/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86%E9%80%9A%E4%BF%A1%E4%B8%8E%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/</id>
    <published>2020-09-02T16:00:00.000Z</published>
    <updated>2020-09-13T08:56:21.911Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文是操作系统课程设计关于进程线程管理通信与同步互斥的综合实验<em>（长文警告）</em>。</p><a id="more"></a><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><ol><li>以OpenEuler等Linux操作系统为实验对象，加深对Linux进程、线程概念的理解，掌握利用Linux系统调用创建、管理进程的方法，掌握利用POSIX线程（Pthread）库创建管理线程的方法，认识进程、线程并发执行的实质；</li><li>深入理解Linux内核提供的消息队列、共享内存、管道、软中断四种进程间通信机制，掌握利用系统调用实现进程间通信；</li><li>了解Pthread线程库提供的线程间通信机制，掌握使用Pthread API实现线程间通信的方法；</li><li>深入理解Linux系统提供的多种进程同步互斥机制，掌握使用信号量实现进程间的同步互斥的方法；</li><li>了解Pthread提供的线程同步互斥机制，掌握使用互斥变量和条件变量实现多线程间的同步互斥的方法</li></ol><h2 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="二、实验环境"></a>二、实验环境</h2><p>硬件：</p><ul><li>Intel i7 7700HQ，内存16GB</li></ul><p>软件：</p><ul><li>虚拟机：VMware Workstation Pro 15.5.6</li><li>Linux系统：华为openEuler-20.03-LTS-x86_64</li><li>Pthread线程库，POSIX接口</li><li>gcc编译</li><li>C语言</li></ul><h2 id="三、实验内容"><a href="#三、实验内容" class="headerlink" title="三、实验内容"></a>三、实验内容</h2><p>在Linux环境下，采用C/C++/Java（或其它语言）编程，完成以下实验内容。</p><h3 id="1、第一组-进程的创建与管理"><a href="#1、第一组-进程的创建与管理" class="headerlink" title="1、第一组 进程的创建与管理"></a>1、第一组 进程的创建与管理</h3><ol><li><p>阅读Linux内核源码，分析Linux进程的组成，观察进PCB/task_struc等进程管理数据结构；</p></li><li><p>利用Linux内核提供的<code>fork()</code>、<code>exec()</code>、<code>wait()</code>等系统调用，创建管理多个进程，观察父子进程的结构和并发行为，掌握睡眠、撤销等进程控制方法；</p></li><li><p>掌握<code>ps</code>、<code>top</code>、<code>pstree –h</code>、<code>vmstat</code>、<code>strace</code>、<code>ltrace</code>、<code>sleep x</code>、<code>kill</code>、<code>jobs</code>等命令的功能和使用方式；</p></li></ol><h3 id="2、第二组-线程的创建与管理"><a href="#2、第二组-线程的创建与管理" class="headerlink" title="2、第二组 线程的创建与管理"></a>2、第二组 线程的创建与管理</h3><ol><li><p>了解POSIX 线程标准库（Pthread线程库）定义的线程结构和提供的线程管理API；</p></li><li><p>利用Pthread线程库API，创建管理多个线程，观察线程的结构和并发执行行为；</p></li></ol><h3 id="3、第三-四组-进程-线程通信"><a href="#3、第三-四组-进程-线程通信" class="headerlink" title="3、第三/四组 进程/线程通信"></a>3、第三/四组 进程/线程通信</h3><ol><li><p>了解Linux提供的消息队列、共享内存、管道、软中断Signal等四种通信机制，编程实现进程间通信；</p></li><li><p>线程通信</p><p>了解Linux所支持的线程机制，在一个进程内创建多个主从线程，采用参数传递机制，实现线程间通信；</p></li></ol><h3 id="4、第五组-进程-线程同步互斥"><a href="#4、第五组-进程-线程同步互斥" class="headerlink" title="4、第五组 进程/线程同步互斥"></a>4、第五组 进程/线程同步互斥</h3><p>要求：参照2019-2020学年操作系统期末考试信号量题目，设计实现三个进程/线程A、B、C，分别模拟题目所描述的生产产品A、B、C的三个worker，观察并记录进程/线程的创建和同步互斥行为。重点分析信号量设计方案是否合理、符合预期，避免设计方案导致死锁或不符合题目要求。</p><p>期末考试试题如下：</p><blockquote><p>An assembly line is to produce a product C with four part As, and three part Bs. The worker of machining(加工) A and worker of machining B will produce two part As and one part B independently each time. Then the two part As or one part B will be moved to the station(工作台), which can hold at most 12 of part As and part Bs altogether. Two part As must be put onto the station simultaneously. The workers must exclusively put a part on the station or get it from the station. In addition, the worker to make C must get all part of As and Bs for one product once. </p><p>Using semaphores to coordinate the three workers who are machining part A, part B and the product C to manufacture the product without deadlock. </p><p>It is required that</p><p>(1) definition and initial value of each semaphore, and</p><p>(2) the algorithm to coordinate the production process for the three workers should be given.</p></blockquote><ol><li><p>进程同步互斥</p><p>创建3个Linux进程，分别模拟生产产品A、B、C的三个worker的行为，利用Linux内核信号量，实现三者间正确的同步互斥；</p></li><li><p>线程同步互斥</p><p>利用Pthread API，创建3个Linux线程，分别模拟生产产品A、B、C的三个worker的行为，采用Pthread提供的信号量/管程机制，现三者间正确的同步互斥；</p></li></ol><h2 id="四、实验步骤"><a href="#四、实验步骤" class="headerlink" title="四、实验步骤"></a>四、实验步骤</h2><h3 id="0、实验环境配置"><a href="#0、实验环境配置" class="headerlink" title="0、实验环境配置"></a>0、实验环境配置</h3><h4 id="0-1-Linux-操作系统安装"><a href="#0-1-Linux-操作系统安装" class="headerlink" title="0-1. Linux 操作系统安装"></a>0-1. Linux 操作系统安装</h4><ul><li><p>选择OpenEuler等Linux发行版本，观察所采用的内核版本，采用硬盘分区模式安装Linux系统；</p></li><li><p>也可以先在本机操作系统上安装VitualBox、VMware、Virtual PC等虚拟机软件，在虚拟机之上安装Linux系统。</p></li></ul><p>注意安装操作系统所需的软硬件环境和硬件配置要求。</p><h4 id="0-2-Pthread-线程库安装"><a href="#0-2-Pthread-线程库安装" class="headerlink" title="0-2. Pthread 线程库安装"></a>0-2. Pthread 线程库安装</h4><p>观察确认所安装的Linux发行版本带有Pthread线程库，注意：</p><ol><li>某些版本Ubuntu  Linux默认不带Pthread线程库，即使在编译的度时候 加上<code>-lpthread</code>也不行，man不到相关Pthread函知数。此时，需要在<code>/usr/lib/…</code>下导入动态库<code>libpthread.a</code>，具体方法可以查阅网上相关资料。</li><li>后续编程时导入头文件：<code>#include &lt;pthread.h&gt;</code></li></ol><p>因为我电脑早已经安装了VMware虚拟机，就不重新安装了，直接下载安装OpenEuler。</p><h5 id="1、下载OpenEuler"><a href="#1、下载OpenEuler" class="headerlink" title="1、下载OpenEuler"></a>1、下载OpenEuler</h5><ol><li><p>进入<a href="https://openeuler.org/zh/releases.html" target="_blank" rel="external nofollow noopener noreferrer">OpenEuler下载页面</a>，下载openEuler-20.03-LTS-x86_64-dvd.iso镜像。</p><img src="https://gitee.com/wxy_666/images/raw/master/20200626132252.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626132252.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_111556" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200626132326.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626132326.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_111616" style="zoom:80%;"></li><li><p>等待下载完成。</p><img src="https://gitee.com/wxy_666/images/raw/master/20200626132420.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626132420.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_132410" style="zoom:80%;"></li></ol><h5 id="2、创建虚拟机"><a href="#2、创建虚拟机" class="headerlink" title="2、创建虚拟机"></a>2、创建虚拟机</h5><ol><li><p>打开VMware Workstation Pro，选择“创建新的虚拟机”。</p><img src="https://gitee.com/wxy_666/images/raw/master/20200626132611.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626132611.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_132601" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200626132632.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626132632.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_112633" style="zoom:80%;"></li><li><p>选择“自定义”。</p><img src="https://gitee.com/wxy_666/images/raw/master/20200626132719.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626132719.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_112704" style="zoom:80%;"></li><li><p>设置虚拟机的硬件兼容性限制，按照默认选择。</p><img src="https://gitee.com/wxy_666/images/raw/master/20200626132800.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626132800.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_112725" style="zoom:80%;"></li><li><p>选择下载好的openEuler-20.03-LTS-x86_64-dvd.iso镜像。</p><img src="https://gitee.com/wxy_666/images/raw/master/20200626132854.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626132854.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_112750" style="zoom:80%;"></li><li><p>选择Linux 操作系统。</p><img src="https://gitee.com/wxy_666/images/raw/master/20200626132954.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626132954.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_112826" style="zoom:80%;"></li><li><p>配置虚拟机的名称，位置，处理器，内存，网络连接、控制器、磁盘等。</p><img src="https://gitee.com/wxy_666/images/raw/master/20200626133108.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626133108.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_112858" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200626133116.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626133116.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_112918" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200626133123.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626133123.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_112938" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200626133132.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626133132.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_112954" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200626133231.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626133231.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_113009" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200626133250.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626133250.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_113016" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200626133416.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626133416.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_113024" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200626133512.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626133512.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_113115" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200626133604.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626133604.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_113126" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200626133611.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626133611.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_113133" style="zoom:80%;"></li></ol><ol start="7"><li><p>创建完成。</p><img src="https://gitee.com/wxy_666/images/raw/master/20200626133817.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626133817.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_113152" style="zoom:80%;"></li></ol><h5 id="3、安装OpenEuler"><a href="#3、安装OpenEuler" class="headerlink" title="3、安装OpenEuler"></a>3、安装OpenEuler</h5><ol><li><p>启动虚拟机。</p><p><img src="https://gitee.com/wxy_666/images/raw/master/20200626133904.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626133904.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_113202"></p></li><li><p>选择第一项安装OpenEuler。</p><img src="https://gitee.com/wxy_666/images/raw/master/20200626133936.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626133936.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_113235" style="zoom:80%;"></li><li><p>等待check完毕。</p><img src="https://gitee.com/wxy_666/images/raw/master/20200626134003.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626134003.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_113312" style="zoom:80%;"></li><li><p>选择安装过程中所使用的语言。</p><img src="https://gitee.com/wxy_666/images/raw/master/20200626134034.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626134034.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_113357" style="zoom:80%;"></li><li><p>选择分区和软件模块，点击“开始安装”后，开始安装系统，在安装期间可以设置Root密码以及创建用户。</p><img src="https://gitee.com/wxy_666/images/raw/master/20200626134155.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626134155.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_113456" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200626134341.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626134341.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_113619" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200626134350.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626134350.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_113643" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200626134418.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626134418.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_113726" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200626134431.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626134431.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_113805" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200626134504.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626134504.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_113813" style="zoom:80%;"></li></ol><ol start="6"><li><p>安装完成。</p><img src="https://gitee.com/wxy_666/images/raw/master/20200626134548.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626134548.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_114538" style="zoom:80%;"></li><li><p>重启后登录OpenEuler系统。</p><img src="https://gitee.com/wxy_666/images/raw/master/20200626134624.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626134624.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_114615" style="zoom:80%;"></li><li><p>创建的wxy用户以及root用户均可以成功登录，安装OpenEuler完成。</p><img src="https://gitee.com/wxy_666/images/raw/master/20200626134930.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626134930.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_134836" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200626134938.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200626134938.jpg" srcset="data:image/png;base64,666" alt="2020-06-26_134905" style="zoom:80%;"></li></ol><h3 id="1、第一组-进程的创建与管理-1"><a href="#1、第一组-进程的创建与管理-1" class="headerlink" title="1、第一组 进程的创建与管理"></a>1、第一组 进程的创建与管理</h3><h4 id="实验1-1-进程观察"><a href="#实验1-1-进程观察" class="headerlink" title="实验1-1. 进程观察"></a>实验1-1. 进程观察</h4><p>查阅相关资料，阅读Linux内核源码，分析Linux进程的组成，了解进程状态，观察进PCB/task_struc等进程管理数据结构；</p><h4 id="实验1-2-进程创建与管理"><a href="#实验1-2-进程创建与管理" class="headerlink" title="实验1-2. 进程创建与管理"></a>实验1-2. 进程创建与管理</h4><p>参照**<em>“【实验指导】1. 进程创建及管理示例”**</em>中的程序，结合所查阅的参考资料，利用Linux内核提供的<code>fork()</code>、<code>exec()</code>、<code>wait()</code>、<code>exit()</code>、<code>kill()</code>等系统调用，创建管理多个进程，观察父子进程的结构和并发行为，掌握睡眠、撤销等进程控制方法；</p><p>要求：本组实验至少用到<code>fork()</code>、<code>exec()</code>、<code>wait()</code>、<code>exit()</code>、<code>kill()</code>、<code>getpid()</code>五个系统调用。</p><h5 id="1-2-1-fork"><a href="#1-2-1-fork" class="headerlink" title="1-2-1 fork()"></a>1-2-1 <code>fork()</code></h5><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char **argv){    __pid_t pid;    if ((pid = fork()) &gt; 0)    {        printf(&quot;I am the parent process.\n&quot;);        /*父进程处理过程*/    }    else if (pid == 0)    {        printf(&quot;I am the child process.\n&quot;);        /*子进程处理过程*/    }    else    {        printf(&quot;fork error\n&quot;);        exit(0);    }}</code></pre><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200512_200044.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200512_200044.png" srcset="data:image/png;base64,666" alt="Screenshot_20200512_200044" style="zoom:80%;"><ul><li>fork的返回值如果是&gt;0，那么就是父进程，这个&gt;0的返回值就是创建的子进程的PID；</li><li>fork的返回值如果是=0，那么就是子进程；</li><li>fork的返回值如果是&lt;0，那么就是fork失败；</li></ul><h5 id="1-2-2-exec"><a href="#1-2-2-exec" class="headerlink" title="1-2-2 exec()"></a>1-2-2 <code>exec()</code></h5><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char **argv){    char *envp[] = {&quot;PATH=/tmp&quot;, &quot;USER = 1ei&quot;, &quot;STATUS = testing&quot;, NULL};    char *argv_execv[] = {&quot;echo&quot;, &quot;excuted by execv&quot;, NULL};    char *argv_execvp[] = {&quot;echo&quot;, &quot;excuted by execvp&quot;, NULL};    char *argv_execve[] = {&quot;env&quot;, NULL};    if (fork() == 0)    {        if (execl(&quot;/bin/echo&quot;, &quot;echo&quot;, &quot;executed by execl&quot;, NULL) &lt; 0)            perror(&quot;Err on execl&quot;);    }    if (fork() == 0)    {        if (execlp(&quot;echo&quot;, &quot;echo&quot;, &quot;executed by execlp&quot;, NULL) &lt; 0)            perror(&quot;Err on execlp&quot;);    }    if (fork() == 0)    {        if (execle(&quot;/usr/bin/env&quot;, &quot;env&quot;, NULL, envp) &lt; 0)            perror(&quot;Err on execle&quot;);    }    if (fork() == 0)    {        if (execv(&quot;/bin/echo&quot;, argv_execv) &lt; 0)            perror(&quot;Err on execv&quot;);    }    if (fork() == 0)    {        if (execvp(&quot;echo&quot;, argv_execvp) &lt; 0)            perror(&quot;Err on execvp&quot;);    }    if (fork() == 0)    {        if (execve(&quot;/usr/bin/env&quot;, argv_execve, envp) &lt; 0)            perror(&quot;Err on execve&quot;);    }}</code></pre><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200512_200606.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200512_200606.png" srcset="data:image/png;base64,666" alt="Screenshot_20200512_200606" style="zoom:80%;"><p>exec用一个指定的程序文件,重新初始化一个进程。</p><ul><li><p>可指定新的命令行参数和环境参数(初始化堆栈底部)。</p></li><li><p>exec不创建新进程,只是将当前进程重新初始化了指令段和用户数据段,堆栈段以及CPU的PC指针。</p></li></ul><p>6种格式exec系统调用，exec前缀,后跟以下字母：</p><ul><li><p>l—list，v—vector</p><p>l与v:指定命令行参数的两种方式，l以表的形式，v要事先组织成一个指针数组。</p></li><li><p>e—env</p><p>需要指定envp来初始化进程。</p></li><li><p>p—path</p><p>使用环境变量PATH查找可执行文件。</p></li></ul><h5 id="1-2-3-wait"><a href="#1-2-3-wait" class="headerlink" title="1-2-3 wait()"></a>1-2-3 <code>wait()</code></h5><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char **argv){    __pid_t pid;    if ((pid = fork()) &gt; 0)    {        int status, wait_pid;        printf(&quot;I am the parent process.\n&quot;);        wait_pid = wait(&amp;status);        printf(&quot;pid=%d,wait_pid=%d\n&quot;, pid, wait_pid);        printf(&quot;status=%#X,WTERMSIG=%d,WEXITSTATUS=%d\n&quot;, status, WTERMSIG(status), WEXITSTATUS(status));        /*父进程处理过程*/    }    else if (pid == 0)    {        int i;        for (i = 0; i &lt; 3; i++)        {            printf(&quot;I am the child process.\n&quot;);            sleep(1);        }        /*子进程处理过程*/        exit(5);    }    else    {        printf(&quot;fork error\n&quot;);        exit(0);    }}</code></pre><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200512_203430.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200512_203430.jpg" srcset="data:image/png;base64,666" alt="Screenshot_20200512_203430" style="zoom:80%;"><ul><li><p>函数返回值为已终止的子进程PID。</p></li><li><p>status中含有子进程终止的原因。</p><ul><li>TERMSIG(status)为被杀信号。</li><li>EXITSTATUS(status)为退出码。</li></ul></li></ul><p>子进程正常退出，且退出码为5，因此wait的status退出码刚好是5。</p><h5 id="1-2-4-kill"><a href="#1-2-4-kill" class="headerlink" title="1-2-4 kill()"></a>1-2-4 <code>kill()</code></h5><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char **argv){    __pid_t pid;    if ((pid = fork()) &gt; 0)    {        int status;        printf(&quot;I am the parent process.\n&quot;);        sleep(3);        kill(pid, 5);        wait(&amp;status);        printf(&quot;%#X,%d,%d\n&quot;, status, WTERMSIG(status), WEXITSTATUS(status));        /*父进程处理过程*/    }    else if (pid == 0)    {        while (1)        {            printf(&quot;I am the child process.\n&quot;);            sleep(1);        }        /*子进程处理过程*/        exit(0);    }    else    {        printf(&quot;fork error\n&quot;);        exit(0);    }}</code></pre><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200512_214107.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200512_214107.png" srcset="data:image/png;base64,666" alt="Screenshot_20200512_214107" style="zoom:80%;"><p>可以发现子进程被父进程杀掉了，且终止码为5，刚好wait的终止码也是5。</p><h5 id="1-2-5-getpid"><a href="#1-2-5-getpid" class="headerlink" title="1-2-5 getpid()"></a>1-2-5 <code>getpid()</code></h5><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char **argv){    __pid_t pid;    if ((pid = fork()) &gt; 0)    {        printf(&quot;I am the parent process.\tpid=%d,child_pid=%d\n&quot;, getpid(), pid);        /*父进程处理过程*/    }    else if (pid == 0)    {        printf(&quot;I am the child process.\t\tpid=%d,ppid=%d\n&quot;, getpid(), getppid());        /*子进程处理过程*/        exit(0);    }    else    {        printf(&quot;fork error\n&quot;);        exit(0);    }}</code></pre><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200512_214652.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200512_214652.png" srcset="data:image/png;base64,666" alt="Screenshot_20200512_214652" style="zoom:80%;"><p>可以发现，父进程打印的子进程pid和子进程的pid相等，子进程打印的父进程的pid也和父进程的pid相等。</p><h4 id="实验1-3-进程管理命令"><a href="#实验1-3-进程管理命令" class="headerlink" title="实验1-3. 进程管理命令"></a>实验1-3. 进程管理命令</h4><p>了解<code>ps</code>、<code>top</code>、<code>pstree –h</code>、<code>vmstat</code>、<code>strace</code>、<code>ltrace</code>、<code>sleep x</code>、<code>kill</code>、<code>jobs</code>等命令的功能，使用这些命令观察进程结构和行为；</p><h5 id="1-3-1-ps"><a href="#1-3-1-ps" class="headerlink" title="1-3-1 ps"></a>1-3-1 <code>ps</code></h5><p>查看正在运行的进程。</p><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200512_214908.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200512_214908.png" srcset="data:image/png;base64,666" alt="Screenshot_20200512_214908" style="zoom:80%;"><h5 id="1-3-2-top"><a href="#1-3-2-top" class="headerlink" title="1-3-2 top"></a>1-3-2 <code>top</code></h5><p>top查看进程相关信息。</p><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200512_215333.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200512_215333.png" srcset="data:image/png;base64,666" alt="Screenshot_20200512_215333" style="zoom:80%;"><h5 id="1-3-3-pstree-–h"><a href="#1-3-3-pstree-–h" class="headerlink" title="1-3-3 pstree –h"></a>1-3-3 <code>pstree –h</code></h5><p>pstree查看进程树。</p><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200512_215518.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200512_215518.png" srcset="data:image/png;base64,666" alt="Screenshot_20200512_215518" style="zoom:80%;"><h5 id="1-3-4-vmstat"><a href="#1-3-4-vmstat" class="headerlink" title="1-3-4 vmstat"></a>1-3-4 <code>vmstat</code></h5><p>vmstat可以查看系统相关信息。</p><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200512_215555.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200512_215555.png" srcset="data:image/png;base64,666" alt="Screenshot_20200512_215555" style="zoom:80%;"><h5 id="1-3-5-strace"><a href="#1-3-5-strace" class="headerlink" title="1-3-5 strace"></a>1-3-5 <code>strace</code></h5><p>先运行这个程序（ltrace、kill、jobs也是一样）：</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char **argv){    __pid_t pid;    if ((pid = fork()) &gt; 0)    {        while (1)        {            printf(&quot;I am the parent process.\tpid=%d,child_pid=%d\n&quot;, getpid(), pid);            sleep(3);        }        /*父进程处理过程*/    }    else if (pid == 0)    {        while (1)        {            printf(&quot;I am the child process.\t\tpid=%d,ppid=%d\n&quot;, getpid(), getppid());            sleep(3);        }        /*子进程处理过程*/        exit(0);    }    else    {        printf(&quot;fork error\n&quot;);        exit(0);    }}</code></pre><p>屏幕输出：</p><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200512_215842.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200512_215842.png" srcset="data:image/png;base64,666" alt="Screenshot_20200512_215842" style="zoom:80%;"><p>strace就相当于是调试信息：</p><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200512_215937.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200512_215937.png" srcset="data:image/png;base64,666" alt="Screenshot_20200512_215937" style="zoom:80%;"><h5 id="1-3-6-ltrace"><a href="#1-3-6-ltrace" class="headerlink" title="1-3-6 ltrace"></a>1-3-6 <code>ltrace</code></h5><p>ltrace也是同理。</p><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200512_220010.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200512_220010.png" srcset="data:image/png;base64,666" alt="Screenshot_20200512_220010" style="zoom:80%;"><h5 id="1-3-7-sleep-x"><a href="#1-3-7-sleep-x" class="headerlink" title="1-3-7 sleep x"></a>1-3-7 <code>sleep x</code></h5><p>睡眠了3s后继续输出。</p><p><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200512_220200.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200512_220200.png" srcset="data:image/png;base64,666" alt="Screenshot_20200512_220200"></p><h5 id="1-3-8-kill"><a href="#1-3-8-kill" class="headerlink" title="1-3-8 kill"></a>1-3-8 <code>kill</code></h5><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200512_220353.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200512_220353.png" srcset="data:image/png;base64,666" alt="Screenshot_20200512_220353" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200512_220330.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200512_220330.png" srcset="data:image/png;base64,666" alt="Screenshot_20200512_220330" style="zoom:80%;"><p>运行kill后只有父进程输出，子进程被杀掉了。</p><h5 id="1-3-9-jobs"><a href="#1-3-9-jobs" class="headerlink" title="1-3-9 jobs"></a>1-3-9 <code>jobs</code></h5><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200512_221109.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200512_221109.png" srcset="data:image/png;base64,666" alt="Screenshot_20200512_221109" style="zoom:80%;"><p>jobs查看已挂载的程序,不用携带任何参数，这里查看了正在后台运行的1-2-5程序。</p><h3 id="2、第二组-线程的创建与管理-1"><a href="#2、第二组-线程的创建与管理-1" class="headerlink" title="2、第二组 线程的创建与管理"></a>2、第二组 线程的创建与管理</h3><h4 id="实验2-1-Pthread线程库背景知识"><a href="#实验2-1-Pthread线程库背景知识" class="headerlink" title="实验2-1. Pthread线程库背景知识"></a>实验2-1. Pthread线程库背景知识</h4><p>了解POSIX 线程标准库（Pthread线程库）相关知识，分析Pthread线程结构，掌握所提供的线程管理API，如<code>pthread_create()</code>, <code>pthread_join()</code>, <code>pthread_self()</code>, <code>pthread_detach()</code>, <code>pthread_exit()</code>；</p><h4 id="实验2-2-线程创建与管理"><a href="#实验2-2-线程创建与管理" class="headerlink" title="实验2-2. 线程创建与管理"></a>实验2-2. 线程创建与管理</h4><p>参照**<em>“【实验指导】 2. 线程创建及管理程序示例”**</em>，查阅参考资料，利用Pthread API，创建和管理线程，观察线程的结构和并发执行行为；</p><p>要求：本组实验至少用到<code>pthread_create()</code>, <code>pthread_exit()</code>,<code>pthread_join()</code>, <code>pthread_self()</code>等四个API。</p><h5 id="2-2-1-pthread-create"><a href="#2-2-1-pthread-create" class="headerlink" title="2-2-1 pthread_create()"></a>2-2-1 <code>pthread_create()</code></h5><p>函数原型：</p><pre><code class="c">#include&lt;pthread.h&gt;int pthread_create(pthread_t *thread，pthread_attr_t*attr，void*(*start_routine)(void *), void *arg)</code></pre><p>函数说明：创建线程。</p><p>参数和返回值：</p><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">thread</td><td align="center">该参数是指向线程标识符的指针，当线程创建成功时，用来返回创建的线程ID</td></tr><tr><td align="center">attr</td><td align="center">该参数用于指定线程的属性，NULL表示使用默认属性</td></tr><tr><td align="center">start_routine</td><td align="center">该参数为一个函数指针，指向线程创建后要调用的函数，是一个以指向void的指针作为参数和返回值的函数指针，这个被线程调用的函数也被称为线程函数</td></tr><tr><td align="center">arg</td><td align="center">指向传递给线程函数的参数，NULL代表不传参数</td></tr><tr><td align="center">返回值</td><td align="center">成功：0<br>出错：返回错误码</td></tr></tbody></table><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;void *mythread1(void *arg){    int i;    for (i = 0; i &lt; 5; i++)    {        printf(&quot;I am thread 1\n&quot;);        sleep(2);    }}void *mythread2(void *arg){    int i;    for (i = 0; i &lt; 5; i++)    {        printf(&quot;I am thread 2\n&quot;);        sleep(2);    }}int main(int argc, char const *argv[]){    pthread_t id1, id2;    int res;    res = pthread_create(&amp;id1, NULL, mythread1, NULL);    if (res)    {        printf(&quot;Create pthread error!\n&quot;);        return -1;    }    res = pthread_create(&amp;id2, NULL, mythread2, NULL);    if (res)    {        printf(&quot;Create pthread error!\n&quot;);        return -2;    }    pthread_join(id1, NULL);    pthread_join(id2, NULL);    return 0;}</code></pre><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200513_085544.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200513_085544.png" srcset="data:image/png;base64,666" alt="Screenshot_20200513_085544" style="zoom:80%;"><p>可以发现，创建了两个线程：thread1和thread2。两个线程分别打印自己的信息，等带2s后继续打印。</p><h5 id="2-2-2-pthread-exit"><a href="#2-2-2-pthread-exit" class="headerlink" title="2-2-2 pthread_exit()"></a>2-2-2 <code>pthread_exit()</code></h5><p>函数原型：</p><pre><code class="c">#include&lt;pthread.h&gt;void pthread_exit(void *retval)</code></pre><p>函数说明：线程退出。</p><p>参数和返回值：</p><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Rretval</td><td align="center">线程结束时的返回值,可由其它函数如pthread_join0来获取</td></tr><tr><td align="center">返回值</td><td align="center">void</td></tr></tbody></table><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;void *create(void *arg){    printf(&quot;New thread is create...\n&quot;);    pthread_exit((void *)6);}int main(int argc, char const *argv[]){    pthread_t tid;    int res;    void *temp;    res = pthread_create(&amp;tid, NULL, create, NULL);    printf(&quot;I am the main thread!\n&quot;);    if (res)    {        printf(&quot;thread id not create...\n&quot;);        return -1;    }    res = pthread_join(tid, &amp;temp);    if (res)    {        printf(&quot;thread is not exit...\n&quot;);        return -2;    }    printf(&quot;Thread is exit code %ld \n&quot;, (long)temp);    return 0;}</code></pre><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200513_093431.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200513_093431.png" srcset="data:image/png;base64,666" alt="Screenshot_20200513_093431" style="zoom:80%;"><p>可以发现，子线程退出，主线程接收到了子线程的退出码6。</p><h5 id="2-2-3-pthread-join"><a href="#2-2-3-pthread-join" class="headerlink" title="2-2-3 pthread_join()"></a>2-2-3 <code>pthread_join()</code></h5><p>函数原型：</p><pre><code class="c">#include&lt;pthread.h&gt;int pthread_join(pthread_t thread，void **thread_return)</code></pre><p>函数说明：线程等待。</p><p>参数和返回值：</p><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">thread</td><td align="center">等待退出的线程ID</td></tr><tr><td align="center">thread_return</td><td align="center">用于定义的指针，用来存储被等待线程结束时的返回值(不为NULL时)</td></tr><tr><td align="center">返回值</td><td align="center">成功：0<br>出错：返回错误码</td></tr></tbody></table><pre><code class="c">#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;void *thread(void *str){    int i;    for (i = 0; i &lt; 4; ++i)    {        sleep(2);        printf(&quot;This is the thread:%d\n&quot;, i);    }    return NULL;}int main(int argc, char const *argv[]){    pthread_t pth;    long i;    int ret = pthread_create(&amp;pth, NULL, thread, (void *)(i));    pthread_join(pth, NULL);    printf(&quot;123\n&quot;);    for (i = 0; i &lt; 3; ++i)    {        sleep(1);        printf(&quot;This is the main:%ld\n&quot;, i);    }    return 0;}</code></pre><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200513_094008.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200513_094008.png" srcset="data:image/png;base64,666" alt="Screenshot_20200513_094008" style="zoom:80%;"><p>可以发现主线程在调用pthread_join后等待子线程输出完毕结束后再进行的输出，相当于是主线程被阻塞。</p><h5 id="2-2-4-pthread-self"><a href="#2-2-4-pthread-self" class="headerlink" title="2-2-4 pthread_self()"></a>2-2-4 <code>pthread_self()</code></h5><p>函数原型：</p><pre><code class="c">#include&lt;pthread.h&gt;Pthread_t pthread_self(void)</code></pre><p>函数说明：获取调用线程的标识ID。</p><p>参数和返回值：</p><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">void</td><td align="center">无</td></tr><tr><td align="center">返回值</td><td align="center">返回调用该函数的线程的标识ID</td></tr></tbody></table><pre><code class="c">#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;void *create(void *arg){    printf(&quot;New thread...\n&quot;);    printf(&quot;This thread&#39;s id is %u \n&quot;, (unsigned int)pthread_self());    printf(&quot;This thread process pid is %d\n&quot;, getpid());    return NULL;}int main(int argc, char const *argv[]){    pthread_t tid;    int res;    printf(&quot;Main thread is starting...\n&quot;);    res = pthread_create(&amp;tid, NULL, create, NULL);    if (res)    {        printf(&quot;thread id not create...\n&quot;);        return -1;    }    printf(&quot;The main process pid is %d\n&quot;, getpid());    sleep(1);    return 0;}</code></pre><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200513_094649.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200513_094649.png" srcset="data:image/png;base64,666" alt="Screenshot_20200513_094649" style="zoom:80%;"><p>可以发现，子线程成功打印了自己的线程id，并且子线程的进程pid和主线程的进场pid相等，这也说明这两个线程属于同一个进程。</p><h5 id="2-2-5-pthread-cleanup-push-，pthread-cleanup-pop"><a href="#2-2-5-pthread-cleanup-push-，pthread-cleanup-pop" class="headerlink" title="2-2-5 pthread_cleanup_push()，pthread_cleanup_pop()"></a>2-2-5 <code>pthread_cleanup_push()</code>，<code>pthread_cleanup_pop()</code></h5><p>函数原型：</p><pre><code class="c">#include&lt;pthread.h&gt;void pthread_cleanup_push(void (*rtn)(void *), void *arg)</code></pre><p>函数说明：将清除函数压入清除栈</p><p>参数和返回值：</p><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">rtn</td><td align="center">清除函数</td></tr><tr><td align="center">arg</td><td align="center">清除函数的参数</td></tr><tr><td align="center">返回值</td><td align="center">void</td></tr></tbody></table><p>函数原型：</p><pre><code class="c">#include&lt;pthread.h&gt;void pthread_cleanup_pop(int execute)</code></pre><p>函数说明：将清除函数弹出清除栈</p><p>参数和返回值：</p><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">execute</td><td align="center">执行到pthread_cleanup_pop()时是否在弹出清理函数的同时执行该函数。<br>非0：执行；0：不执行</td></tr><tr><td align="center">返回值</td><td align="center">void</td></tr></tbody></table><pre><code class="c">#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;void *clean(void *arg){    printf(&quot;Cleanup %s\n&quot;, (char *)arg);    return (void *)0;}void *thr_fn1(void *arg){    printf(&quot;Thread1 start\n&quot;);    pthread_cleanup_push((void *)clean, &quot;Thread1 first handler&quot;);    pthread_cleanup_push((void *)clean, &quot;Thread1 second handler&quot;);    printf(&quot;Thread1 push complete\n&quot;);    if (arg)    {        return ((void *)1);    }    pthread_cleanup_pop(1);    pthread_cleanup_pop(1);    return (void *)2;}void *thr_fn2(void *arg){    printf(&quot;Thread2 start\n&quot;);    pthread_cleanup_push((void *)clean, &quot;Thread2 first handler&quot;);    pthread_cleanup_push((void *)clean, &quot;Thread2 second handler&quot;);    printf(&quot;Thread2 push complete\n&quot;);    if (arg)    {        return ((void *)3);    }    pthread_cleanup_pop(0);    pthread_cleanup_pop(1);    return (void *)4;}int main(int argc, char const *argv[]){    int res;    pthread_t tid1, tid2;    void *tret;    res = pthread_create(&amp;tid1, NULL, thr_fn1, (void *)1);    if (res != 0)    {        printf(&quot;Create theate error...\n&quot;);        return -1;    }    res = pthread_create(&amp;tid2, NULL, thr_fn2, (void *)0);    if (res != 0)    {        printf(&quot;Create theate error...\n&quot;);        return -1;    }    res = pthread_join(tid1, &amp;tret);    if (res != 0)    {        printf(&quot;Thread_join error...\n&quot;);        return -1;    }    printf(&quot;Thread1 exit code %ld\n&quot;, (long)tret);    res = pthread_join(tid2, &amp;tret);    if (res != 0)    {        printf(&quot;Thread_join error...\n&quot;);        return -1;    }    printf(&quot;Thread2 exit code %ld\n&quot;, (long)tret);    return 0;}</code></pre><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200513_141113.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200513_141113.png" srcset="data:image/png;base64,666" alt="Screenshot_20200513_141113" style="zoom:80%;"><ul><li>对于Thread1，传入的参数是1，因此函数thr_fn1只执行了两个pthread_cleanup_push，在pthread_cleanup_pop之前就return 1了，因此Thread1没有Cleanup输出，且返回码是1。</li><li>对于Thread2，传入的参数是0，因此函数thr_fn2在执行了两个pthread_cleanup_push后又执行了两个pthread_cleanup_pop，但是第一个pthread_cleanup_pop传的参数是0，第二个pthread_cleanup_pop传的参数是1，而且这个是栈的结构，第一个出栈的“Thread2 second handler”，参数为0，不清理；第二个出栈的“Thread2 first handler”，参数为1，清理。因此Thread2只有一个Cleanup输出（Thread2 first handler），且返回码是4。</li></ul><h5 id="2-2-6-综合"><a href="#2-2-6-综合" class="headerlink" title="2-2-6 综合"></a>2-2-6 综合</h5><pre><code class="c">#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#define THREAD_NUMBER 3        //线程数#define REPEAT_NUMBER 5        //每个线程中的小任务数#define DELAY_TIME_LEVELS 10.0 //小任务之间的最大时间间隔void *thrd_func(void *arg){    long thrd_num = (long)arg;    int delay_time = 0;    int count = 0;    printf(&quot;Thread %ld is starting\n&quot;, thrd_num);    for (count = 0; count &lt; REPEAT_NUMBER; count++)    {        delay_time = (int)(rand() * DELAY_TIME_LEVELS / (RAND_MAX)) + 1;        sleep(delay_time);        printf(&quot;\tThread %ld:job %d delay=%d\n&quot;, thrd_num, count, delay_time);    }    printf(&quot;Thread %ld finished\n&quot;, thrd_num);    pthread_exit(NULL);}int main(int argc, char const *argv[]){    pthread_t thread[THREAD_NUMBER];    long no, res;    void *thrd_ret;    srand(time(NULL));    for (no = 0; no &lt; THREAD_NUMBER; no++)    {        res = pthread_create(&amp;thread[no], NULL, thrd_func, (void *)no);        if (res != 0)        {            printf(&quot;Create thread %d failed\n&quot;, no);            exit(res);        }    }    printf(&quot;Creating threads success\nWaiting for thread to finish...\n&quot;);    for (no = 0; no &lt; THREAD_NUMBER; no++)    {        res = pthread_join(thread[no], &amp;thrd_ret);        if (!res)        {            printf(&quot;Thread %d joined\n&quot;, no);        }        else        {            printf(&quot;Thread %d joined failed\n&quot;, no);        }    }    return 0;}</code></pre><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200513_154240.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200513_154240.png" srcset="data:image/png;base64,666" alt="Screenshot_20200513_154240" style="zoom:80%;"><p>这个综合案例就是创建了3个线程，让3个线程共用同一个执行函数。每个线程都有5次循环（可以看成5个小任务，也就是5个job），每次循环之间会随机等待1～10s的时间，意义在于模拟每个任务的到达时间是随机的，并没有任何特定的规律。最后就是三个线程相继完成了各自的任务，都成功join，最后主线程结束。</p><h3 id="3、第三组-进程间通信"><a href="#3、第三组-进程间通信" class="headerlink" title="3、第三组 进程间通信"></a>3、第三组 进程间通信</h3><p>了解Linux提供的消息队列（消息传递）、共享内存、管道/命名管道、信号(signal)/软中断四种进程间通信机制的实现原理和方法；</p><ol><li>消息队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。具有一定权限的进程通过向消息队列中写入组织成消息的数据、从队列中读取数据，实现相互间通信。消息队列克服了信号signal承载信息量少，管道pipe只能承载无格式字节流以及缓冲区大小受限等缺点；</li><li>共享内存：多个进程通过访问同一块内存空间，实现快速的进程间通信是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥；</li><li>管道（Pipe）及命名管道（named pipe）：用于具有亲缘关系进程间的通信，命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还支持无亲缘关系进程间的通信；</li><li>信号（Signal：也称为软中断，是一种基于事件的通信机制，用于通知接受进程有某种事件发生。除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction；</li></ol><p>参照**<em>“【实验指导】 6.3 进程间通信示例”**</em>，查阅参考资料，<strong>选择上述四种通信方式中的一种</strong>，编程实现进程间通信，观察进程间通信过程。</p><p><strong><em>我选择的是消息队列（消息传递）方式。</em></strong></p><p>消息结构体：</p><pre><code class="c">struct my_message{    long int message_type;    /* The data you wish to transfer*/};</code></pre><p>相关函数：</p><table><thead><tr><th align="center">函数原型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">int msgget(key_t key, int msgflg);</td><td align="center">创建和访问一个消息队列</td></tr><tr><td align="center">int msgsend(int msgid, const void *msg_ptr, size_t msg_sz, int msgflg);</td><td align="center">将消息添加到消息队列，即消息发送</td></tr><tr><td align="center">int msgrcv(int msgid, void *msg_ptr, size_t msg_st, long int msgtype, int msgflg);</td><td align="center">从一个消息队列获取消息，即消息接收</td></tr><tr><td align="center">int msgctl(int msgid, int command, struct msgid_ds *buf);</td><td align="center">控制消息队列</td></tr></tbody></table><p>代码：</p><p>信息发送方：msgsend.c</p><pre><code class="c">#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;sys/msg.h&gt;#include &lt;errno.h&gt;#define MAX_TEXT 512struct msg_st{    long int msg_type;    char text[MAX_TEXT];};int main(){    int running = 1;    struct msg_st data;    char buffer[BUFSIZ];    int msgid = -1;    //建立消息队列    msgid = msgget((key_t)1234, 0666 | IPC_CREAT);    if (msgid == -1)    {        fprintf(stderr, &quot;msgget failed with error: %d\n&quot;, errno);        exit(EXIT_FAILURE);    }    //向消息队列中写消息，直到写入end    while (running)    {        //输入数据        printf(&quot;Enter some text: &quot;);        fgets(buffer, BUFSIZ, stdin);        data.msg_type = 1; //注意2        strcpy(data.text, buffer);        //向队列发送数据        if (msgsnd(msgid, (void *)&amp;data, MAX_TEXT, 0) == -1)        {            fprintf(stderr, &quot;msgsnd failed\n&quot;);            exit(EXIT_FAILURE);        }        //输入end结束输入        if (strncmp(buffer, &quot;end&quot;, 3) == 0)            running = 0;        sleep(1);    }    exit(EXIT_SUCCESS);}</code></pre><p>消息接受方：msgreceive.c</p><pre><code class="c">#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;sys/msg.h&gt;struct msg_st{    long int msg_type;    char text[BUFSIZ];};int main(){    int running = 1;    int msgid = -1;    struct msg_st data;    long int msgtype = 0; //注意1    //建立消息队列    msgid = msgget((key_t)1234, 0666 | IPC_CREAT);    if (msgid == -1)    {        fprintf(stderr, &quot;msgget failed with error: %d\n&quot;, errno);        exit(EXIT_FAILURE);    }    //从队列中获取消息，直到遇到end消息为止    while (running)    {        if (msgrcv(msgid, (void *)&amp;data, BUFSIZ, msgtype, 0) == -1)        {            fprintf(stderr, &quot;msgrcv failed with errno: %d\n&quot;, errno);            exit(EXIT_FAILURE);        }        printf(&quot;You wrote: %s\n&quot;, data.text);        //遇到end结束        if (strncmp(data.text, &quot;end&quot;, 3) == 0)            running = 0;    }    //删除消息队列    if (msgctl(msgid, IPC_RMID, 0) == -1)    {        fprintf(stderr, &quot;msgctl(IPC_RMID) failed\n&quot;);        exit(EXIT_FAILURE);    }    exit(EXIT_SUCCESS);}</code></pre><p>在第一个终端中编译运行msgsend.c：</p><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200517_144833.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200517_144833.png" srcset="data:image/png;base64,666" alt="Screenshot_20200517_144833" style="zoom:80%;"><p>新开一个终端编译运行msgreceive.c：</p><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200517_145014.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200517_145014.png" srcset="data:image/png;base64,666" alt="Screenshot_20200517_145014" style="zoom:80%;"><p>在第一个终端的发送进程中输入，能在第二个终端的接收进程中显示：</p><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200517_145215.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200517_145215.png" srcset="data:image/png;base64,666" alt="Screenshot_20200517_145215" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200517_145256.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200517_145256.png" srcset="data:image/png;base64,666" alt="Screenshot_20200517_145256" style="zoom:80%;"><p>在发送进程中输入end，接收进程接收到了end信号，就会删除消息队列，退出进程；发送进程也会在退出。</p><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200517_145548.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200517_145548.png" srcset="data:image/png;base64,666" alt="Screenshot_20200517_145548" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200517_145619.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200517_145619.png" srcset="data:image/png;base64,666" alt="Screenshot_20200517_145619" style="zoom:80%;"><p>在同一个终端，发送进程后台运行也是同样的道理。但是如果开两个接收进程，一个发送进程，那么就会出现接收进程争抢使用消息队列的情况，并且每个消息只会被使用一次，不会出现被重复消费的情况。因此最后的end消息因为只会被一个接收方拿到，且将消息队列删除，发送方和接收方1正常退出，但是导致另一个接收方2找不到消息队列，出错退出。</p><p>msgsend：</p><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200517_150046.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200517_150046.png" srcset="data:image/png;base64,666" alt="Screenshot_20200517_150046" style="zoom:80%;"><p>msgreceive1：</p><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200517_150252.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200517_150252.png" srcset="data:image/png;base64,666" alt="Screenshot_20200517_150252" style="zoom:80%;"><p>msgreceive2：</p><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200517_150315.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200517_150315.png" srcset="data:image/png;base64,666" alt="Screenshot_20200517_150315" style="zoom:80%;"><h3 id="4、第四组-线程间通信"><a href="#4、第四组-线程间通信" class="headerlink" title="4、第四组 线程间通信"></a>4、第四组 线程间通信</h3><p>了解Linux中的线程概念、线程通信机制、线程间同步互斥模式，以及多线程编程方式；</p><p>参照*<strong>“【实验指导】 6.2.7 Linux c/c++线程间参数传递”**<em>中的</em></strong>【示例2-3-3】～【示例2-3-5】***，编程实现线程间参数传递。</p><h4 id="示例2-3-3-向新建的线程传递字符串"><a href="#示例2-3-3-向新建的线程传递字符串" class="headerlink" title="示例2-3-3 向新建的线程传递字符串"></a>示例2-3-3 向新建的线程传递字符串</h4><p>代码：</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;void *create(void *arg){    char *str;    str = (char *)arg;    printf(&quot;The parameter passed from main is %s\n&quot;, str);    return (void *)0;}int main(){    int error;    pthread_t id1;    char *str1 = &quot;Hello!&quot;;    char *attr = str1;    error = pthread_create(&amp;id1, NULL, create, (void *)attr);    if (error != 0)    {        printf(&quot;This pthread is not created!\n&quot;);        return -1;    }    sleep(1);    printf(&quot;pthread is created..\n&quot;);    return 0;}</code></pre><p>运行结果：</p><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200517_171450.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200517_171450.png" srcset="data:image/png;base64,666" alt="Screenshot_20200517_171450" style="zoom:80%;"><p>可以发现Hello字符串已经传到了子线程，并在子线程打印输出。</p><h4 id="示例2-3-4-向新建的线程传递字符串"><a href="#示例2-3-4-向新建的线程传递字符串" class="headerlink" title="示例2-3-4 向新建的线程传递字符串"></a>示例2-3-4 向新建的线程传递字符串</h4><p>代码：</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;struct member{    int a;    char *s;};void *create(void *arg){    struct member *temp;    temp = (struct member *)arg;    printf(&quot;member-&gt;a = %d\n&quot;, temp-&gt;a);    printf(&quot;member-&gt;s = %s\n&quot;, temp-&gt;s);    return (void *)0;}int main(int argc, char const *argv[]){    int error;    pthread_t id1;    struct member *p;    p = (struct member *)malloc(sizeof(struct member));    p-&gt;a = 1;    p-&gt;s = &quot;Robben!&quot;;    error = pthread_create(&amp;id1, NULL, create, (void *)p);    if (error)    {        printf(&quot;pthread is not created!\n&quot;);        return -1;    }    sleep(1);    printf(&quot;pthread is created!\n&quot;);    free(p);    p = NULL;    return 0;}</code></pre><p>运行结果：</p><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200517_171737.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200517_171737.png" srcset="data:image/png;base64,666" alt="Screenshot_20200517_171737" style="zoom:80%;"><p>可以发现，结构体member传递到了子线程中，member中的int型a和char*型s，在子线程中被输出。</p><h4 id="示例2-3-5-验证新建立的线程可以共享进程中的数据"><a href="#示例2-3-5-验证新建立的线程可以共享进程中的数据" class="headerlink" title="示例2-3-5 验证新建立的线程可以共享进程中的数据"></a>示例2-3-5 验证新建立的线程可以共享进程中的数据</h4><p>代码：</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;static int a = 5;void *create(void *arg){    printf(&quot;New pthread...\n&quot;);    printf(&quot;a = %d\n&quot;, a);    a = -1;    return (void *)0;}int main(int argc, const char *argv[]){    int error;    pthread_t id1;    a = 10;    error = pthread_create(&amp;id1, NULL, create, NULL);    if (error != 0)    {        printf(&quot;new thread is not created!\n&quot;);        return -1;    }    sleep(1);    printf(&quot;a = %d\n&quot;, a);    printf(&quot;New thread is created...\n&quot;);    return 0;}</code></pre><p>运行结果：</p><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200517_172426.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200517_172426.png" srcset="data:image/png;base64,666" alt="Screenshot_20200517_172426" style="zoom:80%;"><p>可以发现，定义了一个静态变量<code>a=5</code>，在主线程创建子线程之前a被赋值为10，然后主线程创建子线程，子线程读取a，读取到的是重新赋值后的a（10）,因此子线程中输出a = 10。然后子线程中将a修改为-1，因为主线程等待（sleep）了1s，因此主线程拿到的a是子线程修改后的a（-1），因此主线程中输出a = -1。这也证明了新建立的线程可以共享进程中的数据，同一进程中的主线程和子线程可以共享进程中的静态数据。</p><h3 id="5、第五组-进程-线程间同步与互斥（二选一）"><a href="#5、第五组-进程-线程间同步与互斥（二选一）" class="headerlink" title="5、第五组 进程/线程间同步与互斥（二选一）"></a>5、第五组 进程/线程间同步与互斥（二选一）</h3><ol><li><p>针对2019-2020学年操作系统期末考试信号量题目，定义合理的锁和信号量，设计生产产品A、B、C的三个worker三个进程/线程A、B、C的业务流程和同步互斥机制。</p><p><strong>要求：给出具体的设计方案，并单独提交设计方案，类似期末考试答题形式；</strong></p></li><li><p>参照**<em>“【实验指导】 6.5 进程间同步互斥示例”**</em>，根据上一步的设计方案，利用semget、semctl、semop等信号量原语，以进程方式编程实现该设计方案；</p><p>观察分析程序运行结果，重点分析信号量设计方案是否合理、程序运行是否符合预期，应避免设计方案导致死锁或不符合题目要求。</p></li><li><p>参照**<em>“【实验指导】 6.6 线程间同步互斥示例”**</em>，根据第一步的设计方案，利用Pthread提供的<code>pthread_mutex_init()</code>、<code>pthread_mutex_lock()</code>、<code>pthread_mutex_unlock()</code>等线程同步互斥API，以线程方式编程实现该设计方案；</p><p>观察分析程序运行结果。重点分析信号量设计方案是否合理、程序运行是否符合预期，应避免设计方案导致死锁或不符合题目要求。</p></li></ol><p>要求：</p><ul><li><strong>基于进程和基于线程的同步互斥实现方案二选一，完成其中一个即可；</strong></li><li>不论采用进程方式、还是线程方式，模拟A、B、C三个worker的三个进程/线程A、B、C应当多次循环反复执行，便于观察同步互斥效应；</li><li>根据设计方案，给出程序代码，程序运行结果，结果分析。</li></ul><p><strong><em>我选择的是基于进程的同步互斥实现方案。</em></strong></p><h4 id="1、设计方案"><a href="#1、设计方案" class="headerlink" title="1、设计方案"></a>1、设计方案</h4><h5 id="方案1（采用二元互斥信号量-整形变量，效率比方案2高）："><a href="#方案1（采用二元互斥信号量-整形变量，效率比方案2高）：" class="headerlink" title="方案1（采用二元互斥信号量+整形变量，效率比方案2高）："></a>方案1（采用二元互斥信号量+整形变量，效率比方案2高）：</h5><h6 id="整型变量"><a href="#整型变量" class="headerlink" title="整型变量"></a>整型变量</h6><pre><code class="c">int count_A=0; // 当前工作台中已有的A的数量int count_B=0; // 当前工作台中已有的B的数量int empty=12; // 工作台中空位数量，empty=12-(count_A+count_B)</code></pre><h6 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h6><p>经分析题目，发现共需要4个信号量，分别为：</p><pre><code class="c">semaphore MUTEX_STATION = 0 // 二元信号量，控制对工作台和count_A、count_B、empty的互斥访问（取/放零件）semaphore SUSPEND_A = 1     // 控制台无足够空位时，挂起worker Asemaphore SUSPEND_B = 2     // 控制台无足够空位时，挂起worker Bsemaphore SUSPEND_C = 3     // 控制台无足够零件时，挂起worker C</code></pre><h6 id="WorkerA"><a href="#WorkerA" class="headerlink" title="WorkerA"></a>WorkerA</h6><pre><code class="c">WorkerA(){    while (1)    {    // 生产2个A    P(MUTEX_STATION, -1); // 申请对count_A、empty和控制台的访问权        if (count_A &lt;= 7 &amp;&amp; empty &gt;= 2)        {            // 同时放入工作台2个A            count_A += 2; //修改count_A            empty -= 2; //修改empty            V(MUTEX_STATION, 1); //释放对控制台、count_A和empty的访问权            V(SUSPEND_C, 1);     //控制台放入新零件，解挂/唤醒worker C        }        else        {            V(sem_id, MUTEX_STATION, 1); //释放对控制台和count_A、empty的访问权            P(sem_id, SUSPEND_A, -1);    //控制台无足够空位，或不允许再放入A，转入waiting态，挂起自身        }    }}</code></pre><h6 id="WorkerB"><a href="#WorkerB" class="headerlink" title="WorkerB"></a>WorkerB</h6><pre><code class="c">WorkerB(){    while (1)    {        // 生产1个B        P(MUTEX_STATION, -1); // 申请对count_B、empty和控制台的访问权        if (count_B &lt;= 7 &amp;&amp; empty &gt;= 1)        {            // 放入工作台1个B            count_B += 1; //修改count_B            empty -= 1; //修改empty            V(MUTEX_STATION, 1); //释放对控制台、count_B和empty的访问权            V(SUSPEND_C, 1);     //控制台放入新零件，解挂/唤醒worker C        }        else        {            V(MUTEX_STATION, 1); //释放对控制台和count_B、empty的访问权            P(SUSPEND_B, -1);    //控制台无足够空位，或不允许再放入B，转入waiting态，挂起自身        }    }}</code></pre><h6 id="WorkerC"><a href="#WorkerC" class="headerlink" title="WorkerC"></a>WorkerC</h6><pre><code class="c">WorkerC(){    while (1)    {        P(MUTEX_STATION, -1); // 申请对count_A、count_B和控制台的访问权        // 有足够多的A、B用于装配        if (count_A &gt;= 4 &amp;&amp; count_B &gt;= 3)        {            // 同时从工作台取出4个A、3个B            count_A -= 4; //修改count_A            count_B -= 3; //修改count_B            empty += 7; //修改empty            V(MUTEX_STATION, 1); //释放对控制台、count_A、count_B的控制权            V(SUSPEND_A, 1);     //控制台新增空位，解挂A            V(SUSPEND_B, 1);     //控制台新增空位，解挂B            // 生产1个C        }        else        {            V(MUTEX_STATION, 1); //释放对控制台、count_A、count_B的控制权            P(SUSPEND_C, -1);    //控制台无足够零件，转入waiting态，挂起自身        }    }}</code></pre><h6 id="编程实现"><a href="#编程实现" class="headerlink" title="编程实现"></a>编程实现</h6><pre><code class="c">/* * @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. * @Description: 期末信号量题目  * @Version: 1.0 * @Author: 苇名一心 * @Date: 2020-05-28 16:22:53 * @LastEditors: 苇名一心 * @LastEditTime: 2020-07-11 23:57:27 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;signal.h&gt;#include &lt;time.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;#include &lt;sys/shm.h&gt;#define NUM_SEMAPHORE 4 // 信号量个数// 信号量ID#define MUTEX_STATION 0 // 二元信号量，控制对工作台和count_A、count_B、empty的互斥访问（取/放零件）#define SUSPEND_A 1     // 控制台无足够空位时，挂起worker A#define SUSPEND_B 2     // 控制台无足够空位时，挂起worker B#define SUSPEND_C 3     // 控制台无足够零件时，挂起worker C#define SEM_KEY 0x11223344  // 信号量组的KEY#define SHM_KEY1 0x11223355 // 共享内存的KEY1#define SHM_KEY2 0x11223366 // 共享内存的KEY2// 颜色#define NONE &quot;\e[0m&quot;      // 复原#define RED &quot;\e[0;31m&quot;    // ERROR#define YELLOW &quot;\e[1;33m&quot; // WorkerA#define PINK &quot;\e[1;35m&quot;   // WorkerB#define GREEN &quot;\e[1;32m&quot;  // WorkerC#define CYAN &quot;\e[0;36m&quot;   // Share Memory#define BUF_SIZE 12char *buf;int *info; // 用于记录信息的3个整形变量int i, sv, sem_id, shm_id, info_shm_id, C_num = 0;union semun{    int val;               // SETVAL使用的值    struct semid_ds *buf;  // IPC_STAT、IPC_SET 使用缓存区    unsigned short *array; // GETALL,、SETALL 使用的数组    struct seminfo *__buf; // IPC_INFO(Linux特有) 使用缓存区};// 对信号量做减1操作，即P（wait）void P(int sem_id, int sem_num, int op){    if (op &lt; 0)    {        struct sembuf sem_buf;        sem_buf.sem_num = sem_num;        sem_buf.sem_op = op; //P()        sem_buf.sem_flg = SEM_UNDO;        if (semop(sem_id, &amp;sem_buf, 1) == -1)        {            perror(RED &quot;Semaphore P&quot; NONE);            exit(2);        }    }    else    {        perror(RED &quot;Semaphore P&quot; NONE);        exit(3);    }    return;}// 对信号量做减1操作，即V（signal）void V(int sem_id, int sem_num, int op){    if (op &gt; 0)    {        struct sembuf sem_buf;        sem_buf.sem_num = sem_num;        sem_buf.sem_op = op; //V()        sem_buf.sem_flg = SEM_UNDO;        if (semop(sem_id, &amp;sem_buf, 1) == -1)        {            perror(RED &quot;Semaphore V&quot; NONE);            exit(2);        }    }    else    {        perror(RED &quot;Semaphore V&quot; NONE);        exit(3);    }    return;}// 展示共享内存void show_shm(){    printf(CYAN &quot;[&quot;);    for (i = 0; i &lt; BUF_SIZE - 1; i++)    {        printf(&quot;%c,&quot;, buf[i]);    }    printf(&quot;%c]\n\n&quot; NONE, buf[BUF_SIZE - 1]);}// 创建并初始化信号量和共享内存void create_ipc(){    union semun arg[NUM_SEMAPHORE];    arg[MUTEX_STATION].val = 1;    arg[SUSPEND_A].val = 0;    arg[SUSPEND_B].val = 0;    arg[SUSPEND_C].val = 0;    // 创建信号量    if ((sem_id = semget(SEM_KEY, NUM_SEMAPHORE, IPC_CREAT | IPC_EXCL | 0666)) == -1)    {        perror(RED &quot;Create Semaphores&quot; NONE);        exit(1);    }    printf(&quot;Create Semaphores: OK\n&quot;);    printf(&quot;Sem_id = %d\n&quot;, sem_id);    // 初始化信号量    for (i = 0; i &lt; NUM_SEMAPHORE; i++)    {        semctl(sem_id, i, SETVAL, arg[i]);    }    for (i = 0; i &lt; NUM_SEMAPHORE; i++)    {        printf(&quot;The Sem[%d] = %d\n&quot;, i, semctl(sem_id, i, GETVAL, NULL));    }    printf(&quot;\n&quot;);    // 创建Info共享内存，用于记录信息    info_shm_id = shmget(SHM_KEY2, 3 * sizeof(int), IPC_CREAT | IPC_EXCL | 0666);    if (info_shm_id == -1)    {        perror(RED &quot;Create Info Share Memory&quot; NONE);        exit(1);    }    printf(&quot;Create Info Share Memory: OK\n&quot;);    // 初始化Info共享内存    info = (int *)shmat(info_shm_id, 0, 0); // 获取指向共享内存段的指针    if (info == (int *)-1)    {        perror(RED &quot;Attach Info Share Memory&quot; NONE);        exit(1);    }    info[0] = 0;  // 当前工作台中已有的A的数量（count_A）    info[1] = 0;  // 当前工作台中已有的B的数量（count_B）    info[2] = 12; // 工作台中空位数量（empty=12-(count_A+count_B)）    printf(&quot;Attach Info Share Memory: OK\n&quot;);    // 展示info共享内存    printf(&quot;count_A=%d, count_B=%d, empty=%d\n\n&quot;, info[0], info[1], info[2]);    // 创建Buffer共享内存    shm_id = shmget(SHM_KEY1, BUF_SIZE * sizeof(char), IPC_CREAT | IPC_EXCL | 0666);    if (shm_id == -1)    {        perror(RED &quot;Create Buffer Share Memory&quot; NONE);        exit(1);    }    printf(&quot;Create Buffer Share Memory: OK\n&quot;);    // 初始化Buffer共享内存    buf = (char *)shmat(shm_id, 0, 0); // 获取指向共享内存段的指针    if (buf == (char *)-1)    {        perror(RED &quot;Attach Buffer Share Memory&quot; NONE);        exit(1);    }    for (i = 0; i &lt; BUF_SIZE; i++)    {        buf[i] = &#39; &#39;;    }    printf(&quot;Initialize QUEUE: OK\n&quot;);    show_shm();}// 删除信号量和共享内存void remove_ipc(){    // 删除信号量    if (semctl(sem_id, 0, IPC_RMID, 0) == -1)        perror(RED &quot;Remove Semaphores&quot; NONE);    else        printf(&quot;Remove Semaphores: OK\n&quot;);    // 删除共享内存    if (shmctl(shm_id, IPC_RMID, 0) == -1)        perror(RED &quot;Remove Buffer Share Memory&quot; NONE);    else        printf(&quot;Remove Buffer Share Memory: OK\n&quot;);    if (shmctl(info_shm_id, IPC_RMID, 0) == -1)        perror(RED &quot;Remove Info Share Memory&quot; NONE);    else        printf(&quot;Remove Info Share Memory: OK\n&quot;);}// CTRL-C回调函数void sig_handler(int sig){    printf(&quot;\n&quot;);    remove_ipc();    printf(&quot;EXIT: OK\n&quot;);}int main(int argc, char const *argv[]){    srand(time(NULL));    // 创建并初始化信号量和共享内存    create_ipc();    // WorkerA    if (fork() == 0)    {        while (1)        {            sleep(1 + random() % 10);     // 生产2个A            P(sem_id, MUTEX_STATION, -1); // 申请对count_A、empty和控制台的访问权            // 还能再生产放置2个A，最多可放7+2=9个A，以便至少给B留下12-9=3个空位，防止工作台中没有足够多的B，导致worker C无法同时取出3个B            if (info[0] &lt;= 7 &amp;&amp; info[2] &gt;= 2)            {                // 同时放入工作台2个A                for (i = 0; i &lt; 2; i++)                {                    char *c;                    c = strchr(buf, &#39; &#39;);                    *c = &#39;A&#39;;                }                printf(YELLOW &quot;Worker A puts 2 As to the station\n&quot; NONE);                show_shm();                info[0] += 2; //修改count_A                info[2] -= 2; //修改empty                // 展示info共享内存                printf(&quot;count_A=%d, count_B=%d, empty=%d\n\n&quot;, info[0], info[1], info[2]);                V(sem_id, MUTEX_STATION, 1); //释放对控制台、count_A和empty的访问权                V(sem_id, SUSPEND_C, 1);     //控制台放入新零件，解挂/唤醒worker C            }            else            {                V(sem_id, MUTEX_STATION, 1); //释放对控制台和count_A、empty的访问权                printf(&quot;Worker A suspended\n\n&quot;);                P(sem_id, SUSPEND_A, -1); //控制台无足够空位，或不允许再放入A，转入waiting态，挂起自身            }        }    }    // WorkerB    else if (fork() == 0)    {        while (1)        {            sleep(1 + random() % 10);     // 生产1个B            P(sem_id, MUTEX_STATION, -1); // 申请对count_B、empty和控制台的访问权            // 还能再生产并放置1个B，最多可放7+1=8个B，以便至少给A留下12-8=4个空位，防止工作台中没有足够多的A，导致worker C无法同时取出4个A            if (info[1] &lt;= 7 &amp;&amp; info[2] &gt;= 1)            {                // 放入工作台1个B                char *c;                c = strchr(buf, &#39; &#39;);                *c = &#39;B&#39;;                printf(PINK &quot;Worker B puts 1 B to the station\n&quot; NONE);                show_shm();                info[1] += 1; //修改count_B                info[2] -= 1; //修改empty                // 展示info共享内存                printf(&quot;count_A=%d, count_B=%d, empty=%d\n\n&quot;, info[0], info[1], info[2]);                V(sem_id, MUTEX_STATION, 1); //释放对控制台、count_B和empty的访问权                V(sem_id, SUSPEND_C, 1);     //控制台放入新零件，解挂/唤醒worker C            }            else            {                V(sem_id, MUTEX_STATION, 1); //释放对控制台和count_B、empty的访问权                printf(&quot;Worker B suspended\n\n&quot;);                P(sem_id, SUSPEND_B, -1); //控制台无足够空位，或不允许再放入B，转入waiting态，挂起自身            }        }    }    // WorkerC    else if (fork() == 0)    {        while (1)        {            P(sem_id, MUTEX_STATION, -1); // 申请对count_A、count_B和控制台的访问权            // 有足够多的A、B用于装配            if (info[0] &gt;= 4 &amp;&amp; info[1] &gt;= 3)            {                // 同时从工作台取出4个A、3个B                for (i = 0; i &lt; 4; i++)                {                    char *c;                    c = strchr(buf, &#39;A&#39;);                    *c = &#39; &#39;;                }                for (i = 0; i &lt; 3; i++)                {                    char *c;                    c = strchr(buf, &#39;B&#39;);                    *c = &#39; &#39;;                }                printf(GREEN &quot;Worker C gets 4 As and 3 Bs from the station\n&quot; NONE);                show_shm();                info[0] -= 4; //修改count_A                info[1] -= 3; //修改count_B                info[2] += 7; //修改empty                // 展示info共享内存                printf(&quot;count_A=%d, count_B=%d, empty=%d\n\n&quot;, info[0], info[1], info[2]);                V(sem_id, MUTEX_STATION, 1); //释放对控制台、count_A、count_B的控制权                V(sem_id, SUSPEND_A, 1);     //控制台新增空位，解挂A                V(sem_id, SUSPEND_B, 1);     //控制台新增空位，解挂B                // 生产1个C                printf(GREEN &quot;Worker C is producing C-%d......\n\n&quot; NONE, ++C_num);                sleep(1 + random() % 10);                printf(GREEN &quot;C-%d is produced\n\n&quot; NONE, C_num);            }            else            {                V(sem_id, MUTEX_STATION, 1); //释放对控制台、count_A、count_B的控制权                printf(&quot;Worker C suspended\n\n&quot;);                P(sem_id, SUSPEND_C, -1); //控制台无足够零件，转入waiting态，挂起自身            }        }    }    // Main    else    {        // CTRL-C信号自行处理        signal(SIGINT, sig_handler);        wait(&amp;sv);        wait(&amp;sv);        wait(&amp;sv);        printf(&quot;THANKS\n&quot;);        return 0;    }}</code></pre><h5 id="方案2（采用多元信号量，效率不如方案1高）："><a href="#方案2（采用多元信号量，效率不如方案1高）：" class="headerlink" title="方案2（采用多元信号量，效率不如方案1高）："></a>方案2（采用多元信号量，效率不如方案1高）：</h5><h6 id="信号量-1"><a href="#信号量-1" class="headerlink" title="信号量"></a>信号量</h6><p>经分析题目，发现共需要6个信号量，分别为：</p><pre><code class="c">semaphore MUTEX = 1;      // 用于WorkerA、WorkerB和WorkerC对Station的互斥访问semaphore A_FULL = 0;     // 用于限制WorkerC取Asemaphore A_EMPTY = 9;    // 用于限制WorkerA生产A的数量semaphore B_FULL = 0;     // 用于限制WorkerC取Bsemaphore B_EMPTY = 8;    // 用于限制WorkerB生产B的数量semaphore ALL_EMPTY = 12; // 用于限制整个Station的生产数量</code></pre><p>分析：</p><ol><li>WorkerA最多生产9个A，如果生产A的个数大于9，则B的个数就会小于3，导致C永远从Station中拿不到4个A和3个B，产生死锁。但是由于WorkerA一次生产2个A，则WorkerA最多生产8（2×4）个A，因此使用信号量A_EMPTY来控制。A_EMPTY初始值可以设置为8，但是A_EMPTY初始值也可以设置为9，都是可以的。</li><li>同理，WorkerB最多生产8个B，如果生产B的个数大于8，则A的个数就会小于4，导致C永远从Station中拿不到4个A和3个B，产生死锁。因此使用信号量B_EMPTY来控制。</li><li>WorkerA和WorkerB一起最多生产12个A和B，因此使用信号量B_EMPTY来控制。</li><li>需要一个互斥量MUTEX，用于WorkerA、WorkerB和WorkerC对Station的互斥访问。</li></ol><h6 id="WorkerA-1"><a href="#WorkerA-1" class="headerlink" title="WorkerA"></a>WorkerA</h6><pre><code class="c">WorkerA(){    while (1)    {        // 生产2个A        P(A_EMPTY,-2);        P(ALL_EMPTY,-2);        P(MUTEX,-1);        // 同时放入工作台2个A        V(MUTEX,1);        V(A_FULL,2);    }}</code></pre><h6 id="WorkerB-1"><a href="#WorkerB-1" class="headerlink" title="WorkerB"></a>WorkerB</h6><pre><code class="c">WorkerB(){    while (1)    {        // 生产1个B        P(B_EMPTY,-1);        P(ALL_EMPTY,-1);        P(MUTEX,-1);        // 放入工作台1个B        V(MUTEX,1);        V(B_FULL,1);    }}</code></pre><h6 id="WorkerC-1"><a href="#WorkerC-1" class="headerlink" title="WorkerC"></a>WorkerC</h6><pre><code class="c">WorkerC(){    while (1)    {        P(A_FULL,-4);        P(B_FULL,-3);        P(MUTEX,-1);        // 同时从工作台取出4个A、3个B        V(MUTEX,1);        V(ALL_EMPTY,7);        V(B_EMPTY,3);        V(A_EMPTY,4);        // 生产1个C    }}</code></pre><h6 id="编程实现-1"><a href="#编程实现-1" class="headerlink" title="编程实现"></a>编程实现</h6><pre><code class="c">/* * @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. * @Description: 期末信号量题目  * @Version: 1.0 * @Author: 苇名一心 * @Date: 2020-05-28 16:22:53 * @LastEditors: 苇名一心 * @LastEditTime: 2020-07-11 21:08:57 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;signal.h&gt;#include &lt;time.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;#include &lt;sys/shm.h&gt;#define NUM_SEMAPHORE 6 // 信号量个数// 信号量ID#define MUTEX 0     // 用于WorkerA、WorkerB和WorkerC对Station的互斥访问#define A_FULL 1    // 用于限制WorkerC取A#define A_EMPTY 2   // 用于限制WorkerA生产A的数量#define B_FULL 3    // 用于限制WorkerC取B#define B_EMPTY 4   // 用于限制WorkerB生产B的数量#define ALL_EMPTY 5 // 用于限制整个Station的生产数量#define SEM_KEY 0x11223344 // 信号量组的KEY#define SHM_KEY 0x11223355 // 共享内存的KEY// 颜色#define NONE &quot;\e[0m&quot;      // 复原#define RED &quot;\e[0;31m&quot;    // ERROR#define YELLOW &quot;\e[1;33m&quot; // WorkerA#define PINK &quot;\e[1;35m&quot;   // WorkerB#define GREEN &quot;\e[1;32m&quot;  // WorkerC#define CYAN &quot;\e[0;36m&quot;   // Share Memory#define BUF_SIZE 12 // 工作台大小char *buf;int i, sv, sem_id, shm_id, C_num = 0;union semun{    int val;               // SETVAL使用的值    struct semid_ds *buf;  // IPC_STAT、IPC_SET 使用缓存区    unsigned short *array; // GETALL,、SETALL 使用的数组    struct seminfo *__buf; // IPC_INFO(Linux特有) 使用缓存区};// 对信号量做减1操作，即P（wait）void P(int sem_id, int sem_num, int op){    struct sembuf sem_buf;    sem_buf.sem_num = sem_num;    sem_buf.sem_op = op; //P()    sem_buf.sem_flg = SEM_UNDO;    if (semop(sem_id, &amp;sem_buf, 1) == -1)    {        perror(RED &quot;Semaphore P&quot; NONE);        exit(2);    }    return;}// 对信号量做减1操作，即V（signal）void V(int sem_id, int sem_num, int op){    struct sembuf sem_buf;    sem_buf.sem_num = sem_num;    sem_buf.sem_op = op; //V()    sem_buf.sem_flg = SEM_UNDO;    if (semop(sem_id, &amp;sem_buf, 1) == -1)    {        perror(RED &quot;Semaphore V&quot; NONE);        exit(2);    }    return;}// 展示共享内存void show_shm(){    printf(CYAN &quot;[&quot;);    for (i = 0; i &lt; BUF_SIZE - 1; i++)    {        printf(&quot;%c,&quot;, buf[i]);    }    printf(&quot;%c]\n\n&quot; NONE, buf[BUF_SIZE - 1]);}// 创建并初始化信号量和共享内存void create_ipc(){    union semun arg[NUM_SEMAPHORE];    arg[MUTEX].val = 1;    arg[A_FULL].val = 0;    arg[A_EMPTY].val = 9;    arg[B_FULL].val = 0;    arg[B_EMPTY].val = 8;    arg[ALL_EMPTY].val = 12;    // 创建信号量    if ((sem_id = semget(SEM_KEY, NUM_SEMAPHORE, IPC_CREAT | IPC_EXCL | 0666)) == -1)    {        perror(RED &quot;Create Semaphores&quot; NONE);        exit(1);    }    printf(&quot;Create Semaphores: OK\n&quot;);    printf(&quot;Sem_id = %d\n&quot;, sem_id);    // 初始化信号量    for (i = 0; i &lt; NUM_SEMAPHORE; i++)    {        semctl(sem_id, i, SETVAL, arg[i]);    }    for (i = 0; i &lt; NUM_SEMAPHORE; i++)    {        printf(&quot;The Sem[%d] = %d\n&quot;, i, semctl(sem_id, i, GETVAL, NULL));    }    // 创建共享内存    shm_id = shmget(SHM_KEY, BUF_SIZE * sizeof(char), IPC_CREAT | IPC_EXCL | 0666);    if (shm_id == -1)    {        perror(RED &quot;Create Share Memory&quot; NONE);        exit(1);    }    printf(&quot;Create Share Memory: OK\n&quot;);    // 初始化共享内存    buf = (char *)shmat(shm_id, 0, 0); // 获取指向共享内存段的指针    if (buf == (char *)-1)    {        perror(RED &quot;Attach Share Memory&quot; NONE);        exit(1);    }    for (i = 0; i &lt; BUF_SIZE; i++)    {        buf[i] = &#39; &#39;;    }    printf(&quot;Initialize QUEUE: OK\n&quot;);    show_shm();}// 删除信号量和共享内存void remove_ipc(){    // 删除信号量    if (semctl(sem_id, 0, IPC_RMID, 0) == -1)        perror(RED &quot;Remove Semaphores&quot; NONE);    else        printf(&quot;Remove Semaphores: OK\n&quot;);    // 删除共享内存    if (shmctl(shm_id, IPC_RMID, 0) == -1)        perror(RED &quot;Remove Share Memory&quot; NONE);    else        printf(&quot;Remove Share Memory: OK\n&quot;);}// CTRL-C回调函数void sig_handler(int sig){    printf(&quot;\n&quot;);    remove_ipc();    printf(&quot;EXIT: OK\n&quot;);}int main(int argc, char const *argv[]){    srand(time(NULL));    // 创建并初始化信号量和共享内存    create_ipc();    // WorkerA    if (fork() == 0)    {        while (1)        {            sleep(1 + random() % 10); // 生产2个A            P(sem_id, A_EMPTY, -2);            P(sem_id, ALL_EMPTY, -2);            P(sem_id, MUTEX, -1);            // 同时放入工作台2个A            for (i = 0; i &lt; 2; i++)            {                char *c;                c = strchr(buf, &#39; &#39;);                *c = &#39;A&#39;;            }            printf(YELLOW &quot;Worker A puts 2 As to the station\n&quot; NONE);            show_shm();            V(sem_id, MUTEX, 1);            V(sem_id, A_FULL, 2);        }    }    // WorkerB    else if (fork() == 0)    {        while (1)        {            sleep(1 + random() % 10); // 生产1个B            P(sem_id, B_EMPTY, -1);            P(sem_id, ALL_EMPTY, -1);            P(sem_id, MUTEX, -1);            // 放入工作台1个B            char *c;            c = strchr(buf, &#39; &#39;);            *c = &#39;B&#39;;            printf(PINK &quot;Worker B puts 1 B to the station\n&quot; NONE);            show_shm();            V(sem_id, MUTEX, 1);            V(sem_id, B_FULL, 1);        }    }    // WorkerC    else if (fork() == 0)    {        while (1)        {            P(sem_id, A_FULL, -4);            P(sem_id, B_FULL, -3);            P(sem_id, MUTEX, -1);            // 同时从工作台取出4个A、3个B            for (i = 0; i &lt; 4; i++)            {                char *c;                c = strchr(buf, &#39;A&#39;);                *c = &#39; &#39;;            }            for (i = 0; i &lt; 3; i++)            {                char *c;                c = strchr(buf, &#39;B&#39;);                *c = &#39; &#39;;            }            printf(GREEN &quot;Worker C gets 4 As and 3 Bs from the station\n&quot; NONE);            show_shm();            V(sem_id, MUTEX, 1);            V(sem_id, ALL_EMPTY, 7);            V(sem_id, B_EMPTY, 3);            V(sem_id, A_EMPTY, 4);            // 生产1个C            printf(GREEN &quot;Worker C is producing C-%d......\n\n&quot; NONE, ++C_num);            sleep(1 + random() % 10);            printf(GREEN &quot;C-%d is produced\n\n&quot; NONE, C_num);        }    }    // Main    else    {        // CTRL-C信号自行处理        signal(SIGINT, sig_handler);        wait(&amp;sv);        wait(&amp;sv);        wait(&amp;sv);        printf(&quot;THANKS\n&quot;);        return 0;    }}</code></pre><h4 id="2、运行结果及分析"><a href="#2、运行结果及分析" class="headerlink" title="2、运行结果及分析"></a>2、运行结果及分析</h4><p>两种方案的运行情况只选择了其中一种方案的运行结果，如果工作时间一致的话，两种方案的运行情况基本一致，但是因为使用了随机工作时间，每次运行的结果可能不一样，因此只选择了其中的一次运行结果。</p><h5 id="1、编译"><a href="#1、编译" class="headerlink" title="1、编译"></a>1、编译</h5><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200528_205104.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200528_205104.png" srcset="data:image/png;base64,666" alt="Screenshot_20200528_205104" style="zoom:80%;"><h5 id="2、运行"><a href="#2、运行" class="headerlink" title="2、运行"></a>2、运行</h5><h6 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h6><img src="https://gitee.com/wxy_666/images/raw/master/20200713193414.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200713193414.jpg" srcset="data:image/png;base64,666" alt="Screenshot_20200713_190946" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200713193440.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200713193440.jpg" srcset="data:image/png;base64,666" alt="Screenshot_20200713_191031" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200713193450.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200713193450.jpg" srcset="data:image/png;base64,666" alt="Screenshot_20200713_191049" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200713193500.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200713193500.jpg" srcset="data:image/png;base64,666" alt="Screenshot_20200713_191112" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200713193510.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200713193510.jpg" srcset="data:image/png;base64,666" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200713193521.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200713193521.jpg" srcset="data:image/png;base64,666" alt="Screenshot_20200713_191253" style="zoom:80%;"><h6 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h6><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200528_205211.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200528_205211.png" srcset="data:image/png;base64,666" alt="Screenshot_20200528_205211" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200528_205258.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200528_205258.png" srcset="data:image/png;base64,666" alt="Screenshot_20200528_205258" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200528_205330.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200528_205330.png" srcset="data:image/png;base64,666" alt="Screenshot_20200528_205330" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200528_205411.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/Screenshot_20200528_205411.png" srcset="data:image/png;base64,666" style="zoom:80%;"><h5 id="3、分析"><a href="#3、分析" class="headerlink" title="3、分析"></a>3、分析</h5><p>从运行结果来看，完全没有死锁现象，程序完全正常运行，输出结果也正常，创建和初始化信号量和共享内存，释放和删除信号量和共享内存都正常结束。</p><p>方案一的输出中有count_A、count_B、和empty的值，以及Worker A、Worker B和Worker C在进入阻塞状态时的输出，整个过程比较清晰。</p><p>方案二的基本过程在输出中，共享内存的状态也很清晰：</p><p>2A-B-2A-B-2A-B-C-2A-B-2A-B-2A-B-C-2A-B-2A-B-B-C-2A-B-2A-B-B-C-2A……</p><p>方案一和方案二多次运行都没有产生死锁，并且因为设置了随机等待时间模拟生产，每次的结果都有所不同，但都符合预期。但是经过分析，方案二可能会导致Worker A和Worker B都等待Worker C，但是此时工作台却还有一个空位的情况，但是并没有产生死锁，只是效率相较于方案一会低一些。</p><h2 id="五、实验总结"><a href="#五、实验总结" class="headerlink" title="五、实验总结"></a>五、实验总结</h2><p>这次操作系统课程设计的5组实验，虽然难度可能不是那么高，但是结合了操作系统理论课所学的知识，很有实践意义。经过这5组实验，我首先认识了华为最新的OpenEuler开源Linux操作系统，学习了Linux操作系统的安装、基本操作和使用。这次实验还加深了我对操作系统进程、线程概念和消息队列、共享内存、管道、软中断四种进程间通信机制的理解，掌握了利用Linux系统调用创建、管理进程的方法、利用POSIX线程（Pthread）库创建管理线程的方法和实现进程间通信和线程间通信的方法，深刻地认识了进程、线程并发执行的实质，并掌握了编程使用互斥变量和条件变量实现多线程间的同步互斥。</p><p>在实验的过程中，也遇到了各种各样的小问题，比如Linux的命令报错啊，编程gcc编译不通过等等，但经过上网查找资料和与同学讨论交流，都完美解决了问题，总体上看实验过程比较顺利。经过这次的课程设计，明显加深了对操作系统理论课知识的理解，并拓展了很多新的知识和内容，让我受益匪浅。</p><h2 id="六、项目源码"><a href="#六、项目源码" class="headerlink" title="六、项目源码"></a>六、项目源码</h2><p>本项目的源码已经存放于我的Github，欢迎下载查看：</p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/666WXY666/czxt-CompExpSource" target="_blank"><img src="https://github-readme-stats.vercel.app/api/pin/?username=666WXY666&repo=czxt-CompExpSource&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/pin/?username=666WXY666&repo=czxt-CompExpSource&show_owner=true" srcset="data:image/png;base64,666"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是操作系统课程设计关于进程线程管理通信与同步互斥的综合实验&lt;em&gt;（长文警告）&lt;/em&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="https://666wxy666.github.io/categories/C-C/"/>
    
      <category term="操作系统" scheme="https://666wxy666.github.io/categories/C-C/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="C++" scheme="https://666wxy666.github.io/tags/C/"/>
    
      <category term="工程" scheme="https://666wxy666.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="Linux" scheme="https://666wxy666.github.io/tags/Linux/"/>
    
      <category term="操作系统" scheme="https://666wxy666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程" scheme="https://666wxy666.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="同步互斥" scheme="https://666wxy666.github.io/tags/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/"/>
    
      <category term="线程" scheme="https://666wxy666.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="通信" scheme="https://666wxy666.github.io/tags/%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>编译原理 语法分析 LR</title>
    <link href="https://666wxy666.github.io/2020/09/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-LR/"/>
    <id>https://666wxy666.github.io/2020/09/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-LR/</id>
    <published>2020-09-01T16:00:00.000Z</published>
    <updated>2020-09-13T08:56:37.285Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>本文是编译原理C语言LR语法分析器的简单实现项目。</strong></p><a id="more"></a><h2 id="一、需求"><a href="#一、需求" class="headerlink" title="一、需求"></a>一、需求</h2><img src="https://gitee.com/wxy_666/images/raw/master/20200902092212.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200902092212.png" srcset="data:image/png;base64,666" alt="1" style="zoom:80%;"><p><strong>拓展需求：</strong>除题目的基础要求外，还额外实现了对任意SLR1文法，自动生成拓广文法，且求该文法的first集和follow集，并且自动生成LR0项目集规范簇和识别该文法所有活前缀的DFA，然后根据该DFA自动生成SLR1分析表。</p><h2 id="二、运行环境"><a href="#二、运行环境" class="headerlink" title="二、运行环境"></a>二、运行环境</h2><p>电脑硬件配置：</p><ul><li><p>处理器：Intel i7 7700HQ</p></li><li><p>显卡：NVIDIA GeForce GTX 1050 Ti</p></li><li><p>内存：16GB</p></li></ul><p>软件：</p><ul><li><p>编程语言：C++</p></li><li><p>IDE：Microsoft Visual Studio 2019</p></li><li><p>Windows SDK版本：10.0</p></li><li><p>平台工具集：Visual Studio 2019（v142）</p></li></ul><h2 id="三、核心算法"><a href="#三、核心算法" class="headerlink" title="三、核心算法"></a>三、核心算法</h2><h3 id="1、整个程序的模型如图所示"><a href="#1、整个程序的模型如图所示" class="headerlink" title="1、整个程序的模型如图所示"></a>1、整个程序的模型如图所示</h3><h4 id="手动分析："><a href="#手动分析：" class="headerlink" title="手动分析："></a>手动分析：</h4><ol><li><p>首先对文法进行拓广，求first集和follow集，发现该文法是一个SLR1文法。</p></li><li><p>构造LR0项目集规范簇及识别该文法所有活前缀的DFA</p></li><li><p>构造识别该文法的SLR0分析表</p><table><thead><tr><th><img src="https://gitee.com/wxy_666/images/raw/master/20200902092905.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200902092905.png" srcset="data:image/png;base64,666" alt="2" style="zoom: 67%;"></th><th><img src="https://gitee.com/wxy_666/images/raw/master/20200902093010.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200902093010.png" srcset="data:image/png;base64,666" alt="3"></th></tr></thead><tbody><tr><td><img src="https://gitee.com/wxy_666/images/raw/master/20200902093023.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200902093023.png" srcset="data:image/png;base64,666" alt="4"></td><td><img src="https://gitee.com/wxy_666/images/raw/master/20200902093052.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200902093052.png" srcset="data:image/png;base64,666" alt="5" style="zoom: 50%;"></td></tr></tbody></table></li></ol><ol start="4"><li><p>整个程序的模型如图所示</p><img src="https://gitee.com/wxy_666/images/raw/master/20200902093306.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200902093306.png" srcset="data:image/png;base64,666" alt="6" style="zoom:80%;"></li><li><p>预测分析控制程序算法</p><img src="https://gitee.com/wxy_666/images/raw/master/20200902093330.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200902093330.png" srcset="data:image/png;base64,666" alt="7" style="zoom:80%;"></li></ol><h3 id="6、输入形式："><a href="#6、输入形式：" class="headerlink" title="6、输入形式："></a>6、输入形式：</h3><p>文件输入，格式为：</p><p>产生式个数n</p><p>{</p><p>……</p><p>第i(1&lt;=i&lt;=n)个产生式（例如A-&gt;a，按照输入顺序分别从1到n编号，拓广产生式为0号，规定终结符和非终结符都是一个字符且非终结符都为大写字母）</p><p>……</p><p>}</p><p>要分析的字符串个数n</p><p>{</p><p>……</p><p>第i(1&lt;=i&lt;=n)个要分析的字符串（要求以$结尾）</p><p>……</p><p>}</p><img src="https://gitee.com/wxy_666/images/raw/master/20200902093444.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200902093444.png" srcset="data:image/png;base64,666" alt="8" style="zoom:80%;"><h3 id="7、输出形式："><a href="#7、输出形式：" class="headerlink" title="7、输出形式："></a>7、输出形式：</h3><p>先输出该文法的拓广文法，再输出该拓广文法的first集和follow集，再输出SLR0分析表，然后输出用户输入的待分析字符串的分析过程。</p><h2 id="四、变量和函数"><a href="#四、变量和函数" class="headerlink" title="四、变量和函数"></a>四、变量和函数</h2><h3 id="1、类和枚举："><a href="#1、类和枚举：" class="headerlink" title="1、类和枚举："></a>1、类和枚举：</h3><pre><code class="c">enum RS//动作的枚举{    shift,//移进    reduce,//规约    accept//接受};//假定非终结符仅为一个大写字母，终结符仅为一个小写字母和各种符号，且用~代替epsilonclass PF//Production formula,产生式的类{public:    char left;//产生式的左部    string right;//产生式的右部    PF(char l, string r)//构造函数    {        left = l;        right = r;    }};class ITEM//项目集{public:    ITEM();//默认构造函数    ITEM(int NO);//构造函数    int NO;//项目集编号    set&lt;pair&lt;int, int&gt;&gt; production;//项目，第一个int代表产生式编号，第二个int代表.的位置    set&lt;pair&lt;char, int&gt;&gt; go_to;//该项目集指向的项目集，第一个char代表箭头上的字符，第二个int代表指向的项目集编号    bool operator&lt;(const ITEM&amp; item)const;//重载&lt;操作符，以便使用set};class action//动作类{public:    action(RS rs,int num);//重写构造函数    string ret_action();//返回该动作    action();//初始    RS rs;//动作    int num;//移进到哪个状态，或者用哪个产生式规约};</code></pre><h3 id="2、全局变量"><a href="#2、全局变量" class="headerlink" title="2、全局变量"></a>2、全局变量</h3><pre><code class="c">vector&lt;PF&gt; PF_vector;//产生式map&lt;char, set&lt;char&gt; &gt; first;//first集map&lt;char, set&lt;char&gt; &gt; follow;//follow集set&lt;ITEM&gt; DFA;//DFA项目集规范簇vector&lt;map&lt;char, action&gt;&gt; predict_table_action;//SLR1分析表actionvector&lt;map&lt;char, int&gt;&gt; predict_table_goto;//SLR1分析表gotovector&lt;char&gt; A_1;//符号栈vector&lt;int&gt; A_2;//状态栈vector&lt;char&gt; B;//剩余串set&lt;char&gt; terminal;//所有的终结符+&#39;$&#39;set&lt;char&gt; non_terminal;//所有的非终结符int B_point = 0, input_len = 0;//B_point为输入串指针，input_len为输入串长度</code></pre><h3 id="3、函数"><a href="#3、函数" class="headerlink" title="3、函数"></a>3、函数</h3><pre><code class="c">ITEM::ITEM()//默认构造函数ITEM::ITEM(int NO)//构造函数bool ITEM::operator&lt;(const ITEM&amp; item)const//重载&lt;操作符，以便使用setaction::action(RS rs, int num) //构造函数action::action()//默认构造函数string action::ret_action()//返回该动作void first_construction()//构造并输出first集void add_follow(const char&amp; ch1, const char&amp; ch2)//将ch1的follow集加入到ch2的follow集中void follow_construction()//构造并输出follow集void DFA_construction()//构造DFAvoid predict_table_construction()//构造并输出SLR1预测分析表void print_A()//输出分析栈void print_B()//输出剩余串void analyse()//预测分析控制程序int main()</code></pre><p>PS：关于每个函数内部详细实现详见main.cpp中写好了详细的注释，我几乎对每一步操作的目的和函数的目的都写了详细的注释。</p><h2 id="五、测试样例："><a href="#五、测试样例：" class="headerlink" title="五、测试样例："></a>五、测试样例：</h2><table><thead><tr><th><img src="https://gitee.com/wxy_666/images/raw/master/20200902093741.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200902093741.png" srcset="data:image/png;base64,666" alt="1" style="zoom:80%;"></th><th><img src="https://gitee.com/wxy_666/images/raw/master/20200902093801.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200902093801.png" srcset="data:image/png;base64,666" alt="2" style="zoom:80%;"></th></tr></thead><tbody><tr><td><img src="https://gitee.com/wxy_666/images/raw/master/20200902093811.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200902093811.png" srcset="data:image/png;base64,666" alt="3" style="zoom:80%;"></td><td><img src="https://gitee.com/wxy_666/images/raw/master/20200902093822.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200902093822.png" srcset="data:image/png;base64,666" alt="4" style="zoom:80%;"></td></tr><tr><td><img src="https://gitee.com/wxy_666/images/raw/master/20200902093830.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200902093830.png" srcset="data:image/png;base64,666" alt="5" style="zoom:80%;"></td><td></td></tr></tbody></table><h2 id="六、项目地址"><a href="#六、项目地址" class="headerlink" title="六、项目地址"></a>六、项目地址</h2><p>本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看：</p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/666WXY666/yufafenxi-LR" target="_blank"><img src="https://github-readme-stats.vercel.app/api/pin/?username=666WXY666&repo=yufafenxi-LR&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/pin/?username=666WXY666&repo=yufafenxi-LR&show_owner=true" srcset="data:image/png;base64,666"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文是编译原理C语言LR语法分析器的简单实现项目。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="https://666wxy666.github.io/categories/C-C/"/>
    
      <category term="编译原理" scheme="https://666wxy666.github.io/categories/C-C/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="C++" scheme="https://666wxy666.github.io/tags/C/"/>
    
      <category term="工程" scheme="https://666wxy666.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="编译原理" scheme="https://666wxy666.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="语法分析" scheme="https://666wxy666.github.io/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
      <category term="LR" scheme="https://666wxy666.github.io/tags/LR/"/>
    
  </entry>
  
  <entry>
    <title>编译原理 语法分析 LL1</title>
    <link href="https://666wxy666.github.io/2020/09/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-LL1/"/>
    <id>https://666wxy666.github.io/2020/09/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-LL1/</id>
    <published>2020-09-01T16:00:00.000Z</published>
    <updated>2020-09-13T08:56:45.102Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>本文是编译原理C语言LL1语法分析器的简单实现项目。</strong></p><a id="more"></a><h2 id="一、需求"><a href="#一、需求" class="headerlink" title="一、需求"></a>一、需求</h2><img src="https://gitee.com/wxy_666/images/raw/master/20200831111408.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200831111408.png" srcset="data:image/png;base64,666" alt="需求" style="zoom:80%;"><p><strong>拓展需求：</strong>还能自动够造LL1文法的first集和follow集，为LL1文法自动构造预测分析表。</p><h2 id="二、运行环境"><a href="#二、运行环境" class="headerlink" title="二、运行环境"></a>二、运行环境</h2><p>电脑硬件配置：</p><ul><li><p>处理器：Intel i7 7700HQ</p></li><li><p>显卡：NVIDIA GeForce GTX 1050 Ti</p></li><li><p>内存：16GB</p></li></ul><p>软件：</p><ul><li><p>编程语言：C++</p></li><li><p>IDE：Microsoft Visual Studio 2019</p></li><li><p>Windows SDK版本：10.0</p></li><li><p>平台工具集：Visual Studio 2019（v142）</p></li></ul><h2 id="三、核心算法"><a href="#三、核心算法" class="headerlink" title="三、核心算法"></a>三、核心算法</h2><h3 id="1、整个程序的模型如图所示"><a href="#1、整个程序的模型如图所示" class="headerlink" title="1、整个程序的模型如图所示"></a>1、整个程序的模型如图所示</h3><img src="https://gitee.com/wxy_666/images/raw/master/20200831111906.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200831111906.png" srcset="data:image/png;base64,666" alt="1" style="zoom:80%;"><p>分析栈、分析表的数据结构详见【变量和函数】。</p><h3 id="2、first集的构造"><a href="#2、first集的构造" class="headerlink" title="2、first集的构造"></a>2、first集的构造</h3><p>使用深度优先遍历递归的方法，当遍历完所有的非终结符的产生式右部，first集构造完成。详见注释。</p><img src="https://gitee.com/wxy_666/images/raw/master/20200831112033.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200831112033.png" srcset="data:image/png;base64,666" alt="2" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200831112041.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200831112041.png" srcset="data:image/png;base64,666" alt="3" style="zoom:80%;"><h3 id="3、follow集的构造"><a href="#3、follow集的构造" class="headerlink" title="3、follow集的构造"></a>3、follow集的构造</h3><p>不能采用深度优先遍历的方法，否则求给出的测试样例【其它文法1】会无限循环，因为非终结符之间的follow集是互相依赖的，因而采用了另一种方法解决了这个问题。就是无限循环求所有非终结符的follow集，直到所有的follow集都不再增大为止，跳出循环。详见注释。</p><img src="https://gitee.com/wxy_666/images/raw/master/20200831112144.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200831112144.png" srcset="data:image/png;base64,666" alt="4" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200831112152.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200831112152.png" srcset="data:image/png;base64,666" alt="5" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200831112200.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200831112200.png" srcset="data:image/png;base64,666" alt="6" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200831112212.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200831112212.png" srcset="data:image/png;base64,666" alt="7" style="zoom:80%;"><h3 id="4、预测分析表的构造算法"><a href="#4、预测分析表的构造算法" class="headerlink" title="4、预测分析表的构造算法"></a>4、预测分析表的构造算法</h3><p>利用课本上的算法4.2</p><img src="https://gitee.com/wxy_666/images/raw/master/20200831112256.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200831112256.png" srcset="data:image/png;base64,666" alt="8" style="zoom:80%;"><h3 id="5、预测分析控制程序算法"><a href="#5、预测分析控制程序算法" class="headerlink" title="5、预测分析控制程序算法"></a>5、预测分析控制程序算法</h3><p>利用课本上的算法</p><img src="https://gitee.com/wxy_666/images/raw/master/20200831112400.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200831112400.png" srcset="data:image/png;base64,666" alt="9" style="zoom:80%;"><p>但是该算法有点小瑕疵，就是最后while循环的出口判断条件有问题，不应该是只是【栈顶文法符号X不为‘$’】，而应为【栈顶文法符号X不为‘$’&amp;&amp;所指向的输入符号a不为‘$’】。</p><h3 id="6、输入形式："><a href="#6、输入形式：" class="headerlink" title="6、输入形式："></a>6、输入形式：</h3><p>先输入文法的产生式个数，然后输入产生式，该文法必须为LL1文法（消除左递归和左公因子），然后输入1或0，决定是否要进行分析，然后再输入要分析的字符串，该字符串需要用i代表数字，以‘$’结尾。<br>输入的文法默认第一个输入的产生式的左部为起始符，非终结符仅为一个大写字母，终结符仅为一个小写字母和各种符号，且用~代替epsilon,且输入的文法必须满足LL1文法的条件。输入的要分析的字符串需要用i代表数字，以‘$’结尾。我认为没有必要把i也就是题目中的num细化为数字，因为这些操作已经在词法分析中完成了，语法分析只需完成分析类似于这种字符串的输入是否被接受就可以了。</p><h3 id="7、输出形式："><a href="#7、输出形式：" class="headerlink" title="7、输出形式："></a>7、输出形式：</h3><p>先输出该文法的first集和follow集，再输出该文法的LL1预测分析表，最后输出用户输入的待分析字符串的分析过程</p><h2 id="四、变量和函数"><a href="#四、变量和函数" class="headerlink" title="四、变量和函数"></a>四、变量和函数</h2><h3 id="1、类"><a href="#1、类" class="headerlink" title="1、类"></a>1、类</h3><pre><code class="c">class PF//Production formula,产生式的类{public:    string left;//产生式的左部    set&lt;string&gt; right;//产生式的右部    PF(char s[])//构造函数，确定产生式左部    {        left = s;    }    void insert(char s[])//插入产生式右部的函数    {        right.insert(s);    }};</code></pre><h3 id="2、全局变量"><a href="#2、全局变量" class="headerlink" title="2、全局变量"></a>2、全局变量</h3><pre><code class="c">vector&lt;PF&gt; PF_vector;//产生式使用一个vector数组，每个元素为PF类的对象，来存放输入的产生式。map&lt;string, set&lt;char&gt; &gt; first;//first集map&lt;string, set&lt;char&gt; &gt; follow;//follow集使用了map哈希key的类型为string，存放产生式的左部，value的类型为char的set,用来存放对应key的first集和follow集。vector&lt;map&lt;char, string&gt;&gt; predict_table;//LL1分析表//使用一个vector数组，每个元素为一个map，该vector的每一个map分别对应PF_vector中每个产生式的左部的非终结符所在的预测分析表的行，map的key为终结符，value为对应表项中的产生式的右部vector&lt;char&gt; A;//分析栈vector&lt;char&gt; B;//剩余串map&lt;string, int&gt; PF_map;//存储每个非终结符对应的编号，key为非终结符，value为编号vector&lt;char&gt; letter;//所有的终结符,在构造预测分析表的时候创建完毕int B_point = 0, input_len = 0;//B_point为输入串指针，input_len为输入串长度</code></pre><h3 id="3、函数"><a href="#3、函数" class="headerlink" title="3、函数"></a>3、函数</h3><pre><code class="c">//first集的构造：void first_construction() //构造并输出first集void DFS(int x)//为构造first集深度优先遍历PF，递归调用//follow集的构造：void follow_construction()//构造并输出follow集void add_follow(const string&amp; str1, const string&amp; str2)//将str1的follow集加入到str2的follow集中//预测分析表的构造：void predict_table_construction()//构造并输出LL1分析表bool check_first(const string&amp; str, char ch)//检查ch是否属于str的FIRST集合bool check_follow(const string&amp; str, char ch)//检查ch是否属于str的FOLLOW集合//预测分析控制程序：void analyse()//预测分析控制程序void print_A()//输出分析栈void print_B()//输出剩余串//主函数：int main()</code></pre><p>PS：关于每个函数内部详细实现详见main.cpp中写好了详细的注释，我几乎对每一步操作的目的和函数的目的都写了详细的注释。</p><h2 id="五、测试样例："><a href="#五、测试样例：" class="headerlink" title="五、测试样例："></a>五、测试样例：</h2><p>这个语法分析程序普适性较高，不仅对课本上的算数运算文法能实现求first集和follow集，自动生成预测分析表，以及对字符串进行分析，还对几乎所有的LL1文法都可以实现，只要输入的文法按照【核心算法】中的【输入形式】的要求即可。</p><p>在这里我以课本上的算数运算文法为例。其它文法1为follow集循环依赖文法（求follow集不可以用递归求，否则该文法会无限循环），其它文法2为起始符可推空文法（如果不按严格算法4.2构造分析表，也就是作业中把A-&gt;~产生式加入到A的follow集所对应的终结符的表项中的做法其实是不准确的，而应把A可以推空的产生式加入到A的follow集所对应的终结符的表项中，否则就会导致无法识别某些字符串的错误，例如其它文法2就是无法识别空串的错误，但该文法确实可以识别空串）。</p><table><thead><tr><th><img src="https://gitee.com/wxy_666/images/raw/master/20200831181454.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200831181454.png" srcset="data:image/png;base64,666" alt="算数in0" style="zoom:80%;"></th><th><img src="https://gitee.com/wxy_666/images/raw/master/20200831181512.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200831181512.png" srcset="data:image/png;base64,666" alt="算数out0" style="zoom:80%;"></th></tr></thead><tbody><tr><td><img src="https://gitee.com/wxy_666/images/raw/master/20200831181527.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200831181527.png" srcset="data:image/png;base64,666" alt="算数out1" style="zoom:80%;"></td><td><img src="https://gitee.com/wxy_666/images/raw/master/20200831181541.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200831181541.png" srcset="data:image/png;base64,666" alt="算数out2" style="zoom:80%;"></td></tr><tr><td><img src="https://gitee.com/wxy_666/images/raw/master/20200831181551.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200831181551.png" srcset="data:image/png;base64,666" alt="算数out3" style="zoom:80%;"></td><td><img src="https://gitee.com/wxy_666/images/raw/master/20200831181559.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200831181559.png" srcset="data:image/png;base64,666" alt="算数out4" style="zoom:80%;"></td></tr><tr><td><img src="https://gitee.com/wxy_666/images/raw/master/20200831181615.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200831181615.png" srcset="data:image/png;base64,666" alt="算数out5" style="zoom:80%;"></td><td></td></tr></tbody></table><h2 id="六、项目地址"><a href="#六、项目地址" class="headerlink" title="六、项目地址"></a>六、项目地址</h2><p>本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看：</p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/666WXY666/yufafenxi-LL1" target="_blank"><img src="https://github-readme-stats.vercel.app/api/pin/?username=666WXY666&repo=yufafenxi-LL1&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/pin/?username=666WXY666&repo=yufafenxi-LL1&show_owner=true" srcset="data:image/png;base64,666"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文是编译原理C语言LL1语法分析器的简单实现项目。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="https://666wxy666.github.io/categories/C-C/"/>
    
      <category term="编译原理" scheme="https://666wxy666.github.io/categories/C-C/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="C++" scheme="https://666wxy666.github.io/tags/C/"/>
    
      <category term="工程" scheme="https://666wxy666.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="编译原理" scheme="https://666wxy666.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="语法分析" scheme="https://666wxy666.github.io/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
      <category term="LL1" scheme="https://666wxy666.github.io/tags/LL1/"/>
    
  </entry>
  
  <entry>
    <title>编译原理 词法分析</title>
    <link href="https://666wxy666.github.io/2020/09/01/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>https://666wxy666.github.io/2020/09/01/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</id>
    <published>2020-08-31T16:00:00.000Z</published>
    <updated>2020-09-13T08:56:50.559Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>本文是编译原理C语言词法分析器的简单实现项目。</strong></p><a id="more"></a><h2 id="一、需求"><a href="#一、需求" class="headerlink" title="一、需求"></a>一、需求</h2><p>词法分析程序的设计和实现。</p><p>设计并实现C语言的词法分析程序，要求如下： </p><ol><li>可以识别出用C语言编写的源程序中的每个单词符号，并以记号的形式输出每个单词符号。</li><li>可以识别并读取源程序中的注释。</li><li>可以统计源程序汇总的语句行数、各类单词的个数、以及字符个数，并输出统计结果。</li><li>检查源程序中存在的词法错误，并报告错误所在的位置。</li><li>对源程序中存在的错误进行适当的恢复，使词法分析可以继续进行，对源程序进行一次扫描即可检查并报告源程序中存在的所有词法错误。</li></ol><h2 id="二、运行环境"><a href="#二、运行环境" class="headerlink" title="二、运行环境"></a>二、运行环境</h2><p>电脑硬件配置：</p><ul><li><p>处理器：Intel i7 7700HQ</p></li><li><p>显卡：NVIDIA GeForce GTX 1050 Ti</p></li><li><p>内存：16GB</p></li></ul><p>软件：</p><ul><li><p>编程语言：C++</p></li><li><p>IDE：Microsoft Visual Studio 2019</p></li><li><p>Windows SDK版本：10.0</p></li><li><p>平台工具集：Visual Studio 2019（v142）</p></li></ul><h2 id="三、核心算法"><a href="#三、核心算法" class="headerlink" title="三、核心算法"></a>三、核心算法</h2><p>读入源程序，将源程序拆分为单词，同时去除空格和空行并存入vector中，一个字符一个字符的读入自动机，文件输出单词和类型，并在最后输出统计结果，在屏幕输出错误。</p><p>PS:不支持中文字符</p><h3 id="源程序的记号和表达式："><a href="#源程序的记号和表达式：" class="headerlink" title="源程序的记号和表达式："></a>源程序的记号和表达式：</h3><ol><li><p>标识符：字母或“_”开头，后跟字母或数字或“_”组成的符号串</p></li><li><p>关键字：标识符集合的子集。C语言有32个关键字，分别为：</p><pre><code class="c">{&quot;do&quot;,&quot;double&quot;,&quot;auto&quot;,&quot;break&quot;,&quot;case&quot;,&quot;char&quot;,&quot;const&quot;,&quot;continue&quot;,&quot;default&quot;,&quot;else&quot;,&quot;enum&quot;,&quot;extern&quot;,&quot;float&quot;,&quot;for&quot;,&quot;goto&quot;,&quot;if&quot;,&quot;int&quot;,&quot;long&quot;,&quot;register&quot;,&quot;return&quot;,&quot;struct&quot;,&quot;switch&quot;,&quot;typedef&quot;,&quot;short&quot;,&quot;signed&quot;,&quot;sizeof&quot;,&quot;static&quot;,&quot;union&quot;,&quot;unsigned&quot;,&quot;void&quot;,&quot;volatile&quot;,&quot;while&quot; }</code></pre></li><li><p>数字：由整数部分、可选小数部分和可选整数部分构成</p></li><li><p>运算符：</p></li></ol><pre><code>  ```c</code></pre><p>   . ( ) ~ &amp; ^ % &lt;= &lt;&lt; &lt; &gt;= &gt;&gt; &gt; = == / != ! &amp;&amp; &amp; || | -&gt; - : ?<br>      ```</p><ol start="5"><li><p>分隔符：</p><pre><code class="c">; # ’ ” [ ] { } , </code></pre></li><li><p>转义符：\</p></li></ol><h3 id="状态转换图："><a href="#状态转换图：" class="headerlink" title="状态转换图："></a>状态转换图：</h3><img src="https://gitee.com/wxy_666/images/raw/master/20200824091143.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200824091143.jpg" srcset="data:image/png;base64,666" alt="1" style="zoom: 50%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200824091151.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200824091151.jpg" srcset="data:image/png;base64,666" alt="22" style="zoom: 50%;"><h3 id="输入形式："><a href="#输入形式：" class="headerlink" title="输入形式："></a>输入形式：</h3><p>文件输入。</p><h3 id="输出形式："><a href="#输出形式：" class="headerlink" title="输出形式："></a>输出形式：</h3><p>分两部分：文件输出和屏幕输出。文件输出分析内容，分四部分：按文件顺序输出类型和表达式，每种表达式数量统计，每种类型数量统计，行数、单词数、字符数统计；屏幕输出错误。详见输出样例部分。</p><h2 id="四、变量和函数"><a href="#四、变量和函数" class="headerlink" title="四、变量和函数"></a>四、变量和函数</h2><pre><code class="c">int start = 0, over = 0, first = 0;//指针int letters = 0, lines = 0, words = 0;//统计单词数，行数和字符数的变量int state;//状态变量class str//单词类{public:    int linenum;//行号    string Str;//单词       };//输出文件名string file_name;//返回单词或符号,从位置i开始查找，引用参数j返回这个单词最后一个字符在str的位置。string GetWord(string str, int i, int&amp; j);//除去字符串中连续的空格和换行。第一个参数为目标字符串，第二个参数为开始位置。返回值为第一个有效字符在字符串的位置int get_nbc(string str, int i);//文件输出函数，成功输出返回true，失败返回falsebool Output(vector&lt;pair&lt;string, string&gt; &gt; v);//词法分析主要算法函数，返回一个pair型数组vector&lt;pair&lt;string, string&gt; &gt; analyse(vector&lt;str&gt;&amp; vec);//此函数判断str是否为关键字，是的话，返回真，反之返回假bool IsKey(string str);//此函数判断C是否为字母，是的话，返回真，反之返回假bool letter(char C);//此函数判断C是否为数字，是的话，返回真，反之返回假bool digit(char C);</code></pre><p>详细代码见文末github项目。</p><h2 id="五、测试样例："><a href="#五、测试样例：" class="headerlink" title="五、测试样例："></a>五、测试样例：</h2><table><thead><tr><th><img src="https://gitee.com/wxy_666/images/raw/master/20200824093509.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200824093509.png" srcset="data:image/png;base64,666" alt="11"></th><th><img src="https://gitee.com/wxy_666/images/raw/master/20200824093524.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200824093524.png" srcset="data:image/png;base64,666" alt="12" style="zoom: 67%;"></th></tr></thead><tbody><tr><td><img src="https://gitee.com/wxy_666/images/raw/master/20200824093559.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200824093559.png" srcset="data:image/png;base64,666" alt="13" style="zoom:80%;"></td><td><img src="https://gitee.com/wxy_666/images/raw/master/20200824093612.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200824093612.png" srcset="data:image/png;base64,666" alt="14" style="zoom:80%;"></td></tr><tr><td><img src="https://gitee.com/wxy_666/images/raw/master/20200824093708.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200824093708.png" srcset="data:image/png;base64,666" alt="15"></td><td><img src="https://gitee.com/wxy_666/images/raw/master/20200824093715.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200824093715.png" srcset="data:image/png;base64,666" alt="16" style="zoom: 67%;"></td></tr></tbody></table><h2 id="六、项目地址"><a href="#六、项目地址" class="headerlink" title="六、项目地址"></a>六、项目地址</h2><p>本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看：</p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/666WXY666/cifafenxi" target="_blank"><img src="https://github-readme-stats.vercel.app/api/pin/?username=666WXY666&repo=cifafenxi&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/pin/?username=666WXY666&repo=cifafenxi&show_owner=true" srcset="data:image/png;base64,666"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文是编译原理C语言词法分析器的简单实现项目。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="https://666wxy666.github.io/categories/C-C/"/>
    
      <category term="编译原理" scheme="https://666wxy666.github.io/categories/C-C/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="C++" scheme="https://666wxy666.github.io/tags/C/"/>
    
      <category term="工程" scheme="https://666wxy666.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="编译原理" scheme="https://666wxy666.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="词法分析" scheme="https://666wxy666.github.io/tags/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Python杂项工程项目集锦</title>
    <link href="https://666wxy666.github.io/2020/08/15/Python%E6%9D%82%E9%A1%B9%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE%E9%9B%86%E9%94%A6/"/>
    <id>https://666wxy666.github.io/2020/08/15/Python%E6%9D%82%E9%A1%B9%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE%E9%9B%86%E9%94%A6/</id>
    <published>2020-08-14T16:00:00.000Z</published>
    <updated>2020-09-13T08:57:04.541Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>本文是一些我曾经写过的Python项目工程集锦。</strong></p><a id="more"></a><p>这些项目的源码、可执行程序、报告等已经存放于我的Github，欢迎下载查看：</p><h2 id="Python爬虫、数据处理、数据分析、数据可视化"><a href="#Python爬虫、数据处理、数据分析、数据可视化" class="headerlink" title="Python爬虫、数据处理、数据分析、数据可视化"></a>Python爬虫、数据处理、数据分析、数据可视化</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/666WXY666/PythonProjectsCollection" target="_blank"><img src="https://github-readme-stats.vercel.app/api/pin/?username=666WXY666&repo=PythonProjectsCollection&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/pin/?username=666WXY666&repo=PythonProjectsCollection&show_owner=true" srcset="data:image/png;base64,666"></a><div class="btns rounded center grid3">            <a class="button" href="https://github.com/666WXY666/PythonProjectsCollection/tree/master/Python/%E5%AD%A6%E6%A0%A1%E5%92%8C%E6%88%BF%E4%BB%B7%E7%88%AC%E8%99%AB%E5%B0%8F%E9%A1%B9%E7%9B%AE" target="_blank" rel="external nofollow noopener noreferrer" title="学校和房价爬虫小项目"><i class="fas fa-download"></i>学校和房价爬虫小项目</a><a class="button" href="https://github.com/666WXY666/PythonProjectsCollection/tree/master/Python/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E5%B0%8F%E9%A1%B9%E7%9B%AE" target="_blank" rel="external nofollow noopener noreferrer" title="数据预处理小项目"><i class="fas fa-download"></i>数据预处理小项目</a><a class="button" href="https://github.com/666WXY666/PythonProjectsCollection/tree/master/Python/%E6%88%BF%E4%BB%B7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B0%8F%E9%A1%B9%E7%9B%AE" target="_blank" rel="external nofollow noopener noreferrer" title="房价数据分析小项目"><i class="fas fa-download"></i>房价数据分析小项目</a><a class="button" href="https://github.com/666WXY666/PythonProjectsCollection/tree/master/Python/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B0%8F%E9%A1%B9%E7%9B%AE" target="_blank" rel="external nofollow noopener noreferrer" title="数据可视化小项目"><i class="fas fa-download"></i>数据可视化小项目</a><a class="button" href="https://github.com/666WXY666/PythonProjectsCollection/tree/master/Python/%E4%BA%AC%E4%B8%9C%E6%B7%98%E5%AE%9D%E6%89%8B%E6%9C%BA%E7%88%AC%E8%99%AB%E5%88%86%E6%9E%90%E9%A1%B9%E7%9B%AE" target="_blank" rel="external nofollow noopener noreferrer" title="京东淘宝手机爬虫分析项目"><i class="fas fa-download"></i>京东淘宝手机爬虫分析项目</a>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文是一些我曾经写过的Python项目工程集锦。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂项" scheme="https://666wxy666.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
      <category term="Python" scheme="https://666wxy666.github.io/categories/%E6%9D%82%E9%A1%B9/Python/"/>
    
    
      <category term="工程" scheme="https://666wxy666.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="项目" scheme="https://666wxy666.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="Python" scheme="https://666wxy666.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>机器学习 实验 花卉识别</title>
    <link href="https://666wxy666.github.io/2020/08/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%AE%9E%E9%AA%8C-%E8%8A%B1%E5%8D%89%E8%AF%86%E5%88%AB/"/>
    <id>https://666wxy666.github.io/2020/08/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%AE%9E%E9%AA%8C-%E8%8A%B1%E5%8D%89%E8%AF%86%E5%88%AB/</id>
    <published>2020-08-09T16:00:00.000Z</published>
    <updated>2020-09-10T08:06:51.904Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>本文是机器学习人工智能实验，利用华为云ModelArts平台实现花卉分类识别。</strong></p><a id="more"></a><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><p>通过该实验，实现以下目标</p><ul><li>熟悉ModelArts平台，能够调用平台的简单物体识别算法进行物体检测；</li><li>熟悉ModelArts平台特征提取方法，提取数据集的视觉特征；</li><li>熟悉ModelArts的神经网络架构，改进架构算法，进行目标检测算法的设计与实现。</li><li>学会评价检测算法的基本方法，对所设计的算法进行评估。</li></ul><h2 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="二、实验环境"></a>二、实验环境</h2><p>ModelArts平台</p><h2 id="三、实验内容"><a href="#三、实验内容" class="headerlink" title="三、实验内容"></a>三、实验内容</h2><img src="https://gitee.com/wxy_666/images/raw/master/20200715111020.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200715111020.png" srcset="data:image/png;base64,666" alt="1" style="zoom:80%;"><h2 id="四、实验步骤"><a href="#四、实验步骤" class="headerlink" title="四、实验步骤"></a>四、实验步骤</h2><p>由于时间久远，详细内容请前往Github项目查看实验报告。</p><h2 id="五、项目地址"><a href="#五、项目地址" class="headerlink" title="五、项目地址"></a>五、项目地址</h2><p>本项目的实验报告已经存放于我的Github，欢迎下载查看：</p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/666WXY666/PythonProjectsCollection" target="_blank"><img src="https://github-readme-stats.vercel.app/api/pin/?username=666WXY666&repo=PythonProjectsCollection&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/pin/?username=666WXY666&repo=PythonProjectsCollection&show_owner=true" srcset="data:image/png;base64,666"></a><div class="btns rounded center grid1">            <a class="button" href="https://github.com/666WXY666/PythonProjectsCollection/tree/master/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%AE%9E%E9%AA%8C-%E8%8A%B1%E5%8D%89%E8%AF%86%E5%88%AB" target="_blank" rel="external nofollow noopener noreferrer" title="源码仓库"><i class="fas fa-download"></i>源码仓库</a>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文是机器学习人工智能实验，利用华为云ModelArts平台实现花卉分类识别。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="https://666wxy666.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="实验" scheme="https://666wxy666.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="实验" scheme="https://666wxy666.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
      <category term="机器学习" scheme="https://666wxy666.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="华为云" scheme="https://666wxy666.github.io/tags/%E5%8D%8E%E4%B8%BA%E4%BA%91/"/>
    
      <category term="人工智能" scheme="https://666wxy666.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="AI" scheme="https://666wxy666.github.io/tags/AI/"/>
    
      <category term="分类" scheme="https://666wxy666.github.io/tags/%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>大数据实战 Spark 自选日志分析</title>
    <link href="https://666wxy666.github.io/2020/07/21/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%88%98-Spark-%E8%87%AA%E9%80%89%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"/>
    <id>https://666wxy666.github.io/2020/07/21/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%88%98-Spark-%E8%87%AA%E9%80%89%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/</id>
    <published>2020-07-20T16:00:00.000Z</published>
    <updated>2020-09-02T02:05:18.459Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文是关于大数据通过Java进行Spark编程实现自选日志处理分析。</p><a id="more"></a><h2 id="一、实验环境："><a href="#一、实验环境：" class="headerlink" title="一、实验环境："></a>一、实验环境：</h2><ul><li>虚拟机数量：1</li><li>系统版本：Centos 7.5</li><li>Spark版本：Apache Spark 2.1.1</li><li>Eclipse版本：Neno.3 （4.6.3）</li></ul><h2 id="二、实验内容："><a href="#二、实验内容：" class="headerlink" title="二、实验内容："></a>二、实验内容：</h2><ul><li>收集一组自选日志，构造mydata.log数据集，上传到实验环境中，重新完成对自选日志分析。</li></ul><h2 id="三、主要步骤："><a href="#三、主要步骤：" class="headerlink" title="三、主要步骤："></a>三、主要步骤：</h2><ul><li>获取自选数据集</li><li>自选数据集计算的需求分析</li><li>编程设计实现</li><li>运行程序</li></ul><h2 id="四、实验步骤："><a href="#四、实验步骤：" class="headerlink" title="四、实验步骤："></a>四、实验步骤：</h2><h3 id="4-1获取自选数据集以及数据字段格式解释说明"><a href="#4-1获取自选数据集以及数据字段格式解释说明" class="headerlink" title="4.1获取自选数据集以及数据字段格式解释说明"></a>4.1获取自选数据集以及数据字段格式解释说明</h3><p>我受到平台的第一个实验和uber日志文件的启发，想到了自己用python生成uber日志文件，首先是日志的格式：</p><table><thead><tr><th align="center">字段</th><th align="center">数据类型</th><th align="center">说明信息</th></tr></thead><tbody><tr><td align="center">dispatching_base_number</td><td align="center">String</td><td align="center">区域编号</td></tr><tr><td align="center">date</td><td align="center">String</td><td align="center">日期</td></tr><tr><td align="center">active_vehicles</td><td align="center">int</td><td align="center">使用的机动车数量</td></tr><tr><td align="center">trips</td><td align="center">int</td><td align="center">旅游次数</td></tr></tbody></table><p>定义好了日志的格式，只要编写python程序，让他自己按照这个格式生产日志即可，具体代码见附录，下面是部分代码截图和运行结果：</p><img src="https://gitee.com/wxy_666/images/raw/master/20200603145855.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200603145855.jpg" srcset="data:image/png;base64,666" alt="2020-06-03_145833" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200603145923.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200603145923.jpg" srcset="data:image/png;base64,666" alt="2020-06-03_145917" style="zoom:80%;"><h3 id="4-2自选数据集计算的需求分析"><a href="#4-2自选数据集计算的需求分析" class="headerlink" title="4.2自选数据集计算的需求分析"></a>4.2自选数据集计算的需求分析</h3><p>因为是汽车和旅游日志信息，并且有不同日期，不同地区的信息，主要需求就是选取从开始时间到截止时间使用的机动车数量和旅游次数最多的前10个地区，以及他们的机动车总数量和旅游总次数。</p><p>主要步骤就是（与实验一大体相同，又有所区别）：</p><ol><li><p>按照 Serrializable 接口实现自定义排序的 Key；</p></li><li><p>将要进行二次排序的文件加载进来生成 key-value 类型的 RDD</p></li><li><p>使用 sortByKey 基于自定义的 Key 进行二次排序</p></li><li><p>去除掉排序的 key，只保留排序结果</p><p>排序规则如下：</p><p>以区域编号dispatching_base_number为基准，分别按照active_vehicles，trips，date进行降序排序。即先按照active_vehicles排序，如果active_vehicles相同，再比较trips，如果trips相同，再比较date，最后选择前10条记录输出。</p></li></ol><h3 id="4-3编程设计实现"><a href="#4-3编程设计实现" class="headerlink" title="4.3编程设计实现"></a>4.3编程设计实现</h3><h4 id="4-3-1创建工程"><a href="#4-3-1创建工程" class="headerlink" title="4.3.1创建工程"></a>4.3.1创建工程</h4><p>4.3.1.1打开Eclipse IDE</p><pre><code class="shell">cd eclipse/./eclipse &amp;</code></pre><img src="https://gitee.com/wxy_666/images/raw/master/20200603143358.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200603143358.jpg" srcset="data:image/png;base64,666" alt="2020-06-03_102818" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200603143419.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200603143419.jpg" srcset="data:image/png;base64,666" alt="2020-06-03_102840" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200603143431.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200603143431.jpg" srcset="data:image/png;base64,666" alt="2020-06-03_102917" style="zoom:80%;"><p>4.3.1.2点击 File -&gt; New -&gt;Other</p><p>4.3.1.3搜索 maven -&gt; 点击 Maven Project -&gt; Next-&gt;Next</p><img src="https://gitee.com/wxy_666/images/raw/master/20200603143443.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200603143443.jpg" srcset="data:image/png;base64,666" alt="2020-06-03_103021" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200603143500.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200603143500.jpg" srcset="data:image/png;base64,666" alt="2020-06-03_103035" style="zoom:80%;"><p>4.3.1.4选中maven-archetype-quickstart -&gt;Next</p><img src="https://gitee.com/wxy_666/images/raw/master/20200603143535.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200603143535.jpg" srcset="data:image/png;base64,666" alt="2020-06-03_103051" style="zoom:80%;"><p>4.3.1.5输入Group Id 为 org.zkpk；Artifact Id 为 spark ；Package为org.zkpk.spark；-&gt;Finish</p><img src="https://gitee.com/wxy_666/images/raw/master/20200603143603.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200603143603.jpg" srcset="data:image/png;base64,666" alt="2020-06-03_103201" style="zoom:80%;"><p>4.3.1.6升级maven工程</p><img src="https://gitee.com/wxy_666/images/raw/master/20200603143618.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200603143618.jpg" srcset="data:image/png;base64,666" alt="2020-06-03_103247" style="zoom:80%;"><p>升级完成：</p><img src="https://gitee.com/wxy_666/images/raw/master/20200603143638.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200603143638.jpg" srcset="data:image/png;base64,666" alt="2020-06-03_103513" style="zoom:80%;"><p>4.3.1.7更改JRE，右键JRE System Library-&gt; Properties</p><p>4.3.1.8选中jdk1.8.0_131-&gt; OK</p><img src="https://gitee.com/wxy_666/images/raw/master/20200603143649.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200603143649.jpg" srcset="data:image/png;base64,666" alt="2020-06-03_103535" style="zoom:80%;"><p>4.3.1.9点击spark项目-&gt;修改pom.xml-&gt; 保存会自动下载jar包</p><p>4.3.1.10下载Jar包：</p><img src="https://gitee.com/wxy_666/images/raw/master/20200603143734.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200603143734.jpg" srcset="data:image/png;base64,666" alt="2020-06-03_103915" style="zoom:80%;"><p>4.3.1.11最终 pom.xml 如下：</p><pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;org.zkpk&lt;/groupId&gt;  &lt;artifactId&gt;spark&lt;/artifactId&gt;  &lt;version&gt;0.0.1&lt;/version&gt;  &lt;packaging&gt;jar&lt;/packaging&gt;  &lt;name&gt;spark&lt;/name&gt;  &lt;url&gt;http://maven.apache.org&lt;/url&gt;  &lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;  &lt;/properties&gt;  &lt;dependencies&gt;    &lt;dependency&gt;      &lt;groupId&gt;junit&lt;/groupId&gt;      &lt;artifactId&gt;junit&lt;/artifactId&gt;      &lt;version&gt;3.8.1&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;      &lt;artifactId&gt;spark-core_2.10&lt;/artifactId&gt;      &lt;version&gt;1.5.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;      &lt;artifactId&gt;spark-sql_2.10&lt;/artifactId&gt;      &lt;version&gt;1.5.0&lt;/version&gt;      &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;      &lt;artifactId&gt;spark-hive_2.10&lt;/artifactId&gt;      &lt;version&gt;1.5.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;      &lt;artifactId&gt;spark-streaming_2.10&lt;/artifactId&gt;      &lt;version&gt;1.5.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;      &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt;      &lt;version&gt;2.7.3&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;      &lt;artifactId&gt;spark-streaming-kafka_2.10&lt;/artifactId&gt;          &lt;version&gt;1.5.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;      &lt;artifactId&gt;spark-streaming-flume_2.10&lt;/artifactId&gt;          &lt;version&gt;1.5.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;      &lt;artifactId&gt;httpclient&lt;/artifactId&gt;      &lt;version&gt;4.3.5&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;      &lt;artifactId&gt;httpcore&lt;/artifactId&gt;      &lt;version&gt;4.3.1&lt;/version&gt;    &lt;/dependency&gt;  &lt;/dependencies&gt;  &lt;build&gt;    &lt;sourceDirectory&gt;src/main/java&lt;/sourceDirectory&gt;    &lt;testSourceDirectory&gt;src/main/test&lt;/testSourceDirectory&gt;    &lt;plugins&gt;      &lt;plugin&gt;        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;        &lt;configuration&gt;          &lt;descriptorRefs&gt;            &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;          &lt;/descriptorRefs&gt;          &lt;archive&gt;            &lt;manifest&gt;              &lt;mainClass&gt;&lt;/mainClass&gt;            &lt;/manifest&gt;          &lt;/archive&gt;        &lt;/configuration&gt;        &lt;executions&gt;          &lt;execution&gt;            &lt;id&gt;make-assembly&lt;/id&gt;            &lt;phase&gt;package&lt;/phase&gt;            &lt;goals&gt;              &lt;goal&gt;single&lt;/goal&gt;            &lt;/goals&gt;          &lt;/execution&gt;        &lt;/executions&gt;      &lt;/plugin&gt;      &lt;plugin&gt;        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;        &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt;        &lt;version&gt;1.2.1&lt;/version&gt;        &lt;executions&gt;          &lt;execution&gt;            &lt;goals&gt;              &lt;goal&gt;exec&lt;/goal&gt;            &lt;/goals&gt;          &lt;/execution&gt;        &lt;/executions&gt;        &lt;configuration&gt;          &lt;executable&gt;java&lt;/executable&gt;          &lt;includeProjectDependencies&gt;true&lt;/includeProjectDependencies&gt;          &lt;includePluginDependencies&gt;false&lt;/includePluginDependencies&gt;          &lt;classpathScope&gt;compile&lt;/classpathScope&gt;          &lt;mainClass&gt;cn.com.syl.spark.App&lt;/mainClass&gt;        &lt;/configuration&gt;      &lt;/plugin&gt;      &lt;plugin&gt;        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;        &lt;configuration&gt;          &lt;source&gt;1.6&lt;/source&gt;          &lt;target&gt;1.6&lt;/target&gt;        &lt;/configuration&gt;      &lt;/plugin&gt;    &lt;/plugins&gt;  &lt;/build&gt;&lt;/project&gt;</code></pre><p>4.3.1.12删除工程生成的App.java和AppTest.java</p><img src="https://gitee.com/wxy_666/images/raw/master/20200603143746.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200603143746.jpg" srcset="data:image/png;base64,666" alt="2020-06-03_104358" style="zoom:80%;"><p>利用实验一的实验环境编写java程序，同样是SecondarySortKey.java和SecondarySortDemo.java两个java文件。其中SecondarySortKey.java中有两个类，一个是serDemo类，用于存储未排序的数据，一个是SecondarySortKey类，里面重写了一系列排序函数，用于按照自己的规则排序；SecondarySortDemo.java有一个类SecondarySortDemo，里面有主函数和创建Spark RDD，求和，sortByKey等函数，是主要的逻辑运行的地方。</p><h4 id="4-3-2这里只挑出关键的代码进行解释注释和说明，详细的带注释的代码见附录："><a href="#4-3-2这里只挑出关键的代码进行解释注释和说明，详细的带注释的代码见附录：" class="headerlink" title="4.3.2这里只挑出关键的代码进行解释注释和说明，详细的带注释的代码见附录："></a>4.3.2这里只挑出关键的代码进行解释注释和说明，详细的带注释的代码见附录：</h4><p>这是排序的数据存放的类，有三个字段，全参构造函数，getter和setter，以及toString，hashCode和equal方法。</p><pre><code class="java">public class SecondarySortKey implements Ordered&lt;SecondarySortKey&gt;, Serializable {    private static final long serialVersionUID = 3702442700882342403L;    //日期    private String date;    //使用的机动车数量    private int activeVehicles;    //旅游次数    private int trips;    public SecondarySortKey() {        super();    }    public SecondarySortKey(String date, int activeVehicles, int trips) {        super();        this.date = date;        this.activeVehicles = activeVehicles;        this.trips = trips;    }    ......    @Override    public boolean equals(Object o) {        if (this == o) {            return true;        }        if (o == null || getClass() != o.getClass()) {            return false;        }        SecondarySortKey that = (SecondarySortKey) o;        return activeVehicles == that.activeVehicles &amp;&amp;                trips == that.trips &amp;&amp;                Objects.equals(date, that.date);    }    @Override    public int hashCode() {        return Objects.hash(date, activeVehicles, trips);    }    @Override    public String toString() {        return &quot;SortResult{&quot; +                &quot;截止日期：&quot; + date +                &quot;, 使用的机动车总数量：&quot; + activeVehicles +                &quot;, 旅游总次数：&quot; + trips +                &#39;}&#39;;    }}</code></pre><p>最主要的是$greater，$less等一系列比较函数和compare和compareTo函数用于RDD的sortByKey。</p><pre><code class="java">......    public boolean $greater(SecondarySortKey other) {        if (activeVehicles &gt; other.activeVehicles) {            return true;        } else if (activeVehicles == other.activeVehicles &amp;&amp;                trips &gt; other.trips) {            return true;        } else if (activeVehicles == other.activeVehicles &amp;&amp;                trips == other.trips &amp;&amp;                date.compareTo(other.date) &gt; 0) {            return true;        }        return false;    }......    public int compare(SecondarySortKey other) {        if (activeVehicles - other.activeVehicles != 0) {            return activeVehicles - other.activeVehicles;        } else if (trips - other.trips != 0) {            return trips - other.trips;        }        return 0;    }    public int compareTo(SecondarySortKey other) {        if (activeVehicles - other.activeVehicles != 0) {            return activeVehicles - other.activeVehicles;        } else if (trips - other.trips != 0) {            return trips - other.trips;        }        return 0;    }</code></pre><p>下面的类是主方法所在的类，也是主要的对数据进行处理计算的类：</p><p>他有四个函数（算上主函数），分别为：</p><ul><li><p>main：</p><p>用于打开文件，创建SparkConf和SparkContext对象，调用函数对RDD进行操作，并输出结果。</p><pre><code class="java">    public static void main(String[] args) throws Exception {        SparkConf conf = new SparkConf().setAppName(&quot;SecondarySortDemo&quot;).setMaster(&quot;local&quot;);        JavaSparkContext jsc = new JavaSparkContext(conf);        jsc.setLogLevel(&quot;WARN&quot;);        JavaRDD&lt;String&gt; textfile = jsc.textFile(&quot;/home/zkpk/experiment/mydata.log&quot;);        JavaPairRDD&lt;String, serDemo&gt; pairRdd = mapTfRDD2Pair(textfile);        JavaPairRDD&lt;String, serDemo&gt; getlines = aggregateByDeviceID(pairRdd);        JavaPairRDD&lt;SecondarySortKey, String&gt; telval = mapRDDKey2SortKey(getlines);        JavaPairRDD&lt;SecondarySortKey, String&gt; sortedRdd = telval.sortByKey(false);        List&lt;Tuple2&lt;SecondarySortKey, String&gt;&gt; getTop = sortedRdd.take(10);        System.out.println(&quot;============ result ============&quot;);        for (Tuple2&lt;SecondarySortKey, String&gt; dt : getTop) {            System.out.println(&quot;区域编号：&quot; + dt._2 + &quot;, &quot; + dt._1);        }        jsc.close();    }</code></pre></li></ul><ul><li><p>mapTfRDD2Pair：</p><p>用于从文件中读取数据，并将其转化为JavaPairRDD，key为区域编号dispatchingBaseNumber，value为以文件每一行生成的serDemo对象。</p><pre><code class="java">private static JavaPairRDD&lt;String, serDemo&gt; mapTfRDD2Pair(JavaRDD&lt;String&gt; accessLogRDD) {        return accessLogRDD.mapToPair(new PairFunction&lt;String, String, serDemo&gt;() {            private static final long serialVersionUID = 1L;            public Tuple2&lt;String, serDemo&gt; call(String lines) throws Exception {                String[] split = lines.split(&quot;,&quot;);                String dispatchingBaseNumber = split[0];                String date = split[1];                int activeVehicles = Integer.valueOf(split[2]);                int trips = Integer.valueOf(split[3]);                serDemo dataInfo = new serDemo(date, activeVehicles, trips);                return new Tuple2&lt;String, serDemo&gt;(dispatchingBaseNumber, dataInfo);            }        });    }</code></pre></li></ul><ul><li><p>aggregateByRegionID：</p><p>用于将mapTfRDD2Pair生成好的JavaPairRDD按照key对使用的机动车数量activeVehicles和旅游次数trips求和，获得JavaPairRDD，key为区域编号dispatchingBaseNumber，value为已经求和聚集完成的serDemo对象。</p><pre><code class="java">    private static JavaPairRDD&lt;String, serDemo&gt; aggregateByDeviceID(JavaPairRDD&lt;String, serDemo&gt; accessLogPairRDD) {        return accessLogPairRDD.reduceByKey(new Function2&lt;serDemo, serDemo, serDemo&gt;() {            private static final long serialVersionUID = 1L;            public serDemo call(serDemo d1, serDemo d2) throws Exception {                String date = d1.getDate().compareTo(d2.getDate()) &gt; 0 ? d1.getDate() : d2.getDate();                int activeVehicles = d1.getActiveVehicles() + d2.getActiveVehicles();                int trips = d1.getTrips() + d2.getTrips();                serDemo accessLogInfo = new serDemo();                accessLogInfo.setDate(date);                accessLogInfo.setActiveVehicles(activeVehicles);                accessLogInfo.setTrips(trips);                return accessLogInfo;            }        });    }</code></pre></li></ul><ul><li><p>mapRDDKey2SortKey：</p><p>用于将aggregateByRegionID生成好的JavaPairRDD按照上面定义好的规则进行排序，获得排好序的JavaPairRDD，用于输出。</p><pre><code class="java">    private static JavaPairRDD&lt;SecondarySortKey, String&gt; mapRDDKey2SortKey(            JavaPairRDD&lt;String, serDemo&gt; aggrAccessLogPairRDD) {        return aggrAccessLogPairRDD.mapToPair(                new PairFunction&lt;Tuple2&lt;String, serDemo&gt;, SecondarySortKey, String&gt;() {                    private static final long serialVersionUID = 1L;                    public Tuple2&lt;SecondarySortKey, String&gt; call(Tuple2&lt;String, serDemo&gt; tuple) throws Exception {                        String dispatchingBaseNumber = tuple._1;                        serDemo accessLogInfo = tuple._2;                        SecondarySortKey accessLogSortKey = new SecondarySortKey(accessLogInfo.getDate(), accessLogInfo.getActiveVehicles(),                                accessLogInfo.getTrips());                        return new Tuple2&lt;SecondarySortKey, String&gt;(accessLogSortKey, dispatchingBaseNumber);                    }                });    }</code></pre></li></ul><h3 id="4-4运行程序"><a href="#4-4运行程序" class="headerlink" title="4.4运行程序"></a>4.4运行程序</h3><h4 id="4-4-1将生成好的mydata-log发送到平台。"><a href="#4-4-1将生成好的mydata-log发送到平台。" class="headerlink" title="4.4.1将生成好的mydata.log发送到平台。"></a>4.4.1将生成好的mydata.log发送到平台。</h4><img src="https://gitee.com/wxy_666/images/raw/master/20200603153734.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200603153734.jpg" srcset="data:image/png;base64,666" alt="2020-06-03_125258" style="zoom:80%;"><h4 id="4-4-2运行程序，查看结果。"><a href="#4-4-2运行程序，查看结果。" class="headerlink" title="4.4.2运行程序，查看结果。"></a>4.4.2运行程序，查看结果。</h4><p>可以发现，程序正常运行得出了结果，并且已经求和和排序，成功！</p><img src="https://gitee.com/wxy_666/images/raw/master/20200603154055.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200603154055.png" srcset="data:image/png;base64,666" alt="QQ截图20200603142255" style="zoom:80%;"><h2 id="五、附录"><a href="#五、附录" class="headerlink" title="五、附录"></a>五、附录</h2><h3 id="1、SecondarySortKey-java"><a href="#1、SecondarySortKey-java" class="headerlink" title="1、SecondarySortKey.java"></a>1、SecondarySortKey.java</h3><pre><code class="java">package org.zkpk.spark;import scala.math.Ordered;import java.io.Serializable;import java.util.Objects;class serDemo implements Serializable {    private static final long serialVersionUID = 5749943279909593929L;    //日期    private String date;    //使用的机动车数量    private int activeVehicles;    //旅游次数    private int trips;    public serDemo() {        super();    }    public serDemo(String date, int activeVehicles, int trips) {        super();        this.date = date;        this.activeVehicles = activeVehicles;        this.trips = trips;    }    public static long getSerialVersionUID() {        return serialVersionUID;    }    public String getDate() {        return date;    }    public void setDate(String date) {        this.date = date;    }    public int getActiveVehicles() {        return activeVehicles;    }    public void setActiveVehicles(int activeVehicles) {        this.activeVehicles = activeVehicles;    }    public int getTrips() {        return trips;    }    public void setTrips(int trips) {        this.trips = trips;    }}public class SecondarySortKey implements Ordered&lt;SecondarySortKey&gt;, Serializable {    private static final long serialVersionUID = 3702442700882342403L;    //日期    private String date;    //使用的机动车数量    private int activeVehicles;    //旅游次数    private int trips;    public SecondarySortKey() {        super();    }    public SecondarySortKey(String date, int activeVehicles, int trips) {        super();        this.date = date;        this.activeVehicles = activeVehicles;        this.trips = trips;    }    public static long getSerialVersionUID() {        return serialVersionUID;    }    public String getDate() {        return date;    }    public void setDate(String date) {        this.date = date;    }    public int getActiveVehicles() {        return activeVehicles;    }    public void setActiveVehicles(int activeVehicles) {        this.activeVehicles = activeVehicles;    }    public int getTrips() {        return trips;    }    public void setTrips(int trips) {        this.trips = trips;    }    public boolean $greater(SecondarySortKey other) {        if (activeVehicles &gt; other.activeVehicles) {            return true;        } else if (activeVehicles == other.activeVehicles &amp;&amp;                trips &gt; other.trips) {            return true;        } else if (activeVehicles == other.activeVehicles &amp;&amp;                trips == other.trips &amp;&amp;                date.compareTo(other.date) &gt; 0) {            return true;        }        return false;    }    public boolean $greater$eq(SecondarySortKey other) {        if ($greater(other)) {            return true;        } else if (activeVehicles == other.activeVehicles &amp;&amp;                trips == other.trips &amp;&amp;                date.compareTo(other.date) == 0) {            return true;        }        return false;    }    public boolean $less(SecondarySortKey other) {        if (activeVehicles &lt; other.activeVehicles) {            return true;        } else if (activeVehicles == other.activeVehicles &amp;&amp;                trips &lt; other.trips) {            return true;        } else if (activeVehicles == other.activeVehicles &amp;&amp;                trips == other.trips &amp;&amp;                date.compareTo(other.date) &lt; 0) {            return true;        }        return false;    }    public boolean $less$eq(SecondarySortKey other) {        if ($less(other)) {            return true;        } else if (activeVehicles == other.activeVehicles &amp;&amp;                trips == other.trips &amp;&amp;                date.compareTo(other.date) == 0) {            return true;        }        return false;    }    public int compare(SecondarySortKey other) {        if (activeVehicles - other.activeVehicles != 0) {            return activeVehicles - other.activeVehicles;        } else if (trips - other.trips != 0) {            return trips - other.trips;        }        return 0;    }    public int compareTo(SecondarySortKey other) {        if (activeVehicles - other.activeVehicles != 0) {            return activeVehicles - other.activeVehicles;        } else if (trips - other.trips != 0) {            return trips - other.trips;        }        return 0;    }    @Override    public boolean equals(Object o) {        if (this == o) {            return true;        }        if (o == null || getClass() != o.getClass()) {            return false;        }        SecondarySortKey that = (SecondarySortKey) o;        return activeVehicles == that.activeVehicles &amp;&amp;                trips == that.trips &amp;&amp;                Objects.equals(date, that.date);    }    @Override    public int hashCode() {        return Objects.hash(date, activeVehicles, trips);    }    @Override    public String toString() {        return &quot;SortResult{&quot; +                &quot;截止日期：&quot; + date +                &quot;, 使用的机动车总数量：&quot; + activeVehicles +                &quot;, 旅游总次数：&quot; + trips +                &#39;}&#39;;    }}</code></pre><h3 id="2、SecondarySortDemo-java"><a href="#2、SecondarySortDemo-java" class="headerlink" title="2、SecondarySortDemo.java"></a>2、SecondarySortDemo.java</h3><pre><code class="java">package org.zkpk.spark;import org.apache.spark.SparkConf;import org.apache.spark.api.java.JavaPairRDD;import org.apache.spark.api.java.JavaRDD;import org.apache.spark.api.java.JavaSparkContext;import org.apache.spark.api.java.function.Function2;import org.apache.spark.api.java.function.PairFunction;import scala.Tuple2;import java.util.List;public class SecondarySortDemo {    public static void main(String[] args) throws Exception {        SparkConf conf = new SparkConf().setAppName(&quot;SecondarySortDemo&quot;).setMaster(&quot;local&quot;);        JavaSparkContext jsc = new JavaSparkContext(conf);        jsc.setLogLevel(&quot;WARN&quot;);        JavaRDD&lt;String&gt; textfile = jsc.textFile(&quot;/home/zkpk/experiment/mydata.log&quot;);        JavaPairRDD&lt;String, serDemo&gt; pairRdd = mapTfRDD2Pair(textfile);        JavaPairRDD&lt;String, serDemo&gt; getlines = aggregateByRegionID(pairRdd);        JavaPairRDD&lt;SecondarySortKey, String&gt; telval = mapRDDKey2SortKey(getlines);        JavaPairRDD&lt;SecondarySortKey, String&gt; sortedRdd = telval.sortByKey(false);        List&lt;Tuple2&lt;SecondarySortKey, String&gt;&gt; getTop = sortedRdd.take(10);        System.out.println(&quot;============ result ============&quot;);        for (Tuple2&lt;SecondarySortKey, String&gt; dt : getTop) {            System.out.println(&quot;区域编号：&quot; + dt._2 + &quot;, &quot; + dt._1);        }        jsc.close();    }    //从文件读取生成PairRDD    private static JavaPairRDD&lt;String, serDemo&gt; mapTfRDD2Pair(JavaRDD&lt;String&gt; accessLogRDD) {        return accessLogRDD.mapToPair(new PairFunction&lt;String, String, serDemo&gt;() {            private static final long serialVersionUID = 1L;            public Tuple2&lt;String, serDemo&gt; call(String lines) throws Exception {                String[] split = lines.split(&quot;,&quot;);                String dispatchingBaseNumber = split[0];                String date = split[1];                int activeVehicles = Integer.valueOf(split[2]);                int trips = Integer.valueOf(split[3]);                serDemo dataInfo = new serDemo(date, activeVehicles, trips);                return new Tuple2&lt;String, serDemo&gt;(dispatchingBaseNumber, dataInfo);            }        });    }    //对PairRDD进行reduceByKey聚集操作求和    private static JavaPairRDD&lt;String, serDemo&gt; aggregateByRegionID(JavaPairRDD&lt;String, serDemo&gt; accessLogPairRDD) {        return accessLogPairRDD.reduceByKey(new Function2&lt;serDemo, serDemo, serDemo&gt;() {            private static final long serialVersionUID = 1L;            public serDemo call(serDemo d1, serDemo d2) throws Exception {                String date = d1.getDate().compareTo(d2.getDate()) &gt; 0 ? d1.getDate() : d2.getDate();                int activeVehicles = d1.getActiveVehicles() + d2.getActiveVehicles();                int trips = d1.getTrips() + d2.getTrips();                serDemo accessLogInfo = new serDemo();                accessLogInfo.setDate(date);                accessLogInfo.setActiveVehicles(activeVehicles);                accessLogInfo.setTrips(trips);                return accessLogInfo;            }        });    }    //对PairRDD进行排序，用于最后输出    private static JavaPairRDD&lt;SecondarySortKey, String&gt; mapRDDKey2SortKey(            JavaPairRDD&lt;String, serDemo&gt; aggrAccessLogPairRDD) {        return aggrAccessLogPairRDD.mapToPair(                new PairFunction&lt;Tuple2&lt;String, serDemo&gt;, SecondarySortKey, String&gt;() {                    private static final long serialVersionUID = 1L;                    public Tuple2&lt;SecondarySortKey, String&gt; call(Tuple2&lt;String, serDemo&gt; tuple) throws Exception {                        String dispatchingBaseNumber = tuple._1;                        serDemo accessLogInfo = tuple._2;                        SecondarySortKey accessLogSortKey = new SecondarySortKey(accessLogInfo.getDate(), accessLogInfo.getActiveVehicles(),                                accessLogInfo.getTrips());                        return new Tuple2&lt;SecondarySortKey, String&gt;(accessLogSortKey, dispatchingBaseNumber);                    }                });    }}</code></pre><h3 id="3、log-generate-py"><a href="#3、log-generate-py" class="headerlink" title="3、log_generate.py"></a>3、log_generate.py</h3><pre><code class="python">&quot;&quot;&quot;@Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved.@Project: log_generate@Description: @Version: @Author: 苇名一心@Date: 2020-06-03 11:20@LastEditors: 苇名一心@LastEditTime: 2020-06-03 11:20&quot;&quot;&quot;# -*- coding: UTF-8 -*-import randomimport stringimport timefile = open(&quot;mydata.log&quot;, mode=&#39;a&#39;)ch = string.ascii_uppercasedispatching_base_number_list = []for j in range(20):    dispatching_base_number_list.append(random.choice(ch) + str(random.randint(1, 9)))for i in range(100):    for dispatching_base_number in dispatching_base_number_list:        file.write(dispatching_base_number + &quot;,&quot; +                   time.strftime(&quot;%Y-%m-%d&quot;,                                 time.gmtime(                                     time.mktime(                                         time.strptime(&quot;2020-01-02&quot;, &quot;%Y-%m-%d&quot;)) + 86400 * i)) + &quot;,&quot; +                   str(random.randint(100, 10000)) + &quot;,&quot; +                   str(random.randint(1000, 100000)) + &quot;\n&quot;)        if i == 99 and dispatching_base_number == dispatching_base_number_list[len(dispatching_base_number_list) - 1]:            file.write(dispatching_base_number + &quot;,&quot; +                       time.strftime(&quot;%Y-%m-%d&quot;,                                     time.gmtime(                                         time.mktime(                                             time.strptime(&quot;2020-01-02&quot;, &quot;%Y-%m-%d&quot;)) + 86400 * i)) + &quot;,&quot; +                       str(random.randint(100, 10000)) + &quot;,&quot; +                       str(random.randint(1000, 100000)))file.close()</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是关于大数据通过Java进行Spark编程实现自选日志处理分析。&lt;/p&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="实战" scheme="https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="实战" scheme="https://666wxy666.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
      <category term="大数据" scheme="https://666wxy666.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Spark" scheme="https://666wxy666.github.io/tags/Spark/"/>
    
      <category term="流计算" scheme="https://666wxy666.github.io/tags/%E6%B5%81%E8%AE%A1%E7%AE%97/"/>
    
      <category term="单词计数" scheme="https://666wxy666.github.io/tags/%E5%8D%95%E8%AF%8D%E8%AE%A1%E6%95%B0/"/>
    
      <category term="Streaming" scheme="https://666wxy666.github.io/tags/Streaming/"/>
    
      <category term="Scala" scheme="https://666wxy666.github.io/tags/Scala/"/>
    
      <category term="Kafka" scheme="https://666wxy666.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>大数据实战 Spark 分析流量日志</title>
    <link href="https://666wxy666.github.io/2020/07/20/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%88%98-Spark-%E5%88%86%E6%9E%90%E6%B5%81%E9%87%8F%E6%97%A5%E5%BF%97/"/>
    <id>https://666wxy666.github.io/2020/07/20/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%88%98-Spark-%E5%88%86%E6%9E%90%E6%B5%81%E9%87%8F%E6%97%A5%E5%BF%97/</id>
    <published>2020-07-19T16:00:00.000Z</published>
    <updated>2020-09-02T02:05:09.581Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文是关于大数据通过Java进行Spark编程实现日志处理分析。</p><a id="more"></a><h2 id="一、实验环境："><a href="#一、实验环境：" class="headerlink" title="一、实验环境："></a>一、实验环境：</h2><ul><li>虚拟机数量：1</li><li>系统版本：Centos 7.5</li><li>Spark版本：Apache Spark 2.1.1</li><li>Eclipse版本：Neno.3 （4.6.3）</li></ul><h2 id="二、实验目的："><a href="#二、实验目的：" class="headerlink" title="二、实验目的："></a>二、实验目的：</h2><p>掌握</p><ul><li>Spark原理</li><li>Hadoop原理</li><li>Shell</li><li>Spark Streaming</li><li>二次排序</li><li>序列化</li><li>Spark RDD</li></ul><h2 id="三、实验结果："><a href="#三、实验结果：" class="headerlink" title="三、实验结果："></a>三、实验结果：</h2><ul><li><p>以下是分析后的流量日志结果：</p><img src="https://gitee.com/wxy_666/images/raw/master/20200603142941.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200603142941.png" srcset="data:image/png;base64,666" alt="7b6022296ee8fef49cd725321a76c1da" style="zoom:80%;"></li></ul><h2 id="四、实验内容："><a href="#四、实验内容：" class="headerlink" title="四、实验内容："></a>四、实验内容：</h2><ul><li>使用SparkStreaming构建实时数据处理系统，来分析手机流量日志。</li></ul><h2 id="五、主要步骤："><a href="#五、主要步骤：" class="headerlink" title="五、主要步骤："></a>五、主要步骤：</h2><ul><li>日志分析</li><li>代码实现</li><li>运行程序</li></ul><h2 id="六、实验步骤："><a href="#六、实验步骤：" class="headerlink" title="六、实验步骤："></a>六、实验步骤：</h2><h3 id="6-1数据日志介绍"><a href="#6-1数据日志介绍" class="headerlink" title="6.1数据日志介绍"></a>6.1数据日志介绍</h3><p>6.1.1数据字段</p><p>6.1.1.1reportTime（报告时间戳）</p><p>6.1.1.2telNum（手机号）</p><p>6.1.1.3upwardflow（上行总流量）</p><p>6.1.1.4downwardflow（下行总流量）</p><h3 id="6-2需求分析"><a href="#6-2需求分析" class="headerlink" title="6.2需求分析"></a>6.2需求分析</h3><p>6.2.1对文本中数据记录进行排序，排序规则如下：</p><p>以telNum为基准，分别按照 upwardflow，downwardflow，reportTime进行降序排序，即先按照upwardflow排序，如果upwardflow相同，再比较downwardflow，如果downwardflow相同，再比较reportTime，最后选择前10条记录输出。</p><p>6.2.2具体实现步骤：</p><p>6.2.2.1按照 Serrializable 接口实现自定义排序的 Key</p><p>6.2.2.2将要进行二次排序的文件加载进来生成 key-value 类型的 RDD</p><p>6.2.2.3使用 sortByKey 基于自定义的 Key 进行二次排序</p><p>6.2.2.4去除掉排序的 key，只保留排序结果</p><h3 id="6-3代码实现："><a href="#6-3代码实现：" class="headerlink" title="6.3代码实现："></a>6.3代码实现：</h3><h4 id="6-3-1创建maven项目"><a href="#6-3-1创建maven项目" class="headerlink" title="6.3.1创建maven项目"></a>6.3.1创建maven项目</h4><p>6.3.1.1打开Eclipse IDE</p><pre><code class="shell">cd eclipse/./eclipse &amp;</code></pre><img src="https://gitee.com/wxy_666/images/raw/master/20200603143358.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200603143358.jpg" srcset="data:image/png;base64,666" alt="2020-06-03_102818" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200603143419.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200603143419.jpg" srcset="data:image/png;base64,666" alt="2020-06-03_102840" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200603143431.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200603143431.jpg" srcset="data:image/png;base64,666" alt="2020-06-03_102917" style="zoom:80%;"><p>6.3.1.2点击 File -&gt; New -&gt;Other</p><p>6.3.1.3搜索 maven -&gt; 点击 Maven Project -&gt; Next-&gt;Next</p><img src="https://gitee.com/wxy_666/images/raw/master/20200603143443.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200603143443.jpg" srcset="data:image/png;base64,666" alt="2020-06-03_103021" style="zoom:80%;"><img src="https://gitee.com/wxy_666/images/raw/master/20200603143500.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200603143500.jpg" srcset="data:image/png;base64,666" alt="2020-06-03_103035" style="zoom:80%;"><p>6.3.1.4选中maven-archetype-quickstart -&gt;Next</p><img src="https://gitee.com/wxy_666/images/raw/master/20200603143535.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200603143535.jpg" srcset="data:image/png;base64,666" alt="2020-06-03_103051" style="zoom:80%;"><p>6.3.1.5输入Group Id 为 org.zkpk；Artifact Id 为 spark ；Package为org.zkpk.spark；-&gt;Finish</p><img src="https://gitee.com/wxy_666/images/raw/master/20200603143603.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200603143603.jpg" srcset="data:image/png;base64,666" alt="2020-06-03_103201" style="zoom:80%;"><p>6.3.1.6升级maven工程</p><img src="https://gitee.com/wxy_666/images/raw/master/20200603143618.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200603143618.jpg" srcset="data:image/png;base64,666" alt="2020-06-03_103247" style="zoom:80%;"><p>升级完成：</p><img src="https://gitee.com/wxy_666/images/raw/master/20200603143638.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200603143638.jpg" srcset="data:image/png;base64,666" alt="2020-06-03_103513" style="zoom:80%;"><p>6.3.1.7更改JRE，右键JRE System Library-&gt; Properties</p><p>6.3.1.8选中jdk1.8.0_131-&gt; OK</p><img src="https://gitee.com/wxy_666/images/raw/master/20200603143649.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200603143649.jpg" srcset="data:image/png;base64,666" alt="2020-06-03_103535" style="zoom:80%;"><p>6.3.1.9点击spark项目-&gt;修改pom.xml-&gt; 保存会自动下载jar包</p><p>6.3.1.10下载Jar包：</p><img src="https://gitee.com/wxy_666/images/raw/master/20200603143734.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200603143734.jpg" srcset="data:image/png;base64,666" alt="2020-06-03_103915" style="zoom:80%;"><p>6.3.1.11最终 pom.xml 如下：</p><pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;org.zkpk&lt;/groupId&gt;  &lt;artifactId&gt;spark&lt;/artifactId&gt;  &lt;version&gt;0.0.1&lt;/version&gt;  &lt;packaging&gt;jar&lt;/packaging&gt;  &lt;name&gt;spark&lt;/name&gt;  &lt;url&gt;http://maven.apache.org&lt;/url&gt;  &lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;  &lt;/properties&gt;  &lt;dependencies&gt;    &lt;dependency&gt;      &lt;groupId&gt;junit&lt;/groupId&gt;      &lt;artifactId&gt;junit&lt;/artifactId&gt;      &lt;version&gt;3.8.1&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;      &lt;artifactId&gt;spark-core_2.10&lt;/artifactId&gt;      &lt;version&gt;1.5.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;      &lt;artifactId&gt;spark-sql_2.10&lt;/artifactId&gt;      &lt;version&gt;1.5.0&lt;/version&gt;      &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;      &lt;artifactId&gt;spark-hive_2.10&lt;/artifactId&gt;      &lt;version&gt;1.5.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;      &lt;artifactId&gt;spark-streaming_2.10&lt;/artifactId&gt;      &lt;version&gt;1.5.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;      &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt;      &lt;version&gt;2.7.3&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;      &lt;artifactId&gt;spark-streaming-kafka_2.10&lt;/artifactId&gt;          &lt;version&gt;1.5.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;      &lt;artifactId&gt;spark-streaming-flume_2.10&lt;/artifactId&gt;          &lt;version&gt;1.5.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;      &lt;artifactId&gt;httpclient&lt;/artifactId&gt;      &lt;version&gt;4.3.5&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;      &lt;artifactId&gt;httpcore&lt;/artifactId&gt;      &lt;version&gt;4.3.1&lt;/version&gt;    &lt;/dependency&gt;  &lt;/dependencies&gt;  &lt;build&gt;    &lt;sourceDirectory&gt;src/main/java&lt;/sourceDirectory&gt;    &lt;testSourceDirectory&gt;src/main/test&lt;/testSourceDirectory&gt;    &lt;plugins&gt;      &lt;plugin&gt;        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;        &lt;configuration&gt;          &lt;descriptorRefs&gt;            &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;          &lt;/descriptorRefs&gt;          &lt;archive&gt;            &lt;manifest&gt;              &lt;mainClass&gt;&lt;/mainClass&gt;            &lt;/manifest&gt;          &lt;/archive&gt;        &lt;/configuration&gt;        &lt;executions&gt;          &lt;execution&gt;            &lt;id&gt;make-assembly&lt;/id&gt;            &lt;phase&gt;package&lt;/phase&gt;            &lt;goals&gt;              &lt;goal&gt;single&lt;/goal&gt;            &lt;/goals&gt;          &lt;/execution&gt;        &lt;/executions&gt;      &lt;/plugin&gt;      &lt;plugin&gt;        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;        &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt;        &lt;version&gt;1.2.1&lt;/version&gt;        &lt;executions&gt;          &lt;execution&gt;            &lt;goals&gt;              &lt;goal&gt;exec&lt;/goal&gt;            &lt;/goals&gt;          &lt;/execution&gt;        &lt;/executions&gt;        &lt;configuration&gt;          &lt;executable&gt;java&lt;/executable&gt;          &lt;includeProjectDependencies&gt;true&lt;/includeProjectDependencies&gt;          &lt;includePluginDependencies&gt;false&lt;/includePluginDependencies&gt;          &lt;classpathScope&gt;compile&lt;/classpathScope&gt;          &lt;mainClass&gt;cn.com.syl.spark.App&lt;/mainClass&gt;        &lt;/configuration&gt;      &lt;/plugin&gt;      &lt;plugin&gt;        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;        &lt;configuration&gt;          &lt;source&gt;1.6&lt;/source&gt;          &lt;target&gt;1.6&lt;/target&gt;        &lt;/configuration&gt;      &lt;/plugin&gt;    &lt;/plugins&gt;  &lt;/build&gt;&lt;/project&gt;</code></pre><p>6.3.1.12删除工程生成的App.java和AppTest.java</p><img src="https://gitee.com/wxy_666/images/raw/master/20200603143746.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200603143746.jpg" srcset="data:image/png;base64,666" alt="2020-06-03_104358" style="zoom:80%;"><h4 id="6-3-2编写代码"><a href="#6-3-2编写代码" class="headerlink" title="6.3.2编写代码"></a>6.3.2编写代码</h4><p>6.3.2.1在src/main/java中创建类，并命名为SecondarySortKey.java，然后按Finish</p><p>6.3.2.1.1创建SecondarySortKey.java，代码见附录</p><p>6.3.2.1.2在src/main/java中创建类，并命名为SecondarySortDemo，然后按Finish</p><p>6.3.2.1.3创建SecondarySortDemo.java代码见附录</p><p>6.3.2.1.4运行SecondarySortDemo，观察控制台输出</p><p>6.3.2.1.5右键SecondarySortDemo.java -&gt; Run As -&gt; Java Application</p><p>最终结果：</p><img src="https://gitee.com/wxy_666/images/raw/master/20200603143924.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200603143924.png" srcset="data:image/png;base64,666" alt="QQ图片20200603110720" style="zoom:67%;"><h2 id="七、附录"><a href="#七、附录" class="headerlink" title="七、附录"></a>七、附录</h2><h3 id="1、SecondarySortKey-java"><a href="#1、SecondarySortKey-java" class="headerlink" title="1、SecondarySortKey.java"></a>1、SecondarySortKey.java</h3><pre><code class="java">package org.zkpk.spark;import java.io.Serializable;import scala.math.Ordered;class serDemo implements Serializable {    private static final long serialVersionUID = 5749943279909593929L;    private long reportTime;        // 时间戳    private long upwardflow;        // 上行总流量    private long downwardflow;    // 下行总流量    public serDemo() {        super();        // TODO Auto-generated constructor stub    }    public serDemo(long reportTime, long upwardflow, long downwardflow) {        super();        this.reportTime = reportTime;        this.upwardflow = upwardflow;        this.downwardflow = downwardflow;    }    public long getReportTime() {        return reportTime;    }    public void setReportTime(long reportTime) {        this.reportTime = reportTime;    }    public long getUpwardflow() {        return upwardflow;    }    public void setUpwardflow(long upwardflow) {        this.upwardflow = upwardflow;    }    public long getDownwardflow() {        return downwardflow;    }    public void setDownwardflow(long downwardflow) {        this.downwardflow = downwardflow;    }    public static long getSerialversionuid() {        return serialVersionUID;    }}public class SecondarySortKey implements Ordered&lt;SecondarySortKey&gt;, Serializable {    private static final long serialVersionUID = 3702442700882342403L;    private long upwardflow;    private long downwardflow;    private long reportTime;    public SecondarySortKey() {        super();        // TODO Auto-generated constructor stub    }    public SecondarySortKey(long upwardflow, long downwardflow, long reportTime) {        super();        this.upwardflow = upwardflow;        this.downwardflow = downwardflow;        this.reportTime = reportTime;    }    public long getUpwardflow() {        return upwardflow;    }    public void setUpwardflow(long upwardflow) {        this.upwardflow = upwardflow;    }    public long getDownwardflow() {        return downwardflow;    }    public void setDownwardflow(long downwardflow) {        this.downwardflow = downwardflow;    }    public long getReportTime() {        return reportTime;    }    public void setReportTime(long reportTime) {        this.reportTime = reportTime;    }    public static long getSerialversionuid() {        return serialVersionUID;    }    public boolean $greater(SecondarySortKey other) {        if(upwardflow &gt; other.upwardflow) {            return true;        } else if(upwardflow == other.upwardflow &amp;&amp;                downwardflow &gt; other.downwardflow) {            return true;        } else if(upwardflow == other.upwardflow &amp;&amp;                downwardflow == other.downwardflow &amp;&amp;                reportTime &gt; other.reportTime) {            return true;        }        return false;    }    public boolean $greater$eq(SecondarySortKey other) {        if($greater(other)) {            return true;        } else if(upwardflow == other.upwardflow &amp;&amp;                downwardflow == other.downwardflow &amp;&amp;                reportTime == other.reportTime) {            return true;        }        return false;    }    public boolean $less(SecondarySortKey other) {        if(upwardflow &lt; other.upwardflow) {            return true;        } else if(upwardflow == other.upwardflow &amp;&amp;                downwardflow &lt; other.downwardflow) {            return true;        } else if(upwardflow == other.upwardflow &amp;&amp;                downwardflow == other.downwardflow &amp;&amp;                reportTime &lt; other.reportTime) {            return true;        }        return false;    }    public boolean $less$eq(SecondarySortKey other) {        if($less(other)) {            return true;        } else if(upwardflow == other.upwardflow &amp;&amp;                downwardflow == other.downwardflow &amp;&amp;                reportTime == other.reportTime) {            return true;        }        return false;    }    public int compare(SecondarySortKey other) {        if(upwardflow - other.upwardflow != 0) {            return (int) (upwardflow - other.upwardflow);        } else if(downwardflow - other.downwardflow != 0) {            return (int) (downwardflow - other.downwardflow);        } else if(reportTime - other.reportTime != 0) {            return (int) (reportTime - other.reportTime);        }        return 0;    }    public int compareTo(SecondarySortKey other) {        if(upwardflow - other.upwardflow != 0) {            return (int) (upwardflow - other.upwardflow);        } else if(downwardflow - other.downwardflow != 0) {            return (int) (downwardflow - other.downwardflow);        } else if(reportTime - other.reportTime != 0) {            return (int) (reportTime - other.reportTime);        }        return 0;    }    @Override    public int hashCode() {        final int prime = 31;        int result = 1;        result = prime * result + (int) (downwardflow );        result = prime * result + (int) (reportTime );        result = prime * result + (int) (upwardflow );        return result;    }    @Override    public boolean equals(Object obj) {        if (this == obj)            return true;        if (obj == null)            return false;        if (getClass() != obj.getClass())            return false;        SecondarySortKey other = (SecondarySortKey) obj;        if (downwardflow != other.downwardflow)            return false;        if (reportTime != other.reportTime)            return false;        if (upwardflow != other.upwardflow)            return false;        return true;    }    @Override    public String toString() {        return &quot;SortResult： [上行总流量： &quot; + upwardflow + &quot;, 下行总流量：  &quot; + downwardflow + &quot;, 时间戳：&quot;                + reportTime + &quot;]&quot;;    }}</code></pre><h3 id="2、SecondarySortDemo-java"><a href="#2、SecondarySortDemo-java" class="headerlink" title="2、SecondarySortDemo.java"></a>2、SecondarySortDemo.java</h3><pre><code class="java">package org.zkpk.spark;import java.util.List;import org.apache.spark.SparkConf;import org.apache.spark.api.java.JavaPairRDD;import org.apache.spark.api.java.JavaRDD;import org.apache.spark.api.java.JavaSparkContext;import org.apache.spark.api.java.function.Function2;import org.apache.spark.api.java.function.PairFunction;import scala.Tuple2;public class SecondarySortDemo {    public static void main(String[] args) throws Exception {        // 创建sparkcontext对象，sparkcontext是程序的唯一入口        SparkConf conf = new SparkConf().setAppName(&quot;SecondarySortDemo&quot;).setMaster(&quot;local&quot;);        JavaSparkContext jsc = new JavaSparkContext(conf);        // 去掉WARN类的输出信息        jsc.setLogLevel(&quot;WARN&quot;);        // 调用textFile()方法，读取日志文件，这里指定本地磁盘文件        JavaRDD&lt;String&gt; textfile = jsc.textFile(&quot;/home/zkpk/experiment/data.log&quot;);        // 调用mapTfRDD2Pair方法 将tf映射为键值对        JavaPairRDD&lt;String, serDemo&gt; pairRdd = mapTfRDD2Pair(textfile);        // 获取每个手机号的总上行流量、总下行流量、最早报告时间戳        JavaPairRDD&lt;String, serDemo&gt; getlines = aggregateByDeviceID(pairRdd);        // 聚合，封装的RDD作为key,手机号作为值        JavaPairRDD&lt;SecondarySortKey, String&gt; telval = mapRDDKey2SortKey(getlines);        // 依次按照上行流量、下行流量以及时间戳倒序排序        JavaPairRDD&lt;SecondarySortKey, String&gt; sortedRdd = telval.sortByKey(false);        // 根据您的需要获得输出，这里仅显示前10行        List&lt;Tuple2&lt;SecondarySortKey, String&gt;&gt; getTop = sortedRdd.take(10);        System.out.println(&quot;============ result ============&quot;);        for (Tuple2&lt;SecondarySortKey, String&gt; dt : getTop) {            System.out.println(&quot;telNum: &quot; + dt._2 + &quot;, &quot; + dt._1);        }        // 执行结束关闭资源        jsc.close();    }    // mapTfRDD2Pair方法，封装键值对    private static JavaPairRDD&lt;String, serDemo&gt; mapTfRDD2Pair(JavaRDD&lt;String&gt; accessLogRDD) {        return accessLogRDD.mapToPair(new PairFunction&lt;String, String, serDemo&gt;() {            private static final long serialVersionUID = 1L;            @Override            public Tuple2&lt;String, serDemo&gt; call(String lines) throws Exception {                // 根据数据格式进行切分                String[] split = lines.split(&quot;\t&quot;);                // 获取切分的字段                long reportTime = Long.valueOf(split[0]);                String telNum = split[1];                long upwardflow = Long.valueOf(split[2]);                long downwardflow = Long.valueOf(split[3]);                // 创建cmbInfo对象，有参构造 ，将上行流量、下行流量，报告时间戳封装为自定义的可序列化对象                serDemo dataInfo = new serDemo(reportTime, upwardflow, downwardflow);                return new Tuple2&lt;String, serDemo&gt;(telNum, dataInfo);            }        });    }    // 根据手机号进行聚合，依次按照上行流量、下行流量以及报告时间戳倒序排序    private static JavaPairRDD&lt;String, serDemo&gt; aggregateByDeviceID(JavaPairRDD&lt;String, serDemo&gt; accessLogPairRDD) {        return accessLogPairRDD.reduceByKey(new Function2&lt;serDemo, serDemo, serDemo&gt;() {            private static final long serialVersionUID = 1L;            @Override            public serDemo call(serDemo d1, serDemo d2) throws Exception {                long reportTime = d1.getReportTime() &lt; d2.getReportTime() ? d1.getReportTime() : d2.getReportTime();                long upwardflow = d1.getUpwardflow() + d2.getUpwardflow();                long downwardflow = d1.getDownwardflow() + d2.getDownwardflow();                serDemo accessLogInfo = new serDemo();                accessLogInfo.setReportTime(reportTime);                accessLogInfo.setUpwardflow(upwardflow);                accessLogInfo.setDownwardflow(downwardflow);                return accessLogInfo;            }        });    }    // 二次排序，手机号作为值    private static JavaPairRDD&lt;SecondarySortKey, String&gt; mapRDDKey2SortKey(            JavaPairRDD&lt;String, serDemo&gt; aggrAccessLogPairRDD) {        return aggrAccessLogPairRDD.mapToPair(                new PairFunction&lt;Tuple2&lt;String, serDemo&gt;, SecondarySortKey, String&gt;() {                    private static final long serialVersionUID = 1L;                    @Override                    public Tuple2&lt;SecondarySortKey, String&gt; call(Tuple2&lt;String, serDemo&gt; tuple) throws Exception {                        // 获取元祖里的数据                        String telNum = tuple._1;                        serDemo accessLogInfo = tuple._2;                        // 封装为二次排序key                        SecondarySortKey accessLogSortKey = new SecondarySortKey(accessLogInfo.getUpwardflow(),                                accessLogInfo.getDownwardflow(), accessLogInfo.getReportTime());                        // 返回新的Tuple                        return new Tuple2&lt;SecondarySortKey, String&gt;(accessLogSortKey, telNum);                    }                });    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是关于大数据通过Java进行Spark编程实现日志处理分析。&lt;/p&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="实战" scheme="https://666wxy666.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="实战" scheme="https://666wxy666.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
      <category term="大数据" scheme="https://666wxy666.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Spark" scheme="https://666wxy666.github.io/tags/Spark/"/>
    
      <category term="流计算" scheme="https://666wxy666.github.io/tags/%E6%B5%81%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Streaming" scheme="https://666wxy666.github.io/tags/Streaming/"/>
    
      <category term="Java" scheme="https://666wxy666.github.io/tags/Java/"/>
    
      <category term="日志分析" scheme="https://666wxy666.github.io/tags/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>C和C++的struct使用总结</title>
    <link href="https://666wxy666.github.io/2020/07/15/C%E5%92%8CC++%E7%9A%84struct%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://666wxy666.github.io/2020/07/15/C%E5%92%8CC++%E7%9A%84struct%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</id>
    <published>2020-07-14T16:00:00.000Z</published>
    <updated>2020-09-02T01:48:36.334Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简单的写了一下关于C语言和C++中的Struct结构体的定义的疑惑点和C99新增的柔性数组的使用和理解。</p><a id="more"></a><h2 id="一、关于C语言和C-中的Struct结构体的定义"><a href="#一、关于C语言和C-中的Struct结构体的定义" class="headerlink" title="一、关于C语言和C++中的Struct结构体的定义"></a>一、关于C语言和C++中的Struct结构体的定义</h2><h3 id="1、C语言"><a href="#1、C语言" class="headerlink" title="1、C语言"></a>1、C语言</h3><p>对于C语言，结构体的定义可以是以下的标准定义法：</p><pre><code class="c">/* * @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. * @Description:  * @Version:  * @Author: 苇名一心 * @Date: 2020-07-15 08:17:32 * @LastEditors: 苇名一心 * @LastEditTime: 2020-07-15 11:29:00 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct TEST{    int a;};int main(int argc, char const *argv[]){    struct TEST test;    test.a = 1;    printf(&quot;%d\n&quot;, test.a);    return 0;}</code></pre><p>像这样就定义了一个结构体TEST，在声明新结构体变量时，需要使用“struct TEST test”，“struct”必须有，不写会报错，“struct TEST”就相当于是“int”。</p><p>直接在结构体里赋初值是不允许的，例如：</p><pre><code class="c">/* * @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. * @Description:  * @Version:  * @Author: 苇名一心 * @Date: 2020-07-15 08:17:32 * @LastEditors: 苇名一心 * @LastEditTime: 2020-07-15 11:32:27 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct TEST{    int a = 1;};int main(int argc, char const *argv[]){    struct TEST test;    printf(&quot;%d\n&quot;, test.a);    return 0;}</code></pre><p>会产生如下错误：</p><img src="https://gitee.com/wxy_666/images/raw/master/20200715113328.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200715113328.jpg" srcset="data:image/png;base64,666" alt="2020-07-15_113313" style="zoom:80%;"><p>另外，除了标准定义法，C语言还支持直接在定义结构体的时候声明变量，以及给结构体重命名：</p><pre><code class="c">/* * @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. * @Description:  * @Version:  * @Author: 苇名一心 * @Date: 2020-07-15 08:17:32 * @LastEditors: 苇名一心 * @LastEditTime: 2020-07-15 11:37:59 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct TEST1{    int a;} test1;typedef struct TEST2{    int a;} TEST2;int main(int argc, char const *argv[]){    struct TEST1 test11;    TEST2 test2;    struct TEST2 test22;    test1.a = 1;    test2.a = 2;    test11.a = 11;    test22.a = 22;    printf(&quot;%d,%d,%d,%d\n&quot;, test1.a, test2.a, test11.a, test22.a);    return 0;}</code></pre><img src="https://gitee.com/wxy_666/images/raw/master/20200715113946.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200715113946.jpg" srcset="data:image/png;base64,666" alt="2020-07-15_113933" style="zoom: 80%;"><p>可以看出，TEST1是直接在定义结构体时就声明了一个变量test1，在下面可以直接使用test1访问结构体成员a，另外你仍然可以在后面使用标准方法定义新的TEST1结构体。</p><p>而对于TEST2，则是使用“typedef”将“struct TEST2”起了个别名叫“TEST2”，因此后面既可以使用struct TEST2”也可以使用“TEST2”声明TEST2结构体变量。</p><p>在定义结构体的时候，你也可以省略TEST1或者TEST2不写，但是这样对于没有起别名的TEST1就只能在定义结构体的时候声明结构体变量，在后面不能定义（因为没有名字，很好理解），相当于是一次性的结构体。但是对于起了别名的TEST2，在后面就只能使用TEST2来声明结构体变量，而不能再使用标准的“struct TEST2”。</p><pre><code class="c">/* * @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. * @Description:  * @Version:  * @Author: 苇名一心 * @Date: 2020-07-15 08:17:32 * @LastEditors: 苇名一心 * @LastEditTime: 2020-07-15 11:52:58 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct{    int a;} test1;typedef struct{    int a;} TEST2;int main(int argc, char const *argv[]){    TEST2 test2;    test1.a = 1;    test2.a = 2;    printf(&quot;%d,%d\n&quot;, test1.a, test2.a);    return 0;}</code></pre><img src="https://gitee.com/wxy_666/images/raw/master/20200715115648.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200715115648.jpg" srcset="data:image/png;base64,666" alt="2020-07-15_115639" style="zoom:80%;"><h3 id="2、C"><a href="#2、C" class="headerlink" title="2、C++"></a>2、C++</h3><p>对于C++，因为C++是面向对象的程序设计语言，结构体struct就相当于是C++的类class，只是默认继承访问权限不同，class默认的是private，strcut默认的是public。你甚至可以在结构体定义函数，这是在C语言里不允许的，并且C++也允许声明结构体变量时省略“struct”，这个在C语言里也不允许，除非使用typedef起别名。</p><pre><code class="c++">/* * @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. * @Description:  * @Version:  * @Author: 苇名一心 * @Date: 2020-07-15 08:28:24 * @LastEditors: 苇名一心 * @LastEditTime: 2020-07-15 11:48:50 */#include &lt;iostream&gt;using namespace std;struct TEST{    int a = 1;    void hello()    {        cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;    };};int main(int argc, char const *argv[]){    struct TEST test1;    TEST test2;    cout &lt;&lt; test1.a &lt;&lt; endl;    test2.hello();    return 0;}</code></pre><img src="https://gitee.com/wxy_666/images/raw/master/20200715115111.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200715115111.jpg" srcset="data:image/png;base64,666" alt="2020-07-15_115102" style="zoom:80%;"><p>当然，C++也允许对类或者结构体起别名：</p><pre><code class="c++">/* * @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. * @Description:  * @Version:  * @Author: 苇名一心 * @Date: 2020-07-15 08:28:24 * @LastEditors: 苇名一心 * @LastEditTime: 2020-07-15 11:58:18 */#include &lt;iostream&gt;using namespace std;typedef struct TEST{    int a = 1;    void hello()    {        cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;    };} T;int main(int argc, char const *argv[]){    struct TEST test1;    TEST test2;    T test3;    cout &lt;&lt; test1.a &lt;&lt; endl;    test2.hello();    test3.hello();    return 0;}</code></pre><img src="https://gitee.com/wxy_666/images/raw/master/20200715120041.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200715120041.jpg" srcset="data:image/png;base64,666" alt="2020-07-15_120016" style="zoom:80%;"><p>直接在定义结构体的时候声明变量也可以：</p><pre><code class="c++">/* * @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. * @Description:  * @Version:  * @Author: 苇名一心 * @Date: 2020-07-15 08:28:24 * @LastEditors: 苇名一心 * @LastEditTime: 2020-07-15 11:59:23 */#include &lt;iostream&gt;using namespace std;struct TEST{    int a = 1;    void hello()    {        cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;    };} test3;int main(int argc, char const *argv[]){    struct TEST test1;    TEST test2;    cout &lt;&lt; test1.a &lt;&lt; endl;    test2.hello();    test3.hello();    return 0;}</code></pre><img src="https://gitee.com/wxy_666/images/raw/master/20200715120047.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200715120047.jpg" srcset="data:image/png;base64,666" alt="2020-07-15_120029" style="zoom:80%;"><h2 id="二、关于C99新增的柔性数组"><a href="#二、关于C99新增的柔性数组" class="headerlink" title="二、关于C99新增的柔性数组"></a>二、关于C99新增的柔性数组</h2><p>在C99中，结构中的最后一个元素允许是未知大小的数组，这就叫做柔性数组成员，但结构中的柔性数组成员前面必须至少一个其他成员。柔性数组成员允许结构中包含一个大小可变的数组。sizeof返回的这种结构大小不包括柔性数组的内存。包含柔性数组成员的结构用malloc函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。</p><p>例如：</p><pre><code class="c">/* * @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. * @Description:  * @Version:  * @Author: 苇名一心 * @Date: 2020-07-15 08:17:32 * @LastEditors: 苇名一心 * @LastEditTime: 2020-07-15 12:12:45 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct TEST{    int a;    char b[];} T;int main(int argc, char const *argv[]){    T test;    T *test_ptr;    test.a = 1;    printf(&quot;%d,%d,%d,%d\n&quot;, test.a, sizeof(T), sizeof(test), sizeof(*test_ptr));    return 0;}</code></pre><img src="https://gitee.com/wxy_666/images/raw/master/20200715121026.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200715121026.jpg" srcset="data:image/png;base64,666" alt="2020-07-15_121020" style="zoom: 80%;"><p>我们可以发现，结构体的大小确实等于一个整型的大小4字节，也就是a的大小，b数组是没有占空间的。对于编译器来说，此时长度为0的数组并不占用空间，因为数组名本身不占空间，它只是一个偏移量，数组名这个符号本身代表了一个不可修改的地址常量 ，但对于这个数组的大小，我们可以进行动态分配。当我们对结构体指针test_ptr进行malloc分配内存空间，分配的空间减去sizeof(T)就是柔性数组b的空间，我们就可以对b操作了。其实，b就是柔性数组，或者叫动态数组。这个操作常用于缓冲区或者网络通信中构造不定长数据包。</p><p>例如：</p><pre><code class="c">/* * @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. * @Description: * @Version: * @Author: 苇名一心 * @Date: 2020-07-15 08:17:32 * @LastEditors: 苇名一心 * @LastEditTime: 2020-07-15 12:20:33 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct TEST{    int a;    char b[];} T;int main(int argc, char const* argv[]){    T* test_ptr;    test_ptr = (T*)malloc(sizeof(T) + 10 * sizeof(char));    test_ptr-&gt;a = 10;    strcpy(test_ptr-&gt;b, &quot;aaaaaaaaa&quot;);    printf(&quot;%d,%d,%s\n&quot;, sizeof(*test_ptr), test_ptr-&gt;a, test_ptr-&gt;b);    free(test_ptr);    return 0;}</code></pre><img src="https://gitee.com/wxy_666/images/raw/master/20200715122752.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200715122752.jpg" srcset="data:image/png;base64,666" alt="2020-07-15_122744" style="zoom:80%;"><p>可以发现T的大小依然是4字节，因此b明确来说不算是结构体成员。但是我们却可以使用长度为10的数组b。但为什么我只能复制9个a到数组b呢，其实9个a的字符串长度就是10，因为常量字符串最后一个字符是‘\0’，用于标志字符串而结束，因此实际上b[9]是‘\0’。那如果我们此时强制访问越界会怎么样呢？</p><pre><code class="c">/* * @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. * @Description: * @Version: * @Author: 苇名一心 * @Date: 2020-07-15 08:17:32 * @LastEditors: 苇名一心 * @LastEditTime: 2020-07-15 12:20:33 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct TEST{    int a;    char b[];} T;int main(int argc, char const* argv[]){    T* test_ptr;    test_ptr = (T*)malloc(sizeof(T) + 10 * sizeof(char));    test_ptr-&gt;a = 10;    strcpy(test_ptr-&gt;b, &quot;aaaaaaaaabbbbbbbbbb&quot;);    printf(&quot;%d,%d,%s\n&quot;, sizeof(*test_ptr), test_ptr-&gt;a, test_ptr-&gt;b);    free(test_ptr);    return 0;}</code></pre><img src="https://gitee.com/wxy_666/images/raw/master/20200715130032.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200715130032.jpg" srcset="data:image/png;base64,666" alt="2020-07-15_130000" style="zoom:80%;"><p>可以发现产生了异常，但是后面的b却被成功打印了出来。经过调试，发现是free语句产生的异常，如果我们把free语句注释掉，就能正常跑了，但是显然不应该这么做，原因是什么呢？</p><pre><code class="c">/* * @Copyright: Copyright (c) 2020 苇名一心 All Rights Reserved. * @Description: * @Version: * @Author: 苇名一心 * @Date: 2020-07-15 08:17:32 * @LastEditors: 苇名一心 * @LastEditTime: 2020-07-15 12:20:33 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct TEST{    int a;    char b[];} T;int main(int argc, char const* argv[]){    T* test_ptr;    test_ptr = (T*)malloc(sizeof(T) + 10 * sizeof(char));    test_ptr-&gt;a = 10;    strcpy(test_ptr-&gt;b, &quot;aaaaaaaaabbbbbbbbbb&quot;);    printf(&quot;%d,%d,%s\n&quot;, sizeof(*test_ptr), test_ptr-&gt;a, test_ptr-&gt;b);    // free(test_ptr);    return 0;}</code></pre><img src="https://gitee.com/wxy_666/images/raw/master/20200715130305.jpg" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200715130305.jpg" srcset="data:image/png;base64,666" alt="2020-07-15_130244" style="zoom:80%;"><p>其实，在动态分配的时候，会在数组界限外加一个用来标识数组范围的标志，例如b数组，就会在b[-1]和b[10]有两个标志，如果我们在这两个位置赋值，赋值和调用时并不会出错，而是在freed掉b申请的内存时出错，错误的名称就是“before Normal block”或“after Normal block”，一般是后者居多。</p><p>那么这个柔性数组相比与在结构体里的动态数组有什么优势呢？从上面的代码也能看出，如果使用普通的动态数组，需要分配两块内存，即动态数组的内存和结构体的内存，在释放时也要先释放b的内存，再释放test_ptr的内存，比较麻烦。但是柔性数组就完全不需要，直接申请结构体的内存即可，释放时也只需要释放结构体申请的内存，非常方便。</p><p>还有一点要说明的是：在C99之前是不支持灵活数组成员（Fleible Array Member，int a[]）的，C99把它作为一种特例加入了标准。但是，C99所支持的是Incomplete Type（int a[]），而不是Zero Array（int a[0]）。也就是说类似“int a[0];”这种形式是非法的，只不过有些编译器把“int a[0];”作为非标准扩展来支持，而且在C99发布之前已经有了这种非标准扩展了，C99发布之后，有些编译器把两者合而为一了而已。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单的写了一下关于C语言和C++中的Struct结构体的定义的疑惑点和C99新增的柔性数组的使用和理解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="https://666wxy666.github.io/categories/C-C/"/>
    
      <category term="拓展学习" scheme="https://666wxy666.github.io/categories/C-C/%E6%8B%93%E5%B1%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="C++" scheme="https://666wxy666.github.io/tags/C/"/>
    
      <category term="C" scheme="https://666wxy666.github.io/tags/C/"/>
    
      <category term="难点" scheme="https://666wxy666.github.io/tags/%E9%9A%BE%E7%82%B9/"/>
    
      <category term="C99" scheme="https://666wxy666.github.io/tags/C99/"/>
    
      <category term="Struct" scheme="https://666wxy666.github.io/tags/Struct/"/>
    
  </entry>
  
  <entry>
    <title>C++工程项目 单词消除游戏</title>
    <link href="https://666wxy666.github.io/2020/07/12/C++%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE-%E5%8D%95%E8%AF%8D%E6%B6%88%E9%99%A4%E6%B8%B8%E6%88%8F/"/>
    <id>https://666wxy666.github.io/2020/07/12/C++%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE-%E5%8D%95%E8%AF%8D%E6%B6%88%E9%99%A4%E6%B8%B8%E6%88%8F/</id>
    <published>2020-07-11T16:00:00.000Z</published>
    <updated>2020-09-02T01:58:51.050Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>本文是C++面向对象的程序设计实战项目，实现单词消除游戏，具体项目及要求请点击查看。</strong></p><a id="more"></a><h2 id="一、单词消除游戏总体要求"><a href="#一、单词消除游戏总体要求" class="headerlink" title="一、单词消除游戏总体要求"></a>一、单词消除游戏总体要求</h2><p>单词消除游戏由两类参与者组成：闯关者（即游戏玩家），出题者（为游戏增加游戏中使用单词）。游戏规则为，游戏每一轮，程序会根据该关卡难度，显示一个单词，一定时间后单词消失。闯关者需要在相应地方输入刚刚显示并消失的单词，如果闯关者输入正确（即闯关者输入的单词与刚刚显示的单词完全一致，包含大小写）则为通过。一关可以由一轮或者多轮组成。</p><h2 id="二、单词消除游戏具体要求"><a href="#二、单词消除游戏具体要求" class="headerlink" title="二、单词消除游戏具体要求"></a>二、单词消除游戏具体要求</h2><ol><li><p>Version1</p><ul><li>实现闯关者，出题者本地的注册、登录。</li><li>程序支持多人注册，同一时间只有一人可以登录。</li><li>实现游戏规则：出题者增加游戏中使用单词。游戏每一关，程序会根据该关卡难度，显示一个单词，一定时间后单词消失。闯关者需要在相应地方输入刚刚显示并消失的单词，如果闯关者输入正确则为通过。</li><li>任何角色均可查询所有闯关者、出题者，按照属性查找相应闯关者、出题者。</li><li>采用面向对象的方式，使用类设计。</li><li>在设计类时请注意类的继承关系，关注闯关者、出题者的关联（闯关者与出题者有共同的基类）。</li><li>使用文件或者数据库作为存储对象，自行设计文件格式，或者数据库表结构。</li></ul></li><li><p>Version2</p><p>在Version1的基础上增加：</p><ul><li>可以根据闯关者闯过关卡数、经验、等级等对闯关者排名，根据出题者出题数目、等级对出题者排名。</li><li>请根据要求设计每一关的出题方式，注意随着关卡数增加，题目难度增加</li><li>计闯关者经验值，等级增加策略。设计出题者等级升级策略。</li></ul></li><li><p>Version3</p><p>在Version2的基础上增加：</p><ul><li>使用socket进行通信，实现局域网通信游玩。</li><li>需要完成服务器端程序，以及客户端程序。客户端可以启动多个同时与服务器交互，要求服务器具有并发处理能力。</li><li>在题目的要求下自行扩展功能，功能扩展适当者酌情加分。</li></ul></li></ol><h2 id="三、运行环境"><a href="#三、运行环境" class="headerlink" title="三、运行环境"></a>三、运行环境</h2><p>电脑硬件配置：</p><ul><li><p>处理器：Intel i7 7700HQ</p></li><li><p>显卡：NVIDIA GeForce GTX 1050 Ti</p></li><li><p>内存：16GB</p></li></ul><p>编程语言：C++</p><p>QT：Qt Creator 4.11.1 Based on Qt 5.14.1 (MSVC 2017, 32 bit)</p><p>编译器：Desktop Qt 5.14.2 MinGW 7.3.0 64-bit</p><p>数据库：mysql Ver 8.0.20 for Win64 on x86_64 (MySQL Community Server - GPL)</p><p>其它说明：</p><ul><li><p>关于QT数据库驱动</p><ul><li><p>libmysql.dll和libqsqlmysql.a放入【…\Qt5.14.2\5.14.2\mingw73_64\bin】下。</p></li><li><p>qsqlmysql.dll和qsqlmysql.dll.debug放入【…\Qt5.14.2\5.14.2\mingw73_64\plugins\sqldrivers】下。</p></li></ul></li><li><p>数据库信息：</p><p>需要修改请自行修改代码，以下是默认用户名和密码。</p><ul><li>用户名：wxy</li><li>密码：123456</li></ul></li><li><p>由于QT的限制，编译构建时路径不允许有中文。</p></li><li><p>服务器默认IP地址是本地127.0.0.1，有需要请自行修改代码。</p></li></ul><h2 id="四、模块设计"><a href="#四、模块设计" class="headerlink" title="四、模块设计"></a>四、模块设计</h2><h3 id="1、游戏客户端"><a href="#1、游戏客户端" class="headerlink" title="1、游戏客户端"></a>1、游戏客户端</h3><h4 id="模块清单"><a href="#模块清单" class="headerlink" title="模块清单"></a>模块清单</h4><table><thead><tr><th>编号</th><th>模块名称</th><th>模块标识</th><th>模块功能</th></tr></thead><tbody><tr><td>1</td><td>主界面模块</td><td>Widget</td><td>主界面，包括登录等</td></tr><tr><td>2</td><td>用户类模块</td><td>User</td><td>闯关者，出题人类</td></tr><tr><td>3</td><td>注册模块</td><td>Register</td><td>注册用户</td></tr><tr><td>4</td><td>用户信息模块</td><td>Info</td><td>展示用户信息，包括等级、经验等</td></tr><tr><td>5</td><td>游戏模块</td><td>Game</td><td>单词消除游戏游玩界面</td></tr><tr><td>6</td><td>出题模块</td><td>Create</td><td>出题人出题界面</td></tr><tr><td>7</td><td>查询模块</td><td>Check</td><td>查询用户，排名界面</td></tr></tbody></table><h4 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h4><h5 id="1、主界面"><a href="#1、主界面" class="headerlink" title="1、主界面"></a>1、主界面</h5><img src="https://gitee.com/wxy_666/images/raw/master/20200715102903.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200715102903.png" srcset="data:image/png;base64,666" alt="1" style="zoom:80%;"><h5 id="2、注册界面"><a href="#2、注册界面" class="headerlink" title="2、注册界面"></a>2、注册界面</h5><img src="https://gitee.com/wxy_666/images/raw/master/20200715103047.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200715103047.png" srcset="data:image/png;base64,666" alt="2" style="zoom:80%;"><h5 id="3、用户信息界面（出题人与闯关者文字略有不同）"><a href="#3、用户信息界面（出题人与闯关者文字略有不同）" class="headerlink" title="3、用户信息界面（出题人与闯关者文字略有不同）"></a>3、用户信息界面（出题人与闯关者文字略有不同）</h5><img src="https://gitee.com/wxy_666/images/raw/master/20200715103058.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200715103058.png" srcset="data:image/png;base64,666" alt="3" style="zoom:80%;"><h5 id="4、游戏界面"><a href="#4、游戏界面" class="headerlink" title="4、游戏界面"></a>4、游戏界面</h5><img src="https://gitee.com/wxy_666/images/raw/master/20200715103347.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200715103347.png" srcset="data:image/png;base64,666" alt="4" style="zoom:80%;"><h5 id="5、出题界面"><a href="#5、出题界面" class="headerlink" title="5、出题界面"></a>5、出题界面</h5><ul><li><p>Version2：</p><img src="https://gitee.com/wxy_666/images/raw/master/20200715103355.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200715103355.png" srcset="data:image/png;base64,666" alt="5" style="zoom:80%;"></li><li><p>Version3：</p><img src="https://gitee.com/wxy_666/images/raw/master/20200715103405.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200715103405.png" srcset="data:image/png;base64,666" alt="6" style="zoom:80%;"></li></ul><h5 id="6、查询界面"><a href="#6、查询界面" class="headerlink" title="6、查询界面"></a>6、查询界面</h5><img src="https://gitee.com/wxy_666/images/raw/master/20200715103416.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200715103416.png" srcset="data:image/png;base64,666" alt="7" style="zoom:80%;"><h4 id="函数具体功能"><a href="#函数具体功能" class="headerlink" title="函数具体功能"></a>函数具体功能</h4><h5 id="1、Widget"><a href="#1、Widget" class="headerlink" title="1、Widget"></a>1、Widget</h5><pre><code class="c++">void init_UI();//初始化图形界面void connect_event();//信号，槽函数链接void user_registe_show();//显示闯关者注册界面void creater_registe_show();//显示出题人注册界面void check_user_show();    //显示查询闯关者界面void check_creater_show();//显示查询出题人界面void info_show();//显示用户信息界面void check_close();//关闭查询界面void registe_close();//关闭注册界面void info_close();//关闭用户信息界面void showEvent(QShowEvent *);//显示界面void close_Widget();//关闭界面void type_changed();//闯关者，出题人切换void init_database();//初始化数据库</code></pre><h5 id="2、user"><a href="#2、user" class="headerlink" title="2、user"></a>2、user</h5><p>player和creater继承于user类，升级函数采用虚函数，分别在各自类中实现。</p><h5 id="3、register"><a href="#3、register" class="headerlink" title="3、register"></a>3、register</h5><pre><code class="c++">void init_UI();//初始化图形界面void connect_event();//信号，槽函数链接void showEvent(QShowEvent *);//显示界面void close_Widget();//关闭界面void send_change_signal();//改变界面信号</code></pre><h5 id="4、info"><a href="#4、info" class="headerlink" title="4、info"></a>4、info</h5><pre><code class="c++">void init_UI();//初始化图形界面void connect_event();//信号，槽函数链接void showEvent(QShowEvent *);//显示界面void close_Widget();//关闭界面void send_change_signal();//改变界面信号void game_show();//游戏界面显示void game_close();//游戏界面关闭void create_show();//出题界面显示    void create_close();//出题界面关闭</code></pre><h5 id="5、game"><a href="#5、game" class="headerlink" title="5、game"></a>5、game</h5><pre><code class="c++">void init_UI();//初始化图形界面void connect_event();//信号，槽函数链接void showEvent(QShowEvent *);//显示界面void close_Widget();//关闭界面void send_change_signal();//改变界面信void init_timer();//计时器初始化void init_ms_timer();//计时器初始化void timeup();//超时void ms_timeup();//超时</code></pre><h5 id="6、create"><a href="#6、create" class="headerlink" title="6、create"></a>6、create</h5><pre><code class="c++">void init_UI();//初始化图形界面void connect_event();//信号，槽函数链接void showEvent(QShowEvent *);//显示界面void close_Widget();//关闭界面void send_change_signal();//改变界面信号</code></pre><h5 id="6、check"><a href="#6、check" class="headerlink" title="6、check"></a>6、check</h5><pre><code class="c++">void init_UI();//初始化图形界面void connect_event();//信号，槽函数链接void showEvent(QShowEvent *);//显示界面void close_Widget();//关闭界面void send_change_signal();//改变界面信号void search();//搜索信息</code></pre><h3 id="2、服务器端"><a href="#2、服务器端" class="headerlink" title="2、服务器端"></a>2、服务器端</h3><h4 id="模块清单-1"><a href="#模块清单-1" class="headerlink" title="模块清单"></a>模块清单</h4><table><thead><tr><th>编号</th><th>模块名称</th><th>模块标识</th><th>模块功能</th></tr></thead><tbody><tr><td>1</td><td>主界面模块</td><td>Widget</td><td>主界面</td></tr><tr><td>2</td><td>线程模块</td><td>My_thread</td><td>实现多线程</td></tr></tbody></table><h4 id="用户界面-1"><a href="#用户界面-1" class="headerlink" title="用户界面"></a>用户界面</h4><img src="https://gitee.com/wxy_666/images/raw/master/20200715104043.png" class="lazyload" data-srcset="https://gitee.com/wxy_666/images/raw/master/20200715104043.png" srcset="data:image/png;base64,666" alt="8" style="zoom:80%;"><h4 id="函数具体功能-1"><a href="#函数具体功能-1" class="headerlink" title="函数具体功能"></a>函数具体功能</h4><h5 id="1、Widget-1"><a href="#1、Widget-1" class="headerlink" title="1、Widget"></a>1、Widget</h5><pre><code class="c++">void init_UI();//初始化图形界面void tcpserver_connect();//tcpserver连接void tcpsocket_connect();//tcpsocket连接void showEvent(QShowEvent *);//界面显示</code></pre><h5 id="2、My-thread"><a href="#2、My-thread" class="headerlink" title="2、My_thread"></a>2、My_thread</h5><p>当收到客户端的请求后，根据客户端发送的字符串判断是什么请求，在屏幕上输出，同时新建线程，在线程中处理这些请求，从而实现并发处理。</p><pre><code class="c++">void init_database();//初始化数据库</code></pre><h2 id="五、项目地址"><a href="#五、项目地址" class="headerlink" title="五、项目地址"></a>五、项目地址</h2><p>本项目的源码、可执行程序均已经存放于我的Github，欢迎下载查看：</p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/666WXY666/WordGame" target="_blank"><img src="https://github-readme-stats.vercel.app/api/pin/?username=666WXY666&repo=WordGame&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/pin/?username=666WXY666&repo=WordGame&show_owner=true" srcset="data:image/png;base64,666"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文是C++面向对象的程序设计实战项目，实现单词消除游戏，具体项目及要求请点击查看。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="https://666wxy666.github.io/categories/C-C/"/>
    
      <category term="项目" scheme="https://666wxy666.github.io/categories/C-C/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="C++" scheme="https://666wxy666.github.io/tags/C/"/>
    
      <category term="工程" scheme="https://666wxy666.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="QT" scheme="https://666wxy666.github.io/tags/QT/"/>
    
      <category term="小游戏" scheme="https://666wxy666.github.io/tags/%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
</feed>
